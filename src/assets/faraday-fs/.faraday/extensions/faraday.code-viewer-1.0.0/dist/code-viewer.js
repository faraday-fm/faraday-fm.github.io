let Sp = 0, Ke = class {
  constructor(e, O) {
    this.from = e, this.to = O;
  }
};
class Y {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = Sp++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = de.match(e)), (O) => {
      let i = e(O);
      return i === void 0 ? null : [this, i];
    };
  }
}
Y.closedBy = new Y({ deserialize: (t) => t.split(" ") });
Y.openedBy = new Y({ deserialize: (t) => t.split(" ") });
Y.group = new Y({ deserialize: (t) => t.split(" ") });
Y.isolate = new Y({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Y.contextHash = new Y({ perNode: !0 });
Y.lookAhead = new Y({ perNode: !0 });
Y.mounted = new Y({ perNode: !0 });
class bi {
  constructor(e, O, i) {
    this.tree = e, this.overlay = O, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Y.mounted.id];
  }
}
const Xp = /* @__PURE__ */ Object.create(null);
class de {
  /**
  @internal
  */
  constructor(e, O, i, r = 0) {
    this.name = e, this.props = O, this.id = i, this.flags = r;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let O = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : Xp, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new de(e.name || "", O, e.id, i);
    if (e.props) {
      for (let n of e.props)
        if (Array.isArray(n) || (n = n(r)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          O[n[0].id] = n[1];
        }
    }
    return r;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let O = this.prop(Y.group);
      return O ? O.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let O = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let r of i.split(" "))
        O[r] = e[i];
    return (i) => {
      for (let r = i.prop(Y.group), n = -1; n < (r ? r.length : 0); n++) {
        let s = O[n < 0 ? i.name : r[n]];
        if (s)
          return s;
      }
    };
  }
}
de.none = new de(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Hi {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let O = 0; O < e.length; O++)
      if (e[O].id != O)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let O = [];
    for (let i of this.types) {
      let r = null;
      for (let n of e) {
        let s = n(i);
        s && (r || (r = Object.assign({}, i.props)), r[s[0].id] = s[1]);
      }
      O.push(r ? new de(i.name, r, i.id, i.flags) : i);
    }
    return new Hi(O);
  }
}
const hr = /* @__PURE__ */ new WeakMap(), dl = /* @__PURE__ */ new WeakMap();
var H;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(H || (H = {}));
class M {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, O, i, r, n) {
    if (this.type = e, this.children = O, this.positions = i, this.length = r, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of n)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = bi.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let O = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (O && (O += ","), O += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (O.length ? "(" + O + ")" : "") : O;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Kr(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, O = 0, i = 0) {
    let r = hr.get(this) || this.topNode, n = new Kr(r);
    return n.moveTo(e, O), hr.set(this, n._tree), n;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new we(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, O = 0) {
    let i = xi(hr.get(this) || this.topNode, e, O, !1);
    return hr.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, O = 0) {
    let i = xi(dl.get(this) || this.topNode, e, O, !0);
    return dl.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, O = 0) {
    return xp(this, e, O);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: O, leave: i, from: r = 0, to: n = this.length } = e, s = e.mode || 0, a = (s & H.IncludeAnonymous) > 0;
    for (let o = this.cursor(s | H.IncludeAnonymous); ; ) {
      let c = !1;
      if (o.from <= n && o.to >= r && (!a && o.type.isAnonymous || O(o) !== !1)) {
        if (o.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (a || !o.type.isAnonymous) && i(o), !o.nextSibling(); ) {
        if (!o.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let O in this.props)
        e.push([+O, this.props[O]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : ho(de.none, this.children, this.positions, 0, this.children.length, 0, this.length, (O, i, r) => new M(this.type, O, i, r, this.propValues), e.makeTree || ((O, i, r) => new M(de.none, O, i, r)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Tp(e);
  }
}
M.empty = new M(de.none, [], [], 0);
class lo {
  constructor(e, O) {
    this.buffer = e, this.index = O;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new lo(this.buffer, this.index);
  }
}
class LO {
  /**
  Create a tree buffer.
  */
  constructor(e, O, i) {
    this.buffer = e, this.length = O, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return de.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let O = 0; O < this.buffer.length; )
      e.push(this.childString(O)), O = this.buffer[O + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let O = this.buffer[e], i = this.buffer[e + 3], r = this.set.types[O], n = r.name;
    if (/\W/.test(n) && !r.isError && (n = JSON.stringify(n)), e += 4, i == e)
      return n;
    let s = [];
    for (; e < i; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return n + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, O, i, r, n) {
    let { buffer: s } = this, a = -1;
    for (let o = e; o != O && !(CQ(n, r, s[o + 1], s[o + 2]) && (a = o, i > 0)); o = s[o + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, O, i) {
    let r = this.buffer, n = new Uint16Array(O - e), s = 0;
    for (let a = e, o = 0; a < O; ) {
      n[o++] = r[a++], n[o++] = r[a++] - i;
      let c = n[o++] = r[a++] - i;
      n[o++] = r[a++] - e, s = Math.max(s, c);
    }
    return new LO(n, s, this.set);
  }
}
function CQ(t, e, O, i) {
  switch (t) {
    case -2:
      return O < e;
    case -1:
      return i >= e && O < e;
    case 0:
      return O < e && i > e;
    case 1:
      return O <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function xi(t, e, O, i) {
  for (var r; t.from == t.to || (O < 1 ? t.from >= e : t.from > e) || (O > -1 ? t.to <= e : t.to < e); ) {
    let s = !i && t instanceof we && t.index < 0 ? null : t.parent;
    if (!s)
      return t;
    t = s;
  }
  let n = i ? 0 : H.IgnoreOverlays;
  if (i)
    for (let s = t, a = s.parent; a; s = a, a = s.parent)
      s instanceof we && s.index < 0 && ((r = a.enter(e, O, n)) === null || r === void 0 ? void 0 : r.from) != s.from && (t = a);
  for (; ; ) {
    let s = t.enter(e, O, n);
    if (!s)
      return t;
    t = s;
  }
}
class EQ {
  cursor(e = 0) {
    return new Kr(this, e);
  }
  getChild(e, O = null, i = null) {
    let r = pl(this, e, O, i);
    return r.length ? r[0] : null;
  }
  getChildren(e, O = null, i = null) {
    return pl(this, e, O, i);
  }
  resolve(e, O = 0) {
    return xi(this, e, O, !1);
  }
  resolveInner(e, O = 0) {
    return xi(this, e, O, !0);
  }
  matchContext(e) {
    return Gs(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let O = this.childBefore(e), i = this;
    for (; O; ) {
      let r = O.lastChild;
      if (!r || r.to != O.to)
        break;
      r.type.isError && r.from == r.to ? (i = O, O = r.prevSibling) : O = r;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class we extends EQ {
  constructor(e, O, i, r) {
    super(), this._tree = e, this.from = O, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, O, i, r, n = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: o } = s._tree, c = O > 0 ? a.length : -1; e != c; e += O) {
        let h = a[e], Q = o[e] + s.from;
        if (CQ(r, i, Q, Q + h.length)) {
          if (h instanceof LO) {
            if (n & H.ExcludeBuffers)
              continue;
            let f = h.findChild(0, h.buffer.length, O, i - Q, r);
            if (f > -1)
              return new pO(new yp(s, h, e, Q), null, f);
          } else if (n & H.IncludeAnonymous || !h.type.isAnonymous || co(h)) {
            let f;
            if (!(n & H.IgnoreMounts) && (f = bi.get(h)) && !f.overlay)
              return new we(f.tree, Q, e, s);
            let $ = new we(h, Q, e, s);
            return n & H.IncludeAnonymous || !$.type.isAnonymous ? $ : $.nextChild(O < 0 ? h.children.length - 1 : 0, O, i, r);
          }
        }
      }
      if (n & H.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + O : e = O < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, O, i = 0) {
    let r;
    if (!(i & H.IgnoreOverlays) && (r = bi.get(this._tree)) && r.overlay) {
      let n = e - this.from;
      for (let { from: s, to: a } of r.overlay)
        if ((O > 0 ? s <= n : s < n) && (O < 0 ? a >= n : a > n))
          return new we(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, O, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function pl(t, e, O, i) {
  let r = t.cursor(), n = [];
  if (!r.firstChild())
    return n;
  if (O != null) {
    for (let s = !1; !s; )
      if (s = r.type.is(O), !r.nextSibling())
        return n;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return n;
    if (r.type.is(e) && n.push(r.node), !r.nextSibling())
      return i == null ? n : [];
  }
}
function Gs(t, e, O = e.length - 1) {
  for (let i = t.parent; O >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[O] && e[O] != i.name)
        return !1;
      O--;
    }
  }
  return !0;
}
class yp {
  constructor(e, O, i, r) {
    this.parent = e, this.buffer = O, this.index = i, this.start = r;
  }
}
class pO extends EQ {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, O, i) {
    super(), this.context = e, this._parent = O, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, O, i) {
    let { buffer: r } = this.context, n = r.findChild(this.index + 4, r.buffer[this.index + 3], e, O - this.context.start, i);
    return n < 0 ? null : new pO(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, O, i = 0) {
    if (i & H.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, n = r.findChild(this.index + 4, r.buffer[this.index + 3], O > 0 ? 1 : -1, e - this.context.start, O);
    return n < 0 ? null : new pO(this.context, this, n);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, O = e.buffer[this.index + 3];
    return O < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new pO(this.context, this._parent, O) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, O = this._parent ? this._parent.index + 4 : 0;
    return this.index == O ? this.externalSibling(-1) : new pO(this.context, this._parent, e.findChild(
      O,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], O = [], { buffer: i } = this.context, r = this.index + 4, n = i.buffer[this.index + 3];
    if (n > r) {
      let s = i.buffer[this.index + 1];
      e.push(i.slice(r, n, s)), O.push(0);
    }
    return new M(this.type, e, O, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function AQ(t) {
  if (!t.length)
    return null;
  let e = 0, O = t[0];
  for (let n = 1; n < t.length; n++) {
    let s = t[n];
    (s.from > O.from || s.to < O.to) && (O = s, e = n);
  }
  let i = O instanceof we && O.index < 0 ? null : O.parent, r = t.slice();
  return i ? r[e] = i : r.splice(e, 1), new bp(r, O);
}
class bp {
  constructor(e, O) {
    this.heads = e, this.node = O;
  }
  get next() {
    return AQ(this.heads);
  }
}
function xp(t, e, O) {
  let i = t.resolveInner(e, O), r = null;
  for (let n = i instanceof we ? i : i.context.parent; n; n = n.parent)
    if (n.index < 0) {
      let s = n.parent;
      (r || (r = [i])).push(s.resolve(e, O)), n = s;
    } else {
      let s = bi.get(n.tree);
      if (s && s.overlay && s.overlay[0].from <= e && s.overlay[s.overlay.length - 1].to >= e) {
        let a = new we(s.tree, s.overlay[0].from + n.from, -1, n);
        (r || (r = [i])).push(xi(a, e, O, !1));
      }
    }
  return r ? AQ(r) : i;
}
class Kr {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, O = 0) {
    if (this.mode = O, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof we)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, O) {
    this.index = e;
    let { start: i, buffer: r } = this.buffer;
    return this.type = O || r.set.types[r.buffer[e]], this.from = i + r.buffer[e + 1], this.to = i + r.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof we ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, O, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, O, i, this.mode));
    let { buffer: r } = this.buffer, n = r.findChild(this.index + 4, r.buffer[this.index + 3], e, O - this.buffer.start, i);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, O, i = this.mode) {
    return this.buffer ? i & H.ExcludeBuffers ? !1 : this.enterChild(1, e, O) : this.yield(this._tree.enter(e, O, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & H.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & H.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: O } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(O.findChild(
          r,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let r = O.buffer[this.index + 3];
      if (r < (i < 0 ? O.buffer.length : O.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let O, i, { buffer: r } = this;
    if (r) {
      if (e > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (r.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: O, parent: i } = r);
    } else
      ({ index: O, _parent: i } = this._tree);
    for (; i; { index: O, _parent: i } = i)
      if (O > -1)
        for (let n = O + e, s = e < 0 ? -1 : i._tree.children.length; n != s; n += e) {
          let a = i._tree.children[n];
          if (this.mode & H.IncludeAnonymous || a instanceof LO || !a.type.isAnonymous || co(a))
            return !1;
        }
    return !0;
  }
  move(e, O) {
    if (O && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, O = 0) {
    for (; (this.from == this.to || (O < 1 ? this.from >= e : this.from > e) || (O > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, O); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, O = null, i = 0;
    if (e && e.context == this.buffer)
      e: for (let r = this.index, n = this.stack.length; n >= 0; ) {
        for (let s = e; s; s = s._parent)
          if (s.index == r) {
            if (r == this.index)
              return s;
            O = s, i = n + 1;
            break e;
          }
        r = this.stack[--n];
      }
    for (let r = i; r < this.stack.length; r++)
      O = new pO(this.buffer, O, this.stack[r]);
    return this.bufferNode = new pO(this.buffer, O, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, O) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; r && O && O(this), r = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, r = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Gs(this.node, e);
    let { buffer: O } = this.buffer, { types: i } = O.set;
    for (let r = e.length - 1, n = this.stack.length - 1; r >= 0; n--) {
      if (n < 0)
        return Gs(this.node, e, r);
      let s = i[O.buffer[this.stack[n]]];
      if (!s.isAnonymous) {
        if (e[r] && e[r] != s.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}
function co(t) {
  return t.children.some((e) => e instanceof LO || !e.type.isAnonymous || co(e));
}
function Tp(t) {
  var e;
  let { buffer: O, nodeSet: i, maxBufferLength: r = 1024, reused: n = [], minRepeatType: s = i.types.length } = t, a = Array.isArray(O) ? new lo(O, O.length) : O, o = i.types, c = 0, h = 0;
  function Q(S, w, T, U, j, G) {
    let { id: _, start: V, end: B, size: D } = a, ie = h;
    for (; D < 0; )
      if (a.next(), D == -1) {
        let $e = n[_];
        T.push($e), U.push(V - S);
        return;
      } else if (D == -3) {
        c = _;
        return;
      } else if (D == -4) {
        h = _;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${D}`);
    let Ze = o[_], Ye, _e, Me = V - S;
    if (B - V <= r && (_e = p(a.pos - w, j))) {
      let $e = new Uint16Array(_e.size - _e.skip), Le = a.pos - _e.size, cO = $e.length;
      for (; a.pos > Le; )
        cO = m(_e.start, $e, cO);
      Ye = new LO($e, B - _e.start, i), Me = _e.start - S;
    } else {
      let $e = a.pos - D;
      a.next();
      let Le = [], cO = [], et = _ >= s ? _ : -1, mt = 0, cr = B;
      for (; a.pos > $e; )
        et >= 0 && a.id == et && a.size >= 0 ? (a.end <= cr - r && (u(Le, cO, V, mt, a.end, cr, et, ie), mt = Le.length, cr = a.end), a.next()) : G > 2500 ? f(V, $e, Le, cO) : Q(V, $e, Le, cO, et, G + 1);
      if (et >= 0 && mt > 0 && mt < Le.length && u(Le, cO, V, mt, V, cr, et, ie), Le.reverse(), cO.reverse(), et > -1 && mt > 0) {
        let ul = $(Ze);
        Ye = ho(Ze, Le, cO, 0, Le.length, 0, B - V, ul, ul);
      } else
        Ye = d(Ze, Le, cO, B - V, ie - B);
    }
    T.push(Ye), U.push(Me);
  }
  function f(S, w, T, U) {
    let j = [], G = 0, _ = -1;
    for (; a.pos > w; ) {
      let { id: V, start: B, end: D, size: ie } = a;
      if (ie > 4)
        a.next();
      else {
        if (_ > -1 && B < _)
          break;
        _ < 0 && (_ = D - r), j.push(V, B, D), G++, a.next();
      }
    }
    if (G) {
      let V = new Uint16Array(G * 4), B = j[j.length - 2];
      for (let D = j.length - 3, ie = 0; D >= 0; D -= 3)
        V[ie++] = j[D], V[ie++] = j[D + 1] - B, V[ie++] = j[D + 2] - B, V[ie++] = ie;
      T.push(new LO(V, j[2] - B, i)), U.push(B - S);
    }
  }
  function $(S) {
    return (w, T, U) => {
      let j = 0, G = w.length - 1, _, V;
      if (G >= 0 && (_ = w[G]) instanceof M) {
        if (!G && _.type == S && _.length == U)
          return _;
        (V = _.prop(Y.lookAhead)) && (j = T[G] + _.length + V);
      }
      return d(S, w, T, U, j);
    };
  }
  function u(S, w, T, U, j, G, _, V) {
    let B = [], D = [];
    for (; S.length > U; )
      B.push(S.pop()), D.push(w.pop() + T - j);
    S.push(d(i.types[_], B, D, G - j, V - G)), w.push(j - T);
  }
  function d(S, w, T, U, j = 0, G) {
    if (c) {
      let _ = [Y.contextHash, c];
      G = G ? [_].concat(G) : [_];
    }
    if (j > 25) {
      let _ = [Y.lookAhead, j];
      G = G ? [_].concat(G) : [_];
    }
    return new M(S, w, T, U, G);
  }
  function p(S, w) {
    let T = a.fork(), U = 0, j = 0, G = 0, _ = T.end - r, V = { size: 0, start: 0, skip: 0 };
    e: for (let B = T.pos - S; T.pos > B; ) {
      let D = T.size;
      if (T.id == w && D >= 0) {
        V.size = U, V.start = j, V.skip = G, G += 4, U += 4, T.next();
        continue;
      }
      let ie = T.pos - D;
      if (D < 0 || ie < B || T.start < _)
        break;
      let Ze = T.id >= s ? 4 : 0, Ye = T.start;
      for (T.next(); T.pos > ie; ) {
        if (T.size < 0)
          if (T.size == -3)
            Ze += 4;
          else
            break e;
        else T.id >= s && (Ze += 4);
        T.next();
      }
      j = Ye, U += D, G += Ze;
    }
    return (w < 0 || U == S) && (V.size = U, V.start = j, V.skip = G), V.size > 4 ? V : void 0;
  }
  function m(S, w, T) {
    let { id: U, start: j, end: G, size: _ } = a;
    if (a.next(), _ >= 0 && U < s) {
      let V = T;
      if (_ > 4) {
        let B = a.pos - (_ - 4);
        for (; a.pos > B; )
          T = m(S, w, T);
      }
      w[--T] = V, w[--T] = G - S, w[--T] = j - S, w[--T] = U;
    } else _ == -3 ? c = U : _ == -4 && (h = U);
    return T;
  }
  let P = [], X = [];
  for (; a.pos > 0; )
    Q(t.start || 0, t.bufferStart || 0, P, X, -1, 0);
  let y = (e = t.length) !== null && e !== void 0 ? e : P.length ? X[0] + P[0].length : 0;
  return new M(o[t.topID], P.reverse(), X.reverse(), y);
}
const ml = /* @__PURE__ */ new WeakMap();
function _r(t, e) {
  if (!t.isAnonymous || e instanceof LO || e.type != t)
    return 1;
  let O = ml.get(e);
  if (O == null) {
    O = 1;
    for (let i of e.children) {
      if (i.type != t || !(i instanceof M)) {
        O = 1;
        break;
      }
      O += _r(t, i);
    }
    ml.set(e, O);
  }
  return O;
}
function ho(t, e, O, i, r, n, s, a, o) {
  let c = 0;
  for (let u = i; u < r; u++)
    c += _r(t, e[u]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), Q = [], f = [];
  function $(u, d, p, m, P) {
    for (let X = p; X < m; ) {
      let y = X, S = d[X], w = _r(t, u[X]);
      for (X++; X < m; X++) {
        let T = _r(t, u[X]);
        if (w + T >= h)
          break;
        w += T;
      }
      if (X == y + 1) {
        if (w > h) {
          let T = u[y];
          $(T.children, T.positions, 0, T.children.length, d[y] + P);
          continue;
        }
        Q.push(u[y]);
      } else {
        let T = d[X - 1] + u[X - 1].length - S;
        Q.push(ho(t, u, d, y, X, S, T, null, o));
      }
      f.push(S + P - n);
    }
  }
  return $(e, O, i, r, 0), (a || o)(Q, f, s);
}
class Qo {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, O, i) {
    let r = this.map.get(e);
    r || this.map.set(e, r = /* @__PURE__ */ new Map()), r.set(O, i);
  }
  getBuffer(e, O) {
    let i = this.map.get(e);
    return i && i.get(O);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, O) {
    e instanceof pO ? this.setBuffer(e.context.buffer, e.index, O) : e instanceof we && this.map.set(e.tree, O);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof pO ? this.getBuffer(e.context.buffer, e.index) : e instanceof we ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, O) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, O) : this.map.set(e.tree, O);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class wO {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, O, i, r, n = !1, s = !1) {
    this.from = e, this.to = O, this.tree = i, this.offset = r, this.open = (n ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, O = [], i = !1) {
    let r = [new wO(0, e.length, e, 0, !1, i)];
    for (let n of O)
      n.to > e.length && r.push(n);
    return r;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, O, i = 128) {
    if (!O.length)
      return e;
    let r = [], n = 1, s = e.length ? e[0] : null;
    for (let a = 0, o = 0, c = 0; ; a++) {
      let h = a < O.length ? O[a] : null, Q = h ? h.fromA : 1e9;
      if (Q - o >= i)
        for (; s && s.from < Q; ) {
          let f = s;
          if (o >= f.from || Q <= f.to || c) {
            let $ = Math.max(f.from, o) - c, u = Math.min(f.to, Q) - c;
            f = $ >= u ? null : new wO($, u, f.tree, f.offset + c, a > 0, !!h);
          }
          if (f && r.push(f), s.to > Q)
            break;
          s = n < e.length ? e[n++] : null;
        }
      if (!h)
        break;
      o = h.toA, c = h.toA - h.toB;
    }
    return r;
  }
}
class fo {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, O, i) {
    return typeof e == "string" && (e = new wp(e)), i = i ? i.length ? i.map((r) => new Ke(r.from, r.to)) : [new Ke(0, 0)] : [new Ke(0, e.length)], this.createParse(e, O || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, O, i) {
    let r = this.startParse(e, O, i);
    for (; ; ) {
      let n = r.advance();
      if (n)
        return n;
    }
  }
}
class wp {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, O) {
    return this.string.slice(e, O);
  }
}
function SO(t) {
  return (e, O, i, r) => new Wp(e, t, O, i, r);
}
class Pl {
  constructor(e, O, i, r, n) {
    this.parser = e, this.parse = O, this.overlay = i, this.target = r, this.from = n;
  }
}
function gl(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class kp {
  constructor(e, O, i, r, n, s, a) {
    this.parser = e, this.predicate = O, this.mounts = i, this.index = r, this.start = n, this.target = s, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const Cs = new Y({ perNode: !0 });
class Wp {
  constructor(e, O, i, r, n) {
    this.nest = O, this.input = i, this.fragments = r, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let r of this.inner)
          r.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new M(i.type, i.children, i.positions, i.length, i.propValues.concat([[Cs, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], O = e.parse.advance();
    if (O) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[Y.mounted.id] = new bi(O, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let O = this.innerDone; O < this.inner.length; O++)
      this.inner[O].from < e && (e = Math.min(e, this.inner[O].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let O = this.innerDone; O < this.inner.length; O++)
        this.inner[O].parse.stopAt(e);
  }
  startInner() {
    let e = new Zp(this.fragments), O = null, i = null, r = new Kr(new we(this.baseTree, this.ranges[0].from, 0, null), H.IncludeAnonymous | H.IgnoreMounts);
    e: for (let n, s; ; ) {
      let a = !0, o;
      if (this.stoppedAt != null && r.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(r)) {
        if (O) {
          let c = O.mounts.find((h) => h.frag.from <= r.from && h.frag.to >= r.to && h.mount.overlay);
          if (c)
            for (let h of c.mount.overlay) {
              let Q = h.from + c.pos, f = h.to + c.pos;
              Q >= r.from && f <= r.to && !O.ranges.some(($) => $.from < f && $.to > Q) && O.ranges.push({ from: Q, to: f });
            }
        }
        a = !1;
      } else if (i && (s = Rp(i.ranges, r.from, r.to)))
        a = s != 2;
      else if (!r.type.isAnonymous && (n = this.nest(r, this.input)) && (r.from < r.to || !n.overlay)) {
        r.tree || vp(r);
        let c = e.findMounts(r.from, n.parser);
        if (typeof n.overlay == "function")
          O = new kp(n.parser, n.overlay, c, this.inner.length, r.from, r.tree, O);
        else {
          let h = yl(this.ranges, n.overlay || (r.from < r.to ? [new Ke(r.from, r.to)] : []));
          h.length && gl(h), (h.length || !n.overlay) && this.inner.push(new Pl(n.parser, h.length ? n.parser.startParse(this.input, bl(c, h), h) : n.parser.startParse(""), n.overlay ? n.overlay.map((Q) => new Ke(Q.from - r.from, Q.to - r.from)) : null, r.tree, h.length ? h[0].from : r.from)), n.overlay ? h.length && (i = { ranges: h, depth: 0, prev: i }) : a = !1;
        }
      } else O && (o = O.predicate(r)) && (o === !0 && (o = new Ke(r.from, r.to)), o.from < o.to && O.ranges.push(o));
      if (a && r.firstChild())
        O && O.depth++, i && i.depth++;
      else
        for (; !r.nextSibling(); ) {
          if (!r.parent())
            break e;
          if (O && !--O.depth) {
            let c = yl(this.ranges, O.ranges);
            c.length && (gl(c), this.inner.splice(O.index, 0, new Pl(O.parser, O.parser.startParse(this.input, bl(O.mounts, c), c), O.ranges.map((h) => new Ke(h.from - O.start, h.to - O.start)), O.target, c[0].from))), O = O.prev;
          }
          i && !--i.depth && (i = i.prev);
        }
    }
  }
}
function Rp(t, e, O) {
  for (let i of t) {
    if (i.from >= O)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= O ? 2 : 1;
  }
  return 0;
}
function Sl(t, e, O, i, r, n) {
  if (e < O) {
    let s = t.buffer[e + 1];
    i.push(t.slice(e, O, s)), r.push(s - n);
  }
}
function vp(t) {
  let { node: e } = t, O = [], i = e.context.buffer;
  do
    O.push(t.index), t.parent();
  while (!t.tree);
  let r = t.tree, n = r.children.indexOf(i), s = r.children[n], a = s.buffer, o = [n];
  function c(h, Q, f, $, u, d) {
    let p = O[d], m = [], P = [];
    Sl(s, h, p, m, P, $);
    let X = a[p + 1], y = a[p + 2];
    o.push(m.length);
    let S = d ? c(p + 4, a[p + 3], s.set.types[a[p]], X, y - X, d - 1) : e.toTree();
    return m.push(S), P.push(X - $), Sl(s, a[p + 3], Q, m, P, $), new M(f, m, P, u);
  }
  r.children[n] = c(0, a.length, de.none, 0, s.length, O.length - 1);
  for (let h of o) {
    let Q = t.tree.children[h], f = t.tree.positions[h];
    t.yield(new we(Q, f + t.from, h, t._tree));
  }
}
class Xl {
  constructor(e, O) {
    this.offset = O, this.done = !1, this.cursor = e.cursor(H.IncludeAnonymous | H.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: O } = this, i = e - this.offset;
    for (; !this.done && O.from < i; )
      O.to >= e && O.enter(i, 1, H.IgnoreOverlays | H.ExcludeBuffers) || O.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let O = this.cursor.tree; ; ) {
        if (O == e.tree)
          return !0;
        if (O.children.length && O.positions[0] == 0 && O.children[0] instanceof M)
          O = O.children[0];
        else
          break;
      }
    return !1;
  }
}
let Zp = class {
  constructor(e) {
    var O;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (O = i.tree.prop(Cs)) !== null && O !== void 0 ? O : i.to, this.inner = new Xl(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let O = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = O.tree.prop(Cs)) !== null && e !== void 0 ? e : O.to, this.inner = new Xl(O.tree, -O.offset);
    }
  }
  findMounts(e, O) {
    var i;
    let r = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let n = this.inner.cursor.node; n; n = n.parent) {
        let s = (i = n.tree) === null || i === void 0 ? void 0 : i.prop(Y.mounted);
        if (s && s.parser == O)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let o = this.fragments[a];
            if (o.from >= n.to)
              break;
            o.tree == this.curFrag.tree && r.push({
              frag: o,
              pos: n.from - o.offset,
              mount: s
            });
          }
      }
    }
    return r;
  }
};
function yl(t, e) {
  let O = null, i = e;
  for (let r = 1, n = 0; r < t.length; r++) {
    let s = t[r - 1].to, a = t[r].from;
    for (; n < i.length; n++) {
      let o = i[n];
      if (o.from >= a)
        break;
      o.to <= s || (O || (i = O = e.slice()), o.from < s ? (O[n] = new Ke(o.from, s), o.to > a && O.splice(n + 1, 0, new Ke(a, o.to))) : o.to > a ? O[n--] = new Ke(a, o.to) : O.splice(n--, 1));
    }
  }
  return i;
}
function Yp(t, e, O, i) {
  let r = 0, n = 0, s = !1, a = !1, o = -1e9, c = [];
  for (; ; ) {
    let h = r == t.length ? 1e9 : s ? t[r].to : t[r].from, Q = n == e.length ? 1e9 : a ? e[n].to : e[n].from;
    if (s != a) {
      let f = Math.max(o, O), $ = Math.min(h, Q, i);
      f < $ && c.push(new Ke(f, $));
    }
    if (o = Math.min(h, Q), o == 1e9)
      break;
    h == o && (s ? (s = !1, r++) : s = !0), Q == o && (a ? (a = !1, n++) : a = !0);
  }
  return c;
}
function bl(t, e) {
  let O = [];
  for (let { pos: i, mount: r, frag: n } of t) {
    let s = i + (r.overlay ? r.overlay[0].from : 0), a = s + r.tree.length, o = Math.max(n.from, s), c = Math.min(n.to, a);
    if (r.overlay) {
      let h = r.overlay.map((f) => new Ke(f.from + i, f.to + i)), Q = Yp(e, h, o, c);
      for (let f = 0, $ = o; ; f++) {
        let u = f == Q.length, d = u ? c : Q[f].from;
        if (d > $ && O.push(new wO($, d, r.tree, -s, n.from >= $ || n.openStart, n.to <= d || n.openEnd)), u)
          break;
        $ = Q[f].to;
      }
    } else
      O.push(new wO(o, c, r.tree, -s, n.from >= s || n.openStart, n.to <= a || n.openEnd));
  }
  return O;
}
let N = class DQ {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, O, i) {
    [e, O] = Ut(this, e, O);
    let r = [];
    return this.decompose(
      0,
      e,
      r,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      r,
      3
      /* Open.To */
    ), this.decompose(
      O,
      this.length,
      r,
      1
      /* Open.From */
    ), uO.from(r, this.length - (O - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, O = this.length) {
    [e, O] = Ut(this, e, O);
    let i = [];
    return this.decompose(e, O, i, 0), uO.from(i, O - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let O = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), r = new fi(this), n = new fi(e);
    for (let s = O, a = O; ; ) {
      if (r.next(s), n.next(s), s = 0, r.lineBreak != n.lineBreak || r.done != n.done || r.value != n.value)
        return !1;
      if (a += r.value.length, r.done || a >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new fi(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, O = this.length) {
    return new NQ(this, e, O);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, O) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      O == null && (O = this.lines + 1);
      let r = this.line(e).from;
      i = this.iterRange(r, Math.max(r, O == this.lines + 1 ? this.length : O <= 1 ? 0 : this.line(O - 1).to));
    }
    return new IQ(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? DQ.empty : e.length <= 32 ? new oe(e) : uO.from(oe.split(e, []));
  }
};
class oe extends N {
  constructor(e, O = zp(e)) {
    super(), this.text = e, this.length = O;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, O, i, r) {
    for (let n = 0; ; n++) {
      let s = this.text[n], a = r + s.length;
      if ((O ? i : a) >= e)
        return new qp(r, a, i, s);
      r = a + 1, i++;
    }
  }
  decompose(e, O, i, r) {
    let n = e <= 0 && O >= this.length ? this : new oe(xl(this.text, e, O), Math.min(O, this.length) - Math.max(0, e));
    if (r & 1) {
      let s = i.pop(), a = jr(n.text, s.text.slice(), 0, n.length);
      if (a.length <= 32)
        i.push(new oe(a, s.length + n.length));
      else {
        let o = a.length >> 1;
        i.push(new oe(a.slice(0, o)), new oe(a.slice(o)));
      }
    } else
      i.push(n);
  }
  replace(e, O, i) {
    if (!(i instanceof oe))
      return super.replace(e, O, i);
    [e, O] = Ut(this, e, O);
    let r = jr(this.text, jr(i.text, xl(this.text, 0, e)), O), n = this.length + i.length - (O - e);
    return r.length <= 32 ? new oe(r, n) : uO.from(oe.split(r, []), n);
  }
  sliceString(e, O = this.length, i = `
`) {
    [e, O] = Ut(this, e, O);
    let r = "";
    for (let n = 0, s = 0; n <= O && s < this.text.length; s++) {
      let a = this.text[s], o = n + a.length;
      n > e && s && (r += i), e < o && O > n && (r += a.slice(Math.max(0, e - n), O - n)), n = o + 1;
    }
    return r;
  }
  flatten(e) {
    for (let O of this.text)
      e.push(O);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, O) {
    let i = [], r = -1;
    for (let n of e)
      i.push(n), r += n.length + 1, i.length == 32 && (O.push(new oe(i, r)), i = [], r = -1);
    return r > -1 && O.push(new oe(i, r)), O;
  }
}
class uO extends N {
  constructor(e, O) {
    super(), this.children = e, this.length = O, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, O, i, r) {
    for (let n = 0; ; n++) {
      let s = this.children[n], a = r + s.length, o = i + s.lines - 1;
      if ((O ? o : a) >= e)
        return s.lineInner(e, O, i, r);
      r = a + 1, i = o + 1;
    }
  }
  decompose(e, O, i, r) {
    for (let n = 0, s = 0; s <= O && n < this.children.length; n++) {
      let a = this.children[n], o = s + a.length;
      if (e <= o && O >= s) {
        let c = r & ((s <= e ? 1 : 0) | (o >= O ? 2 : 0));
        s >= e && o <= O && !c ? i.push(a) : a.decompose(e - s, O - s, i, c);
      }
      s = o + 1;
    }
  }
  replace(e, O, i) {
    if ([e, O] = Ut(this, e, O), i.lines < this.lines)
      for (let r = 0, n = 0; r < this.children.length; r++) {
        let s = this.children[r], a = n + s.length;
        if (e >= n && O <= a) {
          let o = s.replace(e - n, O - n, i), c = this.lines - s.lines + o.lines;
          if (o.lines < c >> 4 && o.lines > c >> 6) {
            let h = this.children.slice();
            return h[r] = o, new uO(h, this.length - (O - e) + i.length);
          }
          return super.replace(n, a, o);
        }
        n = a + 1;
      }
    return super.replace(e, O, i);
  }
  sliceString(e, O = this.length, i = `
`) {
    [e, O] = Ut(this, e, O);
    let r = "";
    for (let n = 0, s = 0; n < this.children.length && s <= O; n++) {
      let a = this.children[n], o = s + a.length;
      s > e && n && (r += i), e < o && O > s && (r += a.sliceString(e - s, O - s, i)), s = o + 1;
    }
    return r;
  }
  flatten(e) {
    for (let O of this.children)
      O.flatten(e);
  }
  scanIdentical(e, O) {
    if (!(e instanceof uO))
      return 0;
    let i = 0, [r, n, s, a] = O > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; r += O, n += O) {
      if (r == s || n == a)
        return i;
      let o = this.children[r], c = e.children[n];
      if (o != c)
        return i + o.scanIdentical(c, O);
      i += o.length + 1;
    }
  }
  static from(e, O = e.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let $ of e)
      i += $.lines;
    if (i < 32) {
      let $ = [];
      for (let u of e)
        u.flatten($);
      return new oe($, O);
    }
    let r = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), n = r << 1, s = r >> 1, a = [], o = 0, c = -1, h = [];
    function Q($) {
      let u;
      if ($.lines > n && $ instanceof uO)
        for (let d of $.children)
          Q(d);
      else $.lines > s && (o > s || !o) ? (f(), a.push($)) : $ instanceof oe && o && (u = h[h.length - 1]) instanceof oe && $.lines + u.lines <= 32 ? (o += $.lines, c += $.length + 1, h[h.length - 1] = new oe(u.text.concat($.text), u.length + 1 + $.length)) : (o + $.lines > r && f(), o += $.lines, c += $.length + 1, h.push($));
    }
    function f() {
      o != 0 && (a.push(h.length == 1 ? h[0] : uO.from(h, c)), c = -1, o = h.length = 0);
    }
    for (let $ of e)
      Q($);
    return f(), a.length == 1 ? a[0] : new uO(a, O);
  }
}
N.empty = /* @__PURE__ */ new oe([""], 0);
function zp(t) {
  let e = -1;
  for (let O of t)
    e += O.length + 1;
  return e;
}
function jr(t, e, O = 0, i = 1e9) {
  for (let r = 0, n = 0, s = !0; n < t.length && r <= i; n++) {
    let a = t[n], o = r + a.length;
    o >= O && (o > i && (a = a.slice(0, i - r)), r < O && (a = a.slice(O - r)), s ? (e[e.length - 1] += a, s = !1) : e.push(a)), r = o + 1;
  }
  return e;
}
function xl(t, e, O) {
  return jr(t, [""], e, O);
}
class fi {
  constructor(e, O = 1) {
    this.dir = O, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [O > 0 ? 1 : (e instanceof oe ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, O) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], n = this.offsets[i], s = n >> 1, a = r instanceof oe ? r.text.length : r.children.length;
      if (s == (O > 0 ? a : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        O > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (O > 0 ? 0 : 1)) {
        if (this.offsets[i] += O, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (r instanceof oe) {
        let o = r.text[s + (O < 0 ? -1 : 0)];
        if (this.offsets[i] += O, o.length > Math.max(0, e))
          return this.value = e == 0 ? o : O > 0 ? o.slice(e) : o.slice(0, o.length - e), this;
        e -= o.length;
      } else {
        let o = r.children[s + (O < 0 ? -1 : 0)];
        e > o.length ? (e -= o.length, this.offsets[i] += O) : (O < 0 && this.offsets[i]--, this.nodes.push(o), this.offsets.push(O > 0 ? 1 : (o instanceof oe ? o.text.length : o.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class NQ {
  constructor(e, O, i) {
    this.value = "", this.done = !1, this.cursor = new fi(e, O > i ? -1 : 1), this.pos = O > i ? e.length : 0, this.from = Math.min(O, i), this.to = Math.max(O, i);
  }
  nextInner(e, O) {
    if (O < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, O < 0 ? this.pos - this.to : this.from - this.pos);
    let i = O < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: r } = this.cursor.next(e);
    return this.pos += (r.length + e) * O, this.value = r.length <= i ? r : O < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class IQ {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: O, lineBreak: i, value: r } = this.inner.next(e);
    return O && this.afterBreak ? (this.value = "", this.afterBreak = !1) : O ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (N.prototype[Symbol.iterator] = function() {
  return this.iter();
}, fi.prototype[Symbol.iterator] = NQ.prototype[Symbol.iterator] = IQ.prototype[Symbol.iterator] = function() {
  return this;
});
let qp = class {
  /**
  @internal
  */
  constructor(e, O, i, r) {
    this.from = e, this.to = O, this.number = i, this.text = r;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
};
function Ut(t, e, O) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, O))];
}
let Wt = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < Wt.length; t++)
  Wt[t] += Wt[t - 1];
function Up(t) {
  for (let e = 1; e < Wt.length; e += 2)
    if (Wt[e] > t)
      return Wt[e - 1] <= t;
  return !1;
}
function Tl(t) {
  return t >= 127462 && t <= 127487;
}
const wl = 8205;
function be(t, e, O = !0, i = !0) {
  return (O ? MQ : Vp)(t, e, i);
}
function MQ(t, e, O) {
  if (e == t.length)
    return e;
  e && LQ(t.charCodeAt(e)) && BQ(t.charCodeAt(e - 1)) && e--;
  let i = ge(t, e);
  for (e += Fe(i); e < t.length; ) {
    let r = ge(t, e);
    if (i == wl || r == wl || O && Up(r))
      e += Fe(r), i = r;
    else if (Tl(r)) {
      let n = 0, s = e - 2;
      for (; s >= 0 && Tl(ge(t, s)); )
        n++, s -= 2;
      if (n % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function Vp(t, e, O) {
  for (; e > 0; ) {
    let i = MQ(t, e - 2, O);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function LQ(t) {
  return t >= 56320 && t < 57344;
}
function BQ(t) {
  return t >= 55296 && t < 56320;
}
function ge(t, e) {
  let O = t.charCodeAt(e);
  if (!BQ(O) || e + 1 == t.length)
    return O;
  let i = t.charCodeAt(e + 1);
  return LQ(i) ? (O - 55296 << 10) + (i - 56320) + 65536 : O;
}
function $o(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Fe(t) {
  return t < 65536 ? 1 : 2;
}
const Es = /\r\n?|\n/;
var Xe = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Xe || (Xe = {}));
class gO {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let O = 0; O < this.sections.length; O += 2)
      e += this.sections[O];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let O = 0; O < this.sections.length; O += 2) {
      let i = this.sections[O + 1];
      e += i < 0 ? this.sections[O] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let O = 0, i = 0, r = 0; O < this.sections.length; ) {
      let n = this.sections[O++], s = this.sections[O++];
      s < 0 ? (e(i, r, n), r += n) : r += s, i += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, O = !1) {
    As(this, e, O);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let O = 0; O < this.sections.length; ) {
      let i = this.sections[O++], r = this.sections[O++];
      r < 0 ? e.push(i, r) : e.push(r, i);
    }
    return new gO(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : FQ(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, O = !1) {
    return e.empty ? this : Ds(this, e, O);
  }
  mapPos(e, O = -1, i = Xe.Simple) {
    let r = 0, n = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], o = this.sections[s++], c = r + a;
      if (o < 0) {
        if (c > e)
          return n + (e - r);
        n += a;
      } else {
        if (i != Xe.Simple && c >= e && (i == Xe.TrackDel && r < e && c > e || i == Xe.TrackBefore && r < e || i == Xe.TrackAfter && c > e))
          return null;
        if (c > e || c == e && O < 0 && !a)
          return e == r || O < 0 ? n : n + o;
        n += o;
      }
      r = c;
    }
    if (e > r)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, O = e) {
    for (let i = 0, r = 0; i < this.sections.length && r <= O; ) {
      let n = this.sections[i++], s = this.sections[i++], a = r + n;
      if (s >= 0 && r <= O && a >= e)
        return r < e && a > O ? "cover" : !0;
      r = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let O = 0; O < this.sections.length; ) {
      let i = this.sections[O++], r = this.sections[O++];
      e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((O) => typeof O != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new gO(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new gO(e);
  }
}
class ue extends gO {
  constructor(e, O) {
    super(e), this.inserted = O;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return As(this, (O, i, r, n, s) => e = e.replace(r, r + (i - O), s), !1), e;
  }
  mapDesc(e, O = !1) {
    return Ds(this, e, O, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let O = this.sections.slice(), i = [];
    for (let r = 0, n = 0; r < O.length; r += 2) {
      let s = O[r], a = O[r + 1];
      if (a >= 0) {
        O[r] = a, O[r + 1] = s;
        let o = r >> 1;
        for (; i.length < o; )
          i.push(N.empty);
        i.push(s ? e.slice(n, n + s) : N.empty);
      }
      n += s;
    }
    return new ue(O, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : FQ(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, O = !1) {
    return e.empty ? this : Ds(this, e, O, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, O = !1) {
    As(this, e, O);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return gO.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let O = [], i = [], r = [], n = new Ti(this);
    e: for (let s = 0, a = 0; ; ) {
      let o = s == e.length ? 1e9 : e[s++];
      for (; a < o || a == o && n.len == 0; ) {
        if (n.done)
          break e;
        let h = Math.min(n.len, o - a);
        xe(r, h, -1);
        let Q = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
        xe(O, h, Q), Q > 0 && AO(i, O, n.text), n.forward(h), a += h;
      }
      let c = e[s++];
      for (; a < c; ) {
        if (n.done)
          break e;
        let h = Math.min(n.len, c - a);
        xe(O, h, -1), xe(r, h, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(h), a += h;
      }
    }
    return {
      changes: new ue(O, i),
      filtered: gO.create(r)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let O = 0; O < this.sections.length; O += 2) {
      let i = this.sections[O], r = this.sections[O + 1];
      r < 0 ? e.push(i) : r == 0 ? e.push([i]) : e.push([i].concat(this.inserted[O >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, O, i) {
    let r = [], n = [], s = 0, a = null;
    function o(h = !1) {
      if (!h && !r.length)
        return;
      s < O && xe(r, O - s, -1);
      let Q = new ue(r, n);
      a = a ? a.compose(Q.map(a)) : Q, r = [], n = [], s = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let Q of h)
          c(Q);
      else if (h instanceof ue) {
        if (h.length != O)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${O})`);
        o(), a = a ? a.compose(h.map(a)) : h;
      } else {
        let { from: Q, to: f = Q, insert: $ } = h;
        if (Q > f || Q < 0 || f > O)
          throw new RangeError(`Invalid change range ${Q} to ${f} (in doc of length ${O})`);
        let u = $ ? typeof $ == "string" ? N.of($.split(i || Es)) : $ : N.empty, d = u.length;
        if (Q == f && d == 0)
          return;
        Q < s && o(), Q > s && xe(r, Q - s, -1), xe(r, f - Q, d), AO(n, r, u), s = f;
      }
    }
    return c(e), o(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new ue(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let O = [], i = [];
    for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (typeof n == "number")
        O.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          O.push(n[0], 0);
        else {
          for (; i.length < r; )
            i.push(N.empty);
          i[r] = N.of(n.slice(1)), O.push(n[0], i[r].length);
        }
      }
    }
    return new ue(O, i);
  }
  /**
  @internal
  */
  static createSet(e, O) {
    return new ue(e, O);
  }
}
function xe(t, e, O, i = !1) {
  if (e == 0 && O <= 0)
    return;
  let r = t.length - 2;
  r >= 0 && O <= 0 && O == t[r + 1] ? t[r] += e : e == 0 && t[r] == 0 ? t[r + 1] += O : i ? (t[r] += e, t[r + 1] += O) : t.push(e, O);
}
function AO(t, e, O) {
  if (O.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < t.length)
    t[t.length - 1] = t[t.length - 1].append(O);
  else {
    for (; t.length < i; )
      t.push(N.empty);
    t.push(O);
  }
}
function As(t, e, O) {
  let i = t.inserted;
  for (let r = 0, n = 0, s = 0; s < t.sections.length; ) {
    let a = t.sections[s++], o = t.sections[s++];
    if (o < 0)
      r += a, n += a;
    else {
      let c = r, h = n, Q = N.empty;
      for (; c += a, h += o, o && i && (Q = Q.append(i[s - 2 >> 1])), !(O || s == t.sections.length || t.sections[s + 1] < 0); )
        a = t.sections[s++], o = t.sections[s++];
      e(r, c, n, h, Q), r = c, n = h;
    }
  }
}
function Ds(t, e, O, i = !1) {
  let r = [], n = i ? [] : null, s = new Ti(t), a = new Ti(e);
  for (let o = -1; ; )
    if (s.ins == -1 && a.ins == -1) {
      let c = Math.min(s.len, a.len);
      xe(r, c, -1), s.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (s.ins < 0 || o == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !O))) {
      let c = a.len;
      for (xe(r, a.ins, -1); c; ) {
        let h = Math.min(s.len, c);
        s.ins >= 0 && o < s.i && s.len <= h && (xe(r, 0, s.ins), n && AO(n, r, s.text), o = s.i), s.forward(h), c -= h;
      }
      a.next();
    } else if (s.ins >= 0) {
      let c = 0, h = s.len;
      for (; h; )
        if (a.ins == -1) {
          let Q = Math.min(h, a.len);
          c += Q, h -= Q, a.forward(Q);
        } else if (a.ins == 0 && a.len < h)
          h -= a.len, a.next();
        else
          break;
      xe(r, c, o < s.i ? s.ins : 0), n && o < s.i && AO(n, r, s.text), o = s.i, s.forward(s.len - h);
    } else {
      if (s.done && a.done)
        return n ? ue.createSet(r, n) : gO.create(r);
      throw new Error("Mismatched change set lengths");
    }
}
function FQ(t, e, O = !1) {
  let i = [], r = O ? [] : null, n = new Ti(t), s = new Ti(e);
  for (let a = !1; ; ) {
    if (n.done && s.done)
      return r ? ue.createSet(i, r) : gO.create(i);
    if (n.ins == 0)
      xe(i, n.len, 0, a), n.next();
    else if (s.len == 0 && !s.done)
      xe(i, 0, s.ins, a), r && AO(r, i, s.text), s.next();
    else {
      if (n.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let o = Math.min(n.len2, s.len), c = i.length;
        if (n.ins == -1) {
          let h = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          xe(i, o, h, a), r && h && AO(r, i, s.text);
        } else s.ins == -1 ? (xe(i, n.off ? 0 : n.len, o, a), r && AO(r, i, n.textBit(o))) : (xe(i, n.off ? 0 : n.len, s.off ? 0 : s.ins, a), r && !s.off && AO(r, i, s.text));
        a = (n.ins > o || s.ins >= 0 && s.len > o) && (a || i.length > c), n.forward2(o), s.forward(o);
      }
    }
  }
}
class Ti {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, O = this.i - 2 >> 1;
    return O >= e.length ? N.empty : e[O];
  }
  textBit(e) {
    let { inserted: O } = this.set, i = this.i - 2 >> 1;
    return i >= O.length && !e ? N.empty : O[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ot {
  constructor(e, O, i) {
    this.from = e, this.to = O, this.flags = i;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, O = -1) {
    let i, r;
    return this.empty ? i = r = e.mapPos(this.from, O) : (i = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new ot(i, r, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, O = e) {
    if (e <= this.anchor && O >= this.anchor)
      return g.range(e, O);
    let i = Math.abs(e - this.anchor) > Math.abs(O - this.anchor) ? e : O;
    return g.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, O = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!O || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return g.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, O, i) {
    return new ot(e, O, i);
  }
}
class g {
  constructor(e, O) {
    this.ranges = e, this.mainIndex = O;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, O = -1) {
    return e.empty ? this : g.create(this.ranges.map((i) => i.map(e, O)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, O = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], O))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new g([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, O = !0) {
    return g.create([e].concat(this.ranges), O ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, O = this.mainIndex) {
    let i = this.ranges.slice();
    return i[O] = e, g.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new g(e.ranges.map((O) => ot.fromJSON(O)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, O = e) {
    return new g([g.range(e, O)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, O = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.empty ? n.from <= i : n.from < i)
        return g.normalized(e.slice(), O);
      i = n.to;
    }
    return new g(e, O);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, O = 0, i, r) {
    return ot.create(e, e, (O == 0 ? 0 : O < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (r ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, O, i, r) {
    let n = (i ?? 16777215) << 6 | (r == null ? 7 : Math.min(6, r));
    return O < e ? ot.create(O, e, 48 | n) : ot.create(e, O, (O > e ? 8 : 0) | n);
  }
  /**
  @internal
  */
  static normalized(e, O = 0) {
    let i = e[O];
    e.sort((r, n) => r.from - n.from), O = e.indexOf(i);
    for (let r = 1; r < e.length; r++) {
      let n = e[r], s = e[r - 1];
      if (n.empty ? n.from <= s.to : n.from < s.to) {
        let a = s.from, o = Math.max(n.to, s.to);
        r <= O && O--, e.splice(--r, 2, n.anchor > n.head ? g.range(o, a) : g.range(a, o));
      }
    }
    return new g(e, O);
  }
}
function HQ(t, e) {
  for (let O of t.ranges)
    if (O.to > e)
      throw new RangeError("Selection points outside of document");
}
let uo = 0;
class R {
  constructor(e, O, i, r, n) {
    this.combine = e, this.compareInput = O, this.compare = i, this.isStatic = r, this.id = uo++, this.default = e([]), this.extensions = typeof n == "function" ? n(this) : n;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new R(e.combine || ((O) => O), e.compareInput || ((O, i) => O === i), e.compare || (e.combine ? (O, i) => O === i : po), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Gr([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, O) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Gr(e, this, 1, O);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, O) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Gr(e, this, 2, O);
  }
  from(e, O) {
    return O || (O = (i) => i), this.compute([e], (i) => O(i.field(e)));
  }
}
function po(t, e) {
  return t == e || t.length == e.length && t.every((O, i) => O === e[i]);
}
class Gr {
  constructor(e, O, i, r) {
    this.dependencies = e, this.facet = O, this.type = i, this.value = r, this.id = uo++;
  }
  dynamicSlot(e) {
    var O;
    let i = this.value, r = this.facet.compareInput, n = this.id, s = e[n] >> 1, a = this.type == 2, o = !1, c = !1, h = [];
    for (let Q of this.dependencies)
      Q == "doc" ? o = !0 : Q == "selection" ? c = !0 : ((O = e[Q.id]) !== null && O !== void 0 ? O : 1) & 1 || h.push(e[Q.id]);
    return {
      create(Q) {
        return Q.values[s] = i(Q), 1;
      },
      update(Q, f) {
        if (o && f.docChanged || c && (f.docChanged || f.selection) || Ns(Q, h)) {
          let $ = i(Q);
          if (a ? !kl($, Q.values[s], r) : !r($, Q.values[s]))
            return Q.values[s] = $, 1;
        }
        return 0;
      },
      reconfigure: (Q, f) => {
        let $, u = f.config.address[n];
        if (u != null) {
          let d = en(f, u);
          if (this.dependencies.every((p) => p instanceof R ? f.facet(p) === Q.facet(p) : p instanceof pe ? f.field(p, !1) == Q.field(p, !1) : !0) || (a ? kl($ = i(Q), d, r) : r($ = i(Q), d)))
            return Q.values[s] = d, 0;
        } else
          $ = i(Q);
        return Q.values[s] = $, 1;
      }
    };
  }
}
function kl(t, e, O) {
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (!O(t[i], e[i]))
      return !1;
  return !0;
}
function Ns(t, e) {
  let O = !1;
  for (let i of e)
    $i(t, i) & 1 && (O = !0);
  return O;
}
function _p(t, e, O) {
  let i = O.map((o) => t[o.id]), r = O.map((o) => o.type), n = i.filter((o) => !(o & 1)), s = t[e.id] >> 1;
  function a(o) {
    let c = [];
    for (let h = 0; h < i.length; h++) {
      let Q = en(o, i[h]);
      if (r[h] == 2)
        for (let f of Q)
          c.push(f);
      else
        c.push(Q);
    }
    return e.combine(c);
  }
  return {
    create(o) {
      for (let c of i)
        $i(o, c);
      return o.values[s] = a(o), 1;
    },
    update(o, c) {
      if (!Ns(o, n))
        return 0;
      let h = a(o);
      return e.compare(h, o.values[s]) ? 0 : (o.values[s] = h, 1);
    },
    reconfigure(o, c) {
      let h = Ns(o, i), Q = c.config.facets[e.id], f = c.facet(e);
      if (Q && !h && po(O, Q))
        return o.values[s] = f, 0;
      let $ = a(o);
      return e.compare($, f) ? (o.values[s] = f, 0) : (o.values[s] = $, 1);
    }
  };
}
const Wl = /* @__PURE__ */ R.define({ static: !0 });
class pe {
  constructor(e, O, i, r, n) {
    this.id = e, this.createF = O, this.updateF = i, this.compareF = r, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let O = new pe(uo++, e.create, e.update, e.compare || ((i, r) => i === r), e);
    return e.provide && (O.provides = e.provide(O)), O;
  }
  create(e) {
    let O = e.facet(Wl).find((i) => i.field == this);
    return ((O == null ? void 0 : O.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let O = e[this.id] >> 1;
    return {
      create: (i) => (i.values[O] = this.create(i), 1),
      update: (i, r) => {
        let n = i.values[O], s = this.updateF(n, r);
        return this.compareF(n, s) ? 0 : (i.values[O] = s, 1);
      },
      reconfigure: (i, r) => r.config.address[this.id] != null ? (i.values[O] = r.field(this), 0) : (i.values[O] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Wl.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const nt = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Kt(t) {
  return (e) => new KQ(e, t);
}
const qO = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Kt(nt.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Kt(nt.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Kt(nt.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Kt(nt.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Kt(nt.lowest)
};
class KQ {
  constructor(e, O) {
    this.inner = e, this.prec = O;
  }
}
class Ki {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Is(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Ki.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Is {
  constructor(e, O) {
    this.compartment = e, this.inner = O;
  }
}
class Jr {
  constructor(e, O, i, r, n, s) {
    for (this.base = e, this.compartments = O, this.dynamicSlots = i, this.address = r, this.staticValues = n, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let O = this.address[e.id];
    return O == null ? e.default : this.staticValues[O >> 1];
  }
  static resolve(e, O, i) {
    let r = [], n = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let f of jp(e, O, s))
      f instanceof pe ? r.push(f) : (n[f.facet.id] || (n[f.facet.id] = [])).push(f);
    let a = /* @__PURE__ */ Object.create(null), o = [], c = [];
    for (let f of r)
      a[f.id] = c.length << 1, c.push(($) => f.slot($));
    let h = i == null ? void 0 : i.config.facets;
    for (let f in n) {
      let $ = n[f], u = $[0].facet, d = h && h[f] || [];
      if ($.every(
        (p) => p.type == 0
        /* Provider.Static */
      ))
        if (a[u.id] = o.length << 1 | 1, po(d, $))
          o.push(i.facet(u));
        else {
          let p = u.combine($.map((m) => m.value));
          o.push(i && u.compare(p, i.facet(u)) ? i.facet(u) : p);
        }
      else {
        for (let p of $)
          p.type == 0 ? (a[p.id] = o.length << 1 | 1, o.push(p.value)) : (a[p.id] = c.length << 1, c.push((m) => p.dynamicSlot(m)));
        a[u.id] = c.length << 1, c.push((p) => _p(p, u, $));
      }
    }
    let Q = c.map((f) => f(a));
    return new Jr(e, s, Q, a, o, n);
  }
}
function jp(t, e, O) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function n(s, a) {
    let o = r.get(s);
    if (o != null) {
      if (o <= a)
        return;
      let c = i[o].indexOf(s);
      c > -1 && i[o].splice(c, 1), s instanceof Is && O.delete(s.compartment);
    }
    if (r.set(s, a), Array.isArray(s))
      for (let c of s)
        n(c, a);
    else if (s instanceof Is) {
      if (O.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(s.compartment) || s.inner;
      O.set(s.compartment, c), n(c, a);
    } else if (s instanceof KQ)
      n(s.inner, s.prec);
    else if (s instanceof pe)
      i[a].push(s), s.provides && n(s.provides, a);
    else if (s instanceof Gr)
      i[a].push(s), s.facet.extensions && n(s.facet.extensions, nt.default);
    else {
      let c = s.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(c, a);
    }
  }
  return n(t, nt.default), i.reduce((s, a) => s.concat(a));
}
function $i(t, e) {
  if (e & 1)
    return 2;
  let O = e >> 1, i = t.status[O];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  t.status[O] = 4;
  let r = t.computeSlot(t, t.config.dynamicSlots[O]);
  return t.status[O] = 2 | r;
}
function en(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const JQ = /* @__PURE__ */ R.define(), Ms = /* @__PURE__ */ R.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), ef = /* @__PURE__ */ R.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), Of = /* @__PURE__ */ R.define(), tf = /* @__PURE__ */ R.define(), rf = /* @__PURE__ */ R.define(), nf = /* @__PURE__ */ R.define({
  combine: (t) => t.length ? t[0] : !1
});
class UO {
  /**
  @internal
  */
  constructor(e, O) {
    this.type = e, this.value = O;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new Gp();
  }
}
class Gp {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new UO(this, e);
  }
}
class Cp {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new z(this, e);
  }
}
class z {
  /**
  @internal
  */
  constructor(e, O) {
    this.type = e, this.value = O;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let O = this.type.map(this.value, e);
    return O === void 0 ? void 0 : O == this.value ? this : new z(this.type, O);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new Cp(e.map || ((O) => O));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, O) {
    if (!e.length)
      return e;
    let i = [];
    for (let r of e) {
      let n = r.map(O);
      n && i.push(n);
    }
    return i;
  }
}
z.reconfigure = /* @__PURE__ */ z.define();
z.appendConfig = /* @__PURE__ */ z.define();
class he {
  constructor(e, O, i, r, n, s) {
    this.startState = e, this.changes = O, this.selection = i, this.effects = r, this.annotations = n, this.scrollIntoView = s, this._doc = null, this._state = null, i && HQ(i, O.newLength), n.some((a) => a.type == he.time) || (this.annotations = n.concat(he.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, O, i, r, n, s) {
    return new he(e, O, i, r, n, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let O of this.annotations)
      if (O.type == e)
        return O.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let O = this.annotation(he.userEvent);
    return !!(O && (O == e || O.length > e.length && O.slice(0, e.length) == e && O[e.length] == "."));
  }
}
he.time = /* @__PURE__ */ UO.define();
he.userEvent = /* @__PURE__ */ UO.define();
he.addToHistory = /* @__PURE__ */ UO.define();
he.remote = /* @__PURE__ */ UO.define();
function Ep(t, e) {
  let O = [];
  for (let i = 0, r = 0; ; ) {
    let n, s;
    if (i < t.length && (r == e.length || e[r] >= t[i]))
      n = t[i++], s = t[i++];
    else if (r < e.length)
      n = e[r++], s = e[r++];
    else
      return O;
    !O.length || O[O.length - 1] < n ? O.push(n, s) : O[O.length - 1] < s && (O[O.length - 1] = s);
  }
}
function sf(t, e, O) {
  var i;
  let r, n, s;
  return O ? (r = e.changes, n = ue.empty(e.changes.length), s = t.changes.compose(e.changes)) : (r = e.changes.map(t.changes), n = t.changes.mapDesc(e.changes, !0), s = t.changes.compose(r)), {
    changes: s,
    selection: e.selection ? e.selection.map(n) : (i = t.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: z.mapEffects(t.effects, r).concat(z.mapEffects(e.effects, n)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Ls(t, e, O) {
  let i = e.selection, r = Rt(e.annotations);
  return e.userEvent && (r = r.concat(he.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof ue ? e.changes : ue.of(e.changes || [], O, t.facet(ef)),
    selection: i && (i instanceof g ? i : g.single(i.anchor, i.head)),
    effects: Rt(e.effects),
    annotations: r,
    scrollIntoView: !!e.scrollIntoView
  };
}
function af(t, e, O) {
  let i = Ls(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (O = !1);
  for (let n = 1; n < e.length; n++) {
    e[n].filter === !1 && (O = !1);
    let s = !!e[n].sequential;
    i = sf(i, Ls(t, e[n], s ? i.changes.newLength : t.doc.length), s);
  }
  let r = he.create(t, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return Dp(O ? Ap(r) : r);
}
function Ap(t) {
  let e = t.startState, O = !0;
  for (let r of e.facet(Of)) {
    let n = r(t);
    if (n === !1) {
      O = !1;
      break;
    }
    Array.isArray(n) && (O = O === !0 ? n : Ep(O, n));
  }
  if (O !== !0) {
    let r, n;
    if (O === !1)
      n = t.changes.invertedDesc, r = ue.empty(e.doc.length);
    else {
      let s = t.changes.filter(O);
      r = s.changes, n = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    t = he.create(e, r, t.selection && t.selection.map(n), z.mapEffects(t.effects, n), t.annotations, t.scrollIntoView);
  }
  let i = e.facet(tf);
  for (let r = i.length - 1; r >= 0; r--) {
    let n = i[r](t);
    n instanceof he ? t = n : Array.isArray(n) && n.length == 1 && n[0] instanceof he ? t = n[0] : t = af(e, Rt(n), !1);
  }
  return t;
}
function Dp(t) {
  let e = t.startState, O = e.facet(rf), i = t;
  for (let r = O.length - 1; r >= 0; r--) {
    let n = O[r](t);
    n && Object.keys(n).length && (i = sf(i, Ls(e, n, t.changes.newLength), !0));
  }
  return i == t ? t : he.create(e, t.changes, t.selection, i.effects, i.annotations, i.scrollIntoView);
}
const Np = [];
function Rt(t) {
  return t == null ? Np : Array.isArray(t) ? t : [t];
}
var te = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(te || (te = {}));
const Ip = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Bs;
try {
  Bs = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function Mp(t) {
  if (Bs)
    return Bs.test(t);
  for (let e = 0; e < t.length; e++) {
    let O = t[e];
    if (/\w/.test(O) || O > "Â€" && (O.toUpperCase() != O.toLowerCase() || Ip.test(O)))
      return !0;
  }
  return !1;
}
function Lp(t) {
  return (e) => {
    if (!/\S/.test(e))
      return te.Space;
    if (Mp(e))
      return te.Word;
    for (let O = 0; O < t.length; O++)
      if (e.indexOf(t[O]) > -1)
        return te.Word;
    return te.Other;
  };
}
class E {
  constructor(e, O, i, r, n, s) {
    this.config = e, this.doc = O, this.selection = i, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = n, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      $i(this, a << 1);
    this.computeSlot = null;
  }
  field(e, O = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (O)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return $i(this, i), en(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return af(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let O = this.config, { base: i, compartments: r } = O;
    for (let a of e.effects)
      a.is(Ki.reconfigure) ? (O && (r = /* @__PURE__ */ new Map(), O.compartments.forEach((o, c) => r.set(c, o)), O = null), r.set(a.value.compartment, a.value.extension)) : a.is(z.reconfigure) ? (O = null, i = a.value) : a.is(z.appendConfig) && (O = null, i = Rt(i).concat(a.value));
    let n;
    O ? n = e.startState.values.slice() : (O = Jr.resolve(i, r, this), n = new E(O, this.doc, this.selection, O.dynamicSlots.map(() => null), (o, c) => c.reconfigure(o, this), null).values);
    let s = e.startState.facet(Ms) ? e.newSelection : e.newSelection.asSingle();
    new E(O, e.newDoc, s, n, (a, o) => o.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((O) => ({
      changes: { from: O.from, to: O.to, insert: e },
      range: g.cursor(O.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let O = this.selection, i = e(O.ranges[0]), r = this.changes(i.changes), n = [i.range], s = Rt(i.effects);
    for (let a = 1; a < O.ranges.length; a++) {
      let o = e(O.ranges[a]), c = this.changes(o.changes), h = c.map(r);
      for (let f = 0; f < a; f++)
        n[f] = n[f].map(h);
      let Q = r.mapDesc(c, !0);
      n.push(o.range.map(Q)), r = r.compose(h), s = z.mapEffects(s, h).concat(z.mapEffects(Rt(o.effects), Q));
    }
    return {
      changes: r,
      selection: g.create(n, O.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof ue ? e : ue.of(e, this.doc.length, this.facet(E.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return N.of(e.split(this.facet(E.lineSeparator) || Es));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, O = this.doc.length) {
    return this.doc.sliceString(e, O, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let O = this.config.address[e.id];
    return O == null ? e.default : ($i(this, O), en(this, O));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let O = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let r = e[i];
        r instanceof pe && this.config.address[r.id] != null && (O[i] = r.spec.toJSON(this.field(e[i]), this));
      }
    return O;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, O = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let n in i)
        if (Object.prototype.hasOwnProperty.call(e, n)) {
          let s = i[n], a = e[n];
          r.push(s.init((o) => s.spec.fromJSON(a, o)));
        }
    }
    return E.create({
      doc: e.doc,
      selection: g.fromJSON(e.selection),
      extensions: O.extensions ? r.concat([O.extensions]) : r
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let O = Jr.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof N ? e.doc : N.of((e.doc || "").split(O.staticFacet(E.lineSeparator) || Es)), r = e.selection ? e.selection instanceof g ? e.selection : g.single(e.selection.anchor, e.selection.head) : g.single(0);
    return HQ(r, i.length), O.staticFacet(Ms) || (r = r.asSingle()), new E(O, i, r, O.dynamicSlots.map(() => null), (n, s) => s.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(E.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(E.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(nf);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...O) {
    for (let i of this.facet(E.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return O.length && (e = e.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let n = +(r || 1);
      return !n || n > O.length ? i : O[n - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, O, i = -1) {
    let r = [];
    for (let n of this.facet(JQ))
      for (let s of n(this, O, i))
        Object.prototype.hasOwnProperty.call(s, e) && r.push(s[e]);
    return r;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return Lp(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: O, from: i, length: r } = this.doc.lineAt(e), n = this.charCategorizer(e), s = e - i, a = e - i;
    for (; s > 0; ) {
      let o = be(O, s, !1);
      if (n(O.slice(o, s)) != te.Word)
        break;
      s = o;
    }
    for (; a < r; ) {
      let o = be(O, a);
      if (n(O.slice(a, o)) != te.Word)
        break;
      a = o;
    }
    return s == a ? null : g.range(s + i, a + i);
  }
}
E.allowMultipleSelections = Ms;
E.tabSize = /* @__PURE__ */ R.define({
  combine: (t) => t.length ? t[0] : 4
});
E.lineSeparator = ef;
E.readOnly = nf;
E.phrases = /* @__PURE__ */ R.define({
  compare(t, e) {
    let O = Object.keys(t), i = Object.keys(e);
    return O.length == i.length && O.every((r) => t[r] == e[r]);
  }
});
E.languageData = JQ;
E.changeFilter = Of;
E.transactionFilter = tf;
E.transactionExtender = rf;
Ki.reconfigure = /* @__PURE__ */ z.define();
function XO(t, e, O = {}) {
  let i = {};
  for (let r of t)
    for (let n of Object.keys(r)) {
      let s = r[n], a = i[n];
      if (a === void 0)
        i[n] = s;
      else if (!(a === s || s === void 0)) if (Object.hasOwnProperty.call(O, n))
        i[n] = O[n](a, s);
      else
        throw new Error("Config merge conflict for field " + n);
    }
  for (let r in e)
    i[r] === void 0 && (i[r] = e[r]);
  return i;
}
class ft {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, O = e) {
    return wi.create(e, O, this);
  }
}
ft.prototype.startSide = ft.prototype.endSide = 0;
ft.prototype.point = !1;
ft.prototype.mapMode = Xe.TrackDel;
class wi {
  constructor(e, O, i) {
    this.from = e, this.to = O, this.value = i;
  }
  /**
  @internal
  */
  static create(e, O, i) {
    return new wi(e, O, i);
  }
}
function Fs(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class mo {
  constructor(e, O, i, r) {
    this.from = e, this.to = O, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, O, i, r = 0) {
    let n = i ? this.to : this.from;
    for (let s = r, a = n.length; ; ) {
      if (s == a)
        return s;
      let o = s + a >> 1, c = n[o] - e || (i ? this.value[o].endSide : this.value[o].startSide) - O;
      if (o == s)
        return c >= 0 ? s : a;
      c >= 0 ? a = o : s = o + 1;
    }
  }
  between(e, O, i, r) {
    for (let n = this.findIndex(O, -1e9, !0), s = this.findIndex(i, 1e9, !1, n); n < s; n++)
      if (r(this.from[n] + e, this.to[n] + e, this.value[n]) === !1)
        return !1;
  }
  map(e, O) {
    let i = [], r = [], n = [], s = -1, a = -1;
    for (let o = 0; o < this.value.length; o++) {
      let c = this.value[o], h = this.from[o] + e, Q = this.to[o] + e, f, $;
      if (h == Q) {
        let u = O.mapPos(h, c.startSide, c.mapMode);
        if (u == null || (f = $ = u, c.startSide != c.endSide && ($ = O.mapPos(h, c.endSide), $ < f)))
          continue;
      } else if (f = O.mapPos(h, c.startSide), $ = O.mapPos(Q, c.endSide), f > $ || f == $ && c.startSide > 0 && c.endSide <= 0)
        continue;
      ($ - f || c.endSide - c.startSide) < 0 || (s < 0 && (s = f), c.point && (a = Math.max(a, $ - f)), i.push(c), r.push(f - s), n.push($ - s));
    }
    return { mapped: i.length ? new mo(r, n, i, a) : null, pos: s };
  }
}
class A {
  constructor(e, O, i, r) {
    this.chunkPos = e, this.chunk = O, this.nextLayer = i, this.maxPoint = r;
  }
  /**
  @internal
  */
  static create(e, O, i, r) {
    return new A(e, O, i, r);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let O of this.chunk)
      e += O.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: O = [], sort: i = !1, filterFrom: r = 0, filterTo: n = this.length } = e, s = e.filter;
    if (O.length == 0 && !s)
      return this;
    if (i && (O = O.slice().sort(Fs)), this.isEmpty)
      return O.length ? A.of(O) : this;
    let a = new of(this, null, -1).goto(0), o = 0, c = [], h = new BO();
    for (; a.value || o < O.length; )
      if (o < O.length && (a.from - O[o].from || a.startSide - O[o].value.startSide) >= 0) {
        let Q = O[o++];
        h.addInner(Q.from, Q.to, Q.value) || c.push(Q);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (o == O.length || this.chunkEnd(a.chunkIndex) < O[o].from) && (!s || r > this.chunkEnd(a.chunkIndex) || n < this.chunkPos[a.chunkIndex]) && h.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || r > a.to || n < a.from || s(a.from, a.to, a.value)) && (h.addInner(a.from, a.to, a.value) || c.push(wi.create(a.from, a.to, a.value))), a.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? A.empty : this.nextLayer.update({ add: c, filter: s, filterFrom: r, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let O = [], i = [], r = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], o = this.chunk[s], c = e.touchesRange(a, a + o.length);
      if (c === !1)
        r = Math.max(r, o.maxPoint), O.push(o), i.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: h, pos: Q } = o.map(a, e);
        h && (r = Math.max(r, h.maxPoint), O.push(h), i.push(Q));
      }
    }
    let n = this.nextLayer.map(e);
    return O.length == 0 ? n : new A(i, O, n || A.empty, r);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, O, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let n = this.chunkPos[r], s = this.chunk[r];
        if (O >= n && e <= n + s.length && s.between(n, e - n, O - n, i) === !1)
          return;
      }
      this.nextLayer.between(e, O, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return ki.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, O = 0) {
    return ki.from(e).goto(O);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, O, i, r, n = -1) {
    let s = e.filter((Q) => Q.maxPoint > 0 || !Q.isEmpty && Q.maxPoint >= n), a = O.filter((Q) => Q.maxPoint > 0 || !Q.isEmpty && Q.maxPoint >= n), o = Rl(s, a, i), c = new Jt(s, o, n), h = new Jt(a, o, n);
    i.iterGaps((Q, f, $) => vl(c, Q, h, f, $, r)), i.empty && i.length == 0 && vl(c, 0, h, 0, 0, r);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, O, i = 0, r) {
    r == null && (r = 999999999);
    let n = e.filter((h) => !h.isEmpty && O.indexOf(h) < 0), s = O.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (n.length != s.length)
      return !1;
    if (!n.length)
      return !0;
    let a = Rl(n, s), o = new Jt(n, a, 0).goto(i), c = new Jt(s, a, 0).goto(i);
    for (; ; ) {
      if (o.to != c.to || !Hs(o.active, c.active) || o.point && (!c.point || !o.point.eq(c.point)))
        return !1;
      if (o.to > r)
        return !0;
      o.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, O, i, r, n = -1) {
    let s = new Jt(e, null, n).goto(O), a = O, o = s.openStart;
    for (; ; ) {
      let c = Math.min(s.to, i);
      if (s.point) {
        let h = s.activeForPoint(s.to), Q = s.pointFrom < O ? h.length + 1 : s.point.startSide < 0 ? h.length : Math.min(h.length, o);
        r.point(a, c, s.point, h, Q, s.pointRank), o = Math.min(s.openEnd(c), h.length);
      } else c > a && (r.span(a, c, s.active, o), o = s.openEnd(c));
      if (s.to > i)
        return o + (s.point && s.to > i ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, O = !1) {
    let i = new BO();
    for (let r of e instanceof wi ? [e] : O ? Bp(e) : e)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return A.empty;
    let O = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let r = e[i]; r != A.empty; r = r.nextLayer)
        O = new A(r.chunkPos, r.chunk, O, Math.max(r.maxPoint, O.maxPoint));
    return O;
  }
}
A.empty = /* @__PURE__ */ new A([], [], null, -1);
function Bp(t) {
  if (t.length > 1)
    for (let e = t[0], O = 1; O < t.length; O++) {
      let i = t[O];
      if (Fs(e, i) > 0)
        return t.slice().sort(Fs);
      e = i;
    }
  return t;
}
A.empty.nextLayer = A.empty;
class BO {
  finishChunk(e) {
    this.chunks.push(new mo(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, O, i) {
    this.addInner(e, O, i) || (this.nextLayer || (this.nextLayer = new BO())).add(e, O, i);
  }
  /**
  @internal
  */
  addInner(e, O, i) {
    let r = e - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(O - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = O, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, O - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, O) {
    if ((e - this.lastTo || O.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, O.maxPoint), this.chunks.push(O), this.chunkPos.push(e);
    let i = O.value.length - 1;
    return this.last = O.value[i], this.lastFrom = O.from[i] + e, this.lastTo = O.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(A.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let O = A.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, O;
  }
}
function Rl(t, e, O) {
  let i = /* @__PURE__ */ new Map();
  for (let n of t)
    for (let s = 0; s < n.chunk.length; s++)
      n.chunk[s].maxPoint <= 0 && i.set(n.chunk[s], n.chunkPos[s]);
  let r = /* @__PURE__ */ new Set();
  for (let n of e)
    for (let s = 0; s < n.chunk.length; s++) {
      let a = i.get(n.chunk[s]);
      a != null && (O ? O.mapPos(a) : a) == n.chunkPos[s] && !(O != null && O.touchesRange(a, a + n.chunk[s].length)) && r.add(n.chunk[s]);
    }
  return r;
}
class of {
  constructor(e, O, i, r = 0) {
    this.layer = e, this.skip = O, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, O = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, O, !1), this;
  }
  gotoInner(e, O, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], O, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(e, O) {
    (this.to - e || this.endSide - O) < 0 && this.gotoInner(e, O, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], O = this.layer.chunk[this.chunkIndex], i = e + O.from[this.rangeIndex];
        if (this.from = i, this.to = e + O.to[this.rangeIndex], this.value = O.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class ki {
  constructor(e) {
    this.heap = e;
  }
  static from(e, O = null, i = -1) {
    let r = [];
    for (let n = 0; n < e.length; n++)
      for (let s = e[n]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= i && r.push(new of(s, O, i, n));
    return r.length == 1 ? r[0] : new ki(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, O = -1e9) {
    for (let i of this.heap)
      i.goto(e, O);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      In(this.heap, i);
    return this.next(), this;
  }
  forward(e, O) {
    for (let i of this.heap)
      i.forward(e, O);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      In(this.heap, i);
    (this.to - e || this.value.endSide - O) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), In(this.heap, 0);
    }
  }
}
function In(t, e) {
  for (let O = t[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= t.length)
      break;
    let r = t[i];
    if (i + 1 < t.length && r.compare(t[i + 1]) >= 0 && (r = t[i + 1], i++), O.compare(r) < 0)
      break;
    t[i] = O, t[e] = r, e = i;
  }
}
class Jt {
  constructor(e, O, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = ki.from(e, O, i);
  }
  goto(e, O = -1e9) {
    return this.cursor.goto(e, O), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = O, this.openStart = -1, this.next(), this;
  }
  forward(e, O) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - O) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, O);
  }
  removeActive(e) {
    Qr(this.active, e), Qr(this.activeTo, e), Qr(this.activeRank, e), this.minActive = Zl(this.active, this.activeTo);
  }
  addActive(e) {
    let O = 0, { value: i, to: r, rank: n } = this.cursor;
    for (; O < this.activeRank.length && (n - this.activeRank[O] || r - this.activeTo[O]) > 0; )
      O++;
    fr(this.active, O, i), fr(this.activeTo, O, r), fr(this.activeRank, O, n), e && fr(e, O, this.cursor.from), this.minActive = Zl(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, O = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > e) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && Qr(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let n = this.cursor.value;
          if (!n.point)
            this.addActive(i), this.cursor.next();
          else if (O && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = n, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = n.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < e; r--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let O = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && O.push(this.active[i]);
    return O.reverse();
  }
  openEnd(e) {
    let O = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      O++;
    return O;
  }
}
function vl(t, e, O, i, r, n) {
  t.goto(e), O.goto(i);
  let s = i + r, a = i, o = i - e;
  for (; ; ) {
    let c = t.to + o - O.to || t.endSide - O.endSide, h = c < 0 ? t.to + o : O.to, Q = Math.min(h, s);
    if (t.point || O.point ? t.point && O.point && (t.point == O.point || t.point.eq(O.point)) && Hs(t.activeForPoint(t.to), O.activeForPoint(O.to)) || n.comparePoint(a, Q, t.point, O.point) : Q > a && !Hs(t.active, O.active) && n.compareRange(a, Q, t.active, O.active), h > s)
      break;
    a = h, c <= 0 && t.next(), c >= 0 && O.next();
  }
}
function Hs(t, e) {
  if (t.length != e.length)
    return !1;
  for (let O = 0; O < t.length; O++)
    if (t[O] != e[O] && !t[O].eq(e[O]))
      return !1;
  return !0;
}
function Qr(t, e) {
  for (let O = e, i = t.length - 1; O < i; O++)
    t[O] = t[O + 1];
  t.pop();
}
function fr(t, e, O) {
  for (let i = t.length - 1; i >= e; i--)
    t[i + 1] = t[i];
  t[e] = O;
}
function Zl(t, e) {
  let O = -1, i = 1e9;
  for (let r = 0; r < e.length; r++)
    (e[r] - i || t[r].endSide - t[O].endSide) < 0 && (O = r, i = e[r]);
  return O;
}
function sO(t, e, O = t.length) {
  let i = 0;
  for (let r = 0; r < O; )
    t.charCodeAt(r) == 9 ? (i += e - i % e, r++) : (i++, r = be(t, r));
  return i;
}
function Ks(t, e, O, i) {
  for (let r = 0, n = 0; ; ) {
    if (n >= e)
      return r;
    if (r == t.length)
      break;
    n += t.charCodeAt(r) == 9 ? O - n % O : 1, r = be(t, r);
  }
  return i === !0 ? -1 : t.length;
}
const Js = "Í¼", Yl = typeof Symbol > "u" ? "__" + Js : Symbol.for(Js), ea = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), zl = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class FO {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, O) {
    this.rules = [];
    let { finish: i } = O || {};
    function r(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function n(s, a, o, c) {
      let h = [], Q = /^@(\w+)\b/.exec(s[0]), f = Q && Q[1] == "keyframes";
      if (Q && a == null) return o.push(s[0] + ";");
      for (let $ in a) {
        let u = a[$];
        if (/&/.test($))
          n(
            $.split(/,\s*/).map((d) => s.map((p) => d.replace(/&/, p))).reduce((d, p) => d.concat(p)),
            u,
            o
          );
        else if (u && typeof u == "object") {
          if (!Q) throw new RangeError("The value of a property (" + $ + ") should be a primitive value.");
          n(r($), u, h, f);
        } else u != null && h.push($.replace(/_.*/, "").replace(/[A-Z]/g, (d) => "-" + d.toLowerCase()) + ": " + u + ";");
      }
      (h.length || f) && o.push((i && !Q && !c ? s.map(i) : s).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let s in e) n(r(s), e[s], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = zl[Yl] || 1;
    return zl[Yl] = e + 1, Js + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, O, i) {
    let r = e[ea], n = i && i.nonce;
    r ? n && r.setNonce(n) : r = new Fp(e, n), r.mount(Array.isArray(O) ? O : [O], e);
  }
}
let ql = /* @__PURE__ */ new Map();
class Fp {
  constructor(e, O) {
    let i = e.ownerDocument || e, r = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let n = ql.get(i);
      if (n) return e[ea] = n;
      this.sheet = new r.CSSStyleSheet(), ql.set(i, this);
    } else
      this.styleTag = i.createElement("style"), O && this.styleTag.setAttribute("nonce", O);
    this.modules = [], e[ea] = this;
  }
  mount(e, O) {
    let i = this.sheet, r = 0, n = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], o = this.modules.indexOf(a);
      if (o < n && o > -1 && (this.modules.splice(o, 1), n--, o = -1), o == -1) {
        if (this.modules.splice(n++, 0, a), i) for (let c = 0; c < a.rules.length; c++)
          i.insertRule(a.rules[c], r++);
      } else {
        for (; n < o; ) r += this.modules[n++].rules.length;
        r += a.rules.length, n++;
      }
    }
    if (i)
      O.adoptedStyleSheets.indexOf(this.sheet) < 0 && (O.adoptedStyleSheets = [this.sheet, ...O.adoptedStyleSheets]);
    else {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = O.head || O;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var HO = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Wi = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Hp = typeof navigator < "u" && /Mac/.test(navigator.platform), Kp = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Se = 0; Se < 10; Se++) HO[48 + Se] = HO[96 + Se] = String(Se);
for (var Se = 1; Se <= 24; Se++) HO[Se + 111] = "F" + Se;
for (var Se = 65; Se <= 90; Se++)
  HO[Se] = String.fromCharCode(Se + 32), Wi[Se] = String.fromCharCode(Se);
for (var Mn in HO) Wi.hasOwnProperty(Mn) || (Wi[Mn] = HO[Mn]);
function Jp(t) {
  var e = Hp && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || Kp && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", O = !e && t.key || (t.shiftKey ? Wi : HO)[t.keyCode] || t.key || "Unidentified";
  return O == "Esc" && (O = "Escape"), O == "Del" && (O = "Delete"), O == "Left" && (O = "ArrowLeft"), O == "Up" && (O = "ArrowUp"), O == "Right" && (O = "ArrowRight"), O == "Down" && (O = "ArrowDown"), O;
}
function Ri(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Oa(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function em(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Cr(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Oa(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function vi(t) {
  return t.nodeType == 3 ? ut(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function ui(t, e, O, i) {
  return O ? Ul(t, e, O, i, -1) || Ul(t, e, O, i, 1) : !1;
}
function $t(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function On(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
function Ul(t, e, O, i, r) {
  for (; ; ) {
    if (t == O && e == i)
      return !0;
    if (e == (r < 0 ? 0 : WO(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let n = t.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      e = $t(t) + (r < 0 ? 0 : 1), t = n;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (r < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = r < 0 ? WO(t) : 0;
    } else
      return !1;
  }
}
function WO(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Po(t, e) {
  let O = e ? t.left : t.right;
  return { left: O, right: O, top: t.top, bottom: t.bottom };
}
function Om(t) {
  let e = t.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function lf(t, e) {
  let O = e.width / t.offsetWidth, i = e.height / t.offsetHeight;
  return (O > 0.995 && O < 1.005 || !isFinite(O) || Math.abs(e.width - t.offsetWidth) < 1) && (O = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - t.offsetHeight) < 1) && (i = 1), { scaleX: O, scaleY: i };
}
function tm(t, e, O, i, r, n, s, a) {
  let o = t.ownerDocument, c = o.defaultView || window;
  for (let h = t, Q = !1; h && !Q; )
    if (h.nodeType == 1) {
      let f, $ = h == o.body, u = 1, d = 1;
      if ($)
        f = Om(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (Q = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let P = h.getBoundingClientRect();
        ({ scaleX: u, scaleY: d } = lf(h, P)), f = {
          left: P.left,
          right: P.left + h.clientWidth * u,
          top: P.top,
          bottom: P.top + h.clientHeight * d
        };
      }
      let p = 0, m = 0;
      if (r == "nearest")
        e.top < f.top ? (m = -(f.top - e.top + s), O > 0 && e.bottom > f.bottom + m && (m = e.bottom - f.bottom + m + s)) : e.bottom > f.bottom && (m = e.bottom - f.bottom + s, O < 0 && e.top - m < f.top && (m = -(f.top + m - e.top + s)));
      else {
        let P = e.bottom - e.top, X = f.bottom - f.top;
        m = (r == "center" && P <= X ? e.top + P / 2 - X / 2 : r == "start" || r == "center" && O < 0 ? e.top - s : e.bottom - X + s) - f.top;
      }
      if (i == "nearest" ? e.left < f.left ? (p = -(f.left - e.left + n), O > 0 && e.right > f.right + p && (p = e.right - f.right + p + n)) : e.right > f.right && (p = e.right - f.right + n, O < 0 && e.left < f.left + p && (p = -(f.left + p - e.left + n))) : p = (i == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : i == "start" == a ? e.left - n : e.right - (f.right - f.left) + n) - f.left, p || m)
        if ($)
          c.scrollBy(p, m);
        else {
          let P = 0, X = 0;
          if (m) {
            let y = h.scrollTop;
            h.scrollTop += m / d, X = (h.scrollTop - y) * d;
          }
          if (p) {
            let y = h.scrollLeft;
            h.scrollLeft += p / u, P = (h.scrollLeft - y) * u;
          }
          e = {
            left: e.left - P,
            top: e.top - X,
            right: e.right - P,
            bottom: e.bottom - X
          }, P && Math.abs(P - p) < 1 && (i = "nearest"), X && Math.abs(X - m) < 1 && (r = "nearest");
        }
      if ($)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function im(t) {
  let e = t.ownerDocument, O, i;
  for (let r = t.parentNode; r && !(r == e.body || O && i); )
    if (r.nodeType == 1)
      !i && r.scrollHeight > r.clientHeight && (i = r), !O && r.scrollWidth > r.clientWidth && (O = r), r = r.assignedSlot || r.parentNode;
    else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return { x: O, y: i };
}
class rm {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: O, focusNode: i } = e;
    this.set(O, Math.min(e.anchorOffset, O ? WO(O) : 0), i, Math.min(e.focusOffset, i ? WO(i) : 0));
  }
  set(e, O, i, r) {
    this.anchorNode = e, this.anchorOffset = O, this.focusNode = i, this.focusOffset = r;
  }
}
let Pt = null;
function cf(t) {
  if (t.setActive)
    return t.setActive();
  if (Pt)
    return t.focus(Pt);
  let e = [];
  for (let O = t; O && (e.push(O, O.scrollTop, O.scrollLeft), O != O.ownerDocument); O = O.parentNode)
    ;
  if (t.focus(Pt == null ? {
    get preventScroll() {
      return Pt = { preventScroll: !0 }, !0;
    }
  } : void 0), !Pt) {
    Pt = !1;
    for (let O = 0; O < e.length; ) {
      let i = e[O++], r = e[O++], n = e[O++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != n && (i.scrollLeft = n);
    }
  }
}
let Vl;
function ut(t, e, O = e) {
  let i = Vl || (Vl = document.createRange());
  return i.setEnd(t, O), i.setStart(t, e), i;
}
function vt(t, e, O, i) {
  let r = { key: e, code: e, keyCode: O, which: O, cancelable: !0 };
  i && ({ altKey: r.altKey, ctrlKey: r.ctrlKey, shiftKey: r.shiftKey, metaKey: r.metaKey } = i);
  let n = new KeyboardEvent("keydown", r);
  n.synthetic = !0, t.dispatchEvent(n);
  let s = new KeyboardEvent("keyup", r);
  return s.synthetic = !0, t.dispatchEvent(s), n.defaultPrevented || s.defaultPrevented;
}
function nm(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function hf(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function sm(t, e) {
  let O = e.focusNode, i = e.focusOffset;
  if (!O || e.anchorNode != O || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, WO(O)); ; )
    if (i) {
      if (O.nodeType != 1)
        return !1;
      let r = O.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (O = r, i = WO(O));
    } else {
      if (O == t)
        return !0;
      i = $t(O), O = O.parentNode;
    }
}
function Qf(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
function ff(t, e) {
  for (let O = t, i = e; ; ) {
    if (O.nodeType == 3 && i > 0)
      return { node: O, offset: i };
    if (O.nodeType == 1 && i > 0) {
      if (O.contentEditable == "false")
        return null;
      O = O.childNodes[i - 1], i = WO(O);
    } else if (O.parentNode && !On(O))
      i = $t(O), O = O.parentNode;
    else
      return null;
  }
}
function $f(t, e) {
  for (let O = t, i = e; ; ) {
    if (O.nodeType == 3 && i < O.nodeValue.length)
      return { node: O, offset: i };
    if (O.nodeType == 1 && i < O.childNodes.length) {
      if (O.contentEditable == "false")
        return null;
      O = O.childNodes[i], i = 0;
    } else if (O.parentNode && !On(O))
      i = $t(O) + 1, O = O.parentNode;
    else
      return null;
  }
}
class Te {
  constructor(e, O, i = !0) {
    this.node = e, this.offset = O, this.precise = i;
  }
  static before(e, O) {
    return new Te(e.parentNode, $t(e), O);
  }
  static after(e, O) {
    return new Te(e.parentNode, $t(e) + 1, O);
  }
}
const go = [];
class K {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let O = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return O;
      O += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, O) {
    if (this.flags & 2) {
      let i = this.dom, r = null, n;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (n = r ? r.nextSibling : i.firstChild)) {
            let a = K.get(n);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(n);
          }
          s.sync(e, O), s.flags &= -8;
        }
        if (n = r ? r.nextSibling : i.firstChild, O && !O.written && O.node == i && n != s.dom && (O.written = !0), s.dom.parentNode == i)
          for (; n && n != s.dom; )
            n = _l(n);
        else
          i.insertBefore(s.dom, n);
        r = s.dom;
      }
      for (n = r ? r.nextSibling : i.firstChild, n && O && O.node == i && (O.written = !0); n; )
        n = _l(n);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, O), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, O) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[O];
    else {
      let r = WO(e) == 0 ? 0 : O == 0 ? -1 : 1;
      for (; ; ) {
        let n = e.parentNode;
        if (n == this.dom)
          break;
        r == 0 && n.firstChild != n.lastChild && (e == n.firstChild ? r = -1 : r = 1), e = n;
      }
      r < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !K.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, n = 0; ; r++) {
      let s = this.children[r];
      if (s.dom == i)
        return n;
      n += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, O, i = 0) {
    let r = -1, n = -1, s = -1, a = -1;
    for (let o = 0, c = i, h = i; o < this.children.length; o++) {
      let Q = this.children[o], f = c + Q.length;
      if (c < e && f > O)
        return Q.domBoundsAround(e, O, c);
      if (f >= e && r == -1 && (r = o, n = c), c > O && Q.dom.parentNode == this.dom) {
        s = o, a = h;
        break;
      }
      h = f, c = f + Q.breakAfter;
    }
    return {
      from: n,
      to: a < 0 ? i + this.length : a,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let O = this.parent; O; O = O.parent) {
      if (e && (O.flags |= 2), O.flags & 1)
        return;
      O.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let O = e.parent;
      if (!O)
        return e;
      e = O;
    }
  }
  replaceChildren(e, O, i = go) {
    this.markDirty();
    for (let r = e; r < O; r++) {
      let n = this.children[r];
      n.parent == this && i.indexOf(n) < 0 && n.destroy();
    }
    this.children.splice(e, O - e, ...i);
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new uf(this.children, e, this.children.length);
  }
  childPos(e, O = 1) {
    return this.childCursor().findPos(e, O);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, O, i, r, n, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
K.prototype.breakAfter = 0;
function _l(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class uf {
  constructor(e, O, i) {
    this.children = e, this.pos = O, this.i = i, this.off = 0;
  }
  findPos(e, O = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (O > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function df(t, e, O, i, r, n, s, a, o) {
  let { children: c } = t, h = c.length ? c[e] : null, Q = n.length ? n[n.length - 1] : null, f = Q ? Q.breakAfter : s;
  if (!(e == i && h && !s && !f && n.length < 2 && h.merge(O, r, n.length ? Q : null, O == 0, a, o))) {
    if (i < c.length) {
      let $ = c[i];
      $ && (r < $.length || $.breakAfter && (Q != null && Q.breakAfter)) ? (e == i && ($ = $.split(r), r = 0), !f && Q && $.merge(0, r, Q, !0, 0, o) ? n[n.length - 1] = $ : ((r || $.children.length && !$.children[0].length) && $.merge(0, r, null, !1, 0, o), n.push($))) : $ != null && $.breakAfter && (Q ? Q.breakAfter = 1 : s = 1), i++;
    }
    for (h && (h.breakAfter = s, O > 0 && (!s && n.length && h.merge(O, h.length, n[0], !1, a, 0) ? h.breakAfter = n.shift().breakAfter : (O < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(O, h.length, null, !1, a, 0), e++)); e < i && n.length; )
      if (c[i - 1].become(n[n.length - 1]))
        i--, n.pop(), o = n.length ? 0 : a;
      else if (c[e].become(n[0]))
        e++, n.shift(), a = n.length ? 0 : o;
      else
        break;
    !n.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, a, o) && e--, (e < i || n.length) && t.replaceChildren(e, i, n);
  }
}
function pf(t, e, O, i, r, n) {
  let s = t.childCursor(), { i: a, off: o } = s.findPos(O, 1), { i: c, off: h } = s.findPos(e, -1), Q = e - O;
  for (let f of i)
    Q += f.length;
  t.length += Q, df(t, c, h, a, o, i, 0, r, n);
}
let ze = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, ta = typeof document < "u" ? document : { documentElement: { style: {} } };
const ia = /* @__PURE__ */ /Edge\/(\d+)/.exec(ze.userAgent), mf = /* @__PURE__ */ /MSIE \d/.test(ze.userAgent), ra = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ze.userAgent), Zn = !!(mf || ra || ia), jl = !Zn && /* @__PURE__ */ /gecko\/(\d+)/i.test(ze.userAgent), Ln = !Zn && /* @__PURE__ */ /Chrome\/(\d+)/.exec(ze.userAgent), Gl = "webkitFontSmoothing" in ta.documentElement.style, Pf = !Zn && /* @__PURE__ */ /Apple Computer/.test(ze.vendor), Cl = Pf && (/* @__PURE__ */ /Mobile\/\w+/.test(ze.userAgent) || ze.maxTouchPoints > 2);
var W = {
  mac: Cl || /* @__PURE__ */ /Mac/.test(ze.platform),
  windows: /* @__PURE__ */ /Win/.test(ze.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(ze.platform),
  ie: Zn,
  ie_version: mf ? ta.documentMode || 6 : ra ? +ra[1] : ia ? +ia[1] : 0,
  gecko: jl,
  gecko_version: jl ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(ze.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ln,
  chrome_version: Ln ? +Ln[1] : 0,
  ios: Cl,
  android: /* @__PURE__ */ /Android\b/.test(ze.userAgent),
  webkit: Gl,
  safari: Pf,
  webkit_version: Gl ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(ze.userAgent) || [0, 0])[1] : 0,
  tabSize: ta.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const am = 256;
class aO extends K {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, O) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (O && O.node == this.dom && (O.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, O, i) {
    return this.flags & 8 || i && (!(i instanceof aO) || this.length - (O - e) + i.length > am || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(O), this.markDirty(), !0);
  }
  split(e) {
    let O = new aO(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), O.flags |= this.flags & 8, O;
  }
  localPosFromDOM(e, O) {
    return e == this.dom ? O : O ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Te(this.dom, e);
  }
  domBoundsAround(e, O, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, O) {
    return om(this.dom, e, O);
  }
}
class RO extends K {
  constructor(e, O = [], i = 0) {
    super(), this.mark = e, this.children = O, this.length = i;
    for (let r of O)
      r.setParent(this);
  }
  setAttrs(e) {
    if (hf(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let O in this.mark.attrs)
        e.setAttribute(O, this.mark.attrs[O]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, O) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, O);
  }
  merge(e, O, i, r, n, s) {
    return i && (!(i instanceof RO && i.mark.eq(this.mark)) || e && n <= 0 || O < this.length && s <= 0) ? !1 : (pf(this, e, O, i ? i.children.slice() : [], n - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let O = [], i = 0, r = -1, n = 0;
    for (let a of this.children) {
      let o = i + a.length;
      o > e && O.push(i < e ? a.split(e - i) : a), r < 0 && i >= e && (r = n), i = o, n++;
    }
    let s = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new RO(this.mark, O, s);
  }
  domAtPos(e) {
    return gf(this, e);
  }
  coordsAt(e, O) {
    return Xf(this, e, O);
  }
}
function om(t, e, O) {
  let i = t.nodeValue.length;
  e > i && (e = i);
  let r = e, n = e, s = 0;
  e == 0 && O < 0 || e == i && O >= 0 ? W.chrome || W.gecko || (e ? (r--, s = 1) : n < i && (n++, s = -1)) : O < 0 ? r-- : n < i && n++;
  let a = ut(t, r, n).getClientRects();
  if (!a.length)
    return null;
  let o = a[(s ? s < 0 : O >= 0) ? 0 : a.length - 1];
  return W.safari && !s && o.width == 0 && (o = Array.prototype.find.call(a, (c) => c.width) || o), s ? Po(o, s < 0) : o || null;
}
class DO extends K {
  static create(e, O, i) {
    return new DO(e, O, i);
  }
  constructor(e, O, i) {
    super(), this.widget = e, this.length = O, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let O = DO.create(this.widget, this.length - e, this.side);
    return this.length -= e, O;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, O, i, r, n, s) {
    return i && (!(i instanceof DO) || !this.widget.compare(i.widget) || e > 0 && n <= 0 || O < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - O), !0);
  }
  become(e) {
    return e instanceof DO && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return N.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: O } = e, i = O && O.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : N.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Te.before(this.dom) : Te.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, O) {
    let i = this.widget.coordsAt(this.dom, e, O);
    if (i)
      return i;
    let r = this.dom.getClientRects(), n = null;
    if (!r.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? r.length - 1 : 0; n = r[a], !(e > 0 ? a == 0 : a == r.length - 1 || n.top < n.bottom); a += s ? -1 : 1)
      ;
    return Po(n, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Vt extends K {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Vt && e.side == this.side;
  }
  split() {
    return new Vt(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Te.before(this.dom) : Te.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return N.empty;
  }
  get isHidden() {
    return !0;
  }
}
aO.prototype.children = DO.prototype.children = Vt.prototype.children = go;
function gf(t, e) {
  let O = t.dom, { children: i } = t, r = 0;
  for (let n = 0; r < i.length; r++) {
    let s = i[r], a = n + s.length;
    if (!(a == n && s.getSide() <= 0)) {
      if (e > n && e < a && s.dom.parentNode == O)
        return s.domAtPos(e - n);
      if (e <= n)
        break;
      n = a;
    }
  }
  for (let n = r; n > 0; n--) {
    let s = i[n - 1];
    if (s.dom.parentNode == O)
      return s.domAtPos(s.length);
  }
  for (let n = r; n < i.length; n++) {
    let s = i[n];
    if (s.dom.parentNode == O)
      return s.domAtPos(0);
  }
  return new Te(O, 0);
}
function Sf(t, e, O) {
  let i, { children: r } = t;
  O > 0 && e instanceof RO && r.length && (i = r[r.length - 1]) instanceof RO && i.mark.eq(e.mark) ? Sf(i, e.children[0], O - 1) : (r.push(e), e.setParent(t)), t.length += e.length;
}
function Xf(t, e, O) {
  let i = null, r = -1, n = null, s = -1;
  function a(c, h) {
    for (let Q = 0, f = 0; Q < c.children.length && f <= h; Q++) {
      let $ = c.children[Q], u = f + $.length;
      u >= h && ($.children.length ? a($, h - f) : (!n || n.isHidden && O > 0) && (u > h || f == u && $.getSide() > 0) ? (n = $, s = h - f) : (f < h || f == u && $.getSide() < 0 && !$.isHidden) && (i = $, r = h - f)), f = u;
    }
  }
  a(t, e);
  let o = (O < 0 ? i : n) || i || n;
  return o ? o.coordsAt(Math.max(0, o == i ? r : s), O) : lm(t);
}
function lm(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let O = vi(e);
  return O[O.length - 1] || null;
}
function na(t, e) {
  for (let O in t)
    O == "class" && e.class ? e.class += " " + t.class : O == "style" && e.style ? e.style += ";" + t.style : e[O] = t[O];
  return e;
}
const El = /* @__PURE__ */ Object.create(null);
function tn(t, e, O) {
  if (t == e)
    return !0;
  t || (t = El), e || (e = El);
  let i = Object.keys(t), r = Object.keys(e);
  if (i.length - (O && i.indexOf(O) > -1 ? 1 : 0) != r.length - (O && r.indexOf(O) > -1 ? 1 : 0))
    return !1;
  for (let n of i)
    if (n != O && (r.indexOf(n) == -1 || t[n] !== e[n]))
      return !1;
  return !0;
}
function sa(t, e, O) {
  let i = !1;
  if (e)
    for (let r in e)
      O && r in O || (i = !0, r == "style" ? t.style.cssText = "" : t.removeAttribute(r));
  if (O)
    for (let r in O)
      e && e[r] == O[r] || (i = !0, r == "style" ? t.style.cssText = O[r] : t.setAttribute(r, O[r]));
  return i;
}
function cm(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let O = 0; O < t.attributes.length; O++) {
    let i = t.attributes[O];
    e[i.name] = i.value;
  }
  return e;
}
class ce extends K {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, O, i, r, n, s) {
    if (i) {
      if (!(i instanceof ce))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), pf(this, e, O, i ? i.children.slice() : [], n, s), !0;
  }
  split(e) {
    let O = new ce();
    if (O.breakAfter = this.breakAfter, this.length == 0)
      return O;
    let { i, off: r } = this.childPos(e);
    r && (O.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let n = i; n < this.children.length; n++)
      O.append(this.children[n], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, O;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    tn(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, O) {
    Sf(this, e, O);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let O = e.spec.attributes, i = e.spec.class;
    O && (this.attrs = na(O, this.attrs || {})), i && (this.attrs = na({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return gf(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, O) {
    var i;
    this.dom ? this.flags & 4 && (hf(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (sa(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, O);
    let r = this.dom.lastChild;
    for (; r && K.get(r) instanceof RO; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = K.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!W.ios || !this.children.some((n) => n instanceof aO))) {
      let n = document.createElement("BR");
      n.cmIgnore = !0, this.dom.appendChild(n);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, O;
    for (let i of this.children) {
      if (!(i instanceof aO) || /[^ -~]/.test(i.text))
        return null;
      let r = vi(i.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, O = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: O
    } : null;
  }
  coordsAt(e, O) {
    let i = Xf(this, e, O);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, n = i.bottom - i.top;
      if (Math.abs(n - r.lineHeight) < 2 && r.textHeight < n) {
        let s = (n - r.textHeight) / 2;
        return { top: i.top + s, bottom: i.bottom - s, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return e instanceof ce && this.children.length == 0 && e.children.length == 0 && tn(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, O) {
    for (let i = 0, r = 0; i < e.children.length; i++) {
      let n = e.children[i], s = r + n.length;
      if (s >= O) {
        if (n instanceof ce)
          return n;
        if (s > O)
          break;
      }
      r = s + n.breakAfter;
    }
    return null;
  }
}
class kO extends K {
  constructor(e, O, i) {
    super(), this.widget = e, this.length = O, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, O, i, r, n, s) {
    return i && (!(i instanceof kO) || !this.widget.compare(i.widget) || e > 0 && n <= 0 || O < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - O), !0);
  }
  domAtPos(e) {
    return e == 0 ? Te.before(this.dom) : Te.after(this.dom, e == this.length);
  }
  split(e) {
    let O = this.length - e;
    this.length = e;
    let i = new kO(this.widget, O, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return go;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : N.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof kO && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, O) {
    return this.widget.coordsAt(this.dom, e, O);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: O, endSide: i } = this.deco;
    return O == i ? !1 : e < 0 ? O < 0 : i > 0;
  }
}
class VO {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, O) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, O, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Re = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Re || (Re = {}));
class Z extends ft {
  constructor(e, O, i, r) {
    super(), this.startSide = e, this.endSide = O, this.widget = i, this.spec = r;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Ji(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let O = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return O += i && !e.inlineOrder ? O > 0 ? 3e8 : -4e8 : O > 0 ? 1e8 : -1e8, new KO(e, O, O, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let O = !!e.block, i, r;
    if (e.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: n, end: s } = yf(e, O);
      i = (n ? O ? -3e8 : -1 : 5e8) - 1, r = (s ? O ? 2e8 : 1 : -6e8) + 1;
    }
    return new KO(e, i, r, O, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new er(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, O = !1) {
    return A.of(e, O);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Z.none = A.empty;
class Ji extends Z {
  constructor(e) {
    let { start: O, end: i } = yf(e);
    super(O ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var O, i;
    return this == e || e instanceof Ji && this.tagName == e.tagName && (this.class || ((O = this.attrs) === null || O === void 0 ? void 0 : O.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && tn(this.attrs, e.attrs, "class");
  }
  range(e, O = e) {
    if (e >= O)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, O);
  }
}
Ji.prototype.point = !1;
class er extends Z {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof er && this.spec.class == e.spec.class && tn(this.spec.attributes, e.spec.attributes);
  }
  range(e, O = e) {
    if (O != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, O);
  }
}
er.prototype.mapMode = Xe.TrackBefore;
er.prototype.point = !0;
class KO extends Z {
  constructor(e, O, i, r, n, s) {
    super(O, i, n, e), this.block = r, this.isReplace = s, this.mapMode = r ? O <= 0 ? Xe.TrackBefore : Xe.TrackAfter : Xe.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Re.WidgetRange : this.startSide <= 0 ? Re.WidgetBefore : Re.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof KO && hm(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, O = e) {
    if (this.isReplace && (e > O || e == O && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && O != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, O);
  }
}
KO.prototype.point = !0;
function yf(t, e = !1) {
  let { inclusiveStart: O, inclusiveEnd: i } = t;
  return O == null && (O = t.inclusive), i == null && (i = t.inclusive), { start: O ?? e, end: i ?? e };
}
function hm(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function aa(t, e, O, i = 0) {
  let r = O.length - 1;
  r >= 0 && O[r] + i >= t ? O[r] = Math.max(O[r], e) : O.push(t, e);
}
class di {
  constructor(e, O, i, r) {
    this.doc = e, this.pos = O, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = O;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof kO && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ce()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append($r(new Vt(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof kO) && this.getLine();
  }
  buildText(e, O, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: n, lineBreak: s, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = n, this.textOff = 0;
      }
      let r = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(O.slice(O.length - i)), this.getLine().append($r(new aO(this.text.slice(this.textOff, this.textOff + r)), O), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0;
    }
  }
  span(e, O, i, r) {
    this.buildText(O - e, i, r), this.pos = O, this.openStart < 0 && (this.openStart = r);
  }
  point(e, O, i, r, n, s) {
    if (this.disallowBlockEffectsFor[s] && i instanceof KO) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (O > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = O - e;
    if (i instanceof KO)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new kO(i.widget || _t.block, a, i));
      else {
        let o = DO.create(i.widget || _t.inline, a, a ? 0 : i.startSide), c = this.atCursorPos && !o.isEditable && n <= r.length && (e < O || i.startSide > 0), h = !o.isEditable && (e < O || n > r.length || i.startSide <= 0), Q = this.getLine();
        this.pendingBuffer == 2 && !c && !o.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (Q.append($r(new Vt(1), r), n), n = r.length + Math.max(0, n - r.length)), Q.append($r(o, r), n), this.atCursorPos = h, this.pendingBuffer = h ? e < O || n > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = O), this.openStart < 0 && (this.openStart = n);
  }
  static build(e, O, i, r, n) {
    let s = new di(e, O, i, n);
    return s.openEnd = A.spans(r, O, i, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function $r(t, e) {
  for (let O of e)
    t = new RO(O, [t], t.length);
  return t;
}
class _t extends VO {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
_t.inline = /* @__PURE__ */ new _t("span");
_t.block = /* @__PURE__ */ new _t("div");
var Oe = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(Oe || (Oe = {}));
const dt = Oe.LTR, So = Oe.RTL;
function bf(t) {
  let e = [];
  for (let O = 0; O < t.length; O++)
    e.push(1 << +t[O]);
  return e;
}
const Qm = /* @__PURE__ */ bf("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), fm = /* @__PURE__ */ bf("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), oa = /* @__PURE__ */ Object.create(null), hO = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), O = /* @__PURE__ */ t.charCodeAt(1);
  oa[e] = O, oa[O] = -e;
}
function xf(t) {
  return t <= 247 ? Qm[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? fm[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const $m = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class NO {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? So : dt;
  }
  /**
  @internal
  */
  constructor(e, O, i) {
    this.from = e, this.to = O, this.level = i;
  }
  /**
  @internal
  */
  side(e, O) {
    return this.dir == O == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, O) {
    return e == (this.dir == O);
  }
  /**
  @internal
  */
  static find(e, O, i, r) {
    let n = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= O && a.to >= O) {
        if (a.level == i)
          return s;
        (n < 0 || (r != 0 ? r < 0 ? a.from < O : a.to > O : e[n].level > a.level)) && (n = s);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}
function Tf(t, e) {
  if (t.length != e.length)
    return !1;
  for (let O = 0; O < t.length; O++) {
    let i = t[O], r = e[O];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !Tf(i.inner, r.inner))
      return !1;
  }
  return !0;
}
const F = [];
function um(t, e, O, i, r) {
  for (let n = 0; n <= i.length; n++) {
    let s = n ? i[n - 1].to : e, a = n < i.length ? i[n].from : O, o = n ? 256 : r;
    for (let c = s, h = o, Q = o; c < a; c++) {
      let f = xf(t.charCodeAt(c));
      f == 512 ? f = h : f == 8 && Q == 4 && (f = 16), F[c] = f == 4 ? 2 : f, f & 7 && (Q = f), h = f;
    }
    for (let c = s, h = o, Q = o; c < a; c++) {
      let f = F[c];
      if (f == 128)
        c < a - 1 && h == F[c + 1] && h & 24 ? f = F[c] = h : F[c] = 256;
      else if (f == 64) {
        let $ = c + 1;
        for (; $ < a && F[$] == 64; )
          $++;
        let u = c && h == 8 || $ < O && F[$] == 8 ? Q == 1 ? 1 : 8 : 256;
        for (let d = c; d < $; d++)
          F[d] = u;
        c = $ - 1;
      } else f == 8 && Q == 1 && (F[c] = 1);
      h = f, f & 7 && (Q = f);
    }
  }
}
function dm(t, e, O, i, r) {
  let n = r == 1 ? 2 : 1;
  for (let s = 0, a = 0, o = 0; s <= i.length; s++) {
    let c = s ? i[s - 1].to : e, h = s < i.length ? i[s].from : O;
    for (let Q = c, f, $, u; Q < h; Q++)
      if ($ = oa[f = t.charCodeAt(Q)])
        if ($ < 0) {
          for (let d = a - 3; d >= 0; d -= 3)
            if (hO[d + 1] == -$) {
              let p = hO[d + 2], m = p & 2 ? r : p & 4 ? p & 1 ? n : r : 0;
              m && (F[Q] = F[hO[d]] = m), a = d;
              break;
            }
        } else {
          if (hO.length == 189)
            break;
          hO[a++] = Q, hO[a++] = f, hO[a++] = o;
        }
      else if ((u = F[Q]) == 2 || u == 1) {
        let d = u == r;
        o = d ? 0 : 1;
        for (let p = a - 3; p >= 0; p -= 3) {
          let m = hO[p + 2];
          if (m & 2)
            break;
          if (d)
            hO[p + 2] |= 2;
          else {
            if (m & 4)
              break;
            hO[p + 2] |= 4;
          }
        }
      }
  }
}
function pm(t, e, O, i) {
  for (let r = 0, n = i; r <= O.length; r++) {
    let s = r ? O[r - 1].to : t, a = r < O.length ? O[r].from : e;
    for (let o = s; o < a; ) {
      let c = F[o];
      if (c == 256) {
        let h = o + 1;
        for (; ; )
          if (h == a) {
            if (r == O.length)
              break;
            h = O[r++].to, a = r < O.length ? O[r].from : e;
          } else if (F[h] == 256)
            h++;
          else
            break;
        let Q = n == 1, f = (h < e ? F[h] : i) == 1, $ = Q == f ? Q ? 1 : 2 : i;
        for (let u = h, d = r, p = d ? O[d - 1].to : t; u > o; )
          u == p && (u = O[--d].from, p = d ? O[d - 1].to : t), F[--u] = $;
        o = h;
      } else
        n = c, o++;
    }
  }
}
function la(t, e, O, i, r, n, s) {
  let a = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let o = e, c = 0; o < O; ) {
      let h = !0, Q = !1;
      if (c == n.length || o < n[c].from) {
        let d = F[o];
        d != a && (h = !1, Q = d == 16);
      }
      let f = !h && a == 1 ? [] : null, $ = h ? i : i + 1, u = o;
      e: for (; ; )
        if (c < n.length && u == n[c].from) {
          if (Q)
            break e;
          let d = n[c];
          if (!h)
            for (let p = d.to, m = c + 1; ; ) {
              if (p == O)
                break e;
              if (m < n.length && n[m].from == p)
                p = n[m++].to;
              else {
                if (F[p] == a)
                  break e;
                break;
              }
            }
          if (c++, f)
            f.push(d);
          else {
            d.from > o && s.push(new NO(o, d.from, $));
            let p = d.direction == dt != !($ % 2);
            ca(t, p ? i + 1 : i, r, d.inner, d.from, d.to, s), o = d.to;
          }
          u = d.to;
        } else {
          if (u == O || (h ? F[u] != a : F[u] == a))
            break;
          u++;
        }
      f ? la(t, o, u, i + 1, r, f, s) : o < u && s.push(new NO(o, u, $)), o = u;
    }
  else
    for (let o = O, c = n.length; o > e; ) {
      let h = !0, Q = !1;
      if (!c || o > n[c - 1].to) {
        let d = F[o - 1];
        d != a && (h = !1, Q = d == 16);
      }
      let f = !h && a == 1 ? [] : null, $ = h ? i : i + 1, u = o;
      e: for (; ; )
        if (c && u == n[c - 1].to) {
          if (Q)
            break e;
          let d = n[--c];
          if (!h)
            for (let p = d.from, m = c; ; ) {
              if (p == e)
                break e;
              if (m && n[m - 1].to == p)
                p = n[--m].from;
              else {
                if (F[p - 1] == a)
                  break e;
                break;
              }
            }
          if (f)
            f.push(d);
          else {
            d.to < o && s.push(new NO(d.to, o, $));
            let p = d.direction == dt != !($ % 2);
            ca(t, p ? i + 1 : i, r, d.inner, d.from, d.to, s), o = d.from;
          }
          u = d.from;
        } else {
          if (u == e || (h ? F[u - 1] != a : F[u - 1] == a))
            break;
          u--;
        }
      f ? la(t, u, o, i + 1, r, f, s) : u < o && s.push(new NO(u, o, $)), o = u;
    }
}
function ca(t, e, O, i, r, n, s) {
  let a = e % 2 ? 2 : 1;
  um(t, r, n, i, a), dm(t, r, n, i, a), pm(r, n, i, a), la(t, r, n, e, O, i, s);
}
function mm(t, e, O) {
  if (!t)
    return [new NO(0, 0, e == So ? 1 : 0)];
  if (e == dt && !O.length && !$m.test(t))
    return wf(t.length);
  if (O.length)
    for (; t.length > F.length; )
      F[F.length] = 256;
  let i = [], r = e == dt ? 0 : 1;
  return ca(t, r, r, O, 0, t.length, i), i;
}
function wf(t) {
  return [new NO(0, t, 0)];
}
let kf = "";
function Pm(t, e, O, i, r) {
  var n;
  let s = i.head - t.from, a = NO.find(e, s, (n = i.bidiLevel) !== null && n !== void 0 ? n : -1, i.assoc), o = e[a], c = o.side(r, O);
  if (s == c) {
    let f = a += r ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    o = e[a = f], s = o.side(!r, O), c = o.side(r, O);
  }
  let h = be(t.text, s, o.forward(r, O));
  (h < o.from || h > o.to) && (h = c), kf = t.text.slice(Math.min(s, h), Math.max(s, h));
  let Q = a == (r ? e.length - 1 : 0) ? null : e[a + (r ? 1 : -1)];
  return Q && h == c && Q.level + (r ? 0 : 1) < o.level ? g.cursor(Q.side(!r, O) + t.from, Q.forward(r, O) ? 1 : -1, Q.level) : g.cursor(h + t.from, o.forward(r, O) ? -1 : 1, o.level);
}
function gm(t, e, O) {
  for (let i = e; i < O; i++) {
    let r = xf(t.charCodeAt(i));
    if (r == 1)
      return dt;
    if (r == 2 || r == 4)
      return So;
  }
  return dt;
}
const Wf = /* @__PURE__ */ R.define(), Rf = /* @__PURE__ */ R.define(), vf = /* @__PURE__ */ R.define(), Zf = /* @__PURE__ */ R.define(), ha = /* @__PURE__ */ R.define(), Yf = /* @__PURE__ */ R.define(), zf = /* @__PURE__ */ R.define(), qf = /* @__PURE__ */ R.define({
  combine: (t) => t.some((e) => e)
}), Uf = /* @__PURE__ */ R.define({
  combine: (t) => t.some((e) => e)
}), Vf = /* @__PURE__ */ R.define();
class Zt {
  constructor(e, O = "nearest", i = "nearest", r = 5, n = 5, s = !1) {
    this.range = e, this.y = O, this.x = i, this.yMargin = r, this.xMargin = n, this.isSnapshot = s;
  }
  map(e) {
    return e.empty ? this : new Zt(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Zt(g.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const ur = /* @__PURE__ */ z.define({ map: (t, e) => t.map(e) }), _f = /* @__PURE__ */ z.define();
function Ue(t, e, O) {
  let i = t.facet(Zf);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), O, void 0, void 0, e) : O ? console.error(O + ":", e) : console.error(e);
}
const CO = /* @__PURE__ */ R.define({ combine: (t) => t.length ? t[0] : !0 });
let Sm = 0;
const ai = /* @__PURE__ */ R.define();
class Qe {
  constructor(e, O, i, r, n) {
    this.id = e, this.create = O, this.domEventHandlers = i, this.domEventObservers = r, this.extension = n(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, O) {
    const { eventHandlers: i, eventObservers: r, provide: n, decorations: s } = O || {};
    return new Qe(Sm++, e, i, r, (a) => {
      let o = [ai.of(a)];
      return s && o.push(Zi.of((c) => {
        let h = c.plugin(a);
        return h ? s(h) : Z.none;
      })), n && o.push(n(a)), o;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, O) {
    return Qe.define((i) => new e(i), O);
  }
}
class Bn {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let O = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(O);
          } catch (i) {
            if (Ue(O.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (O) {
        Ue(e.state, O, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var O;
    if (!((O = this.value) === null || O === void 0) && O.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Ue(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const jf = /* @__PURE__ */ R.define(), Xo = /* @__PURE__ */ R.define(), Zi = /* @__PURE__ */ R.define(), Gf = /* @__PURE__ */ R.define(), yo = /* @__PURE__ */ R.define(), Cf = /* @__PURE__ */ R.define();
function Al(t, e) {
  let O = t.state.facet(Cf);
  if (!O.length)
    return O;
  let i = O.map((n) => n instanceof Function ? n(t) : n), r = [];
  return A.spans(i, e.from, e.to, {
    point() {
    },
    span(n, s, a, o) {
      let c = n - e.from, h = s - e.from, Q = r;
      for (let f = a.length - 1; f >= 0; f--, o--) {
        let $ = a[f].spec.bidiIsolate, u;
        if ($ == null && ($ = gm(e.text, c, h)), o > 0 && Q.length && (u = Q[Q.length - 1]).to == c && u.direction == $)
          u.to = h, Q = u.inner;
        else {
          let d = { from: c, to: h, direction: $, inner: [] };
          Q.push(d), Q = d.inner;
        }
      }
    }
  }), r;
}
const Ef = /* @__PURE__ */ R.define();
function Af(t) {
  let e = 0, O = 0, i = 0, r = 0;
  for (let n of t.state.facet(Ef)) {
    let s = n(t);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (O = Math.max(O, s.right)), s.top != null && (i = Math.max(i, s.top)), s.bottom != null && (r = Math.max(r, s.bottom)));
  }
  return { left: e, right: O, top: i, bottom: r };
}
const oi = /* @__PURE__ */ R.define();
class OO {
  constructor(e, O, i, r) {
    this.fromA = e, this.toA = O, this.fromB = i, this.toB = r;
  }
  join(e) {
    return new OO(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let O = e.length, i = this;
    for (; O > 0; O--) {
      let r = e[O - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), e.splice(O - 1, 1);
      }
    }
    return e.splice(O, 0, i), e;
  }
  static extendWithRanges(e, O) {
    if (O.length == 0)
      return e;
    let i = [];
    for (let r = 0, n = 0, s = 0, a = 0; ; r++) {
      let o = r == e.length ? null : e[r], c = s - a, h = o ? o.fromB : 1e9;
      for (; n < O.length && O[n] < h; ) {
        let Q = O[n], f = O[n + 1], $ = Math.max(a, Q), u = Math.min(h, f);
        if ($ <= u && new OO($ + c, u + c, $, u).addToSet(i), f > h)
          break;
        n += 2;
      }
      if (!o)
        return i;
      new OO(o.fromA, o.toA, o.fromB, o.toB).addToSet(i), s = o.toA, a = o.toB;
    }
  }
}
class rn {
  constructor(e, O, i) {
    this.view = e, this.state = O, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = ue.empty(this.startState.doc.length);
    for (let n of i)
      this.changes = this.changes.compose(n.changes);
    let r = [];
    this.changes.iterChangedRanges((n, s, a, o) => r.push(new OO(n, s, a, o))), this.changedRanges = r;
  }
  /**
  @internal
  */
  static create(e, O, i) {
    return new rn(e, O, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class Dl extends K {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Z.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new ce()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new OO(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var O;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let r = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((O = this.domChanged) === null || O === void 0) && O.newSel ? r = this.domChanged.newSel.head : !km(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head));
    let n = r > -1 ? ym(this.view, e.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      i = new OO(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(i.slice());
    }
    this.hasComposition = n ? { from: n.range.fromB, to: n.range.toB } : null, (W.ie || W.chrome) && !n && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations, a = this.updateDeco(), o = Tm(s, a, e.changes);
    return i = OO.extendWithRanges(i, o), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, n), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, O, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, O, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = W.chrome || W.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || r.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let n = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof kO && s.widget instanceof Nl && n.push(s.dom);
    r.updateGaps(n);
  }
  updateChildren(e, O, i) {
    let r = i ? i.range.addToSet(e.slice()) : e, n = this.childCursor(O);
    for (let s = r.length - 1; ; s--) {
      let a = s >= 0 ? r[s] : null;
      if (!a)
        break;
      let { fromA: o, toA: c, fromB: h, toB: Q } = a, f, $, u, d;
      if (i && i.range.fromB < Q && i.range.toB > h) {
        let y = di.build(this.view.state.doc, h, i.range.fromB, this.decorations, this.dynamicDecorationMap), S = di.build(this.view.state.doc, i.range.toB, Q, this.decorations, this.dynamicDecorationMap);
        $ = y.breakAtStart, u = y.openStart, d = S.openEnd;
        let w = this.compositionView(i);
        S.breakAtStart ? w.breakAfter = 1 : S.content.length && w.merge(w.length, w.length, S.content[0], !1, S.openStart, 0) && (w.breakAfter = S.content[0].breakAfter, S.content.shift()), y.content.length && w.merge(0, 0, y.content[y.content.length - 1], !0, 0, y.openEnd) && y.content.pop(), f = y.content.concat(w).concat(S.content);
      } else
        ({ content: f, breakAtStart: $, openStart: u, openEnd: d } = di.build(this.view.state.doc, h, Q, this.decorations, this.dynamicDecorationMap));
      let { i: p, off: m } = n.findPos(c, 1), { i: P, off: X } = n.findPos(o, -1);
      df(this, P, X, p, m, f, $, u, d);
    }
    i && this.fixCompositionDOM(i);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let O of e.transactions)
      for (let i of O.effects)
        i.is(_f) && (this.editContextFormatting = i.value);
  }
  compositionView(e) {
    let O = new aO(e.text.nodeValue);
    O.flags |= 8;
    for (let { deco: r } of e.marks)
      O = new RO(r, [O], O.length);
    let i = new ce();
    return i.append(O, 0), i;
  }
  fixCompositionDOM(e) {
    let O = (n, s) => {
      s.flags |= 8 | (s.children.some(
        (o) => o.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = K.get(n);
      a && a != s && (a.dom = null), s.setDOM(n);
    }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i];
    O(e.line, r);
    for (let n = e.marks.length - 1; n >= -1; n--)
      i = r.childPos(i.off, 1), r = r.children[i.i], O(n >= 0 ? e.marks[n].node : e.text, r);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, O = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, n = !r && Cr(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || O || n))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, o = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? o : this.moveToLine(this.domAtPos(a.head));
    if (W.gecko && a.empty && !this.hasComposition && Xm(o)) {
      let Q = document.createTextNode("");
      this.view.observer.ignore(() => o.node.insertBefore(Q, o.node.childNodes[o.offset] || null)), o = c = new Te(Q, 0), s = !0;
    }
    let h = this.view.observer.selectionRange;
    (s || !h.focusNode || (!ui(o.node, o.offset, h.anchorNode, h.anchorOffset) || !ui(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, a)) && (this.view.observer.ignore(() => {
      W.android && W.chrome && this.dom.contains(h.focusNode) && wm(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let Q = Ri(this.view.root);
      if (Q) if (a.empty) {
        if (W.gecko) {
          let f = bm(o.node, o.offset);
          if (f && f != 3) {
            let $ = (f == 1 ? ff : $f)(o.node, o.offset);
            $ && (o = new Te($.node, $.offset));
          }
        }
        Q.collapse(o.node, o.offset), a.bidiLevel != null && Q.caretBidiLevel !== void 0 && (Q.caretBidiLevel = a.bidiLevel);
      } else if (Q.extend) {
        Q.collapse(o.node, o.offset);
        try {
          Q.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        a.anchor > a.head && ([o, c] = [c, o]), f.setEnd(c.node, c.offset), f.setStart(o.node, o.offset), Q.removeAllRanges(), Q.addRange(f);
      }
      n && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(o, c)), this.impreciseAnchor = o.precise ? null : new Te(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new Te(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, O) {
    return this.hasComposition && O.empty && ui(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == O.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, O = e.state.selection.main, i = Ri(e.root), { anchorNode: r, anchorOffset: n } = e.observer.selectionRange;
    if (!i || !O.empty || !O.assoc || !i.modify)
      return;
    let s = ce.find(this, O.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (O.head == a || O.head == a + s.length)
      return;
    let o = this.coordsAt(O.head, -1), c = this.coordsAt(O.head, 1);
    if (!o || !c || o.bottom > c.top)
      return;
    let h = this.domAtPos(O.head + O.assoc);
    i.collapse(h.node, h.offset), i.modify("move", O.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let Q = e.observer.selectionRange;
    e.docView.posFromDOM(Q.anchorNode, Q.anchorOffset) != O.from && i.collapse(r, n);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let O = this.dom, i;
    if (e.node != O)
      return e;
    for (let r = e.offset; !i && r < O.childNodes.length; r++) {
      let n = K.get(O.childNodes[r]);
      n instanceof ce && (i = n.domAtPos(0));
    }
    for (let r = e.offset - 1; !i && r >= 0; r--) {
      let n = K.get(O.childNodes[r]);
      n instanceof ce && (i = n.domAtPos(n.length));
    }
    return i ? new Te(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let O = e; O; ) {
      let i = K.get(O);
      if (i && i.rootView == this)
        return i;
      O = O.parentNode;
    }
    return null;
  }
  posFromDOM(e, O) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, O) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: O, off: i } = this.childCursor().findPos(e, -1);
    for (; O < this.children.length - 1; ) {
      let r = this.children[O];
      if (i < r.length || r instanceof ce)
        break;
      O++, i = 0;
    }
    return this.children[O].domAtPos(i);
  }
  coordsAt(e, O) {
    let i = null, r = 0;
    for (let n = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], o = n - a.breakAfter, c = o - a.length;
      if (o < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (o > e || a.covers(1)) && (!i || a instanceof ce && !(i instanceof ce && O >= 0)))
        i = a, r = c;
      else if (i && c == e && o == e && a instanceof kO && Math.abs(O) < 2) {
        if (a.deco.startSide < 0)
          break;
        s && (i = null);
      }
      n = c;
    }
    return i ? i.coordsAt(e - r, O) : null;
  }
  coordsForChar(e) {
    let { i: O, off: i } = this.childPos(e, 1), r = this.children[O];
    if (!(r instanceof ce))
      return null;
    for (; r.children.length; ) {
      let { i: a, off: o } = r.childPos(i, 1);
      for (; ; a++) {
        if (a == r.children.length)
          return null;
        if ((r = r.children[a]).length)
          break;
      }
      i = o;
    }
    if (!(r instanceof aO))
      return null;
    let n = be(r.text, i);
    if (n == i)
      return null;
    let s = ut(r.dom, i, n).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let o = s[a];
      if (a == s.length - 1 || o.top < o.bottom && o.left < o.right)
        return o;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let O = [], { from: i, to: r } = e, n = this.view.contentDOM.clientWidth, s = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, o = this.view.textDirection == Oe.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let Q = this.children[h], f = c + Q.length;
      if (f > r)
        break;
      if (c >= i) {
        let $ = Q.dom.getBoundingClientRect();
        if (O.push($.height), s) {
          let u = Q.dom.lastChild, d = u ? vi(u) : [];
          if (d.length) {
            let p = d[d.length - 1], m = o ? p.right - $.left : $.right - p.left;
            m > a && (a = m, this.minWidth = n, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + Q.breakAfter;
    }
    return O;
  }
  textDirectionAt(e) {
    let { i: O } = this.childPos(e, 1);
    return getComputedStyle(this.children[O].dom).direction == "rtl" ? Oe.RTL : Oe.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof ce) {
        let s = n.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), O, i, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let n = vi(e.firstChild)[0];
      O = e.getBoundingClientRect().height, i = n ? n.width / 27 : 7, r = n ? n.height : O, e.remove();
    }), { lineHeight: O, charWidth: i, textHeight: r };
  }
  childCursor(e = this.length) {
    let O = this.children.length;
    return O && (e -= this.children[--O].length), new uf(this.children, e, O);
  }
  computeBlockGapDeco() {
    let e = [], O = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let n = r == O.viewports.length ? null : O.viewports[r], s = n ? n.from - 1 : this.length;
      if (s > i) {
        let a = (O.lineBlockAt(s).bottom - O.lineBlockAt(i).top) / this.view.scaleY;
        e.push(Z.replace({
          widget: new Nl(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, s));
      }
      if (!n)
        break;
      i = n.to + 1;
    }
    return Z.set(e);
  }
  updateDeco() {
    let e = 1, O = this.view.state.facet(Zi).map((n) => (this.dynamicDecorationMap[e++] = typeof n == "function") ? n(this.view) : n), i = !1, r = this.view.state.facet(Gf).map((n, s) => {
      let a = typeof n == "function";
      return a && (i = !0), a ? n(this.view) : n;
    });
    for (r.length && (this.dynamicDecorationMap[e++] = i, O.push(A.join(r))), this.decorations = [
      this.editContextFormatting,
      ...O,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(Vf))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (h) {
        Ue(this.view.state, h, "scroll handler");
      }
    let { range: O } = e, i = this.coordsAt(O.head, O.empty ? O.assoc : O.head > O.anchor ? -1 : 1), r;
    if (!i)
      return;
    !O.empty && (r = this.coordsAt(O.anchor, O.anchor > O.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let n = Af(this.view), s = {
      left: i.left - n.left,
      top: i.top - n.top,
      right: i.right + n.right,
      bottom: i.bottom + n.bottom
    }, { offsetWidth: a, offsetHeight: o } = this.view.scrollDOM;
    tm(this.view.scrollDOM, s, O.head < O.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, o), -o), this.view.textDirection == Oe.LTR);
  }
}
function Xm(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class Nl extends VO {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function Df(t, e) {
  let O = t.observer.selectionRange;
  if (!O.focusNode)
    return null;
  let i = ff(O.focusNode, O.focusOffset), r = $f(O.focusNode, O.focusOffset), n = i || r;
  if (r && i && r.node != i.node) {
    let a = K.get(r.node);
    if (!a || a instanceof aO && a.text != r.node.nodeValue)
      n = r;
    else if (t.docView.lastCompositionAfterCursor) {
      let o = K.get(i.node);
      !o || o instanceof aO && o.text != i.node.nodeValue || (n = r);
    }
  }
  if (t.docView.lastCompositionAfterCursor = n != i, !n)
    return null;
  let s = e - n.offset;
  return { from: s, to: s + n.node.nodeValue.length, node: n.node };
}
function ym(t, e, O) {
  let i = Df(t, O);
  if (!i)
    return null;
  let { node: r, from: n, to: s } = i, a = r.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(i.from, i.to) != a)
    return null;
  let o = e.invertedDesc, c = new OO(o.mapPos(n), o.mapPos(s), n, s), h = [];
  for (let Q = r.parentNode; ; Q = Q.parentNode) {
    let f = K.get(Q);
    if (f instanceof RO)
      h.push({ node: Q, deco: f.mark });
    else {
      if (f instanceof ce || Q.nodeName == "DIV" && Q.parentNode == t.contentDOM)
        return { range: c, text: r, marks: h, line: Q };
      if (Q != t.contentDOM)
        h.push({ node: Q, deco: new Ji({
          inclusive: !0,
          attributes: cm(Q),
          tagName: Q.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function bm(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let xm = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, O) {
    aa(e, O, this.changes);
  }
  comparePoint(e, O) {
    aa(e, O, this.changes);
  }
};
function Tm(t, e, O) {
  let i = new xm();
  return A.compare(t, e, O, i), i.changes;
}
function wm(t, e) {
  for (let O = t; O && O != e; O = O.assignedSlot || O.parentNode)
    if (O.nodeType == 1 && O.contentEditable == "false")
      return !0;
  return !1;
}
function km(t, e) {
  let O = !1;
  return e && t.iterChangedRanges((i, r) => {
    i < e.to && r > e.from && (O = !0);
  }), O;
}
function Wm(t, e, O = 1) {
  let i = t.charCategorizer(e), r = t.doc.lineAt(e), n = e - r.from;
  if (r.length == 0)
    return g.cursor(e);
  n == 0 ? O = 1 : n == r.length && (O = -1);
  let s = n, a = n;
  O < 0 ? s = be(r.text, n, !1) : a = be(r.text, n);
  let o = i(r.text.slice(s, a));
  for (; s > 0; ) {
    let c = be(r.text, s, !1);
    if (i(r.text.slice(c, s)) != o)
      break;
    s = c;
  }
  for (; a < r.length; ) {
    let c = be(r.text, a);
    if (i(r.text.slice(a, c)) != o)
      break;
    a = c;
  }
  return g.range(s + r.from, a + r.from);
}
function Rm(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function vm(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Fn(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function Il(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function Ml(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Qa(t, e, O) {
  let i, r, n, s, a = !1, o, c, h, Q;
  for (let u = t.firstChild; u; u = u.nextSibling) {
    let d = vi(u);
    for (let p = 0; p < d.length; p++) {
      let m = d[p];
      r && Fn(r, m) && (m = Il(Ml(m, r.bottom), r.top));
      let P = Rm(e, m), X = vm(O, m);
      if (P == 0 && X == 0)
        return u.nodeType == 3 ? Ll(u, e, O) : Qa(u, e, O);
      if (!i || s > X || s == X && n > P) {
        i = u, r = m, n = P, s = X;
        let y = X ? O < m.top ? -1 : 1 : P ? e < m.left ? -1 : 1 : 0;
        a = !y || (y > 0 ? p < d.length - 1 : p > 0);
      }
      P == 0 ? O > m.bottom && (!h || h.bottom < m.bottom) ? (o = u, h = m) : O < m.top && (!Q || Q.top > m.top) && (c = u, Q = m) : h && Fn(h, m) ? h = Ml(h, m.bottom) : Q && Fn(Q, m) && (Q = Il(Q, m.top));
    }
  }
  if (h && h.bottom >= O ? (i = o, r = h) : Q && Q.top <= O && (i = c, r = Q), !i)
    return { node: t, offset: 0 };
  let f = Math.max(r.left, Math.min(r.right, e));
  if (i.nodeType == 3)
    return Ll(i, f, O);
  if (a && i.contentEditable != "false")
    return Qa(i, f, O);
  let $ = Array.prototype.indexOf.call(t.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: t, offset: $ };
}
function Ll(t, e, O) {
  let i = t.nodeValue.length, r = -1, n = 1e9, s = 0;
  for (let a = 0; a < i; a++) {
    let o = ut(t, a, a + 1).getClientRects();
    for (let c = 0; c < o.length; c++) {
      let h = o[c];
      if (h.top == h.bottom)
        continue;
      s || (s = e - h.left);
      let Q = (h.top > O ? h.top - O : O - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && Q < n) {
        let f = e >= (h.left + h.right) / 2, $ = f;
        if ((W.chrome || W.gecko) && ut(t, a).getBoundingClientRect().left == h.right && ($ = !f), Q <= 0)
          return { node: t, offset: a + ($ ? 1 : 0) };
        r = a + ($ ? 1 : 0), n = Q;
      }
    }
  }
  return { node: t, offset: r > -1 ? r : s > 0 ? t.nodeValue.length : 0 };
}
function Nf(t, e, O, i = -1) {
  var r, n;
  let s = t.contentDOM.getBoundingClientRect(), a = s.top + t.viewState.paddingTop, o, { docHeight: c } = t.viewState, { x: h, y: Q } = e, f = Q - a;
  if (f < 0)
    return 0;
  if (f > c)
    return t.state.doc.length;
  for (let y = t.viewState.heightOracle.textHeight / 2, S = !1; o = t.elementAtHeight(f), o.type != Re.Text; )
    for (; f = i > 0 ? o.bottom + y : o.top - y, !(f >= 0 && f <= c); ) {
      if (S)
        return O ? null : 0;
      S = !0, i = -i;
    }
  Q = a + f;
  let $ = o.from;
  if ($ < t.viewport.from)
    return t.viewport.from == 0 ? 0 : O ? null : Bl(t, s, o, h, Q);
  if ($ > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : O ? null : Bl(t, s, o, h, Q);
  let u = t.dom.ownerDocument, d = t.root.elementFromPoint ? t.root : u, p = d.elementFromPoint(h, Q);
  p && !t.contentDOM.contains(p) && (p = null), p || (h = Math.max(s.left + 1, Math.min(s.right - 1, h)), p = d.elementFromPoint(h, Q), p && !t.contentDOM.contains(p) && (p = null));
  let m, P = -1;
  if (p && ((r = t.docView.nearest(p)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (u.caretPositionFromPoint) {
      let y = u.caretPositionFromPoint(h, Q);
      y && ({ offsetNode: m, offset: P } = y);
    } else if (u.caretRangeFromPoint) {
      let y = u.caretRangeFromPoint(h, Q);
      y && ({ startContainer: m, startOffset: P } = y, (!t.contentDOM.contains(m) || W.safari && Zm(m, P, h) || W.chrome && Ym(m, P, h)) && (m = void 0));
    }
  }
  if (!m || !t.docView.dom.contains(m)) {
    let y = ce.find(t.docView, $);
    if (!y)
      return f > o.top + o.height / 2 ? o.to : o.from;
    ({ node: m, offset: P } = Qa(y.dom, h, Q));
  }
  let X = t.docView.nearest(m);
  if (!X)
    return null;
  if (X.isWidget && ((n = X.dom) === null || n === void 0 ? void 0 : n.nodeType) == 1) {
    let y = X.dom.getBoundingClientRect();
    return e.y < y.top || e.y <= y.bottom && e.x <= (y.left + y.right) / 2 ? X.posAtStart : X.posAtEnd;
  } else
    return X.localPosFromDOM(m, P) + X.posAtStart;
}
function Bl(t, e, O, i, r) {
  let n = Math.round((i - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && O.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, o = Math.floor((r - O.top - (t.defaultLineHeight - a) * 0.5) / a);
    n += o * t.viewState.heightOracle.lineLength;
  }
  let s = t.state.sliceDoc(O.from, O.to);
  return O.from + Ks(s, n, t.state.tabSize);
}
function Zm(t, e, O) {
  let i;
  if (t.nodeType != 3 || e != (i = t.nodeValue.length))
    return !1;
  for (let r = t.nextSibling; r; r = r.nextSibling)
    if (r.nodeType != 1 || r.nodeName != "BR")
      return !1;
  return ut(t, i - 1, i).getBoundingClientRect().left > O;
}
function Ym(t, e, O) {
  if (e != 0)
    return !1;
  for (let r = t; ; ) {
    let n = r.parentNode;
    if (!n || n.nodeType != 1 || n.firstChild != r)
      return !1;
    if (n.classList.contains("cm-line"))
      break;
    r = n;
  }
  let i = t.nodeType == 1 ? t.getBoundingClientRect() : ut(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return O - i.left > 5;
}
function fa(t, e) {
  let O = t.lineBlockAt(e);
  if (Array.isArray(O.type)) {
    for (let i of O.type)
      if (i.to > e || i.to == e && (i.to == O.to || i.type == Re.Text))
        return i;
  }
  return O;
}
function zm(t, e, O, i) {
  let r = fa(t, e.head), n = !i || r.type != Re.Text || !(t.lineWrapping || r.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (n) {
    let s = t.dom.getBoundingClientRect(), a = t.textDirectionAt(r.from), o = t.posAtCoords({
      x: O == (a == Oe.LTR) ? s.right - 1 : s.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (o != null)
      return g.cursor(o, O ? -1 : 1);
  }
  return g.cursor(O ? r.to : r.from, O ? -1 : 1);
}
function Fl(t, e, O, i) {
  let r = t.state.doc.lineAt(e.head), n = t.bidiSpans(r), s = t.textDirectionAt(r.from);
  for (let a = e, o = null; ; ) {
    let c = Pm(r, n, s, a, O), h = kf;
    if (!c) {
      if (r.number == (O ? t.state.doc.lines : 1))
        return a;
      h = `
`, r = t.state.doc.line(r.number + (O ? 1 : -1)), n = t.bidiSpans(r), c = t.visualLineSide(r, !O);
    }
    if (o) {
      if (!o(h))
        return a;
    } else {
      if (!i)
        return c;
      o = i(h);
    }
    a = c;
  }
}
function qm(t, e, O) {
  let i = t.state.charCategorizer(e), r = i(O);
  return (n) => {
    let s = i(n);
    return r == te.Space && (r = s), r == s;
  };
}
function Um(t, e, O, i) {
  let r = e.head, n = O ? 1 : -1;
  if (r == (O ? t.state.doc.length : 0))
    return g.cursor(r, e.assoc);
  let s = e.goalColumn, a, o = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(r, e.assoc || -1), h = t.documentTop;
  if (c)
    s == null && (s = c.left - o.left), a = n < 0 ? c.top : c.bottom;
  else {
    let $ = t.viewState.lineBlockAt(r);
    s == null && (s = Math.min(o.right - o.left, t.defaultCharacterWidth * (r - $.from))), a = (n < 0 ? $.top : $.bottom) + h;
  }
  let Q = o.left + s, f = i ?? t.viewState.heightOracle.textHeight >> 1;
  for (let $ = 0; ; $ += 10) {
    let u = a + (f + $) * n, d = Nf(t, { x: Q, y: u }, !1, n);
    if (u < o.top || u > o.bottom || (n < 0 ? d < r : d > r)) {
      let p = t.docView.coordsForChar(d), m = !p || u < p.top ? -1 : 1;
      return g.cursor(d, m, void 0, s);
    }
  }
}
function Er(t, e, O) {
  for (; ; ) {
    let i = 0;
    for (let r of t)
      r.between(e - 1, e + 1, (n, s, a) => {
        if (e > n && e < s) {
          let o = i || O || (e - n < s - e ? -1 : 1);
          e = o < 0 ? n : s, i = o;
        }
      });
    if (!i)
      return e;
  }
}
function Hn(t, e, O) {
  let i = Er(t.state.facet(yo).map((r) => r(t)), O.from, e.head > O.from ? -1 : 1);
  return i == O.from ? O : g.cursor(i, i < O.from ? 1 : -1);
}
const li = "ï¿¿";
class Vm {
  constructor(e, O) {
    this.points = e, this.text = "", this.lineSeparator = O.facet(E.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += li;
  }
  readRange(e, O) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(i, r);
      let n = this.text.length;
      this.readNode(r);
      let s = r.nextSibling;
      if (s == O)
        break;
      let a = K.get(r), o = K.get(s);
      (a && o ? a.breakAfter : (a ? a.breakAfter : On(r)) || On(s) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > n) && this.lineBreak(), r = s;
    }
    return this.findPointBefore(i, O), this;
  }
  readTextNode(e) {
    let O = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, O.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, s = 1, a;
      if (this.lineSeparator ? (n = O.indexOf(this.lineSeparator, i), s = this.lineSeparator.length) : (a = r.exec(O)) && (n = a.index, s = a[0].length), this.append(O.slice(i, n < 0 ? O.length : n)), n < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let o of this.points)
          o.node == e && o.pos > this.text.length && (o.pos -= s - 1);
      i = n + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let O = K.get(e), i = O && O.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, O) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == O && (i.pos = this.text.length);
  }
  findPointInside(e, O) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (_m(e, i.node, i.offset) ? O : 0));
  }
}
function _m(t, e, O) {
  for (; ; ) {
    if (!e || O < WO(e))
      return !1;
    if (e == t)
      return !0;
    O = $t(e) + 1, e = e.parentNode;
  }
}
class Hl {
  constructor(e, O) {
    this.node = e, this.offset = O, this.pos = -1;
  }
}
class jm {
  constructor(e, O, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "", this.domChanged = O > -1;
    let { impreciseHead: n, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && O > -1)
      this.newSel = null;
    else if (O > -1 && (this.bounds = e.docView.domBoundsAround(O, i, 0))) {
      let a = n || s ? [] : Em(e), o = new Vm(a, e.state);
      o.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = o.text, this.newSel = Am(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, o = n && n.node == a.focusNode && n.offset == a.focusOffset || !Oa(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !Oa(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), h = e.viewport;
      if ((W.ios || W.chrome) && e.state.selection.main.empty && o != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let Q = Math.min(o, c), f = Math.max(o, c), $ = h.from - Q, u = h.to - f;
        ($ == 0 || $ == 1 || Q == 0) && (u == 0 || u == -1 || f == e.state.doc.length) && (o = 0, c = e.state.doc.length);
      }
      this.newSel = g.single(c, o);
    }
  }
}
function If(t, e) {
  let O, { newSel: i } = e, r = t.state.selection.main, n = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, o = r.from, c = null;
    (n === 8 || W.android && e.text.length < a - s) && (o = r.to, c = "end");
    let h = Cm(t.state.doc.sliceString(s, a, li), e.text, o - s, c);
    h && (W.chrome && n == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == li + li && h.toB--, O = {
      from: s + h.from,
      to: s + h.toA,
      insert: N.of(e.text.slice(h.from, h.toB).split(li))
    });
  } else i && (!t.hasFocus && t.state.facet(CO) || i.main.eq(r)) && (i = null);
  if (!O && !i)
    return !1;
  if (!O && e.typeOver && !r.empty && i && i.main.empty ? O = { from: r.from, to: r.to, insert: t.state.doc.slice(r.from, r.to) } : O && O.from >= r.from && O.to <= r.to && (O.from != r.from || O.to != r.to) && r.to - r.from - (O.to - O.from) <= 4 ? O = {
    from: r.from,
    to: r.to,
    insert: t.state.doc.slice(r.from, O.from).append(O.insert).append(t.state.doc.slice(O.to, r.to))
  } : (W.mac || W.android) && O && O.from == O.to && O.from == r.head - 1 && /^\. ?$/.test(O.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (i && O.insert.length == 2 && (i = g.single(i.main.anchor - 1, i.main.head - 1)), O = { from: r.from, to: r.to, insert: N.of([" "]) }) : W.chrome && O && O.from == O.to && O.from == r.head && O.insert.toString() == `
 ` && t.lineWrapping && (i && (i = g.single(i.main.anchor - 1, i.main.head - 1)), O = { from: r.from, to: r.to, insert: N.of([" "]) }), O)
    return bo(t, O, i, n);
  if (i && !i.main.eq(r)) {
    let s = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (s = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: i, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function bo(t, e, O, i = -1) {
  if (W.ios && t.inputState.flushIOSKey(e))
    return !0;
  let r = t.state.selection.main;
  if (W.android && (e.to == r.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == r.from || e.from == r.from - 1 && t.state.sliceDoc(e.from, r.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && vt(t.contentDOM, "Enter", 13) || (e.from == r.from - 1 && e.to == r.to && e.insert.length == 0 || i == 8 && e.insert.length < e.to - e.from && e.to > r.head) && vt(t.contentDOM, "Backspace", 8) || e.from == r.from && e.to == r.to + 1 && e.insert.length == 0 && vt(t.contentDOM, "Delete", 46)))
    return !0;
  let n = e.insert.toString();
  t.inputState.composing >= 0 && t.inputState.composing++;
  let s, a = () => s || (s = Gm(t, e, O));
  return t.state.facet(Yf).some((o) => o(t, e.from, e.to, n, a)) || t.dispatch(a()), !0;
}
function Gm(t, e, O) {
  let i, r = t.state, n = r.selection.main;
  if (e.from >= n.from && e.to <= n.to && e.to - e.from >= (n.to - n.from) / 3 && (!O || O.main.empty && O.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = n.from < e.from ? r.sliceDoc(n.from, e.from) : "", o = n.to > e.to ? r.sliceDoc(e.to, n.to) : "";
    i = r.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + o));
  } else {
    let a = r.changes(e), o = O && O.main.to <= a.newLength ? O.main : void 0;
    if (r.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= n.to && e.to >= n.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), h, Q = O && Df(t, O.main.head);
      if (Q) {
        let u = e.insert.length - (e.to - e.from);
        h = { from: Q.from, to: Q.to - u };
      } else
        h = t.state.doc.lineAt(n.head);
      let f = n.to - e.to, $ = n.to - n.from;
      i = r.changeByRange((u) => {
        if (u.from == n.from && u.to == n.to)
          return { changes: a, range: o || u.map(a) };
        let d = u.to - f, p = d - c.length;
        if (u.to - u.from != $ || t.state.sliceDoc(p, d) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        u.to >= h.from && u.from <= h.to)
          return { range: u };
        let m = r.changes({ from: p, to: d, insert: e.insert }), P = u.to - n.to;
        return {
          changes: m,
          range: o ? g.range(Math.max(0, o.anchor + P), Math.max(0, o.head + P)) : u.map(m)
        };
      });
    } else
      i = {
        changes: a,
        selection: o && r.selection.replaceRange(o)
      };
  }
  let s = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, s += ".compose", t.inputState.compositionFirstChange && (s += ".start", t.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: s, scrollIntoView: !0 });
}
function Cm(t, e, O, i) {
  let r = Math.min(t.length, e.length), n = 0;
  for (; n < r && t.charCodeAt(n) == e.charCodeAt(n); )
    n++;
  if (n == r && t.length == e.length)
    return null;
  let s = t.length, a = e.length;
  for (; s > 0 && a > 0 && t.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (i == "end") {
    let o = Math.max(0, n - Math.min(s, a));
    O -= s + o - n;
  }
  if (s < n && t.length < e.length) {
    let o = O <= n && O >= s ? n - O : 0;
    n -= o, a = n + (a - s), s = n;
  } else if (a < n) {
    let o = O <= n && O >= a ? n - O : 0;
    n -= o, s = n + (s - a), a = n;
  }
  return { from: n, toA: s, toB: a };
}
function Em(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: O, anchorOffset: i, focusNode: r, focusOffset: n } = t.observer.selectionRange;
  return O && (e.push(new Hl(O, i)), (r != O || n != i) && e.push(new Hl(r, n))), e;
}
function Am(t, e) {
  if (t.length == 0)
    return null;
  let O = t[0].pos, i = t.length == 2 ? t[1].pos : O;
  return O > -1 && i > -1 ? g.single(O + e, i + e) : null;
}
class Dm {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, W.safari && e.contentDOM.addEventListener("input", () => null), W.gecko && sP(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !Km(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, O) {
    let i = this.handlers[e];
    if (i) {
      for (let r of i.observers)
        r(this.view, O);
      for (let r of i.handlers) {
        if (O.defaultPrevented)
          break;
        if (r(this.view, O)) {
          O.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let O = Nm(e), i = this.handlers, r = this.view.contentDOM;
    for (let n in O)
      if (n != "scroll") {
        let s = !O[n].handlers.length, a = i[n];
        a && s != !a.handlers.length && (r.removeEventListener(n, this.handleEvent), a = null), a || r.addEventListener(n, this.handleEvent, { passive: s });
      }
    for (let n in i)
      n != "scroll" && !O[n] && r.removeEventListener(n, this.handleEvent);
    this.handlers = O;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && Lf.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), W.android && W.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let O;
    return W.ios && !e.synthetic && !e.altKey && !e.metaKey && ((O = Mf.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || Im.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = O || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let O = this.pendingIOSKey;
    return !O || O.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, vt(this.view.contentDOM, O.key, O.keyCode, O instanceof KeyboardEvent ? O : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : W.safari && !W.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function Kl(t, e) {
  return (O, i) => {
    try {
      return e.call(t, i, O);
    } catch (r) {
      Ue(O.state, r);
    }
  };
}
function Nm(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function O(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of t) {
    let r = i.spec;
    if (r && r.domEventHandlers)
      for (let n in r.domEventHandlers) {
        let s = r.domEventHandlers[n];
        s && O(n).handlers.push(Kl(i.value, s));
      }
    if (r && r.domEventObservers)
      for (let n in r.domEventObservers) {
        let s = r.domEventObservers[n];
        s && O(n).observers.push(Kl(i.value, s));
      }
  }
  for (let i in oO)
    O(i).handlers.push(oO[i]);
  for (let i in tO)
    O(i).observers.push(tO[i]);
  return e;
}
const Mf = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Im = "dthko", Lf = [16, 17, 18, 20, 91, 92, 224, 225], dr = 6;
function pr(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function Mm(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class Lm {
  constructor(e, O, i, r) {
    this.view = e, this.startEvent = O, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = O, this.scrollParents = im(e.contentDOM), this.atoms = e.state.facet(yo).map((s) => s(e));
    let n = e.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = O.shiftKey, this.multiple = e.state.facet(E.allowMultipleSelections) && Bm(e, O), this.dragging = Hm(e, O) && Hf(O) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Mm(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let O = 0, i = 0, r = 0, n = 0, s = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: r, right: s } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: n, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let o = Af(this.view);
    e.clientX - o.left <= r + dr ? O = -pr(r - e.clientX) : e.clientX + o.right >= s - dr && (O = pr(e.clientX - s)), e.clientY - o.top <= n + dr ? i = -pr(n - e.clientY) : e.clientY + o.bottom >= a - dr && (i = pr(e.clientY - a)), this.setScrollSpeed(O, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, O) {
    this.scrollSpeed = { x: e, y: O }, e || O ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: O } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), O && this.scrollParents.y && (this.scrollParents.y.scrollTop += O, O = 0), (e || O) && this.view.win.scrollBy(e, O), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let O = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let r = e.ranges[i], n = null;
      if (r.empty) {
        let s = Er(this.atoms, r.from, 0);
        s != r.from && (n = g.cursor(s, -1));
      } else {
        let s = Er(this.atoms, r.from, -1), a = Er(this.atoms, r.to, 1);
        (s != r.from || a != r.to) && (n = g.range(r.from == r.anchor ? s : a, r.from == r.head ? s : a));
      }
      n && (O || (O = e.ranges.slice()), O[i] = n);
    }
    return O ? g.create(O, e.mainIndex) : e;
  }
  select(e) {
    let { view: O } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(O.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((O) => O.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Bm(t, e) {
  let O = t.state.facet(Wf);
  return O.length ? O[0](e) : W.mac ? e.metaKey : e.ctrlKey;
}
function Fm(t, e) {
  let O = t.state.facet(Rf);
  return O.length ? O[0](e) : W.mac ? !e.altKey : !e.ctrlKey;
}
function Hm(t, e) {
  let { main: O } = t.state.selection;
  if (O.empty)
    return !1;
  let i = Ri(t.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let n = 0; n < r.length; n++) {
    let s = r[n];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function Km(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let O = e.target, i; O != t.contentDOM; O = O.parentNode)
    if (!O || O.nodeType == 11 || (i = K.get(O)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const oO = /* @__PURE__ */ Object.create(null), tO = /* @__PURE__ */ Object.create(null), Bf = W.ie && W.ie_version < 15 || W.ios && W.webkit_version < 604;
function Jm(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let O = e.appendChild(document.createElement("textarea"));
  O.style.cssText = "position: fixed; left: -10000px; top: 10px", O.focus(), setTimeout(() => {
    t.focus(), O.remove(), Ff(t, O.value);
  }, 50);
}
function Ff(t, e) {
  let { state: O } = t, i, r = 1, n = O.toText(e), s = n.lines == O.selection.ranges.length;
  if ($a != null && O.selection.ranges.every((o) => o.empty) && $a == n.toString()) {
    let o = -1;
    i = O.changeByRange((c) => {
      let h = O.doc.lineAt(c.from);
      if (h.from == o)
        return { range: c };
      o = h.from;
      let Q = O.toText((s ? n.line(r++).text : e) + O.lineBreak);
      return {
        changes: { from: h.from, insert: Q },
        range: g.cursor(c.from + Q.length)
      };
    });
  } else s ? i = O.changeByRange((o) => {
    let c = n.line(r++);
    return {
      changes: { from: o.from, to: o.to, insert: c.text },
      range: g.cursor(o.from + c.length)
    };
  }) : i = O.replaceSelection(n);
  t.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
tO.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
oO.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && t.inputState.tabFocusMode != 0 && (t.inputState.tabFocusMode = Date.now() + 2e3), !1);
tO.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
tO.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
oO.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let O = null;
  for (let i of t.state.facet(vf))
    if (O = i(t, e), O)
      break;
  if (!O && e.button == 0 && (O = tP(t, e)), O) {
    let i = !t.hasFocus;
    t.inputState.startMouseSelection(new Lm(t, e, O, i)), i && t.observer.ignore(() => {
      cf(t.contentDOM);
      let n = t.root.activeElement;
      n && !n.contains(t.contentDOM) && n.blur();
    });
    let r = t.inputState.mouseSelection;
    if (r)
      return r.start(e), r.dragging === !1;
  }
  return !1;
};
function Jl(t, e, O, i) {
  if (i == 1)
    return g.cursor(e, O);
  if (i == 2)
    return Wm(t.state, e, O);
  {
    let r = ce.find(t.docView, e), n = t.state.doc.lineAt(r ? r.posAtEnd : e), s = r ? r.posAtStart : n.from, a = r ? r.posAtEnd : n.to;
    return a < t.state.doc.length && a == n.to && a++, g.range(s, a);
  }
}
let ec = (t, e, O) => e >= O.top && e <= O.bottom && t >= O.left && t <= O.right;
function eP(t, e, O, i) {
  let r = ce.find(t.docView, e);
  if (!r)
    return 1;
  let n = e - r.posAtStart;
  if (n == 0)
    return 1;
  if (n == r.length)
    return -1;
  let s = r.coordsAt(n, -1);
  if (s && ec(O, i, s))
    return -1;
  let a = r.coordsAt(n, 1);
  return a && ec(O, i, a) ? 1 : s && s.bottom >= i ? -1 : 1;
}
function Oc(t, e) {
  let O = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: O, bias: eP(t, O, e.clientX, e.clientY) };
}
const OP = W.ie && W.ie_version <= 11;
let tc = null, ic = 0, rc = 0;
function Hf(t) {
  if (!OP)
    return t.detail;
  let e = tc, O = rc;
  return tc = t, rc = Date.now(), ic = !e || O > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (ic + 1) % 3 : 1;
}
function tP(t, e) {
  let O = Oc(t, e), i = Hf(e), r = t.state.selection;
  return {
    update(n) {
      n.docChanged && (O.pos = n.changes.mapPos(O.pos), r = r.map(n.changes));
    },
    get(n, s, a) {
      let o = Oc(t, n), c, h = Jl(t, o.pos, o.bias, i);
      if (O.pos != o.pos && !s) {
        let Q = Jl(t, O.pos, O.bias, i), f = Math.min(Q.from, h.from), $ = Math.max(Q.to, h.to);
        h = f < h.from ? g.range(f, $) : g.range($, f);
      }
      return s ? r.replaceRange(r.main.extend(h.from, h.to)) : a && i == 1 && r.ranges.length > 1 && (c = iP(r, o.pos)) ? c : a ? r.addRange(h) : g.create([h]);
    }
  };
}
function iP(t, e) {
  for (let O = 0; O < t.ranges.length; O++) {
    let { from: i, to: r } = t.ranges[O];
    if (i <= e && r >= e)
      return g.create(t.ranges.slice(0, O).concat(t.ranges.slice(O + 1)), t.mainIndex == O ? 0 : t.mainIndex - (t.mainIndex > O ? 1 : 0));
  }
  return null;
}
oO.dragstart = (t, e) => {
  let { selection: { main: O } } = t.state;
  if (e.target.draggable) {
    let r = t.docView.nearest(e.target);
    if (r && r.isWidget) {
      let n = r.posAtStart, s = n + r.length;
      (n >= O.to || s <= O.from) && (O = g.range(n, s));
    }
  }
  let { inputState: i } = t;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = O, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(O.from, O.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
oO.dragend = (t) => (t.inputState.draggedContent = null, !1);
function nc(t, e, O, i) {
  if (!O)
    return;
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: n } = t.inputState, s = i && n && Fm(t, e) ? { from: n.from, to: n.to } : null, a = { from: r, insert: O }, o = t.state.changes(s ? [s, a] : a);
  t.focus(), t.dispatch({
    changes: o,
    selection: { anchor: o.mapPos(r, -1), head: o.mapPos(r, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
oO.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let O = e.dataTransfer.files;
  if (O && O.length) {
    let i = Array(O.length), r = 0, n = () => {
      ++r == O.length && nc(t, e, i.filter((s) => s != null).join(t.state.lineBreak), !1);
    };
    for (let s = 0; s < O.length; s++) {
      let a = new FileReader();
      a.onerror = n, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (i[s] = a.result), n();
      }, a.readAsText(O[s]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return nc(t, e, i, !0), !0;
  }
  return !1;
};
oO.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let O = Bf ? null : e.clipboardData;
  return O ? (Ff(t, O.getData("text/plain") || O.getData("text/uri-list")), !0) : (Jm(t), !1);
};
function rP(t, e) {
  let O = t.dom.parentNode;
  if (!O)
    return;
  let i = O.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), t.focus();
  }, 50);
}
function nP(t) {
  let e = [], O = [], i = !1;
  for (let r of t.selection.ranges)
    r.empty || (e.push(t.sliceDoc(r.from, r.to)), O.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: n } of t.selection.ranges) {
      let s = t.doc.lineAt(n);
      s.number > r && (e.push(s.text), O.push({ from: s.from, to: Math.min(t.doc.length, s.to + 1) })), r = s.number;
    }
    i = !0;
  }
  return { text: e.join(t.lineBreak), ranges: O, linewise: i };
}
let $a = null;
oO.copy = oO.cut = (t, e) => {
  let { text: O, ranges: i, linewise: r } = nP(t.state);
  if (!O && !r)
    return !1;
  $a = r ? O : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let n = Bf ? null : e.clipboardData;
  return n ? (n.clearData(), n.setData("text/plain", O), !0) : (rP(t, O), !1);
};
const Kf = /* @__PURE__ */ UO.define();
function Jf(t, e) {
  let O = [];
  for (let i of t.facet(zf)) {
    let r = i(t, e);
    r && O.push(r);
  }
  return O ? t.update({ effects: O, annotations: Kf.of(!0) }) : null;
}
function e$(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let O = Jf(t.state, e);
      O ? t.dispatch(O) : t.update([]);
    }
  }, 10);
}
tO.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), e$(t);
};
tO.blur = (t) => {
  t.observer.clearSelectionRange(), e$(t);
};
tO.compositionstart = tO.compositionupdate = (t) => {
  t.observer.editContext || (t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0));
};
tO.compositionend = (t) => {
  t.observer.editContext || (t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, W.chrome && W.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50));
};
tO.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
oO.beforeinput = (t, e) => {
  var O, i;
  if (e.inputType == "insertReplacementText" && t.observer.editContext) {
    let n = (O = e.dataTransfer) === null || O === void 0 ? void 0 : O.getData("text/plain"), s = e.getTargetRanges();
    if (n && s.length) {
      let a = s[0], o = t.posAtDOM(a.startContainer, a.startOffset), c = t.posAtDOM(a.endContainer, a.endOffset);
      return bo(t, { from: o, to: c, insert: t.state.toText(n) }, null), !0;
    }
  }
  let r;
  if (W.chrome && W.android && (r = Mf.find((n) => n.inputType == e.inputType)) && (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let n = ((i = window.visualViewport) === null || i === void 0 ? void 0 : i.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > n + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return W.ios && e.inputType == "deleteContentForward" && t.observer.flushSoon(), W.safari && e.inputType == "insertText" && t.inputState.composing >= 0 && setTimeout(() => tO.compositionend(t, e), 20), !1;
};
const sc = /* @__PURE__ */ new Set();
function sP(t) {
  sc.has(t) || (sc.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const ac = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let jt = !1;
function oc() {
  jt = !1;
}
class aP {
  constructor(e) {
    this.lineWrapping = e, this.doc = N.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, O) {
    let i = this.doc.lineAt(O).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((O - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return ac.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let O = !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (O = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return O;
  }
  refresh(e, O, i, r, n, s) {
    let a = ac.indexOf(e) > -1, o = Math.round(O) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = O, this.charWidth = i, this.textHeight = r, this.lineLength = n, o) {
      this.heightSamples = {};
      for (let c = 0; c < s.length; c++) {
        let h = s[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return o;
  }
}
class oP {
  constructor(e, O) {
    this.from = e, this.heights = O, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class dO {
  /**
  @internal
  */
  constructor(e, O, i, r, n) {
    this.from = e, this.length = O, this.top = i, this.height = r, this._content = n;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Re.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof KO ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let O = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new dO(this.from, this.length + e.length, this.top, this.height + e.height, O);
  }
}
var ee = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(ee || (ee = {}));
const Ar = 1e-3;
class ve {
  constructor(e, O, i = 2) {
    this.length = e, this.height = O, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Ar && (jt = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, O, i) {
    return ve.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, O) {
    O.push(this);
  }
  decomposeRight(e, O) {
    O.push(this);
  }
  applyChanges(e, O, i, r) {
    let n = this, s = i.doc;
    for (let a = r.length - 1; a >= 0; a--) {
      let { fromA: o, toA: c, fromB: h, toB: Q } = r[a], f = n.lineAt(o, ee.ByPosNoHeight, i.setDoc(O), 0, 0), $ = f.to >= c ? f : n.lineAt(c, ee.ByPosNoHeight, i, 0, 0);
      for (Q += $.to - c, c = $.to; a > 0 && f.from <= r[a - 1].toA; )
        o = r[a - 1].fromA, h = r[a - 1].fromB, a--, o < f.from && (f = n.lineAt(o, ee.ByPosNoHeight, i, 0, 0));
      h += f.from - o, o = f.from;
      let u = xo.build(i.setDoc(s), e, h, Q);
      n = nn(n, n.replace(o, c, u));
    }
    return n.updateHeight(i, 0);
  }
  static empty() {
    return new Ee(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let O = 0, i = e.length, r = 0, n = 0;
    for (; ; )
      if (O == i)
        if (r > n * 2) {
          let a = e[O - 1];
          a.break ? e.splice(--O, 1, a.left, null, a.right) : e.splice(--O, 1, a.left, a.right), i += 1 + a.break, r -= a.size;
        } else if (n > r * 2) {
          let a = e[i];
          a.break ? e.splice(i, 1, a.left, null, a.right) : e.splice(i, 1, a.left, a.right), i += 2 + a.break, n -= a.size;
        } else
          break;
      else if (r < n) {
        let a = e[O++];
        a && (r += a.size);
      } else {
        let a = e[--i];
        a && (n += a.size);
      }
    let s = 0;
    return e[O - 1] == null ? (s = 1, O--) : e[O] == null && (s = 1, i++), new lP(ve.of(e.slice(0, O)), s, ve.of(e.slice(i)));
  }
}
function nn(t, e) {
  return t == e ? t : (t.constructor != e.constructor && (jt = !0), e);
}
ve.prototype.size = 1;
class O$ extends ve {
  constructor(e, O, i) {
    super(e, O), this.deco = i;
  }
  blockAt(e, O, i, r) {
    return new dO(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, O, i, r, n) {
    return this.blockAt(0, i, r, n);
  }
  forEachLine(e, O, i, r, n, s) {
    e <= n + this.length && O >= n && s(this.blockAt(0, i, r, n));
  }
  updateHeight(e, O = 0, i = !1, r) {
    return r && r.from <= O && r.more && this.setHeight(r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Ee extends O$ {
  constructor(e, O) {
    super(e, O, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, O, i, r) {
    return new dO(r, this.length, i, this.height, this.breaks);
  }
  replace(e, O, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof Ee || r instanceof Pe && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof Pe ? r = new Ee(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : ve.of(i);
  }
  updateHeight(e, O = 0, i = !1, r) {
    return r && r.from <= O && r.more ? this.setHeight(r.heights[r.index++]) : (i || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Pe extends ve {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, O) {
    let i = e.doc.lineAt(O).number, r = e.doc.lineAt(O + this.length).number, n = r - i + 1, s, a = 0;
    if (e.lineWrapping) {
      let o = Math.min(this.height, e.lineHeight * n);
      s = o / n, this.length > n + 1 && (a = (this.height - o) / (this.length - n - 1));
    } else
      s = this.height / n;
    return { firstLine: i, lastLine: r, perLine: s, perChar: a };
  }
  blockAt(e, O, i, r) {
    let { firstLine: n, lastLine: s, perLine: a, perChar: o } = this.heightMetrics(O, r);
    if (O.lineWrapping) {
      let c = r + (e < O.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length)), h = O.doc.lineAt(c), Q = a + h.length * o, f = Math.max(i, e - Q / 2);
      return new dO(h.from, h.length, f, Q, 0);
    } else {
      let c = Math.max(0, Math.min(s - n, Math.floor((e - i) / a))), { from: h, length: Q } = O.doc.line(n + c);
      return new dO(h, Q, i + a * c, a, 0);
    }
  }
  lineAt(e, O, i, r, n) {
    if (O == ee.ByHeight)
      return this.blockAt(e, i, r, n);
    if (O == ee.ByPosNoHeight) {
      let { from: $, to: u } = i.doc.lineAt(e);
      return new dO($, u - $, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: o } = this.heightMetrics(i, n), c = i.doc.lineAt(e), h = a + c.length * o, Q = c.number - s, f = r + a * Q + o * (c.from - n - Q);
    return new dO(c.from, c.length, Math.max(r, Math.min(f, r + this.height - h)), h, 0);
  }
  forEachLine(e, O, i, r, n, s) {
    e = Math.max(e, n), O = Math.min(O, n + this.length);
    let { firstLine: a, perLine: o, perChar: c } = this.heightMetrics(i, n);
    for (let h = e, Q = r; h <= O; ) {
      let f = i.doc.lineAt(h);
      if (h == e) {
        let u = f.number - a;
        Q += o * u + c * (e - n - u);
      }
      let $ = o + c * f.length;
      s(new dO(f.from, f.length, Q, $, 0)), Q += $, h = f.to + 1;
    }
  }
  replace(e, O, i) {
    let r = this.length - O;
    if (r > 0) {
      let n = i[i.length - 1];
      n instanceof Pe ? i[i.length - 1] = new Pe(n.length + r) : i.push(null, new Pe(r - 1));
    }
    if (e > 0) {
      let n = i[0];
      n instanceof Pe ? i[0] = new Pe(e + n.length) : i.unshift(new Pe(e - 1), null);
    }
    return ve.of(i);
  }
  decomposeLeft(e, O) {
    O.push(new Pe(e - 1), null);
  }
  decomposeRight(e, O) {
    O.push(null, new Pe(this.length - e - 1));
  }
  updateHeight(e, O = 0, i = !1, r) {
    let n = O + this.length;
    if (r && r.from <= O + this.length && r.more) {
      let s = [], a = Math.max(O, r.from), o = -1;
      for (r.from > O && s.push(new Pe(r.from - O - 1).updateHeight(e, O)); a <= n && r.more; ) {
        let h = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let Q = r.heights[r.index++];
        o == -1 ? o = Q : Math.abs(Q - o) >= Ar && (o = -2);
        let f = new Ee(h, Q);
        f.outdated = !1, s.push(f), a += h + 1;
      }
      a <= n && s.push(null, new Pe(n - a).updateHeight(e, a));
      let c = ve.of(s);
      return (o < 0 || Math.abs(c.height - this.height) >= Ar || Math.abs(o - this.heightMetrics(e, O).perLine) >= Ar) && (jt = !0), nn(this, c);
    } else (i || this.outdated) && (this.setHeight(e.heightForGap(O, O + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class lP extends ve {
  constructor(e, O, i) {
    super(e.length + O + i.length, e.height + i.height, O | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, O, i, r) {
    let n = i + this.left.height;
    return e < n ? this.left.blockAt(e, O, i, r) : this.right.blockAt(e, O, n, r + this.left.length + this.break);
  }
  lineAt(e, O, i, r, n) {
    let s = r + this.left.height, a = n + this.left.length + this.break, o = O == ee.ByHeight ? e < s : e < a, c = o ? this.left.lineAt(e, O, i, r, n) : this.right.lineAt(e, O, i, s, a);
    if (this.break || (o ? c.to < a : c.from > a))
      return c;
    let h = O == ee.ByPosNoHeight ? ee.ByPosNoHeight : ee.ByPos;
    return o ? c.join(this.right.lineAt(a, h, i, s, a)) : this.left.lineAt(a, h, i, r, n).join(c);
  }
  forEachLine(e, O, i, r, n, s) {
    let a = r + this.left.height, o = n + this.left.length + this.break;
    if (this.break)
      e < o && this.left.forEachLine(e, O, i, r, n, s), O >= o && this.right.forEachLine(e, O, i, a, o, s);
    else {
      let c = this.lineAt(o, ee.ByPos, i, r, n);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, r, n, s), c.to >= e && c.from <= O && s(c), O > c.to && this.right.forEachLine(c.to + 1, O, i, a, o, s);
    }
  }
  replace(e, O, i) {
    let r = this.left.length + this.break;
    if (O < r)
      return this.balanced(this.left.replace(e, O, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, O - r, i));
    let n = [];
    e > 0 && this.decomposeLeft(e, n);
    let s = n.length;
    for (let a of i)
      n.push(a);
    if (e > 0 && lc(n, s - 1), O < this.length) {
      let a = n.length;
      this.decomposeRight(O, n), lc(n, a);
    }
    return ve.of(n);
  }
  decomposeLeft(e, O) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, O);
    O.push(this.left), this.break && (i++, e >= i && O.push(null)), e > i && this.right.decomposeLeft(e - i, O);
  }
  decomposeRight(e, O) {
    let i = this.left.length, r = i + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, O);
    e < i && this.left.decomposeRight(e, O), this.break && e < r && O.push(null), O.push(this.right);
  }
  balanced(e, O) {
    return e.size > 2 * O.size || O.size > 2 * e.size ? ve.of(this.break ? [e, null, O] : [e, O]) : (this.left = nn(this.left, e), this.right = nn(this.right, O), this.setHeight(e.height + O.height), this.outdated = e.outdated || O.outdated, this.size = e.size + O.size, this.length = e.length + this.break + O.length, this);
  }
  updateHeight(e, O = 0, i = !1, r) {
    let { left: n, right: s } = this, a = O + n.length + this.break, o = null;
    return r && r.from <= O + n.length && r.more ? o = n = n.updateHeight(e, O, i, r) : n.updateHeight(e, O, i), r && r.from <= a + s.length && r.more ? o = s = s.updateHeight(e, a, i, r) : s.updateHeight(e, a, i), o ? this.balanced(n, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function lc(t, e) {
  let O, i;
  t[e] == null && (O = t[e - 1]) instanceof Pe && (i = t[e + 1]) instanceof Pe && t.splice(e - 1, 3, new Pe(O.length + 1 + i.length));
}
const cP = 5;
class xo {
  constructor(e, O) {
    this.pos = e, this.oracle = O, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, O) {
    if (this.lineStart > -1) {
      let i = Math.min(O, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof Ee ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Ee(i - this.pos, -1)), this.writtenTo = i, O > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = O;
  }
  point(e, O, i) {
    if (e < O || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, n = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let s = O - e;
      i.block ? this.addBlock(new O$(s, r, i)) : (s || n || r >= cP) && this.addLineDeco(r, n, s);
    } else O > e && this.span(e, O);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: O } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = O, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Ee(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, O) {
    let i = new Pe(O - e);
    return this.oracle.doc.lineAt(e).to == O && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Ee)
      return e;
    let O = new Ee(0, -1);
    return this.nodes.push(O), O;
  }
  addBlock(e) {
    this.enterLine();
    let O = e.deco;
    O && O.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, O && O.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, O, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += O, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let O = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(O instanceof Ee) && !this.isCovered ? this.nodes.push(new Ee(0, -1)) : (this.writtenTo < this.pos || O == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let r of this.nodes)
      r instanceof Ee && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, O, i, r) {
    let n = new xo(i, e);
    return A.spans(O, i, r, n, 0), n.finish(i);
  }
}
function hP(t, e, O) {
  let i = new QP();
  return A.compare(t, e, O, i, 0), i.changes;
}
class QP {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, O, i, r) {
    (e < O || i && i.heightRelevant || r && r.heightRelevant) && aa(e, O, this.changes, 5);
  }
}
function fP(t, e) {
  let O = t.getBoundingClientRect(), i = t.ownerDocument, r = i.defaultView || window, n = Math.max(0, O.left), s = Math.min(r.innerWidth, O.right), a = Math.max(0, O.top), o = Math.min(r.innerHeight, O.bottom);
  for (let c = t.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let h = c, Q = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && Q.overflow != "visible") {
        let f = h.getBoundingClientRect();
        n = Math.max(n, f.left), s = Math.min(s, f.right), a = Math.max(a, f.top), o = c == t.parentNode ? f.bottom : Math.min(o, f.bottom);
      }
      c = Q.position == "absolute" || Q.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: n - O.left,
    right: Math.max(n, s) - O.left,
    top: a - (O.top + e),
    bottom: Math.max(a, o) - (O.top + e)
  };
}
function $P(t, e) {
  let O = t.getBoundingClientRect();
  return {
    left: 0,
    right: O.right - O.left,
    top: e,
    bottom: O.bottom - (O.top + e)
  };
}
class Kn {
  constructor(e, O, i) {
    this.from = e, this.to = O, this.size = i;
  }
  static same(e, O) {
    if (e.length != O.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i], n = O[i];
      if (r.from != n.from || r.to != n.to || r.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(e, O) {
    return Z.replace({
      widget: new uP(this.size * (O ? e.scaleY : e.scaleX), O)
    }).range(this.from, this.to);
  }
}
class uP extends VO {
  constructor(e, O) {
    super(), this.size = e, this.vertical = O;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class cc {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = hc, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Oe.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let O = e.facet(Xo).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new aP(O), this.stateDeco = e.facet(Zi).filter((i) => typeof i != "function"), this.heightMap = ve.empty().applyChanges(this.stateDeco, N.empty, this.heightOracle.setDoc(e.doc), [new OO(0, 0, 0, e.doc.length)]);
    for (let i = 0; i < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); i++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Z.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: O } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? O.head : O.anchor;
      if (!e.some(({ from: n, to: s }) => r >= n && r <= s)) {
        let { from: n, to: s } = this.lineBlockAt(r);
        e.push(new mr(n, s));
      }
    }
    return this.viewports = e.sort((i, r) => i.from - r.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? hc : new To(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(ci(e, this.scaler));
    });
  }
  update(e, O = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Zi).filter((h) => typeof h != "function");
    let r = e.changedRanges, n = OO.extendWithRanges(r, hP(i, this.stateDeco, e ? e.changes : ue.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    oc(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), n), (this.heightMap.height != s || jt) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let o = n.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (O && (O.range.head < o.from || O.range.head > o.to) || !this.viewportIsAppropriate(o)) && (o = this.getViewport(0, O));
    let c = o.from != this.viewport.from || o.to != this.viewport.to;
    this.viewport = o, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), O && (this.scrollTarget = O), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Uf) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let O = e.contentDOM, i = window.getComputedStyle(O), r = this.heightOracle, n = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Oe.RTL : Oe.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(n), a = O.getBoundingClientRect(), o = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (a.width && a.height) {
      let { scaleX: y, scaleY: S } = lf(O, a);
      (y > 5e-3 && Math.abs(this.scaleX - y) > 5e-3 || S > 5e-3 && Math.abs(this.scaleY - S) > 5e-3) && (this.scaleX = y, this.scaleY = S, c |= 8, s = o = !0);
    }
    let Q = (parseInt(i.paddingTop) || 0) * this.scaleY, f = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != Q || this.paddingBottom != f) && (this.paddingTop = Q, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (o = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let $ = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != $ && (this.scrollAnchorHeight = -1, this.scrollTop = $), this.scrolledToBottom = Qf(e.scrollDOM);
    let u = (this.printing ? $P : fP)(O, this.paddingTop), d = u.top - this.pixelViewport.top, p = u.bottom - this.pixelViewport.bottom;
    this.pixelViewport = u;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (o = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let P = a.width;
    if ((this.contentDOMWidth != P || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), o) {
      let y = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(y) && (s = !0), s || r.lineWrapping && Math.abs(P - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: S, charWidth: w, textHeight: T } = e.docView.measureTextSize();
        s = S > 0 && r.refresh(n, S, w, T, P / w, y), s && (e.docView.minWidth = 0, c |= 8);
      }
      d > 0 && p > 0 ? h = Math.max(d, p) : d < 0 && p < 0 && (h = Math.min(d, p)), oc();
      for (let S of this.viewports) {
        let w = S.from == this.viewport.from ? y : e.docView.measureVisibleLineHeights(S);
        this.heightMap = (s ? ve.empty().applyChanges(this.stateDeco, N.empty, this.heightOracle, [new OO(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, s, new oP(S.from, w));
      }
      jt && (c |= 2);
    }
    let X = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return X && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(h, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || X) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, O) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, n = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, o = new mr(r.lineAt(s - i * 1e3, ee.ByHeight, n, 0, 0).from, r.lineAt(a + (1 - i) * 1e3, ee.ByHeight, n, 0, 0).to);
    if (O) {
      let { head: c } = O.range;
      if (c < o.from || c > o.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), Q = r.lineAt(c, ee.ByPos, n, 0, 0), f;
        O.y == "center" ? f = (Q.top + Q.bottom) / 2 - h / 2 : O.y == "start" || O.y == "nearest" && c < o.from ? f = Q.top : f = Q.bottom - h, o = new mr(r.lineAt(f - 1e3 / 2, ee.ByHeight, n, 0, 0).from, r.lineAt(f + h + 1e3 / 2, ee.ByHeight, n, 0, 0).to);
      }
    }
    return o;
  }
  mapViewport(e, O) {
    let i = O.mapPos(e.from, -1), r = O.mapPos(e.to, 1);
    return new mr(this.heightMap.lineAt(i, ee.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, ee.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: O }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, ee.ByPos, this.heightOracle, 0, 0), { bottom: n } = this.heightMap.lineAt(O, ee.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || r <= s - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (O == this.state.doc.length || n >= a + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && r > s - 2 * 1e3 && n < a + 2 * 1e3;
  }
  mapLineGaps(e, O) {
    if (!e.length || O.empty)
      return e;
    let i = [];
    for (let r of e)
      O.touchesRange(r.from, r.to) || i.push(new Kn(O.mapPos(r.from), O.mapPos(r.to), r.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, O) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, n = r >> 1, s = r << 1;
    if (this.defaultTextDirection != Oe.LTR && !i)
      return [];
    let a = [], o = (h, Q, f, $) => {
      if (Q - h < n)
        return;
      let u = this.state.selection.main, d = [u.from];
      u.empty || d.push(u.to);
      for (let m of d)
        if (m > h && m < Q) {
          o(h, m - 10, f, $), o(m + 10, Q, f, $);
          return;
        }
      let p = pP(e, (m) => m.from >= f.from && m.to <= f.to && Math.abs(m.from - h) < n && Math.abs(m.to - Q) < n && !d.some((P) => m.from < P && m.to > P));
      if (!p) {
        if (Q < f.to && O && i && O.visibleRanges.some((m) => m.from <= Q && m.to >= Q)) {
          let m = O.moveToLineBoundary(g.cursor(Q), !1, !0).head;
          m > h && (Q = m);
        }
        p = new Kn(h, Q, this.gapSize(f, h, Q, $));
      }
      a.push(p);
    }, c = (h) => {
      if (h.length < s || h.type != Re.Text)
        return;
      let Q = dP(h.from, h.to, this.stateDeco);
      if (Q.total < s)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, $, u;
      if (i) {
        let d = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, p, m;
        if (f != null) {
          let P = gr(Q, f), X = ((this.visibleBottom - this.visibleTop) / 2 + d) / h.height;
          p = P - X, m = P + X;
        } else
          p = (this.visibleTop - h.top - d) / h.height, m = (this.visibleBottom - h.top + d) / h.height;
        $ = Pr(Q, p), u = Pr(Q, m);
      } else {
        let d = Q.total * this.heightOracle.charWidth, p = r * this.heightOracle.charWidth, m, P;
        if (f != null) {
          let X = gr(Q, f), y = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + p) / d;
          m = X - y, P = X + y;
        } else
          m = (this.pixelViewport.left - p) / d, P = (this.pixelViewport.right + p) / d;
        $ = Pr(Q, m), u = Pr(Q, P);
      }
      $ > h.from && o(h.from, $, h, Q), u < h.to && o(u, h.to, h, Q);
    };
    for (let h of this.viewportLines)
      Array.isArray(h.type) ? h.type.forEach(c) : c(h);
    return a;
  }
  gapSize(e, O, i, r) {
    let n = gr(r, i) - gr(r, O);
    return this.heightOracle.lineWrapping ? e.height * n : r.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(e) {
    Kn.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Z.set(e.map((O) => O.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let O = [];
    A.spans(e, this.viewport.from, this.viewport.to, {
      span(r, n) {
        O.push({ from: r, to: n });
      },
      point() {
      }
    }, 20);
    let i = O.length != this.visibleRanges.length || this.visibleRanges.some((r, n) => r.from != O[n].from || r.to != O[n].to);
    return this.visibleRanges = O, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((O) => O.from <= e && O.to >= e) || ci(this.heightMap.lineAt(e, ee.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((O) => O.top <= e && O.bottom >= e) || ci(this.heightMap.lineAt(this.scaler.fromDOM(e), ee.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let O = this.lineBlockAtHeight(e + 8);
    return O.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? O : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ci(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class mr {
  constructor(e, O) {
    this.from = e, this.to = O;
  }
}
function dP(t, e, O) {
  let i = [], r = t, n = 0;
  return A.spans(O, t, e, {
    span() {
    },
    point(s, a) {
      s > r && (i.push({ from: r, to: s }), n += s - r), r = a;
    }
  }, 20), r < e && (i.push({ from: r, to: e }), n += e - r), { total: n, ranges: i };
}
function Pr({ total: t, ranges: e }, O) {
  if (O <= 0)
    return e[0].from;
  if (O >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(t * O);
  for (let r = 0; ; r++) {
    let { from: n, to: s } = e[r], a = s - n;
    if (i <= a)
      return n + i;
    i -= a;
  }
}
function gr(t, e) {
  let O = 0;
  for (let { from: i, to: r } of t.ranges) {
    if (e <= r) {
      O += e - i;
      break;
    }
    O += r - i;
  }
  return O / t.total;
}
function pP(t, e) {
  for (let O of t)
    if (e(O))
      return O;
}
const hc = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1,
  eq(t) {
    return t == this;
  }
};
class To {
  constructor(e, O, i) {
    let r = 0, n = 0, s = 0;
    this.viewports = i.map(({ from: a, to: o }) => {
      let c = O.lineAt(a, ee.ByPos, e, 0, 0).top, h = O.lineAt(o, ee.ByPos, e, 0, 0).bottom;
      return r += h - c, { from: a, to: o, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (O.height - r);
    for (let a of this.viewports)
      a.domTop = s + (a.top - n) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), n = a.bottom;
  }
  toDOM(e) {
    for (let O = 0, i = 0, r = 0; ; O++) {
      let n = O < this.viewports.length ? this.viewports[O] : null;
      if (!n || e < n.top)
        return r + (e - i) * this.scale;
      if (e <= n.bottom)
        return n.domTop + (e - n.top);
      i = n.bottom, r = n.domBottom;
    }
  }
  fromDOM(e) {
    for (let O = 0, i = 0, r = 0; ; O++) {
      let n = O < this.viewports.length ? this.viewports[O] : null;
      if (!n || e < n.domTop)
        return i + (e - r) / this.scale;
      if (e <= n.domBottom)
        return n.top + (e - n.domTop);
      i = n.bottom, r = n.domBottom;
    }
  }
  eq(e) {
    return e instanceof To ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((O, i) => O.from == e.viewports[i].from && O.to == e.viewports[i].to) : !1;
  }
}
function ci(t, e) {
  if (e.scale == 1)
    return t;
  let O = e.toDOM(t.top), i = e.toDOM(t.bottom);
  return new dO(t.from, t.length, O, i - O, Array.isArray(t._content) ? t._content.map((r) => ci(r, e)) : t._content);
}
const Sr = /* @__PURE__ */ R.define({ combine: (t) => t.join(" ") }), ua = /* @__PURE__ */ R.define({ combine: (t) => t.indexOf(!0) > -1 }), da = /* @__PURE__ */ FO.newName(), t$ = /* @__PURE__ */ FO.newName(), i$ = /* @__PURE__ */ FO.newName(), r$ = { "&light": "." + t$, "&dark": "." + i$ };
function pa(t, e, O) {
  return new FO(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return t;
        if (!O || !O[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return O[r];
      }) : t + " " + i;
    }
  });
}
const mP = /* @__PURE__ */ pa("." + da, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, r$), PP = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Jn = W.ie && W.ie_version <= 11;
class gP {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new rm(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((O) => {
      for (let i of O)
        this.queue.push(i);
      (W.ie && W.ie_version <= 11 || W.ios && e.composing) && O.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(W.chrome && W.chrome_version < 126) && (this.editContext = new XP(e), e.state.facet(CO) && (e.contentDOM.editContext = this.editContext.editContext)), Jn && (this.onCharData = (O) => {
      this.queue.push({
        target: O.target,
        type: "characterData",
        oldValue: O.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var O;
      ((O = this.view.docView) === null || O === void 0 ? void 0 : O.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((O) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), O.length > 0 && O[O.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((O) => {
      O.length > 0 && O[O.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((O, i) => O != e[i]))) {
      this.gapIntersection.disconnect();
      for (let O of e)
        this.gapIntersection.observe(O);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let O = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(CO) ? i.root.activeElement != this.dom : !Cr(i.dom, r))
      return;
    let n = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (n && n.ignoreEvent(e)) {
      O || (this.selectionChanged = !1);
      return;
    }
    (W.ie && W.ie_version <= 11 || W.android && W.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    r.focusNode && ui(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, O = Ri(e.root);
    if (!O)
      return !1;
    let i = W.safari && e.root.nodeType == 11 && em(this.dom.ownerDocument) == this.dom && SP(this.view, O) || O;
    if (!i || this.selectionRange.eq(i))
      return !1;
    let r = Cr(this.dom, i);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && sm(this.dom, i) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(i), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, O) {
    this.selectionRange.set(e.node, e.offset, O.node, O.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, O = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !O && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : O || (O = this.scrollTargets.slice(0, e)), O && O.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !O && (O = this.scrollTargets.slice(0, e)), O) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = O)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, PP), Jn && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Jn && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, O) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let n = this.delayedAndroidKey;
        n && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = n.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && n.force && vt(this.dom, n.key, n.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: O,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let O = -1, i = -1, r = !1;
    for (let n of e) {
      let s = this.readMutation(n);
      s && (s.typeOver && (r = !0), O == -1 ? { from: O, to: i } = s : (O = Math.min(s.from, O), i = Math.max(s.to, i)));
    }
    return { from: O, to: i, typeOver: r };
  }
  readChange() {
    let { from: e, to: O, typeOver: i } = this.processRecords(), r = this.selectionChanged && Cr(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let n = new jm(this.view, e, O, i);
    return this.view.docView.domChanged = { newSel: n.newSel ? n.newSel.main : null }, n;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let O = this.readChange();
    if (!O)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = If(this.view, O);
    return this.view.state == i && (O.domChanged || O.newSel && !O.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), r;
  }
  readMutation(e) {
    let O = this.view.docView.nearest(e.target);
    if (!O || O.ignoreMutation(e))
      return null;
    if (O.markDirty(e.type == "attributes"), e.type == "attributes" && (O.flags |= 4), e.type == "childList") {
      let i = Qc(O, e.previousSibling || e.target.previousSibling, -1), r = Qc(O, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? O.posAfter(i) : O.posAtStart,
        to: r ? O.posBefore(r) : O.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: O.posAtStart, to: O.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(CO) != e.state.facet(CO) && (e.view.contentDOM.editContext = e.state.facet(CO) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, O, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (O = this.gapIntersection) === null || O === void 0 || O.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
}
function Qc(t, e, O) {
  for (; e; ) {
    let i = K.get(e);
    if (i && i.parent == t)
      return i;
    let r = e.parentNode;
    e = r != t.dom ? r : O > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function fc(t, e) {
  let O = e.startContainer, i = e.startOffset, r = e.endContainer, n = e.endOffset, s = t.docView.domAtPos(t.state.selection.main.anchor);
  return ui(s.node, s.offset, r, n) && ([O, i, r, n] = [r, n, O, i]), { anchorNode: O, anchorOffset: i, focusNode: r, focusOffset: n };
}
function SP(t, e) {
  if (e.getComposedRanges) {
    let r = e.getComposedRanges(t.root)[0];
    if (r)
      return fc(t, r);
  }
  let O = null;
  function i(r) {
    r.preventDefault(), r.stopImmediatePropagation(), O = r.getTargetRanges()[0];
  }
  return t.contentDOM.addEventListener("beforeinput", i, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", i, !0), O ? fc(t, O) : null;
}
class XP {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(e.state);
    let O = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (i) => {
      let { anchor: r } = e.state.selection.main, n = {
        from: this.toEditorPos(i.updateRangeStart),
        to: this.toEditorPos(i.updateRangeEnd),
        insert: N.of(i.text.split(`
`))
      };
      n.from == this.from && r < this.from ? n.from = r : n.to == this.to && r > this.to && (n.to = r), !(n.from == n.to && !n.insert.length) && (this.pendingContextChange = n, e.state.readOnly || bo(e, n, g.single(this.toEditorPos(i.selectionStart), this.toEditorPos(i.selectionEnd))), this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)));
    }, this.handlers.characterboundsupdate = (i) => {
      let r = [], n = null;
      for (let s = this.toEditorPos(i.rangeStart), a = this.toEditorPos(i.rangeEnd); s < a; s++) {
        let o = e.coordsForChar(s);
        n = o && new DOMRect(o.left, o.top, o.right - o.left, o.bottom - o.top) || n || new DOMRect(), r.push(n);
      }
      O.updateCharacterBounds(i.rangeStart, r);
    }, this.handlers.textformatupdate = (i) => {
      let r = [];
      for (let n of i.getTextFormats()) {
        let s = n.underlineStyle, a = n.underlineThickness;
        if (s != "None" && a != "None") {
          let o = `text-decoration: underline ${s == "Dashed" ? "dashed " : s == "Squiggle" ? "wavy " : ""}${a == "Thin" ? 1 : 2}px`;
          r.push(Z.mark({ attributes: { style: o } }).range(this.toEditorPos(n.rangeStart), this.toEditorPos(n.rangeEnd)));
        }
      }
      e.dispatch({ effects: _f.of(Z.set(r)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      e.inputState.composing = -1, e.inputState.compositionFirstChange = null;
    };
    for (let i in this.handlers)
      O.addEventListener(i, this.handlers[i]);
    this.measureReq = { read: (i) => {
      this.editContext.updateControlBounds(i.contentDOM.getBoundingClientRect());
      let r = Ri(i.root);
      r && r.rangeCount && this.editContext.updateSelectionBounds(r.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let O = 0, i = !1, r = this.pendingContextChange;
    return e.changes.iterChanges((n, s, a, o, c) => {
      if (i)
        return;
      let h = c.length - (s - n);
      if (r && s >= r.to)
        if (r.from == n && r.to == s && r.insert.eq(c)) {
          r = this.pendingContextChange = null, O += h, this.to += h;
          return;
        } else
          r = null, this.revertPending(e.state);
      if (n += O, s += O, s <= this.from)
        this.from += h, this.to += h;
      else if (n < this.to) {
        if (n < this.from || s > this.to || this.to - this.from + c.length > 3e4) {
          i = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(n), this.toContextPos(s), c.toString()), this.to += h;
      }
      O += h;
    }), r && !i && this.revertPending(e.state), !i;
  }
  update(e) {
    let O = this.pendingContextChange;
    !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.resetRange(e.state), this.editContext.updateText(0, this.editContext.text.length, e.state.doc.sliceString(this.from, this.to)), this.setSelection(e.state)) : (e.docChanged || e.selectionSet || O) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: O } = e.selection.main;
    this.from = Math.max(
      0,
      O - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      O + 1e4
      /* CxVp.Margin */
    );
  }
  revertPending(e) {
    let O = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(O.from), this.toContextPos(O.from + O.insert.length), e.doc.sliceString(O.from, O.to));
  }
  setSelection(e) {
    let { main: O } = e.selection, i = this.toContextPos(Math.max(this.from, Math.min(this.to, O.anchor))), r = this.toContextPos(O.head);
    (this.editContext.selectionStart != i || this.editContext.selectionEnd != r) && this.editContext.updateSelection(i, r);
  }
  rangeIsValid(e) {
    let { head: O } = e.selection.main;
    return !(this.from > 0 && O - this.from < 500 || this.to < e.doc.length && this.to - O < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e) {
    return e + this.from;
  }
  toContextPos(e) {
    return e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
class k {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: O } = e;
    this.dispatchTransactions = e.dispatchTransactions || O && ((i) => i.forEach((r) => O(r, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || nm(e.parent) || document, this.viewState = new cc(e.state || E.create(e)), e.scrollTo && e.scrollTo.is(ur) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(ai).map((i) => new Bn(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new gP(this), this.inputState = new Dm(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Dl(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let O = e.length == 1 && e[0] instanceof he ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(O, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let O = !1, i = !1, r, n = this.state;
    for (let f of e) {
      if (f.startState != n)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = n;
      return;
    }
    let s = this.hasFocus, a = 0, o = null;
    e.some((f) => f.annotation(Kf)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, o = Jf(n, s), o || (a = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(n.doc) || !this.state.selection.eq(n.selection)) && (h = null)) : this.observer.clear(), n.facet(E.phrases) != this.state.facet(E.phrases))
      return this.setState(n);
    r = rn.create(this, n, e), r.flags |= a;
    let Q = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (Q && (Q = Q.map(f.changes)), f.scrollIntoView) {
          let { main: $ } = f.state.selection;
          Q = new Zt($.empty ? $ : g.cursor($.head, $.head > $.anchor ? -1 : 1));
        }
        for (let $ of f.effects)
          $.is(ur) && (Q = $.value.clip(this.state));
      }
      this.viewState.update(r, Q), this.bidiCache = sn.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), O = this.docView.update(r), this.state.facet(oi) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(O, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(Sr) != r.state.facet(Sr) && (this.viewState.mustMeasureContent = !0), (O || i || Q || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), O && this.docViewUpdate(), !r.empty)
      for (let f of this.state.facet(ha))
        try {
          f(r);
        } catch ($) {
          Ue(this.state, $, "update listener");
        }
    (o || h) && Promise.resolve().then(() => {
      o && this.state == o.startState && this.dispatch(o), h && !If(this, h) && c.force && vt(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let O = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new cc(e), this.plugins = e.facet(ai).map((i) => new Bn(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new Dl(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    O && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let O = e.startState.facet(ai), i = e.state.facet(ai);
    if (O != i) {
      let r = [];
      for (let n of i) {
        let s = O.indexOf(n);
        if (s < 0)
          r.push(new Bn(n));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, r.push(a);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != e && n.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    O != i && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let O = e.value;
      if (O && O.docViewUpdate)
        try {
          O.docViewUpdate(this);
        } catch (i) {
          Ue(this.state, i, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let O = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: n, scrollAnchorHeight: s } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (Qf(i))
            n = -1, s = this.viewState.heightMap.height;
          else {
            let $ = this.viewState.scrollAnchorAt(r);
            n = $.from, s = $.top;
          }
        this.updateState = 1;
        let o = this.viewState.measure(this);
        if (!o && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        o & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map(($) => {
          try {
            return $.read(this);
          } catch (u) {
            return Ue(this.state, u), $c;
          }
        }), Q = rn.create(this, this.state, []), f = !1;
        Q.flags |= o, O ? O.flags |= o : O = Q, this.updateState = 2, Q.empty || (this.updatePlugins(Q), this.inputState.update(Q), this.updateAttrs(), f = this.docView.update(Q), f && this.docViewUpdate());
        for (let $ = 0; $ < c.length; $++)
          if (h[$] != $c)
            try {
              let u = c[$];
              u.write && u.write(h[$], this);
            } catch (u) {
              Ue(this.state, u);
            }
        if (f && this.docView.updateSelection(!0), !Q.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let u = (n < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n).top) - s;
              if (u > 1 || u < -1) {
                r = r + u, i.scrollTop = r / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (O && !O.empty)
      for (let a of this.state.facet(ha))
        a(O);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return da + " " + (this.state.facet(ua) ? i$ : t$) + " " + this.state.facet(Sr);
  }
  updateAttrs() {
    let e = uc(this, jf, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), O = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(CO) ? "true" : "false",
      class: "cm-content",
      style: `${W.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (O["aria-readonly"] = "true"), uc(this, Xo, O);
    let i = this.observer.ignore(() => {
      let r = sa(this.contentDOM, this.contentAttrs, O), n = sa(this.dom, this.editorAttrs, e);
      return r || n;
    });
    return this.editorAttrs = e, this.contentAttrs = O, i;
  }
  showAnnouncements(e) {
    let O = !0;
    for (let i of e)
      for (let r of i.effects)
        if (r.is(k.announce)) {
          O && (this.announceDOM.textContent = ""), O = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(oi);
    let e = this.state.facet(k.cspNonce);
    FO.mount(this.root, this.styleModules.concat(mP).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let O = 0; O < this.measureRequests.length; O++)
          if (this.measureRequests[O].key === e.key) {
            this.measureRequests[O] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let O = this.pluginMap.get(e);
    return (O === void 0 || O && O.spec != e) && this.pluginMap.set(e, O = this.plugins.find((i) => i.spec == e) || null), O && O.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, O, i) {
    return Hn(this, e, Fl(this, e, O, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, O) {
    return Hn(this, e, Fl(this, e, O, (i) => qm(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, O) {
    let i = this.bidiSpans(e), r = this.textDirectionAt(e.from), n = i[O ? i.length - 1 : 0];
    return g.cursor(n.side(O, r) + e.from, n.forward(!O, r) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, O, i = !0) {
    return zm(this, e, O, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, O, i) {
    return Hn(this, e, Um(this, e, O, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, O = 0) {
    return this.docView.posFromDOM(e, O);
  }
  posAtCoords(e, O = !0) {
    return this.readMeasured(), Nf(this, e, O);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, O = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, O);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(e), n = this.bidiSpans(r), s = n[NO.find(n, e - r.from, -1, O)];
    return Po(i, s.dir == Oe.LTR == O > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(qf) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > yP)
      return wf(e.length);
    let O = this.textDirectionAt(e.from), i;
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == O && (n.fresh || Tf(n.isolates, i = Al(this, e))))
        return n.order;
    i || (i = Al(this, e));
    let r = mm(e.text, O, i);
    return this.bidiCache.push(new sn(e.from, e.to, O, i, !0, r)), r;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || W.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      cf(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, O = {}) {
    return ur.of(new Zt(typeof e == "number" ? g.cursor(e) : e, O.y, O.x, O.yMargin, O.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: O } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return ur.of(new Zt(g.cursor(i.from), "start", "start", i.top - e, O, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Qe.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Qe.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, O) {
    let i = FO.newName(), r = [Sr.of(i), oi.of(pa(`.${i}`, e))];
    return O && O.dark && r.push(ua.of(!0)), r;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return qO.lowest(oi.of(pa("." + da, e, r$)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var O;
    let i = e.querySelector(".cm-content"), r = i && K.get(i) || K.get(e);
    return ((O = r == null ? void 0 : r.rootView) === null || O === void 0 ? void 0 : O.view) || null;
  }
}
k.styleModule = oi;
k.inputHandler = Yf;
k.scrollHandler = Vf;
k.focusChangeEffect = zf;
k.perLineTextDirection = qf;
k.exceptionSink = Zf;
k.updateListener = ha;
k.editable = CO;
k.mouseSelectionStyle = vf;
k.dragMovesSelection = Rf;
k.clickAddsSelectionRange = Wf;
k.decorations = Zi;
k.outerDecorations = Gf;
k.atomicRanges = yo;
k.bidiIsolatedRanges = Cf;
k.scrollMargins = Ef;
k.darkTheme = ua;
k.cspNonce = /* @__PURE__ */ R.define({ combine: (t) => t.length ? t[0] : "" });
k.contentAttributes = Xo;
k.editorAttributes = jf;
k.lineWrapping = /* @__PURE__ */ k.contentAttributes.of({ class: "cm-lineWrapping" });
k.announce = /* @__PURE__ */ z.define();
const yP = 4096, $c = {};
class sn {
  constructor(e, O, i, r, n, s) {
    this.from = e, this.to = O, this.dir = i, this.isolates = r, this.fresh = n, this.order = s;
  }
  static update(e, O) {
    if (O.empty && !e.some((n) => n.fresh))
      return e;
    let i = [], r = e.length ? e[e.length - 1].dir : Oe.LTR;
    for (let n = Math.max(0, e.length - 10); n < e.length; n++) {
      let s = e[n];
      s.dir == r && !O.touchesRange(s.from, s.to) && i.push(new sn(O.mapPos(s.from, 1), O.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return i;
  }
}
function uc(t, e, O) {
  for (let i = t.state.facet(e), r = i.length - 1; r >= 0; r--) {
    let n = i[r], s = typeof n == "function" ? n(t) : n;
    s && na(s, O);
  }
  return O;
}
const bP = W.mac ? "mac" : W.windows ? "win" : W.linux ? "linux" : "key";
function xP(t, e) {
  const O = t.split(/-(?!$)/);
  let i = O[O.length - 1];
  i == "Space" && (i = " ");
  let r, n, s, a;
  for (let o = 0; o < O.length - 1; ++o) {
    const c = O[o];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      n = !0;
    else if (/^s(hift)?$/i.test(c))
      s = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (i = "Alt-" + i), n && (i = "Ctrl-" + i), a && (i = "Meta-" + i), s && (i = "Shift-" + i), i;
}
function Xr(t, e, O) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), O !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const TP = /* @__PURE__ */ qO.default(/* @__PURE__ */ k.domEventHandlers({
  keydown(t, e) {
    return s$(n$(e.state), t, e, "editor");
  }
})), Or = /* @__PURE__ */ R.define({ enables: TP }), dc = /* @__PURE__ */ new WeakMap();
function n$(t) {
  let e = t.facet(Or), O = dc.get(e);
  return O || dc.set(e, O = WP(e.reduce((i, r) => i.concat(r), []))), O;
}
function wP(t, e, O) {
  return s$(n$(t.state), e, t, O);
}
let EO = null;
const kP = 4e3;
function WP(t, e = bP) {
  let O = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = (s, a) => {
    let o = i[s];
    if (o == null)
      i[s] = a;
    else if (o != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, n = (s, a, o, c, h) => {
    var Q, f;
    let $ = O[s] || (O[s] = /* @__PURE__ */ Object.create(null)), u = a.split(/ (?!$)/).map((m) => xP(m, e));
    for (let m = 1; m < u.length; m++) {
      let P = u.slice(0, m).join(" ");
      r(P, !0), $[P] || ($[P] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(X) => {
          let y = EO = { view: X, prefix: P, scope: s };
          return setTimeout(() => {
            EO == y && (EO = null);
          }, kP), !0;
        }]
      });
    }
    let d = u.join(" ");
    r(d, !1);
    let p = $[d] || ($[d] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (Q = $._any) === null || Q === void 0 ? void 0 : Q.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    o && p.run.push(o), c && (p.preventDefault = !0), h && (p.stopPropagation = !0);
  };
  for (let s of t) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let c of a) {
        let h = O[c] || (O[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: Q } = s;
        for (let f in h)
          h[f].run.push(($) => Q($, ma));
      }
    let o = s[e] || s.key;
    if (o)
      for (let c of a)
        n(c, o, s.run, s.preventDefault, s.stopPropagation), s.shift && n(c, "Shift-" + o, s.shift, s.preventDefault, s.stopPropagation);
  }
  return O;
}
let ma = null;
function s$(t, e, O, i) {
  ma = e;
  let r = Jp(e), n = ge(r, 0), s = Fe(n) == r.length && r != " ", a = "", o = !1, c = !1, h = !1;
  EO && EO.view == O && EO.scope == i && (a = EO.prefix + " ", Lf.indexOf(e.keyCode) < 0 && (c = !0, EO = null));
  let Q = /* @__PURE__ */ new Set(), f = (p) => {
    if (p) {
      for (let m of p.run)
        if (!Q.has(m) && (Q.add(m), m(O)))
          return p.stopPropagation && (h = !0), !0;
      p.preventDefault && (p.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, $ = t[i], u, d;
  return $ && (f($[a + Xr(r, e, !s)]) ? o = !0 : s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(W.windows && e.ctrlKey && e.altKey) && (u = HO[e.keyCode]) && u != r ? (f($[a + Xr(u, e, !0)]) || e.shiftKey && (d = Wi[e.keyCode]) != r && d != u && f($[a + Xr(d, e, !1)])) && (o = !0) : s && e.shiftKey && f($[a + Xr(r, e, !0)]) && (o = !0), !o && f($._any) && (o = !0)), c && (o = !0), o && h && e.stopPropagation(), ma = null, o;
}
class tr {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, O, i, r, n) {
    this.className = e, this.left = O, this.top = i, this.width = r, this.height = n;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, O) {
    return O.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, O, i) {
    if (i.empty) {
      let r = e.coordsAtPos(i.head, i.assoc || 1);
      if (!r)
        return [];
      let n = a$(e);
      return [new tr(O, r.left - n.left, r.top - n.top, null, r.bottom - r.top)];
    } else
      return RP(e, O, i);
  }
}
function a$(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == Oe.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function pc(t, e, O, i) {
  let r = t.coordsAtPos(e, O * 2);
  if (!r)
    return i;
  let n = t.dom.getBoundingClientRect(), s = (r.top + r.bottom) / 2, a = t.posAtCoords({ x: n.left + 1, y: s }), o = t.posAtCoords({ x: n.right - 1, y: s });
  return a == null || o == null ? i : { from: Math.max(i.from, Math.min(a, o)), to: Math.min(i.to, Math.max(a, o)) };
}
function RP(t, e, O) {
  if (O.to <= t.viewport.from || O.from >= t.viewport.to)
    return [];
  let i = Math.max(O.from, t.viewport.from), r = Math.min(O.to, t.viewport.to), n = t.textDirection == Oe.LTR, s = t.contentDOM, a = s.getBoundingClientRect(), o = a$(t), c = s.querySelector(".cm-line"), h = c && window.getComputedStyle(c), Q = a.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), f = a.right - (h ? parseInt(h.paddingRight) : 0), $ = fa(t, i), u = fa(t, r), d = $.type == Re.Text ? $ : null, p = u.type == Re.Text ? u : null;
  if (d && (t.lineWrapping || $.widgetLineBreaks) && (d = pc(t, i, 1, d)), p && (t.lineWrapping || u.widgetLineBreaks) && (p = pc(t, r, -1, p)), d && p && d.from == p.from && d.to == p.to)
    return P(X(O.from, O.to, d));
  {
    let S = d ? X(O.from, null, d) : y($, !1), w = p ? X(null, O.to, p) : y(u, !0), T = [];
    return (d || $).to < (p || u).from - (d && p ? 1 : 0) || $.widgetLineBreaks > 1 && S.bottom + t.defaultLineHeight / 2 < w.top ? T.push(m(Q, S.bottom, f, w.top)) : S.bottom < w.top && t.elementAtHeight((S.bottom + w.top) / 2).type == Re.Text && (S.bottom = w.top = (S.bottom + w.top) / 2), P(S).concat(T).concat(P(w));
  }
  function m(S, w, T, U) {
    return new tr(
      e,
      S - o.left,
      w - o.top - 0.01,
      T - S,
      U - w + 0.01
      /* C.Epsilon */
    );
  }
  function P({ top: S, bottom: w, horizontal: T }) {
    let U = [];
    for (let j = 0; j < T.length; j += 2)
      U.push(m(T[j], S, T[j + 1], w));
    return U;
  }
  function X(S, w, T) {
    let U = 1e9, j = -1e9, G = [];
    function _(D, ie, Ze, Ye, _e) {
      let Me = t.coordsAtPos(D, D == T.to ? -2 : 2), $e = t.coordsAtPos(Ze, Ze == T.from ? 2 : -2);
      !Me || !$e || (U = Math.min(Me.top, $e.top, U), j = Math.max(Me.bottom, $e.bottom, j), _e == Oe.LTR ? G.push(n && ie ? Q : Me.left, n && Ye ? f : $e.right) : G.push(!n && Ye ? Q : $e.left, !n && ie ? f : Me.right));
    }
    let V = S ?? T.from, B = w ?? T.to;
    for (let D of t.visibleRanges)
      if (D.to > V && D.from < B)
        for (let ie = Math.max(D.from, V), Ze = Math.min(D.to, B); ; ) {
          let Ye = t.state.doc.lineAt(ie);
          for (let _e of t.bidiSpans(Ye)) {
            let Me = _e.from + Ye.from, $e = _e.to + Ye.from;
            if (Me >= Ze)
              break;
            $e > ie && _(Math.max(Me, ie), S == null && Me <= V, Math.min($e, Ze), w == null && $e >= B, _e.dir);
          }
          if (ie = Ye.to + 1, ie >= Ze)
            break;
        }
    return G.length == 0 && _(V, S == null, B, w == null, t.textDirection), { top: U, bottom: j, horizontal: G };
  }
  function y(S, w) {
    let T = a.top + (w ? S.top : S.bottom);
    return { top: T, bottom: T, horizontal: [] };
  }
}
function vP(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class ZP {
  constructor(e, O) {
    this.view = e, this.layer = O, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), O.above && this.dom.classList.add("cm-layer-above"), O.class && this.dom.classList.add(O.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), O.mount && O.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Dr) != e.state.facet(Dr) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let O = 0, i = e.facet(Dr);
    for (; O < i.length && i[O] != this.layer; )
      O++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - O);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: O } = this.view;
    (e != this.scaleX || O != this.scaleY) && (this.scaleX = e, this.scaleY = O, this.dom.style.transform = `scale(${1 / e}, ${1 / O})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((O, i) => !vP(O, this.drawn[i]))) {
      let O = this.dom.firstChild, i = 0;
      for (let r of e)
        r.update && O && r.constructor && this.drawn[i].constructor && r.update(O, this.drawn[i]) ? (O = O.nextSibling, i++) : this.dom.insertBefore(r.draw(), O);
      for (; O; ) {
        let r = O.nextSibling;
        O.remove(), O = r;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Dr = /* @__PURE__ */ R.define();
function o$(t) {
  return [
    Qe.define((e) => new ZP(e, t)),
    Dr.of(t)
  ];
}
const l$ = !W.ios, Yi = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, O) => Math.min(e, O),
      drawRangeCursor: (e, O) => e || O
    });
  }
});
function YP(t = {}) {
  return [
    Yi.of(t),
    zP,
    qP,
    UP,
    Uf.of(!0)
  ];
}
function c$(t) {
  return t.startState.facet(Yi) != t.state.facet(Yi);
}
const zP = /* @__PURE__ */ o$({
  above: !0,
  markers(t) {
    let { state: e } = t, O = e.facet(Yi), i = [];
    for (let r of e.selection.ranges) {
      let n = r == e.selection.main;
      if (r.empty ? !n || l$ : O.drawRangeCursor) {
        let s = n ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = r.empty ? r : g.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let o of tr.forRange(t, s, a))
          i.push(o);
      }
    }
    return i;
  },
  update(t, e) {
    t.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let O = c$(t);
    return O && mc(t.state, e), t.docChanged || t.selectionSet || O;
  },
  mount(t, e) {
    mc(e.state, t);
  },
  class: "cm-cursorLayer"
});
function mc(t, e) {
  e.style.animationDuration = t.facet(Yi).cursorBlinkRate + "ms";
}
const qP = /* @__PURE__ */ o$({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : tr.forRange(t, "cm-selectionBackground", e)).reduce((e, O) => e.concat(O));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || c$(t);
  },
  class: "cm-selectionLayer"
}), Pa = {
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
l$ && (Pa[".cm-line"].caretColor = Pa[".cm-content"].caretColor = "transparent !important");
const UP = /* @__PURE__ */ qO.highest(/* @__PURE__ */ k.theme(Pa)), h$ = /* @__PURE__ */ z.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), hi = /* @__PURE__ */ pe.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((O, i) => i.is(h$) ? i.value : O, t);
  }
}), VP = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let O = t.state.field(hi);
    O == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(hi) != O || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(hi), O = e != null && t.coordsAtPos(e);
    if (!O)
      return null;
    let i = t.scrollDOM.getBoundingClientRect();
    return {
      left: O.left - i.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: O.top - i.top + t.scrollDOM.scrollTop * t.scaleY,
      height: O.bottom - O.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: O } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / O + "px", this.cursor.style.height = t.height / O + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(hi) != t && this.view.dispatch({ effects: h$.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function _P() {
  return [hi, VP];
}
function Pc(t, e, O, i, r) {
  e.lastIndex = 0;
  for (let n = t.iterRange(O, i), s = O, a; !n.next().done; s += n.value.length)
    if (!n.lineBreak)
      for (; a = e.exec(n.value); )
        r(s + a.index, a);
}
function jP(t, e) {
  let O = t.visibleRanges;
  if (O.length == 1 && O[0].from == t.viewport.from && O[0].to == t.viewport.to)
    return O;
  let i = [];
  for (let { from: r, to: n } of O)
    r = Math.max(t.state.doc.lineAt(r).from, r - e), n = Math.min(t.state.doc.lineAt(n).to, n + e), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = n : i.push({ from: r, to: n });
  return i;
}
class GP {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: O, decoration: i, decorate: r, boundary: n, maxLength: s = 1e3 } = e;
    if (!O.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = O, r)
      this.addMatch = (a, o, c, h) => r(h, c, c + a[0].length, a, o);
    else if (typeof i == "function")
      this.addMatch = (a, o, c, h) => {
        let Q = i(a, o, c);
        Q && h(c, c + a[0].length, Q);
      };
    else if (i)
      this.addMatch = (a, o, c, h) => h(c, c + a[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let O = new BO(), i = O.add.bind(O);
    for (let { from: r, to: n } of jP(e, this.maxLength))
      Pc(e.state.doc, this.regexp, r, n, (s, a) => this.addMatch(a, e, s, i));
    return O.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, O) {
    let i = 1e9, r = -1;
    return e.docChanged && e.changes.iterChanges((n, s, a, o) => {
      o > e.view.viewport.from && a < e.view.viewport.to && (i = Math.min(a, i), r = Math.max(o, r));
    }), e.viewportChanged || r - i > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, O.map(e.changes), i, r) : O;
  }
  updateRange(e, O, i, r) {
    for (let n of e.visibleRanges) {
      let s = Math.max(n.from, i), a = Math.min(n.to, r);
      if (a > s) {
        let o = e.state.doc.lineAt(s), c = o.to < a ? e.state.doc.lineAt(a) : o, h = Math.max(n.from, o.from), Q = Math.min(n.to, c.to);
        if (this.boundary) {
          for (; s > o.from; s--)
            if (this.boundary.test(o.text[s - 1 - o.from])) {
              h = s;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              Q = a;
              break;
            }
        }
        let f = [], $, u = (d, p, m) => f.push(m.range(d, p));
        if (o == c)
          for (this.regexp.lastIndex = h - o.from; ($ = this.regexp.exec(o.text)) && $.index < Q - o.from; )
            this.addMatch($, e, $.index + o.from, u);
        else
          Pc(e.state.doc, this.regexp, h, Q, (d, p) => this.addMatch(p, e, d, u));
        O = O.update({ filterFrom: h, filterTo: Q, filter: (d, p) => d < h || p > Q, add: f });
      }
    }
    return O;
  }
}
const ga = /x/.unicode != null ? "gu" : "g", CP = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, ga), EP = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let es = null;
function AP() {
  var t;
  if (es == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    es = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return es || !1;
}
const Nr = /* @__PURE__ */ R.define({
  combine(t) {
    let e = XO(t, {
      render: null,
      specialChars: CP,
      addSpecialChars: null
    });
    return (e.replaceTabs = !AP()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, ga)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, ga)), e;
  }
});
function DP(t = {}) {
  return [Nr.of(t), NP()];
}
let gc = null;
function NP() {
  return gc || (gc = Qe.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = Z.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Nr)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new GP({
        regexp: t.specialChars,
        decoration: (e, O, i) => {
          let { doc: r } = O.state, n = ge(e[0], 0);
          if (n == 9) {
            let s = r.lineAt(i), a = O.state.tabSize, o = sO(s.text, a, i - s.from);
            return Z.replace({
              widget: new BP((a - o % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[n] || (this.decorationCache[n] = Z.replace({ widget: new LP(t, n) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Nr);
      t.startState.facet(Nr) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const IP = "â€¢";
function MP(t) {
  return t >= 32 ? IP : t == 10 ? "â¤" : String.fromCharCode(9216 + t);
}
class LP extends VO {
  constructor(e, O) {
    super(), this.options = e, this.code = O;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let O = MP(this.code), i = e.state.phrase("Control character") + " " + (EP[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, i, O);
    if (r)
      return r;
    let n = document.createElement("span");
    return n.textContent = O, n.title = i, n.setAttribute("aria-label", i), n.className = "cm-specialChar", n;
  }
  ignoreEvent() {
    return !1;
  }
}
class BP extends VO {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function FP() {
  return KP;
}
const HP = /* @__PURE__ */ Z.line({ class: "cm-activeLine" }), KP = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, O = [];
    for (let i of t.state.selection.ranges) {
      let r = t.lineBlockAt(i.head);
      r.from > e && (O.push(HP.range(r.from)), e = r.from);
    }
    return Z.set(O);
  }
}, {
  decorations: (t) => t.decorations
}), Sa = 2e3;
function JP(t, e, O) {
  let i = Math.min(e.line, O.line), r = Math.max(e.line, O.line), n = [];
  if (e.off > Sa || O.off > Sa || e.col < 0 || O.col < 0) {
    let s = Math.min(e.off, O.off), a = Math.max(e.off, O.off);
    for (let o = i; o <= r; o++) {
      let c = t.doc.line(o);
      c.length <= a && n.push(g.range(c.from + s, c.to + a));
    }
  } else {
    let s = Math.min(e.col, O.col), a = Math.max(e.col, O.col);
    for (let o = i; o <= r; o++) {
      let c = t.doc.line(o), h = Ks(c.text, s, t.tabSize, !0);
      if (h < 0)
        n.push(g.cursor(c.to));
      else {
        let Q = Ks(c.text, a, t.tabSize);
        n.push(g.range(c.from + h, c.from + Q));
      }
    }
  }
  return n;
}
function eg(t, e) {
  let O = t.coordsAtPos(t.viewport.from);
  return O ? Math.round(Math.abs((O.left - e) / t.defaultCharacterWidth)) : -1;
}
function Sc(t, e) {
  let O = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = t.state.doc.lineAt(O), r = O - i.from, n = r > Sa ? -1 : r == i.length ? eg(t, e.clientX) : sO(i.text, t.state.tabSize, O - i.from);
  return { line: i.number, col: n, off: r };
}
function Og(t, e) {
  let O = Sc(t, e), i = t.state.selection;
  return O ? {
    update(r) {
      if (r.docChanged) {
        let n = r.changes.mapPos(r.startState.doc.line(O.line).from), s = r.state.doc.lineAt(n);
        O = { line: s.number, col: O.col, off: Math.min(O.off, s.length) }, i = i.map(r.changes);
      }
    },
    get(r, n, s) {
      let a = Sc(t, r);
      if (!a)
        return i;
      let o = JP(t.state, O, a);
      return o.length ? s ? g.create(o.concat(i.ranges)) : g.create(o) : i;
    }
  } : null;
}
function tg(t) {
  let e = (O) => O.altKey && O.button == 0;
  return k.mouseSelectionStyle.of((O, i) => e(i) ? Og(O, i) : null);
}
const ig = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, rg = { style: "cursor: crosshair" };
function ng(t = {}) {
  let [e, O] = ig[t.key || "Alt"], i = Qe.fromClass(class {
    constructor(r) {
      this.view = r, this.isDown = !1;
    }
    set(r) {
      this.isDown != r && (this.isDown = r, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(r) {
        this.set(r.keyCode == e || O(r));
      },
      keyup(r) {
        (r.keyCode == e || !O(r)) && this.set(!1);
      },
      mousemove(r) {
        this.set(O(r));
      }
    }
  });
  return [
    i,
    k.contentAttributes.of((r) => {
      var n;
      return !((n = r.plugin(i)) === null || n === void 0) && n.isDown ? rg : null;
    })
  ];
}
const ei = "-10000px";
class Q$ {
  constructor(e, O, i, r) {
    this.facet = O, this.createTooltipView = i, this.removeTooltipView = r, this.input = e.state.facet(O), this.tooltips = this.input.filter((s) => s);
    let n = null;
    this.tooltipViews = this.tooltips.map((s) => n = i(s, n));
  }
  update(e, O) {
    var i;
    let r = e.state.facet(this.facet), n = r.filter((o) => o);
    if (r === this.input) {
      for (let o of this.tooltipViews)
        o.update && o.update(e);
      return !1;
    }
    let s = [], a = O ? [] : null;
    for (let o = 0; o < n.length; o++) {
      let c = n[o], h = -1;
      if (c) {
        for (let Q = 0; Q < this.tooltips.length; Q++) {
          let f = this.tooltips[Q];
          f && f.create == c.create && (h = Q);
        }
        if (h < 0)
          s[o] = this.createTooltipView(c, o ? s[o - 1] : null), a && (a[o] = !!c.above);
        else {
          let Q = s[o] = this.tooltipViews[h];
          a && (a[o] = O[h]), Q.update && Q.update(e);
        }
      }
    }
    for (let o of this.tooltipViews)
      s.indexOf(o) < 0 && (this.removeTooltipView(o), (i = o.destroy) === null || i === void 0 || i.call(o));
    return O && (a.forEach((o, c) => O[c] = o), O.length = a.length), this.input = r, this.tooltips = n, this.tooltipViews = s, !0;
  }
}
function sg(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const Os = /* @__PURE__ */ R.define({
  combine: (t) => {
    var e, O, i;
    return {
      position: W.ios ? "absolute" : ((e = t.find((r) => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((O = t.find((r) => r.parent)) === null || O === void 0 ? void 0 : O.parent) || null,
      tooltipSpace: ((i = t.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || sg
    };
  }
}), Xc = /* @__PURE__ */ new WeakMap(), wo = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Os);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new Q$(t, ko, (O, i) => this.createTooltip(O, i), (O) => {
      this.resizeObserver && this.resizeObserver.unobserve(O.dom), O.dom.remove();
    }), this.above = this.manager.tooltips.map((O) => !!O.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((O) => {
      Date.now() > this.lastTransaction - 50 && O.length > 0 && O[O.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let O = e || t.geometryChanged, i = t.state.facet(Os);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      O = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      O = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    O && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let O = t.create(this.view), i = e ? e.dom : null;
    if (O.dom.classList.add("cm-tooltip"), t.arrow && !O.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let r = document.createElement("div");
      r.className = "cm-tooltip-arrow", O.dom.appendChild(r);
    }
    return O.dom.style.position = this.position, O.dom.style.top = ei, O.dom.style.left = "0px", this.container.insertBefore(O.dom, i), O.mount && O.mount(this.view), this.resizeObserver && this.resizeObserver.observe(O.dom), O;
  }
  destroy() {
    var t, e, O;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (O = this.intersectionObserver) === null || O === void 0 || O.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, O = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: r } = this.manager.tooltipViews[0];
      if (W.gecko)
        i = r.offsetParent != this.container.ownerDocument.body;
      else if (r.style.top == ei && r.style.left == "0px") {
        let n = r.getBoundingClientRect();
        i = Math.abs(n.top + 1e4) > 1 || Math.abs(n.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let r = this.parent.getBoundingClientRect();
        r.width && r.height && (e = r.width / this.parent.offsetWidth, O = r.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: O } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((r, n) => {
        let s = this.manager.tooltipViews[n];
        return s.getCoords ? s.getCoords(r.pos) : this.view.coordsAtPos(r.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: r }) => r.getBoundingClientRect()),
      space: this.view.state.facet(Os).tooltipSpace(this.view),
      scaleX: e,
      scaleY: O,
      makeAbsolute: i
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: O, space: i, scaleX: r, scaleY: n } = t, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let o = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: h } = c, Q = t.pos[a], f = t.size[a];
      if (!Q || Q.bottom <= Math.max(O.top, i.top) || Q.top >= Math.min(O.bottom, i.bottom) || Q.right < Math.max(O.left, i.left) - 0.1 || Q.left > Math.min(O.right, i.right) + 0.1) {
        h.style.top = ei;
        continue;
      }
      let $ = o.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, u = $ ? 7 : 0, d = f.right - f.left, p = (e = Xc.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, m = c.offset || og, P = this.view.textDirection == Oe.LTR, X = f.width > i.right - i.left ? P ? i.left : i.right - f.width : P ? Math.max(i.left, Math.min(Q.left - ($ ? 14 : 0) + m.x, i.right - d)) : Math.min(Math.max(i.left, Q.left - d + ($ ? 14 : 0) - m.x), i.right - d), y = this.above[a];
      !o.strictSide && (y ? Q.top - (f.bottom - f.top) - m.y < i.top : Q.bottom + (f.bottom - f.top) + m.y > i.bottom) && y == i.bottom - Q.bottom > Q.top - i.top && (y = this.above[a] = !y);
      let S = (y ? Q.top - i.top : i.bottom - Q.bottom) - u;
      if (S < p && c.resize !== !1) {
        if (S < this.view.defaultLineHeight) {
          h.style.top = ei;
          continue;
        }
        Xc.set(c, p), h.style.height = (p = S) / n + "px";
      } else h.style.height && (h.style.height = "");
      let w = y ? Q.top - p - u - m.y : Q.bottom + u + m.y, T = X + d;
      if (c.overlap !== !0)
        for (let U of s)
          U.left < T && U.right > X && U.top < w + p && U.bottom > w && (w = y ? U.top - p - 2 - u : U.bottom + u + 2);
      if (this.position == "absolute" ? (h.style.top = (w - t.parent.top) / n + "px", h.style.left = (X - t.parent.left) / r + "px") : (h.style.top = w / n + "px", h.style.left = X / r + "px"), $) {
        let U = Q.left + (P ? m.x : -m.x) - (X + 14 - 7);
        $.style.left = U / r + "px";
      }
      c.overlap !== !0 && s.push({ left: X, top: w, right: T, bottom: w + p }), h.classList.toggle("cm-tooltip-above", y), h.classList.toggle("cm-tooltip-below", !y), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = ei;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), ag = /* @__PURE__ */ k.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), og = { x: 0, y: 0 }, ko = /* @__PURE__ */ R.define({
  enables: [wo, ag]
}), an = /* @__PURE__ */ R.define({
  combine: (t) => t.reduce((e, O) => e.concat(O), [])
});
class Yn {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Yn(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Q$(e, an, (O, i) => this.createHostedView(O, i), (O) => O.dom.remove());
  }
  createHostedView(e, O) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, O ? O.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let O of this.manager.tooltipViews)
      O.mount && O.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let O of this.manager.tooltipViews)
      O.positioned && O.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let O of this.manager.tooltipViews)
      (e = O.destroy) === null || e === void 0 || e.call(O);
  }
  passProp(e) {
    let O;
    for (let i of this.manager.tooltipViews) {
      let r = i[e];
      if (r !== void 0) {
        if (O === void 0)
          O = r;
        else if (O !== r)
          return;
      }
    }
    return O;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const lg = /* @__PURE__ */ ko.compute([an], (t) => {
  let e = t.facet(an);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((O) => O.pos)),
    end: Math.max(...e.map((O) => {
      var i;
      return (i = O.end) !== null && i !== void 0 ? i : O.pos;
    })),
    create: Yn.create,
    above: e[0].above,
    arrow: e.some((O) => O.arrow)
  };
});
class cg {
  constructor(e, O, i, r, n) {
    this.view = e, this.source = O, this.field = i, this.setHover = r, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: O } = this, i = e.docView.nearest(O.target);
    if (!i)
      return;
    let r, n = 1;
    if (i instanceof DO)
      r = i.posAtStart;
    else {
      if (r = e.posAtCoords(O), r == null)
        return;
      let a = e.coordsAtPos(r);
      if (!a || O.y < a.top || O.y > a.bottom || O.x < a.left - e.defaultCharacterWidth || O.x > a.right + e.defaultCharacterWidth)
        return;
      let o = e.bidiSpans(e.state.doc.lineAt(r)).find((h) => h.from <= r && h.to >= r), c = o && o.dir == Oe.RTL ? -1 : 1;
      n = O.x < a.left ? -c : c;
    }
    let s = this.source(e, r, n);
    if (s != null && s.then) {
      let a = this.pending = { pos: r };
      s.then((o) => {
        this.pending == a && (this.pending = null, o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) }));
      }, (o) => Ue(e.state, o, "hover tooltip"));
    } else s && !(Array.isArray(s) && !s.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let e = this.view.plugin(wo), O = e ? e.manager.tooltips.findIndex((i) => i.create == Yn.create) : -1;
    return O > -1 ? e.manager.tooltipViews[O] : null;
  }
  mousemove(e) {
    var O, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: n } = this;
    if (r.length && n && !hg(n.dom, e) || this.pending) {
      let { pos: s } = r[0] || this.pending, a = (i = (O = r[0]) === null || O === void 0 ? void 0 : O.end) !== null && i !== void 0 ? i : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !Qg(this.view, s, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: O } = this;
    if (O.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let O = (i) => {
      e.removeEventListener("mouseleave", O), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", O);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const yr = 4;
function hg(t, e) {
  let O = t.getBoundingClientRect();
  return e.clientX >= O.left - yr && e.clientX <= O.right + yr && e.clientY >= O.top - yr && e.clientY <= O.bottom + yr;
}
function Qg(t, e, O, i, r, n) {
  let s = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (s.left > i || s.right < i || s.top > r || Math.min(s.bottom, a) < r)
    return !1;
  let o = t.posAtCoords({ x: i, y: r }, !1);
  return o >= e && o <= O;
}
function fg(t, e = {}) {
  let O = z.define(), i = pe.define({
    create() {
      return [];
    },
    update(r, n) {
      if (r.length && (e.hideOnChange && (n.docChanged || n.selection) ? r = [] : e.hideOn && (r = r.filter((s) => !e.hideOn(n, s))), n.docChanged)) {
        let s = [];
        for (let a of r) {
          let o = n.changes.mapPos(a.pos, -1, Xe.TrackDel);
          if (o != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = o, c.end != null && (c.end = n.changes.mapPos(c.end)), s.push(c);
          }
        }
        r = s;
      }
      for (let s of n.effects)
        s.is(O) && (r = s.value), s.is($g) && (r = []);
      return r;
    },
    provide: (r) => an.from(r)
  });
  return {
    active: i,
    extension: [
      i,
      Qe.define((r) => new cg(
        r,
        t,
        i,
        O,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      lg
    ]
  };
}
function f$(t, e) {
  let O = t.plugin(wo);
  if (!O)
    return null;
  let i = O.manager.tooltips.indexOf(e);
  return i < 0 ? null : O.manager.tooltipViews[i];
}
const $g = /* @__PURE__ */ z.define(), yc = /* @__PURE__ */ R.define({
  combine(t) {
    let e, O;
    for (let i of t)
      e = e || i.topContainer, O = O || i.bottomContainer;
    return { topContainer: e, bottomContainer: O };
  }
});
function zi(t, e) {
  let O = t.plugin($$), i = O ? O.specs.indexOf(e) : -1;
  return i > -1 ? O.panels[i] : null;
}
const $$ = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(qi), this.specs = this.input.filter((O) => O), this.panels = this.specs.map((O) => O(t));
    let e = t.state.facet(yc);
    this.top = new br(t, !0, e.topContainer), this.bottom = new br(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((O) => O.top)), this.bottom.sync(this.panels.filter((O) => !O.top));
    for (let O of this.panels)
      O.dom.classList.add("cm-panel"), O.mount && O.mount();
  }
  update(t) {
    let e = t.state.facet(yc);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new br(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new br(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let O = t.state.facet(qi);
    if (O != this.input) {
      let i = O.filter((o) => o), r = [], n = [], s = [], a = [];
      for (let o of i) {
        let c = this.specs.indexOf(o), h;
        c < 0 ? (h = o(t.view), a.push(h)) : (h = this.panels[c], h.update && h.update(t)), r.push(h), (h.top ? n : s).push(h);
      }
      this.specs = i, this.panels = r, this.top.sync(n), this.bottom.sync(s);
      for (let o of a)
        o.dom.classList.add("cm-panel"), o.mount && o.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => k.scrollMargins.of((e) => {
    let O = e.plugin(t);
    return O && { top: O.top.scrollMargin(), bottom: O.bottom.scrollMargin() };
  })
});
class br {
  constructor(e, O, i) {
    this.view = e, this.top = O, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let O of this.panels)
      O.destroy && e.indexOf(O) < 0 && O.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let O = this.container || this.view.dom;
      O.insertBefore(this.dom, this.top ? O.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let O of this.panels)
      if (O.dom.parentNode == this.dom) {
        for (; e != O.dom; )
          e = bc(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(O.dom, e);
    for (; e; )
      e = bc(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function bc(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const qi = /* @__PURE__ */ R.define({
  enables: $$
});
class vO extends ft {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
vO.prototype.elementClass = "";
vO.prototype.toDOM = void 0;
vO.prototype.mapMode = Xe.TrackBefore;
vO.prototype.startSide = vO.prototype.endSide = -1;
vO.prototype.point = !0;
const Ir = /* @__PURE__ */ R.define(), ug = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => A.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, pi = /* @__PURE__ */ R.define();
function dg(t) {
  return [u$(), pi.of(Object.assign(Object.assign({}, ug), t))];
}
const xc = /* @__PURE__ */ R.define({
  combine: (t) => t.some((e) => e)
});
function u$(t) {
  return [
    pg
  ];
}
const pg = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(pi).map((e) => new wc(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(xc), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, O = t.view.viewport, i = Math.min(e.to, O.to) - Math.max(e.from, O.from);
      this.syncGutters(i < (O.to - O.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(xc) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let O = A.iter(this.view.state.facet(Ir), this.view.viewport.from), i = [], r = this.gutters.map((n) => new mg(n, this.view.viewport, -this.view.documentPadding.top));
    for (let n of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(n.type)) {
        let s = !0;
        for (let a of n.type)
          if (a.type == Re.Text && s) {
            Xa(O, i, a.from);
            for (let o of r)
              o.line(this.view, a, i);
            s = !1;
          } else if (a.widget)
            for (let o of r)
              o.widget(this.view, a);
      } else if (n.type == Re.Text) {
        Xa(O, i, n.from);
        for (let s of r)
          s.line(this.view, n, i);
      } else if (n.widget)
        for (let s of r)
          s.widget(this.view, n);
    for (let n of r)
      n.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(pi), O = t.state.facet(pi), i = t.docChanged || t.heightChanged || t.viewportChanged || !A.eq(t.startState.facet(Ir), t.state.facet(Ir), t.view.viewport.from, t.view.viewport.to);
    if (e == O)
      for (let r of this.gutters)
        r.update(t) && (i = !0);
    else {
      i = !0;
      let r = [];
      for (let n of O) {
        let s = e.indexOf(n);
        s < 0 ? r.push(new wc(this.view, n)) : (this.gutters[s].update(t), r.push(this.gutters[s]));
      }
      for (let n of this.gutters)
        n.dom.remove(), r.indexOf(n) < 0 && n.destroy();
      for (let n of r)
        this.dom.appendChild(n.dom);
      this.gutters = r;
    }
    return i;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => k.scrollMargins.of((e) => {
    let O = e.plugin(t);
    return !O || O.gutters.length == 0 || !O.fixed ? null : e.textDirection == Oe.LTR ? { left: O.dom.offsetWidth * e.scaleX } : { right: O.dom.offsetWidth * e.scaleX };
  })
});
function Tc(t) {
  return Array.isArray(t) ? t : [t];
}
function Xa(t, e, O) {
  for (; t.value && t.from <= O; )
    t.from == O && e.push(t.value), t.next();
}
class mg {
  constructor(e, O, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = A.iter(e.markers, O.from);
  }
  addElement(e, O, i) {
    let { gutter: r } = this, n = (O.top - this.height) / e.scaleY, s = O.height / e.scaleY;
    if (this.i == r.elements.length) {
      let a = new d$(e, s, n, i);
      r.elements.push(a), r.dom.appendChild(a.dom);
    } else
      r.elements[this.i].update(e, s, n, i);
    this.height = O.bottom, this.i++;
  }
  line(e, O, i) {
    let r = [];
    Xa(this.cursor, r, O.from), i.length && (r = r.concat(i));
    let n = this.gutter.config.lineMarker(e, O, r);
    n && r.unshift(n);
    let s = this.gutter;
    r.length == 0 && !s.config.renderEmptyElements || this.addElement(e, O, r);
  }
  widget(e, O) {
    let i = this.gutter.config.widgetMarker(e, O.widget, O);
    i && this.addElement(e, O, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let O = e.elements.pop();
      e.dom.removeChild(O.dom), O.destroy();
    }
  }
}
class wc {
  constructor(e, O) {
    this.view = e, this.config = O, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in O.domEventHandlers)
      this.dom.addEventListener(i, (r) => {
        let n = r.target, s;
        if (n != this.dom && this.dom.contains(n)) {
          for (; n.parentNode != this.dom; )
            n = n.parentNode;
          let o = n.getBoundingClientRect();
          s = (o.top + o.bottom) / 2;
        } else
          s = r.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        O.domEventHandlers[i](e, a, r) && r.preventDefault();
      });
    this.markers = Tc(O.markers(e)), O.initialSpacer && (this.spacer = new d$(e, 0, 0, [O.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let O = this.markers;
    if (this.markers = Tc(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let i = e.view.viewport;
    return !A.eq(this.markers, O, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class d$ {
  constructor(e, O, i, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, O, i, r);
  }
  update(e, O, i, r) {
    this.height != O && (this.height = O, this.dom.style.height = O + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), Pg(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, O) {
    let i = "cm-gutterElement", r = this.dom.firstChild;
    for (let n = 0, s = 0; ; ) {
      let a = s, o = n < O.length ? O[n++] : null, c = !1;
      if (o) {
        let h = o.elementClass;
        h && (i += " " + h);
        for (let Q = s; Q < this.markers.length; Q++)
          if (this.markers[Q].compare(o)) {
            a = Q, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let h = this.markers[s++];
        if (h.toDOM) {
          h.destroy(r);
          let Q = r.nextSibling;
          r.remove(), r = Q;
        }
      }
      if (!o)
        break;
      o.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(o.toDOM(e), r)), c && s++;
    }
    this.dom.className = i, this.markers = O;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Pg(t, e) {
  if (t.length != e.length)
    return !1;
  for (let O = 0; O < t.length; O++)
    if (!t[O].compare(e[O]))
      return !1;
  return !0;
}
const gg = /* @__PURE__ */ R.define(), Tt = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, O) {
        let i = Object.assign({}, e);
        for (let r in O) {
          let n = i[r], s = O[r];
          i[r] = n ? (a, o, c) => n(a, o, c) || s(a, o, c) : s;
        }
        return i;
      }
    });
  }
});
class ts extends vO {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function is(t, e) {
  return t.state.facet(Tt).formatNumber(e, t.state);
}
const Sg = /* @__PURE__ */ pi.compute([Tt], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(gg);
  },
  lineMarker(e, O, i) {
    return i.some((r) => r.toDOM) ? null : new ts(is(e, e.state.doc.lineAt(O.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Tt) != e.state.facet(Tt),
  initialSpacer(e) {
    return new ts(is(e, kc(e.state.doc.lines)));
  },
  updateSpacer(e, O) {
    let i = is(O.view, kc(O.view.state.doc.lines));
    return i == e.number ? e : new ts(i);
  },
  domEventHandlers: t.facet(Tt).domEventHandlers
}));
function Xg(t = {}) {
  return [
    Tt.of(t),
    u$(),
    Sg
  ];
}
function kc(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const yg = /* @__PURE__ */ new class extends vO {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), bg = /* @__PURE__ */ Ir.compute(["selection"], (t) => {
  let e = [], O = -1;
  for (let i of t.selection.ranges) {
    let r = t.doc.lineAt(i.head).from;
    r > O && (O = r, e.push(yg.range(r)));
  }
  return A.of(e);
});
function xg() {
  return bg;
}
let Tg = 0, bO = class p$ {
  /**
  @internal
  */
  constructor(e, O, i) {
    this.set = e, this.base = O, this.modified = i, this.id = Tg++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let O = new p$([], null, []);
    if (O.set.push(O), e)
      for (let i of e.set)
        O.set.push(i);
    return O;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new on();
    return (O) => O.modified.indexOf(e) > -1 ? O : on.get(O.base || O, O.modified.concat(e).sort((i, r) => i.id - r.id));
  }
}, wg = 0;
class on {
  constructor() {
    this.instances = [], this.id = wg++;
  }
  static get(e, O) {
    if (!O.length)
      return e;
    let i = O[0].instances.find((a) => a.base == e && kg(O, a.modified));
    if (i)
      return i;
    let r = [], n = new bO(r, e, O);
    for (let a of O)
      a.instances.push(n);
    let s = Wg(O);
    for (let a of e.set)
      if (!a.modified.length)
        for (let o of s)
          r.push(on.get(a, o));
    return n;
  }
}
function kg(t, e) {
  return t.length == e.length && t.every((O, i) => O == e[i]);
}
function Wg(t) {
  let e = [[]];
  for (let O = 0; O < t.length; O++)
    for (let i = 0, r = e.length; i < r; i++)
      e.push(e[i].concat(t[O]));
  return e.sort((O, i) => i.length - O.length);
}
function se(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let O in t) {
    let i = t[O];
    Array.isArray(i) || (i = [i]);
    for (let r of O.split(" "))
      if (r) {
        let n = [], s = 2, a = r;
        for (let Q = 0; ; ) {
          if (a == "..." && Q > 0 && Q + 3 == r.length) {
            s = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!f)
            throw new RangeError("Invalid path: " + r);
          if (n.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), Q += f[0].length, Q == r.length)
            break;
          let $ = r[Q++];
          if (Q == r.length && $ == "!") {
            s = 0;
            break;
          }
          if ($ != "/")
            throw new RangeError("Invalid path: " + r);
          a = r.slice(Q);
        }
        let o = n.length - 1, c = n[o];
        if (!c)
          throw new RangeError("Invalid path: " + r);
        let h = new ln(i, s, o > 0 ? n.slice(0, o) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return m$.add(e);
}
const m$ = new Y();
class ln {
  constructor(e, O, i, r) {
    this.tags = e, this.mode = O, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
ln.empty = new ln([], 2, null);
function P$(t, e) {
  let O = /* @__PURE__ */ Object.create(null);
  for (let n of t)
    if (!Array.isArray(n.tag))
      O[n.tag.id] = n.class;
    else
      for (let s of n.tag)
        O[s.id] = n.class;
  let { scope: i, all: r = null } = e || {};
  return {
    style: (n) => {
      let s = r;
      for (let a of n)
        for (let o of a.set) {
          let c = O[o.id];
          if (c) {
            s = s ? s + " " + c : c;
            break;
          }
        }
      return s;
    },
    scope: i
  };
}
function Rg(t, e) {
  let O = null;
  for (let i of t) {
    let r = i.style(e);
    r && (O = O ? O + " " + r : r);
  }
  return O;
}
function vg(t, e, O, i = 0, r = t.length) {
  let n = new Zg(i, Array.isArray(e) ? e : [e], O);
  n.highlightRange(t.cursor(), i, r, "", n.highlighters), n.flush(r);
}
class Zg {
  constructor(e, O, i) {
    this.at = e, this.highlighters = O, this.span = i, this.class = "";
  }
  startSpan(e, O) {
    O != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = O);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, O, i, r, n) {
    let { type: s, from: a, to: o } = e;
    if (a >= i || o <= O)
      return;
    s.isTop && (n = this.highlighters.filter(($) => !$.scope || $.scope(s)));
    let c = r, h = Yg(e) || ln.empty, Q = Rg(n, h.tags);
    if (Q && (c && (c += " "), c += Q, h.mode == 1 && (r += (r ? " " : "") + Q)), this.startSpan(Math.max(O, a), c), h.opaque)
      return;
    let f = e.tree && e.tree.prop(Y.mounted);
    if (f && f.overlay) {
      let $ = e.node.enter(f.overlay[0].from + a, 1), u = this.highlighters.filter((p) => !p.scope || p.scope(f.tree.type)), d = e.firstChild();
      for (let p = 0, m = a; ; p++) {
        let P = p < f.overlay.length ? f.overlay[p] : null, X = P ? P.from + a : o, y = Math.max(O, m), S = Math.min(i, X);
        if (y < S && d)
          for (; e.from < S && (this.highlightRange(e, y, S, r, n), this.startSpan(Math.min(S, e.to), c), !(e.to >= X || !e.nextSibling())); )
            ;
        if (!P || X > i)
          break;
        m = P.to + a, m > O && (this.highlightRange($.cursor(), Math.max(O, P.from + a), Math.min(i, m), "", u), this.startSpan(Math.min(i, m), c));
      }
      d && e.parent();
    } else if (e.firstChild()) {
      f && (r = "");
      do
        if (!(e.to <= O)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, O, i, r, n), this.startSpan(Math.min(i, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function Yg(t) {
  let e = t.type.prop(m$);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const x = bO.define, xr = x(), jO = x(), Wc = x(jO), Rc = x(jO), GO = x(), Tr = x(GO), rs = x(GO), $O = x(), Ot = x($O), QO = x(), fO = x(), ya = x(), Oi = x(ya), wr = x(), l = {
  /**
  A comment.
  */
  comment: xr,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: x(xr),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: x(xr),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: x(xr),
  /**
  Any kind of identifier.
  */
  name: jO,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: x(jO),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Wc,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: x(Wc),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Rc,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: x(Rc),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: x(jO),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: x(jO),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: x(jO),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: x(jO),
  /**
  A literal value.
  */
  literal: GO,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Tr,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: x(Tr),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: x(Tr),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: x(Tr),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: rs,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: x(rs),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: x(rs),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: x(GO),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: x(GO),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: x(GO),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: x(GO),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: x(GO),
  /**
  A language keyword.
  */
  keyword: QO,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: x(QO),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: x(QO),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: x(QO),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: x(QO),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: x(QO),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: x(QO),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: x(QO),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: x(QO),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: x(QO),
  /**
  An operator.
  */
  operator: fO,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: x(fO),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: x(fO),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: x(fO),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: x(fO),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: x(fO),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: x(fO),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: x(fO),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: x(fO),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: x(fO),
  /**
  Program or markup punctuation.
  */
  punctuation: ya,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: x(ya),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Oi,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: x(Oi),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: x(Oi),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: x(Oi),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: x(Oi),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: $O,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Ot,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: x(Ot),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: x(Ot),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: x(Ot),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: x(Ot),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: x(Ot),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: x(Ot),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: x($O),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: x($O),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: x($O),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: x($O),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: x($O),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: x($O),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: x($O),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: x($O),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: x(),
  /**
  Deleted text.
  */
  deleted: x(),
  /**
  Changed text.
  */
  changed: x(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: x(),
  /**
  Metadata or meta-instruction.
  */
  meta: wr,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: x(wr),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: x(wr),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: x(wr),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: bO.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: bO.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: bO.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: bO.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: bO.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: bO.defineModifier()
};
P$([
  { tag: l.link, class: "tok-link" },
  { tag: l.heading, class: "tok-heading" },
  { tag: l.emphasis, class: "tok-emphasis" },
  { tag: l.strong, class: "tok-strong" },
  { tag: l.keyword, class: "tok-keyword" },
  { tag: l.atom, class: "tok-atom" },
  { tag: l.bool, class: "tok-bool" },
  { tag: l.url, class: "tok-url" },
  { tag: l.labelName, class: "tok-labelName" },
  { tag: l.inserted, class: "tok-inserted" },
  { tag: l.deleted, class: "tok-deleted" },
  { tag: l.literal, class: "tok-literal" },
  { tag: l.string, class: "tok-string" },
  { tag: l.number, class: "tok-number" },
  { tag: [l.regexp, l.escape, l.special(l.string)], class: "tok-string2" },
  { tag: l.variableName, class: "tok-variableName" },
  { tag: l.local(l.variableName), class: "tok-variableName tok-local" },
  { tag: l.definition(l.variableName), class: "tok-variableName tok-definition" },
  { tag: l.special(l.variableName), class: "tok-variableName2" },
  { tag: l.definition(l.propertyName), class: "tok-propertyName tok-definition" },
  { tag: l.typeName, class: "tok-typeName" },
  { tag: l.namespace, class: "tok-namespace" },
  { tag: l.className, class: "tok-className" },
  { tag: l.macroName, class: "tok-macroName" },
  { tag: l.propertyName, class: "tok-propertyName" },
  { tag: l.operator, class: "tok-operator" },
  { tag: l.comment, class: "tok-comment" },
  { tag: l.meta, class: "tok-meta" },
  { tag: l.invalid, class: "tok-invalid" },
  { tag: l.punctuation, class: "tok-punctuation" }
]);
var ns;
const lt = /* @__PURE__ */ new Y();
function Wo(t) {
  return R.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const Ro = /* @__PURE__ */ new Y();
class Je {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, O, i = [], r = "") {
    this.data = e, this.name = r, E.prototype.hasOwnProperty("tree") || Object.defineProperty(E.prototype, "tree", { get() {
      return I(this);
    } }), this.parser = O, this.extension = [
      ZO.of(this),
      E.languageData.of((n, s, a) => {
        let o = vc(n, s, a), c = o.type.prop(lt);
        if (!c)
          return [];
        let h = n.facet(c), Q = o.type.prop(Ro);
        if (Q) {
          let f = o.resolve(s - o.from, a);
          for (let $ of Q)
            if ($.test(f, n)) {
              let u = n.facet($.facet);
              return $.type == "replace" ? u : u.concat(h);
            }
        }
        return h;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, O, i = -1) {
    return vc(e, O, i).type.prop(lt) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let O = e.facet(ZO);
    if ((O == null ? void 0 : O.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!O || !O.allowsNesting)
      return [];
    let i = [], r = (n, s) => {
      if (n.prop(lt) == this.data) {
        i.push({ from: s, to: s + n.length });
        return;
      }
      let a = n.prop(Y.mounted);
      if (a) {
        if (a.tree.prop(lt) == this.data) {
          if (a.overlay)
            for (let o of a.overlay)
              i.push({ from: o.from + s, to: o.to + s });
          else
            i.push({ from: s, to: s + n.length });
          return;
        } else if (a.overlay) {
          let o = i.length;
          if (r(a.tree, a.overlay[0].from + s), i.length > o)
            return;
        }
      }
      for (let o = 0; o < n.children.length; o++) {
        let c = n.children[o];
        c instanceof M && r(c, n.positions[o] + s);
      }
    };
    return r(I(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Je.setState = /* @__PURE__ */ z.define();
function vc(t, e, O) {
  let i = t.facet(ZO), r = I(t).topNode;
  if (!i || i.allowsNesting)
    for (let n = r; n; n = n.enter(e, O, H.ExcludeBuffers))
      n.type.isTop && (r = n);
  return r;
}
class re extends Je {
  constructor(e, O, i) {
    super(e, O, [], i), this.parser = O;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let O = Wo(e.languageData);
    return new re(O, e.parser.configure({
      props: [lt.add((i) => i.isTop ? O : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, O) {
    return new re(this.data, this.parser.configure(e), O || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function I(t) {
  let e = t.field(Je.state, !1);
  return e ? e.tree : M.empty;
}
class zg {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, O) {
    let i = this.cursorPos - this.string.length;
    return e < i || O >= this.cursorPos ? this.doc.sliceString(e, O) : this.string.slice(e - i, O - i);
  }
}
let ti = null;
class Ui {
  constructor(e, O, i = [], r, n, s, a, o) {
    this.parser = e, this.state = O, this.fragments = i, this.tree = r, this.treeLen = n, this.viewport = s, this.skipped = a, this.scheduleOn = o, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, O, i) {
    return new Ui(e, O, [], M.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new zg(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, O) {
    return O != null && O >= this.state.doc.length && (O = void 0), this.tree != M.empty && this.isDone(O ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let r = Date.now() + e;
        e = () => Date.now() > r;
      }
      for (this.parse || (this.parse = this.startParse()), O != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > O) && O < this.state.doc.length && this.parse.stopAt(O); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(wO.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (O ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, O;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(O = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = O, this.fragments = this.withoutTempSkipped(wO.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let O = ti;
    ti = this;
    try {
      return e();
    } finally {
      ti = O;
    }
  }
  withoutTempSkipped(e) {
    for (let O; O = this.tempSkipped.pop(); )
      e = Zc(e, O.from, O.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, O) {
    let { fragments: i, tree: r, treeLen: n, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let o = [];
      if (e.iterChangedRanges((c, h, Q, f) => o.push({ fromA: c, toA: h, fromB: Q, toB: f })), i = wO.applyChanges(i, o), r = M.empty, n = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), Q = e.mapPos(c.to, -1);
          h < Q && a.push({ from: h, to: Q });
        }
      }
    }
    return new Ui(this.parser, O, i, r, n, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let O = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: n } = this.skipped[i];
      r < e.to && n > e.from && (this.fragments = Zc(this.fragments, r, n), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= O ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, O) {
    this.skipped.push({ from: e, to: O });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends fo {
      createParse(O, i, r) {
        let n = r[0].from, s = r[r.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let o = ti;
            if (o) {
              for (let c of r)
                o.tempSkipped.push(c);
              e && (o.scheduleOn = o.scheduleOn ? Promise.all([o.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new M(de.none, [], [], s - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let O = this.fragments;
    return this.treeLen >= e && O.length && O[0].from == 0 && O[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return ti;
  }
}
function Zc(t, e, O) {
  return wO.applyChanges(t, [{ fromA: e, toA: O, fromB: e, toB: O }]);
}
class Gt {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let O = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), O.viewport.to);
    return O.work(20, i) || O.takeTree(), new Gt(O);
  }
  static init(e) {
    let O = Math.min(3e3, e.doc.length), i = Ui.create(e.facet(ZO).parser, e, { from: 0, to: O });
    return i.work(20, O) || i.takeTree(), new Gt(i);
  }
}
Je.state = /* @__PURE__ */ pe.define({
  create: Gt.init,
  update(t, e) {
    for (let O of e.effects)
      if (O.is(Je.setState))
        return O.value;
    return e.startState.facet(ZO) != e.state.facet(ZO) ? Gt.init(e.state) : t.apply(e);
  }
});
let g$ = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (g$ = (t) => {
  let e = -1, O = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(O) : cancelIdleCallback(e);
});
const ss = typeof navigator < "u" && (!((ns = navigator.scheduling) === null || ns === void 0) && ns.isInputPending) ? () => navigator.scheduling.isInputPending() : null, qg = /* @__PURE__ */ Qe.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let O = this.view.state.field(Je.state).context;
    (O.updateViewport(e.view.viewport) || this.view.viewport.to > O.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(O);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, O = e.field(Je.state);
    (O.tree != O.context.tree || !O.context.isDone(e.doc.length)) && (this.working = g$(this.work));
  }
  work(e) {
    this.working = null;
    let O = Date.now();
    if (this.chunkEnd < O && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = O + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, n = i.field(Je.state);
    if (n.tree == n.context.tree && n.context.isDone(
      r + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !ss ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = n.context.treeLen < r && i.doc.length > r + 1e3, o = n.context.work(() => ss && ss() || Date.now() > s, r + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - O, (o || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: Je.setState.of(new Gt(n.context)) })), this.chunkBudget > 0 && !(o && !a) && this.scheduleWork(), this.checkAsyncSchedule(n.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((O) => Ue(this.view.state, O)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), ZO = /* @__PURE__ */ R.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    Je.state,
    qg,
    k.contentAttributes.compute([t], (e) => {
      let O = e.facet(t);
      return O && O.name ? { "data-language": O.name } : {};
    })
  ]
});
class le {
  /**
  Create a language support object.
  */
  constructor(e, O = []) {
    this.language = e, this.support = O, this.extension = [e, O];
  }
}
class cn {
  constructor(e, O, i, r, n, s = void 0) {
    this.name = e, this.alias = O, this.extensions = i, this.filename = r, this.loadFunc = n, this.support = s, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: O, support: i } = e;
    if (!O) {
      if (!i)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      O = () => Promise.resolve(i);
    }
    return new cn(e.name, (e.alias || []).concat(e.name).map((r) => r.toLowerCase()), e.extensions || [], e.filename, O, i);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, O) {
    for (let r of e)
      if (r.filename && r.filename.test(O))
        return r;
    let i = /\.([^.]+)$/.exec(O);
    if (i) {
      for (let r of e)
        if (r.extensions.indexOf(i[1]) > -1)
          return r;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, O, i = !0) {
    O = O.toLowerCase();
    for (let r of e)
      if (r.alias.some((n) => n == O))
        return r;
    if (i)
      for (let r of e)
        for (let n of r.alias) {
          let s = O.indexOf(n);
          if (s > -1 && (n.length > 2 || !/\w/.test(O[s - 1]) && !/\w/.test(O[s + n.length])))
            return r;
        }
    return null;
  }
}
const Ug = /* @__PURE__ */ R.define(), ir = /* @__PURE__ */ R.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((O) => O != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function hn(t) {
  let e = t.facet(ir);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function Vi(t, e) {
  let O = "", i = t.tabSize, r = t.facet(ir)[0];
  if (r == "	") {
    for (; e >= i; )
      O += "	", e -= i;
    r = " ";
  }
  for (let n = 0; n < e; n++)
    O += r;
  return O;
}
function vo(t, e) {
  t instanceof E && (t = new zn(t));
  for (let i of t.state.facet(Ug)) {
    let r = i(t, e);
    if (r !== void 0)
      return r;
  }
  let O = I(t.state);
  return O.length >= e ? Vg(t, O, e) : null;
}
class zn {
  /**
  Create an indent context.
  */
  constructor(e, O = {}) {
    this.state = e, this.options = O, this.unit = hn(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, O = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: n } = this.options;
    return r != null && r >= i.from && r <= i.to ? n && r == e ? { text: "", from: e } : (O < 0 ? r < e : r <= e) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, O = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(e, O);
    return i.slice(e - r, Math.min(i.length, e + 100 - r));
  }
  /**
  Find the column for the given position.
  */
  column(e, O = 1) {
    let { text: i, from: r } = this.lineAt(e, O), n = this.countColumn(i, e - r), s = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return s > -1 && (n += s - this.countColumn(i, i.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, O = e.length) {
    return sO(e, this.state.tabSize, O);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, O = 1) {
    let { text: i, from: r } = this.lineAt(e, O), n = this.options.overrideIndentation;
    if (n) {
      let s = n(r);
      if (s > -1)
        return s;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const me = /* @__PURE__ */ new Y();
function Vg(t, e, O) {
  let i = e.resolveStack(O), r = i.node.enterUnfinishedNodesBefore(O);
  if (r != i.node) {
    let n = [];
    for (let s = r; s != i.node; s = s.parent)
      n.push(s);
    for (let s = n.length - 1; s >= 0; s--)
      i = { node: n[s], next: i };
  }
  return S$(i, t, O);
}
function S$(t, e, O) {
  for (let i = t; i; i = i.next) {
    let r = jg(i.node);
    if (r)
      return r(Zo.create(e, O, i));
  }
  return 0;
}
function _g(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function jg(t) {
  let e = t.type.prop(me);
  if (e)
    return e;
  let O = t.firstChild, i;
  if (O && (i = O.type.prop(Y.closedBy))) {
    let r = t.lastChild, n = r && i.indexOf(r.name) > -1;
    return (s) => X$(s, !0, 1, void 0, n && !_g(s) ? r.from : void 0);
  }
  return t.parent == null ? Gg : null;
}
function Gg() {
  return 0;
}
class Zo extends zn {
  constructor(e, O, i) {
    super(e.state, e.options), this.base = e, this.pos = O, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, O, i) {
    return new Zo(e, O, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let O = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(O.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (Cg(i, e))
        break;
      O = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(O.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return S$(this.context.next, this.base, this.pos);
  }
}
function Cg(t, e) {
  for (let O = e; O; O = O.parent)
    if (t == O)
      return !0;
  return !1;
}
function Eg(t) {
  let e = t.node, O = e.childAfter(e.from), i = e.lastChild;
  if (!O)
    return null;
  let r = t.options.simulateBreak, n = t.state.doc.lineAt(O.from), s = r == null || r <= n.from ? n.to : Math.min(n.to, r);
  for (let a = O.to; ; ) {
    let o = e.childAfter(a);
    if (!o || o == i)
      return null;
    if (!o.type.isSkipped)
      return o.from < s ? O : null;
    a = o.to;
  }
}
function YO({ closing: t, align: e = !0, units: O = 1 }) {
  return (i) => X$(i, e, O, t);
}
function X$(t, e, O, i, r) {
  let n = t.textAfter, s = n.match(/^\s*/)[0].length, a = i && n.slice(s, s + i.length) == i || r == t.pos + s, o = e ? Eg(t) : null;
  return o ? a ? t.column(o.from) : t.column(o.to) : t.baseIndent + (a ? 0 : t.unit * O);
}
const qn = (t) => t.baseIndent;
function ae({ except: t, units: e = 1 } = {}) {
  return (O) => {
    let i = t && t.test(O.textAfter);
    return O.baseIndent + (i ? 0 : e * O.unit);
  };
}
const Ag = 200;
function Dg() {
  return E.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let O = t.newDoc, { head: i } = t.newSelection.main, r = O.lineAt(i);
    if (i > r.from + Ag)
      return t;
    let n = O.sliceString(r.from, i);
    if (!e.some((c) => c.test(n)))
      return t;
    let { state: s } = t, a = -1, o = [];
    for (let { head: c } of s.selection.ranges) {
      let h = s.doc.lineAt(c);
      if (h.from == a)
        continue;
      a = h.from;
      let Q = vo(s, h.from);
      if (Q == null)
        continue;
      let f = /^\s*/.exec(h.text)[0], $ = Vi(s, Q);
      f != $ && o.push({ from: h.from, to: h.from + f.length, insert: $ });
    }
    return o.length ? [t, { changes: o, sequential: !0 }] : t;
  });
}
const y$ = /* @__PURE__ */ R.define(), fe = /* @__PURE__ */ new Y();
function Ie(t) {
  let e = t.firstChild, O = t.lastChild;
  return e && e.to < O.from ? { from: e.to, to: O.type.isError ? t.to : O.from } : null;
}
function Ng(t, e, O) {
  let i = I(t);
  if (i.length < O)
    return null;
  let r = i.resolveStack(O, 1), n = null;
  for (let s = r; s; s = s.next) {
    let a = s.node;
    if (a.to <= O || a.from > O)
      continue;
    if (n && a.from < e)
      break;
    let o = a.type.prop(fe);
    if (o && (a.to < i.length - 50 || i.length == t.doc.length || !Ig(a))) {
      let c = o(a, t);
      c && c.from <= O && c.from >= e && c.to > O && (n = c);
    }
  }
  return n;
}
function Ig(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Qn(t, e, O) {
  for (let i of t.facet(y$)) {
    let r = i(t, e, O);
    if (r)
      return r;
  }
  return Ng(t, e, O);
}
function b$(t, e) {
  let O = e.mapPos(t.from, 1), i = e.mapPos(t.to, -1);
  return O >= i ? void 0 : { from: O, to: i };
}
const Un = /* @__PURE__ */ z.define({ map: b$ }), rr = /* @__PURE__ */ z.define({ map: b$ });
function x$(t) {
  let e = [];
  for (let { head: O } of t.state.selection.ranges)
    e.some((i) => i.from <= O && i.to >= O) || e.push(t.lineBlockAt(O));
  return e;
}
const pt = /* @__PURE__ */ pe.define({
  create() {
    return Z.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let O of e.effects)
      if (O.is(Un) && !Mg(t, O.value.from, O.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(k$), r = i ? Z.replace({ widget: new eS(i(e.state, O.value)) }) : Yc;
        t = t.update({ add: [r.range(O.value.from, O.value.to)] });
      } else O.is(rr) && (t = t.update({
        filter: (i, r) => O.value.from != i || O.value.to != r,
        filterFrom: O.value.from,
        filterTo: O.value.to
      }));
    if (e.selection) {
      let O = !1, { head: i } = e.selection.main;
      t.between(i, i, (r, n) => {
        r < i && n > i && (O = !0);
      }), O && (t = t.update({
        filterFrom: i,
        filterTo: i,
        filter: (r, n) => n <= i || r >= i
      }));
    }
    return t;
  },
  provide: (t) => k.decorations.from(t),
  toJSON(t, e) {
    let O = [];
    return t.between(0, e.doc.length, (i, r) => {
      O.push(i, r);
    }), O;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let O = 0; O < t.length; ) {
      let i = t[O++], r = t[O++];
      if (typeof i != "number" || typeof r != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Yc.range(i, r));
    }
    return Z.set(e, !0);
  }
});
function fn(t, e, O) {
  var i;
  let r = null;
  return (i = t.field(pt, !1)) === null || i === void 0 || i.between(e, O, (n, s) => {
    (!r || r.from > n) && (r = { from: n, to: s });
  }), r;
}
function Mg(t, e, O) {
  let i = !1;
  return t.between(e, e, (r, n) => {
    r == e && n == O && (i = !0);
  }), i;
}
function T$(t, e) {
  return t.field(pt, !1) ? e : e.concat(z.appendConfig.of(W$()));
}
const Lg = (t) => {
  for (let e of x$(t)) {
    let O = Qn(t.state, e.from, e.to);
    if (O)
      return t.dispatch({ effects: T$(t.state, [Un.of(O), w$(t, O)]) }), !0;
  }
  return !1;
}, Bg = (t) => {
  if (!t.state.field(pt, !1))
    return !1;
  let e = [];
  for (let O of x$(t)) {
    let i = fn(t.state, O.from, O.to);
    i && e.push(rr.of(i), w$(t, i, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function w$(t, e, O = !0) {
  let i = t.state.doc.lineAt(e.from).number, r = t.state.doc.lineAt(e.to).number;
  return k.announce.of(`${t.state.phrase(O ? "Folded lines" : "Unfolded lines")} ${i} ${t.state.phrase("to")} ${r}.`);
}
const Fg = (t) => {
  let { state: e } = t, O = [];
  for (let i = 0; i < e.doc.length; ) {
    let r = t.lineBlockAt(i), n = Qn(e, r.from, r.to);
    n && O.push(Un.of(n)), i = (n ? t.lineBlockAt(n.to) : r).to + 1;
  }
  return O.length && t.dispatch({ effects: T$(t.state, O) }), !!O.length;
}, Hg = (t) => {
  let e = t.state.field(pt, !1);
  if (!e || !e.size)
    return !1;
  let O = [];
  return e.between(0, t.state.doc.length, (i, r) => {
    O.push(rr.of({ from: i, to: r }));
  }), t.dispatch({ effects: O }), !0;
}, Kg = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Lg },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Bg },
  { key: "Ctrl-Alt-[", run: Fg },
  { key: "Ctrl-Alt-]", run: Hg }
], Jg = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "â€¦"
}, k$ = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, Jg);
  }
});
function W$(t) {
  return [pt, iS];
}
function R$(t, e) {
  let { state: O } = t, i = O.facet(k$), r = (s) => {
    let a = t.lineBlockAt(t.posAtDOM(s.target)), o = fn(t.state, a.from, a.to);
    o && t.dispatch({ effects: rr.of(o) }), s.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(t, r, e);
  let n = document.createElement("span");
  return n.textContent = i.placeholderText, n.setAttribute("aria-label", O.phrase("folded code")), n.title = O.phrase("unfold"), n.className = "cm-foldPlaceholder", n.onclick = r, n;
}
const Yc = /* @__PURE__ */ Z.replace({ widget: /* @__PURE__ */ new class extends VO {
  toDOM(t) {
    return R$(t, null);
  }
}() });
class eS extends VO {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return R$(e, this.value);
  }
}
const OS = {
  openText: "âŒ„",
  closedText: "â€º",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class as extends vO {
  constructor(e, O) {
    super(), this.config = e, this.open = O;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let O = document.createElement("span");
    return O.textContent = this.open ? this.config.openText : this.config.closedText, O.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), O;
  }
}
function tS(t = {}) {
  let e = Object.assign(Object.assign({}, OS), t), O = new as(e, !0), i = new as(e, !1), r = Qe.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(ZO) != s.state.facet(ZO) || s.startState.field(pt, !1) != s.state.field(pt, !1) || I(s.startState) != I(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new BO();
      for (let o of s.viewportLineBlocks) {
        let c = fn(s.state, o.from, o.to) ? i : Qn(s.state, o.from, o.to) ? O : null;
        c && a.add(o.from, o.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: n } = e;
  return [
    r,
    dg({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(r)) === null || a === void 0 ? void 0 : a.markers) || A.empty;
      },
      initialSpacer() {
        return new as(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, n), { click: (s, a, o) => {
        if (n.click && n.click(s, a, o))
          return !0;
        let c = fn(s.state, a.from, a.to);
        if (c)
          return s.dispatch({ effects: rr.of(c) }), !0;
        let h = Qn(s.state, a.from, a.to);
        return h ? (s.dispatch({ effects: Un.of(h) }), !0) : !1;
      } })
    }),
    W$()
  ];
}
const iS = /* @__PURE__ */ k.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class nr {
  constructor(e, O) {
    this.specs = e;
    let i;
    function r(a) {
      let o = FO.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + o] = a, o;
    }
    const n = typeof O.all == "string" ? O.all : O.all ? r(O.all) : void 0, s = O.scope;
    this.scope = s instanceof Je ? (a) => a.prop(lt) == s.data : s ? (a) => a == s : void 0, this.style = P$(e.map((a) => ({
      tag: a.tag,
      class: a.class || r(Object.assign({}, a, { tag: null }))
    })), {
      all: n
    }).style, this.module = i ? new FO(i) : null, this.themeType = O.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, O) {
    return new nr(e, O || {});
  }
}
const ba = /* @__PURE__ */ R.define(), v$ = /* @__PURE__ */ R.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function os(t) {
  let e = t.facet(ba);
  return e.length ? e : t.facet(v$);
}
function Z$(t, e) {
  let O = [nS], i;
  return t instanceof nr && (t.module && O.push(k.styleModule.of(t.module)), i = t.themeType), e != null && e.fallback ? O.push(v$.of(t)) : i ? O.push(ba.computeN([k.darkTheme], (r) => r.facet(k.darkTheme) == (i == "dark") ? [t] : [])) : O.push(ba.of(t)), O;
}
class rS {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = I(e.state), this.decorations = this.buildDeco(e, os(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let O = I(e.state), i = os(e.state), r = i != os(e.startState), { viewport: n } = e.view, s = e.changes.mapPos(this.decoratedTo, 1);
    O.length < n.to && !r && O.type == this.tree.type && s >= n.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = s) : (O != this.tree || e.viewportChanged || r) && (this.tree = O, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = n.to);
  }
  buildDeco(e, O) {
    if (!O || !this.tree.length)
      return Z.none;
    let i = new BO();
    for (let { from: r, to: n } of e.visibleRanges)
      vg(this.tree, O, (s, a, o) => {
        i.add(s, a, this.markCache[o] || (this.markCache[o] = Z.mark({ class: o })));
      }, r, n);
    return i.finish();
  }
}
const nS = /* @__PURE__ */ qO.high(/* @__PURE__ */ Qe.fromClass(rS, {
  decorations: (t) => t.decorations
})), sS = /* @__PURE__ */ nr.define([
  {
    tag: l.meta,
    color: "#404740"
  },
  {
    tag: l.link,
    textDecoration: "underline"
  },
  {
    tag: l.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: l.emphasis,
    fontStyle: "italic"
  },
  {
    tag: l.strong,
    fontWeight: "bold"
  },
  {
    tag: l.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: l.keyword,
    color: "#708"
  },
  {
    tag: [l.atom, l.bool, l.url, l.contentSeparator, l.labelName],
    color: "#219"
  },
  {
    tag: [l.literal, l.inserted],
    color: "#164"
  },
  {
    tag: [l.string, l.deleted],
    color: "#a11"
  },
  {
    tag: [l.regexp, l.escape, /* @__PURE__ */ l.special(l.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ l.definition(l.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ l.local(l.variableName),
    color: "#30a"
  },
  {
    tag: [l.typeName, l.namespace],
    color: "#085"
  },
  {
    tag: l.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ l.special(l.variableName), l.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ l.definition(l.propertyName),
    color: "#00c"
  },
  {
    tag: l.comment,
    color: "#940"
  },
  {
    tag: l.invalid,
    color: "#f00"
  }
]), aS = /* @__PURE__ */ k.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Y$ = 1e4, z$ = "()[]{}", q$ = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, {
      afterCursor: !0,
      brackets: z$,
      maxScanDistance: Y$,
      renderMatch: cS
    });
  }
}), oS = /* @__PURE__ */ Z.mark({ class: "cm-matchingBracket" }), lS = /* @__PURE__ */ Z.mark({ class: "cm-nonmatchingBracket" });
function cS(t) {
  let e = [], O = t.matched ? oS : lS;
  return e.push(O.range(t.start.from, t.start.to)), t.end && e.push(O.range(t.end.from, t.end.to)), e;
}
const hS = /* @__PURE__ */ pe.define({
  create() {
    return Z.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let O = [], i = e.state.facet(q$);
    for (let r of e.state.selection.ranges) {
      if (!r.empty)
        continue;
      let n = mO(e.state, r.head, -1, i) || r.head > 0 && mO(e.state, r.head - 1, 1, i) || i.afterCursor && (mO(e.state, r.head, 1, i) || r.head < e.state.doc.length && mO(e.state, r.head + 1, -1, i));
      n && (O = O.concat(i.renderMatch(n, e.state)));
    }
    return Z.set(O, !0);
  },
  provide: (t) => k.decorations.from(t)
}), QS = [
  hS,
  aS
];
function fS(t = {}) {
  return [q$.of(t), QS];
}
const Yo = /* @__PURE__ */ new Y();
function xa(t, e, O) {
  let i = t.prop(e < 0 ? Y.openedBy : Y.closedBy);
  if (i)
    return i;
  if (t.name.length == 1) {
    let r = O.indexOf(t.name);
    if (r > -1 && r % 2 == (e < 0 ? 1 : 0))
      return [O[r + e]];
  }
  return null;
}
function Ta(t) {
  let e = t.type.prop(Yo);
  return e ? e(t.node) : t;
}
function mO(t, e, O, i = {}) {
  let r = i.maxScanDistance || Y$, n = i.brackets || z$, s = I(t), a = s.resolveInner(e, O);
  for (let o = a; o; o = o.parent) {
    let c = xa(o.type, O, n);
    if (c && o.from < o.to) {
      let h = Ta(o);
      if (h && (O > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return $S(t, e, O, o, h, c, n);
    }
  }
  return uS(t, e, O, s, a.type, r, n);
}
function $S(t, e, O, i, r, n, s) {
  let a = i.parent, o = { from: r.from, to: r.to }, c = 0, h = a == null ? void 0 : a.cursor();
  if (h && (O < 0 ? h.childBefore(i.from) : h.childAfter(i.to)))
    do
      if (O < 0 ? h.to <= i.from : h.from >= i.to) {
        if (c == 0 && n.indexOf(h.type.name) > -1 && h.from < h.to) {
          let Q = Ta(h);
          return { start: o, end: Q ? { from: Q.from, to: Q.to } : void 0, matched: !0 };
        } else if (xa(h.type, O, s))
          c++;
        else if (xa(h.type, -O, s)) {
          if (c == 0) {
            let Q = Ta(h);
            return {
              start: o,
              end: Q && Q.from < Q.to ? { from: Q.from, to: Q.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (O < 0 ? h.prevSibling() : h.nextSibling());
  return { start: o, matched: !1 };
}
function uS(t, e, O, i, r, n, s) {
  let a = O < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), o = s.indexOf(a);
  if (o < 0 || o % 2 == 0 != O > 0)
    return null;
  let c = { from: O < 0 ? e - 1 : e, to: O > 0 ? e + 1 : e }, h = t.doc.iterRange(e, O > 0 ? t.doc.length : 0), Q = 0;
  for (let f = 0; !h.next().done && f <= n; ) {
    let $ = h.value;
    O < 0 && (f += $.length);
    let u = e + f * O;
    for (let d = O > 0 ? 0 : $.length - 1, p = O > 0 ? $.length : -1; d != p; d += O) {
      let m = s.indexOf($[d]);
      if (!(m < 0 || i.resolveInner(u + d, 1).type != r))
        if (m % 2 == 0 == O > 0)
          Q++;
        else {
          if (Q == 1)
            return { start: c, end: { from: u + d, to: u + d + 1 }, matched: m >> 1 == o >> 1 };
          Q--;
        }
    }
    O > 0 && (f += $.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const dS = /* @__PURE__ */ Object.create(null), zc = [de.none], qc = [], Uc = /* @__PURE__ */ Object.create(null), pS = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  pS[t] = /* @__PURE__ */ mS(dS, e);
function ls(t, e) {
  qc.indexOf(t) > -1 || (qc.push(t), console.warn(e));
}
function mS(t, e) {
  let O = [];
  for (let a of e.split(" ")) {
    let o = [];
    for (let c of a.split(".")) {
      let h = t[c] || l[c];
      h ? typeof h == "function" ? o.length ? o = o.map(h) : ls(c, `Modifier ${c} used at start of tag`) : o.length ? ls(c, `Tag ${c} used as modifier`) : o = Array.isArray(h) ? h : [h] : ls(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of o)
      O.push(c);
  }
  if (!O.length)
    return 0;
  let i = e.replace(/ /g, "_"), r = i + " " + O.map((a) => a.id), n = Uc[r];
  if (n)
    return n.id;
  let s = Uc[r] = de.define({
    id: zc.length,
    name: i,
    props: [se({ [i]: O })]
  });
  return zc.push(s), s.id;
}
Oe.RTL, Oe.LTR;
var Vc = 1024 * 1024;
function PS(t, e, O) {
  let i, r = 0;
  return new ReadableStream({
    async start() {
      i = await t.open(e, 1, 2, void 0, { signal: O });
    },
    async pull(s) {
      try {
        const a = await t.read(i, r, Vc, { signal: O });
        r += Vc, a.byteLength > 0 ? s.enqueue(a) : s.close();
      } catch {
        s.close();
      }
    },
    async cancel() {
      t.close(i);
    }
  });
}
async function gS(t) {
  const e = t.getReader(), O = [];
  let i = 0;
  for (; ; ) {
    const { done: s, value: a } = await e.read();
    if (s)
      break;
    a && (O.push(a), i += a.length);
  }
  const r = new Uint8Array(i);
  let n = 0;
  for (const s of O)
    r.set(s, n), n += s.length;
  return r;
}
async function SS(t, e) {
  const O = PS(faraday.fs, t, e == null ? void 0 : e.signal);
  return gS(O);
}
const XS = (t) => {
  let { state: e } = t, O = e.doc.lineAt(e.selection.main.from), i = qo(t.state, O.from);
  return i.line ? yS(t) : i.block ? xS(t) : !1;
};
function zo(t, e) {
  return ({ state: O, dispatch: i }) => {
    if (O.readOnly)
      return !1;
    let r = t(e, O);
    return r ? (i(O.update(r)), !0) : !1;
  };
}
const yS = /* @__PURE__ */ zo(
  kS,
  0
  /* CommentOption.Toggle */
), bS = /* @__PURE__ */ zo(
  U$,
  0
  /* CommentOption.Toggle */
), xS = /* @__PURE__ */ zo(
  (t, e) => U$(t, e, wS(e)),
  0
  /* CommentOption.Toggle */
);
function qo(t, e) {
  let O = t.languageDataAt("commentTokens", e);
  return O.length ? O[0] : {};
}
const ii = 50;
function TS(t, { open: e, close: O }, i, r) {
  let n = t.sliceDoc(i - ii, i), s = t.sliceDoc(r, r + ii), a = /\s*$/.exec(n)[0].length, o = /^\s*/.exec(s)[0].length, c = n.length - a;
  if (n.slice(c - e.length, c) == e && s.slice(o, o + O.length) == O)
    return {
      open: { pos: i - a, margin: a && 1 },
      close: { pos: r + o, margin: o && 1 }
    };
  let h, Q;
  r - i <= 2 * ii ? h = Q = t.sliceDoc(i, r) : (h = t.sliceDoc(i, i + ii), Q = t.sliceDoc(r - ii, r));
  let f = /^\s*/.exec(h)[0].length, $ = /\s*$/.exec(Q)[0].length, u = Q.length - $ - O.length;
  return h.slice(f, f + e.length) == e && Q.slice(u, u + O.length) == O ? {
    open: {
      pos: i + f + e.length,
      margin: /\s/.test(h.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: r - $ - O.length,
      margin: /\s/.test(Q.charAt(u - 1)) ? 1 : 0
    }
  } : null;
}
function wS(t) {
  let e = [];
  for (let O of t.selection.ranges) {
    let i = t.doc.lineAt(O.from), r = O.to <= i.to ? i : t.doc.lineAt(O.to), n = e.length - 1;
    n >= 0 && e[n].to > i.from ? e[n].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return e;
}
function U$(t, e, O = e.selection.ranges) {
  let i = O.map((n) => qo(e, n.from).block);
  if (!i.every((n) => n))
    return null;
  let r = O.map((n, s) => TS(e, i[s], n.from, n.to));
  if (t != 2 && !r.every((n) => n))
    return { changes: e.changes(O.map((n, s) => r[s] ? [] : [{ from: n.from, insert: i[s].open + " " }, { from: n.to, insert: " " + i[s].close }])) };
  if (t != 1 && r.some((n) => n)) {
    let n = [];
    for (let s = 0, a; s < r.length; s++)
      if (a = r[s]) {
        let o = i[s], { open: c, close: h } = a;
        n.push({ from: c.pos - o.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + o.close.length });
      }
    return { changes: n };
  }
  return null;
}
function kS(t, e, O = e.selection.ranges) {
  let i = [], r = -1;
  for (let { from: n, to: s } of O) {
    let a = i.length, o = 1e9, c = qo(e, n).line;
    if (c) {
      for (let h = n; h <= s; ) {
        let Q = e.doc.lineAt(h);
        if (Q.from > r && (n == s || s > Q.from)) {
          r = Q.from;
          let f = /^\s*/.exec(Q.text)[0].length, $ = f == Q.length, u = Q.text.slice(f, f + c.length) == c ? f : -1;
          f < Q.text.length && f < o && (o = f), i.push({ line: Q, comment: u, token: c, indent: f, empty: $, single: !1 });
        }
        h = Q.to + 1;
      }
      if (o < 1e9)
        for (let h = a; h < i.length; h++)
          i[h].indent < i[h].line.text.length && (i[h].indent = o);
      i.length == a + 1 && (i[a].single = !0);
    }
  }
  if (t != 2 && i.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: a, token: o, indent: c, empty: h, single: Q } of i)
      (Q || !h) && n.push({ from: a.from + c, insert: o + " " });
    let s = e.changes(n);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (t != 1 && i.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: s, comment: a, token: o } of i)
      if (a >= 0) {
        let c = s.from + a, h = c + o.length;
        s.text[h - s.from] == " " && h++, n.push({ from: c, to: h });
      }
    return { changes: n };
  }
  return null;
}
const wa = /* @__PURE__ */ UO.define(), WS = /* @__PURE__ */ UO.define(), RS = /* @__PURE__ */ R.define(), V$ = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, O) => O
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, O) => (i, r) => e(i, r) || O(i, r)
    });
  }
}), _$ = /* @__PURE__ */ pe.define({
  create() {
    return PO.empty;
  },
  update(t, e) {
    let O = e.state.facet(V$), i = e.annotation(wa);
    if (i) {
      let o = Ve.fromTransaction(e, i.selection), c = i.side, h = c == 0 ? t.undone : t.done;
      return o ? h = $n(h, h.length, O.minDepth, o) : h = C$(h, e.startState.selection), new PO(c == 0 ? i.rest : h, c == 0 ? h : i.rest);
    }
    let r = e.annotation(WS);
    if ((r == "full" || r == "before") && (t = t.isolate()), e.annotation(he.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let n = Ve.fromTransaction(e), s = e.annotation(he.time), a = e.annotation(he.userEvent);
    return n ? t = t.addChanges(n, s, a, O, e) : e.selection && (t = t.addSelection(e.startState.selection, s, a, O.newGroupDelay)), (r == "full" || r == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new PO(t.done.map(Ve.fromJSON), t.undone.map(Ve.fromJSON));
  }
});
function vS(t = {}) {
  return [
    _$,
    V$.of(t),
    k.domEventHandlers({
      beforeinput(e, O) {
        let i = e.inputType == "historyUndo" ? j$ : e.inputType == "historyRedo" ? ka : null;
        return i ? (e.preventDefault(), i(O)) : !1;
      }
    })
  ];
}
function Vn(t, e) {
  return function({ state: O, dispatch: i }) {
    if (!e && O.readOnly)
      return !1;
    let r = O.field(_$, !1);
    if (!r)
      return !1;
    let n = r.pop(t, O, e);
    return n ? (i(n), !0) : !1;
  };
}
const j$ = /* @__PURE__ */ Vn(0, !1), ka = /* @__PURE__ */ Vn(1, !1), ZS = /* @__PURE__ */ Vn(0, !0), YS = /* @__PURE__ */ Vn(1, !0);
class Ve {
  constructor(e, O, i, r, n) {
    this.changes = e, this.effects = O, this.mapped = i, this.startSelection = r, this.selectionsAfter = n;
  }
  setSelAfter(e) {
    return new Ve(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, O, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (O = this.mapped) === null || O === void 0 ? void 0 : O.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(e) {
    return new Ve(e.changes && ue.fromJSON(e.changes), [], e.mapped && gO.fromJSON(e.mapped), e.startSelection && g.fromJSON(e.startSelection), e.selectionsAfter.map(g.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, O) {
    let i = eO;
    for (let r of e.startState.facet(RS)) {
      let n = r(e);
      n.length && (i = i.concat(n));
    }
    return !i.length && e.changes.empty ? null : new Ve(e.changes.invert(e.startState.doc), i, void 0, O || e.startState.selection, eO);
  }
  static selection(e) {
    return new Ve(void 0, eO, void 0, void 0, e);
  }
}
function $n(t, e, O, i) {
  let r = e + 1 > O + 20 ? e - O - 1 : 0, n = t.slice(r, e);
  return n.push(i), n;
}
function zS(t, e) {
  let O = [], i = !1;
  return t.iterChangedRanges((r, n) => O.push(r, n)), e.iterChangedRanges((r, n, s, a) => {
    for (let o = 0; o < O.length; ) {
      let c = O[o++], h = O[o++];
      a >= c && s <= h && (i = !0);
    }
  }), i;
}
function qS(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((O, i) => O.empty != e.ranges[i].empty).length === 0;
}
function G$(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const eO = [], US = 200;
function C$(t, e) {
  if (t.length) {
    let O = t[t.length - 1], i = O.selectionsAfter.slice(Math.max(0, O.selectionsAfter.length - US));
    return i.length && i[i.length - 1].eq(e) ? t : (i.push(e), $n(t, t.length - 1, 1e9, O.setSelAfter(i)));
  } else
    return [Ve.selection([e])];
}
function VS(t) {
  let e = t[t.length - 1], O = t.slice();
  return O[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), O;
}
function cs(t, e) {
  if (!t.length)
    return t;
  let O = t.length, i = eO;
  for (; O; ) {
    let r = _S(t[O - 1], e, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let n = t.slice(0, O);
      return n[O - 1] = r, n;
    } else
      e = r.mapped, O--, i = r.selectionsAfter;
  }
  return i.length ? [Ve.selection(i)] : eO;
}
function _S(t, e, O) {
  let i = G$(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : eO, O);
  if (!t.changes)
    return Ve.selection(i);
  let r = t.changes.map(e), n = e.mapDesc(t.changes, !0), s = t.mapped ? t.mapped.composeDesc(n) : n;
  return new Ve(r, z.mapEffects(t.effects, e), s, t.startSelection.map(n), i);
}
const jS = /^(input\.type|delete)($|\.)/;
class PO {
  constructor(e, O, i = 0, r = void 0) {
    this.done = e, this.undone = O, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new PO(this.done, this.undone) : this;
  }
  addChanges(e, O, i, r, n) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!i || jS.test(i)) && (!a.selectionsAfter.length && O - this.prevTime < r.newGroupDelay && r.joinToEvent(n, zS(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? s = $n(s, s.length - 1, r.minDepth, new Ve(e.changes.compose(a.changes), G$(e.effects, a.effects), a.mapped, a.startSelection, eO)) : s = $n(s, s.length, r.minDepth, e), new PO(s, eO, O, i);
  }
  addSelection(e, O, i, r) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : eO;
    return n.length > 0 && O - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && qS(n[n.length - 1], e) ? this : new PO(C$(this.done, e), this.undone, O, i);
  }
  addMapping(e) {
    return new PO(cs(this.done, e), cs(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, O, i) {
    let r = e == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let n = r[r.length - 1], s = n.selectionsAfter[0] || O.selection;
    if (i && n.selectionsAfter.length)
      return O.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: wa.of({ side: e, rest: VS(r), selection: s }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let a = r.length == 1 ? eO : r.slice(0, r.length - 1);
      return n.mapped && (a = cs(a, n.mapped)), O.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: wa.of({ side: e, rest: a, selection: s }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
PO.empty = /* @__PURE__ */ new PO(eO, eO);
const GS = [
  { key: "Mod-z", run: j$, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: ka, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: ka, preventDefault: !0 },
  { key: "Mod-u", run: ZS, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: YS, preventDefault: !0 }
];
function Mt(t, e) {
  return g.create(t.ranges.map(e), t.mainIndex);
}
function yO(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function lO({ state: t, dispatch: e }, O) {
  let i = Mt(t.selection, O);
  return i.eq(t.selection, !0) ? !1 : (e(yO(t, i)), !0);
}
function _n(t, e) {
  return g.cursor(e ? t.to : t.from);
}
function E$(t, e) {
  return lO(t, (O) => O.empty ? t.moveByChar(O, e) : _n(O, e));
}
function ke(t) {
  return t.textDirectionAt(t.state.selection.main.head) == Oe.LTR;
}
const A$ = (t) => E$(t, !ke(t)), D$ = (t) => E$(t, ke(t));
function N$(t, e) {
  return lO(t, (O) => O.empty ? t.moveByGroup(O, e) : _n(O, e));
}
const CS = (t) => N$(t, !ke(t)), ES = (t) => N$(t, ke(t));
function AS(t, e, O) {
  if (e.type.prop(O))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function jn(t, e, O) {
  let i = I(t).resolveInner(e.head), r = O ? Y.closedBy : Y.openedBy;
  for (let o = e.head; ; ) {
    let c = O ? i.childAfter(o) : i.childBefore(o);
    if (!c)
      break;
    AS(t, c, r) ? i = c : o = O ? c.to : c.from;
  }
  let n = i.type.prop(r), s, a;
  return n && (s = O ? mO(t, i.from, 1) : mO(t, i.to, -1)) && s.matched ? a = O ? s.end.to : s.end.from : a = O ? i.to : i.from, g.cursor(a, O ? -1 : 1);
}
const DS = (t) => lO(t, (e) => jn(t.state, e, !ke(t))), NS = (t) => lO(t, (e) => jn(t.state, e, ke(t)));
function I$(t, e) {
  return lO(t, (O) => {
    if (!O.empty)
      return _n(O, e);
    let i = t.moveVertically(O, e);
    return i.head != O.head ? i : t.moveToLineBoundary(O, e);
  });
}
const M$ = (t) => I$(t, !1), L$ = (t) => I$(t, !0);
function B$(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, O = 0, i = 0, r;
  if (e) {
    for (let n of t.state.facet(k.scrollMargins)) {
      let s = n(t);
      s != null && s.top && (O = Math.max(s == null ? void 0 : s.top, O)), s != null && s.bottom && (i = Math.max(s == null ? void 0 : s.bottom, i));
    }
    r = t.scrollDOM.clientHeight - O - i;
  } else
    r = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: O,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, r - 5)
  };
}
function F$(t, e) {
  let O = B$(t), { state: i } = t, r = Mt(i.selection, (s) => s.empty ? t.moveVertically(s, e, O.height) : _n(s, e));
  if (r.eq(i.selection))
    return !1;
  let n;
  if (O.selfScroll) {
    let s = t.coordsAtPos(i.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), o = a.top + O.marginTop, c = a.bottom - O.marginBottom;
    s && s.top > o && s.bottom < c && (n = k.scrollIntoView(r.main.head, { y: "start", yMargin: s.top - o }));
  }
  return t.dispatch(yO(i, r), { effects: n }), !0;
}
const _c = (t) => F$(t, !1), Wa = (t) => F$(t, !0);
function JO(t, e, O) {
  let i = t.lineBlockAt(e.head), r = t.moveToLineBoundary(e, O);
  if (r.head == e.head && r.head != (O ? i.to : i.from) && (r = t.moveToLineBoundary(e, O, !1)), !O && r.head == i.from && i.length) {
    let n = /^\s*/.exec(t.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    n && e.head != i.from + n && (r = g.cursor(i.from + n));
  }
  return r;
}
const IS = (t) => lO(t, (e) => JO(t, e, !0)), MS = (t) => lO(t, (e) => JO(t, e, !1)), LS = (t) => lO(t, (e) => JO(t, e, !ke(t))), BS = (t) => lO(t, (e) => JO(t, e, ke(t))), FS = (t) => lO(t, (e) => g.cursor(t.lineBlockAt(e.head).from, 1)), HS = (t) => lO(t, (e) => g.cursor(t.lineBlockAt(e.head).to, -1));
function KS(t, e, O) {
  let i = !1, r = Mt(t.selection, (n) => {
    let s = mO(t, n.head, -1) || mO(t, n.head, 1) || n.head > 0 && mO(t, n.head - 1, 1) || n.head < t.doc.length && mO(t, n.head + 1, -1);
    if (!s || !s.end)
      return n;
    i = !0;
    let a = s.start.from == n.head ? s.end.to : s.end.from;
    return g.cursor(a);
  });
  return i ? (e(yO(t, r)), !0) : !1;
}
const JS = ({ state: t, dispatch: e }) => KS(t, e);
function iO(t, e) {
  let O = Mt(t.state.selection, (i) => {
    let r = e(i);
    return g.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return O.eq(t.state.selection) ? !1 : (t.dispatch(yO(t.state, O)), !0);
}
function H$(t, e) {
  return iO(t, (O) => t.moveByChar(O, e));
}
const K$ = (t) => H$(t, !ke(t)), J$ = (t) => H$(t, ke(t));
function eu(t, e) {
  return iO(t, (O) => t.moveByGroup(O, e));
}
const eX = (t) => eu(t, !ke(t)), OX = (t) => eu(t, ke(t)), tX = (t) => iO(t, (e) => jn(t.state, e, !ke(t))), iX = (t) => iO(t, (e) => jn(t.state, e, ke(t)));
function Ou(t, e) {
  return iO(t, (O) => t.moveVertically(O, e));
}
const tu = (t) => Ou(t, !1), iu = (t) => Ou(t, !0);
function ru(t, e) {
  return iO(t, (O) => t.moveVertically(O, e, B$(t).height));
}
const jc = (t) => ru(t, !1), Gc = (t) => ru(t, !0), rX = (t) => iO(t, (e) => JO(t, e, !0)), nX = (t) => iO(t, (e) => JO(t, e, !1)), sX = (t) => iO(t, (e) => JO(t, e, !ke(t))), aX = (t) => iO(t, (e) => JO(t, e, ke(t))), oX = (t) => iO(t, (e) => g.cursor(t.lineBlockAt(e.head).from)), lX = (t) => iO(t, (e) => g.cursor(t.lineBlockAt(e.head).to)), Cc = ({ state: t, dispatch: e }) => (e(yO(t, { anchor: 0 })), !0), Ec = ({ state: t, dispatch: e }) => (e(yO(t, { anchor: t.doc.length })), !0), Ac = ({ state: t, dispatch: e }) => (e(yO(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Dc = ({ state: t, dispatch: e }) => (e(yO(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), cX = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), hX = ({ state: t, dispatch: e }) => {
  let O = Gn(t).map(({ from: i, to: r }) => g.range(i, Math.min(r + 1, t.doc.length)));
  return e(t.update({ selection: g.create(O), userEvent: "select" })), !0;
}, QX = ({ state: t, dispatch: e }) => {
  let O = Mt(t.selection, (i) => {
    var r;
    let n = I(t).resolveStack(i.from, 1);
    for (let s = n; s; s = s.next) {
      let { node: a } = s;
      if ((a.from < i.from && a.to >= i.to || a.to > i.to && a.from <= i.from) && (!((r = a.parent) === null || r === void 0) && r.parent))
        return g.range(a.to, a.from);
    }
    return i;
  });
  return e(yO(t, O)), !0;
}, fX = ({ state: t, dispatch: e }) => {
  let O = t.selection, i = null;
  return O.ranges.length > 1 ? i = g.create([O.main]) : O.main.empty || (i = g.create([g.cursor(O.main.head)])), i ? (e(yO(t, i)), !0) : !1;
};
function sr(t, e) {
  if (t.state.readOnly)
    return !1;
  let O = "delete.selection", { state: i } = t, r = i.changeByRange((n) => {
    let { from: s, to: a } = n;
    if (s == a) {
      let o = e(n);
      o < s ? (O = "delete.backward", o = kr(t, o, !1)) : o > s && (O = "delete.forward", o = kr(t, o, !0)), s = Math.min(s, o), a = Math.max(a, o);
    } else
      s = kr(t, s, !1), a = kr(t, a, !0);
    return s == a ? { range: n } : { changes: { from: s, to: a }, range: g.cursor(s, s < n.head ? -1 : 1) };
  });
  return r.changes.empty ? !1 : (t.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: O,
    effects: O == "delete.selection" ? k.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function kr(t, e, O) {
  if (t instanceof k)
    for (let i of t.state.facet(k.atomicRanges).map((r) => r(t)))
      i.between(e, e, (r, n) => {
        r < e && n > e && (e = O ? n : r);
      });
  return e;
}
const nu = (t, e, O) => sr(t, (i) => {
  let r = i.from, { state: n } = t, s = n.doc.lineAt(r), a, o;
  if (O && !e && r > s.from && r < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, r - s.from))) {
    if (a[a.length - 1] == "	")
      return r - 1;
    let c = sO(a, n.tabSize), h = c % hn(n) || hn(n);
    for (let Q = 0; Q < h && a[a.length - 1 - Q] == " "; Q++)
      r--;
    o = r;
  } else
    o = be(s.text, r - s.from, e, e) + s.from, o == r && s.number != (e ? n.doc.lines : 1) ? o += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(o - s.from, r - s.from)) && (o = be(s.text, o - s.from, !1, !1) + s.from);
  return o;
}), Ra = (t) => nu(t, !1, !0), su = (t) => nu(t, !0, !1), au = (t, e) => sr(t, (O) => {
  let i = O.head, { state: r } = t, n = r.doc.lineAt(i), s = r.charCategorizer(i);
  for (let a = null; ; ) {
    if (i == (e ? n.to : n.from)) {
      i == O.head && n.number != (e ? r.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let o = be(n.text, i - n.from, e) + n.from, c = n.text.slice(Math.min(i, o) - n.from, Math.max(i, o) - n.from), h = s(c);
    if (a != null && h != a)
      break;
    (c != " " || i != O.head) && (a = h), i = o;
  }
  return i;
}), ou = (t) => au(t, !1), $X = (t) => au(t, !0), uX = (t) => sr(t, (e) => {
  let O = t.lineBlockAt(e.head).to;
  return e.head < O ? O : Math.min(t.state.doc.length, e.head + 1);
}), dX = (t) => sr(t, (e) => {
  let O = t.moveToLineBoundary(e, !1).head;
  return e.head > O ? O : Math.max(0, e.head - 1);
}), pX = (t) => sr(t, (e) => {
  let O = t.moveToLineBoundary(e, !0).head;
  return e.head < O ? O : Math.min(t.state.doc.length, e.head + 1);
}), mX = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let O = t.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: N.of(["", ""]) },
    range: g.cursor(i.from)
  }));
  return e(t.update(O, { scrollIntoView: !0, userEvent: "input" })), !0;
}, PX = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let O = t.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == t.doc.length)
      return { range: i };
    let r = i.from, n = t.doc.lineAt(r), s = r == n.from ? r - 1 : be(n.text, r - n.from, !1) + n.from, a = r == n.to ? r + 1 : be(n.text, r - n.from, !0) + n.from;
    return {
      changes: { from: s, to: a, insert: t.doc.slice(r, a).append(t.doc.slice(s, r)) },
      range: g.cursor(a)
    };
  });
  return O.changes.empty ? !1 : (e(t.update(O, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Gn(t) {
  let e = [], O = -1;
  for (let i of t.selection.ranges) {
    let r = t.doc.lineAt(i.from), n = t.doc.lineAt(i.to);
    if (!i.empty && i.to == n.from && (n = t.doc.lineAt(i.to - 1)), O >= r.number) {
      let s = e[e.length - 1];
      s.to = n.to, s.ranges.push(i);
    } else
      e.push({ from: r.from, to: n.to, ranges: [i] });
    O = n.number + 1;
  }
  return e;
}
function lu(t, e, O) {
  if (t.readOnly)
    return !1;
  let i = [], r = [];
  for (let n of Gn(t)) {
    if (O ? n.to == t.doc.length : n.from == 0)
      continue;
    let s = t.doc.lineAt(O ? n.to + 1 : n.from - 1), a = s.length + 1;
    if (O) {
      i.push({ from: n.to, to: s.to }, { from: n.from, insert: s.text + t.lineBreak });
      for (let o of n.ranges)
        r.push(g.range(Math.min(t.doc.length, o.anchor + a), Math.min(t.doc.length, o.head + a)));
    } else {
      i.push({ from: s.from, to: n.from }, { from: n.to, insert: t.lineBreak + s.text });
      for (let o of n.ranges)
        r.push(g.range(o.anchor - a, o.head - a));
    }
  }
  return i.length ? (e(t.update({
    changes: i,
    scrollIntoView: !0,
    selection: g.create(r, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const gX = ({ state: t, dispatch: e }) => lu(t, e, !1), SX = ({ state: t, dispatch: e }) => lu(t, e, !0);
function cu(t, e, O) {
  if (t.readOnly)
    return !1;
  let i = [];
  for (let r of Gn(t))
    O ? i.push({ from: r.from, insert: t.doc.slice(r.from, r.to) + t.lineBreak }) : i.push({ from: r.to, insert: t.lineBreak + t.doc.slice(r.from, r.to) });
  return e(t.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const XX = ({ state: t, dispatch: e }) => cu(t, e, !1), yX = ({ state: t, dispatch: e }) => cu(t, e, !0), bX = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, O = e.changes(Gn(e).map(({ from: r, to: n }) => (r > 0 ? r-- : n < e.doc.length && n++, { from: r, to: n }))), i = Mt(e.selection, (r) => {
    let n;
    if (t.lineWrapping) {
      let s = t.lineBlockAt(r.head), a = t.coordsAtPos(r.head, r.assoc || 1);
      a && (n = s.bottom + t.documentTop - a.bottom + t.defaultLineHeight / 2);
    }
    return t.moveVertically(r, !0, n);
  }).map(O);
  return t.dispatch({ changes: O, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function xX(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let O = I(t).resolveInner(e), i = O.childBefore(e), r = O.childAfter(e), n;
  return i && r && i.to <= e && r.from >= e && (n = i.type.prop(Y.closedBy)) && n.indexOf(r.name) > -1 && t.doc.lineAt(i.to).from == t.doc.lineAt(r.from).from && !/\S/.test(t.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
const TX = /* @__PURE__ */ hu(!1), wX = /* @__PURE__ */ hu(!0);
function hu(t) {
  return ({ state: e, dispatch: O }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((r) => {
      let { from: n, to: s } = r, a = e.doc.lineAt(n), o = !t && n == s && xX(e, n);
      t && (n = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let c = new zn(e, { simulateBreak: n, simulateDoubleBreak: !!o }), h = vo(c, n);
      for (h == null && (h = sO(/^\s*/.exec(e.doc.lineAt(n).text)[0], e.tabSize)); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      o ? { from: n, to: s } = o : n > a.from && n < a.from + 100 && !/\S/.test(a.text.slice(0, n)) && (n = a.from);
      let Q = ["", Vi(e, h)];
      return o && Q.push(Vi(e, c.lineIndent(a.from, -1))), {
        changes: { from: n, to: s, insert: N.of(Q) },
        range: g.cursor(n + 1 + Q[1].length)
      };
    });
    return O(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Uo(t, e) {
  let O = -1;
  return t.changeByRange((i) => {
    let r = [];
    for (let s = i.from; s <= i.to; ) {
      let a = t.doc.lineAt(s);
      a.number > O && (i.empty || i.to > a.from) && (e(a, r, i), O = a.number), s = a.to + 1;
    }
    let n = t.changes(r);
    return {
      changes: r,
      range: g.range(n.mapPos(i.anchor, 1), n.mapPos(i.head, 1))
    };
  });
}
const kX = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let O = /* @__PURE__ */ Object.create(null), i = new zn(t, { overrideIndentation: (n) => {
    let s = O[n];
    return s ?? -1;
  } }), r = Uo(t, (n, s, a) => {
    let o = vo(i, n.from);
    if (o == null)
      return;
    /\S/.test(n.text) || (o = 0);
    let c = /^\s*/.exec(n.text)[0], h = Vi(t, o);
    (c != h || a.from < n.from + c.length) && (O[n.from] = o, s.push({ from: n.from, to: n.from + c.length, insert: h }));
  });
  return r.changes.empty || e(t.update(r, { userEvent: "indent" })), !0;
}, WX = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Uo(t, (O, i) => {
  i.push({ from: O.from, insert: t.facet(ir) });
}), { userEvent: "input.indent" })), !0), RX = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Uo(t, (O, i) => {
  let r = /^\s*/.exec(O.text)[0];
  if (!r)
    return;
  let n = sO(r, t.tabSize), s = 0, a = Vi(t, Math.max(0, n - hn(t)));
  for (; s < r.length && s < a.length && r.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  i.push({ from: O.from + s, to: O.from + r.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), !0), vX = (t) => (t.setTabFocusMode(), !0), ZX = [
  { key: "Ctrl-b", run: A$, shift: K$, preventDefault: !0 },
  { key: "Ctrl-f", run: D$, shift: J$ },
  { key: "Ctrl-p", run: M$, shift: tu },
  { key: "Ctrl-n", run: L$, shift: iu },
  { key: "Ctrl-a", run: FS, shift: oX },
  { key: "Ctrl-e", run: HS, shift: lX },
  { key: "Ctrl-d", run: su },
  { key: "Ctrl-h", run: Ra },
  { key: "Ctrl-k", run: uX },
  { key: "Ctrl-Alt-h", run: ou },
  { key: "Ctrl-o", run: mX },
  { key: "Ctrl-t", run: PX },
  { key: "Ctrl-v", run: Wa }
], YX = /* @__PURE__ */ [
  { key: "ArrowLeft", run: A$, shift: K$, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: CS, shift: eX, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: LS, shift: sX, preventDefault: !0 },
  { key: "ArrowRight", run: D$, shift: J$, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: ES, shift: OX, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: BS, shift: aX, preventDefault: !0 },
  { key: "ArrowUp", run: M$, shift: tu, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Cc, shift: Ac },
  { mac: "Ctrl-ArrowUp", run: _c, shift: jc },
  { key: "ArrowDown", run: L$, shift: iu, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Ec, shift: Dc },
  { mac: "Ctrl-ArrowDown", run: Wa, shift: Gc },
  { key: "PageUp", run: _c, shift: jc },
  { key: "PageDown", run: Wa, shift: Gc },
  { key: "Home", run: MS, shift: nX, preventDefault: !0 },
  { key: "Mod-Home", run: Cc, shift: Ac },
  { key: "End", run: IS, shift: rX, preventDefault: !0 },
  { key: "Mod-End", run: Ec, shift: Dc },
  { key: "Enter", run: TX },
  { key: "Mod-a", run: cX },
  { key: "Backspace", run: Ra, shift: Ra },
  { key: "Delete", run: su },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: ou },
  { key: "Mod-Delete", mac: "Alt-Delete", run: $X },
  { mac: "Mod-Backspace", run: dX },
  { mac: "Mod-Delete", run: pX }
].concat(/* @__PURE__ */ ZX.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), zX = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: DS, shift: tX },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: NS, shift: iX },
  { key: "Alt-ArrowUp", run: gX },
  { key: "Shift-Alt-ArrowUp", run: XX },
  { key: "Alt-ArrowDown", run: SX },
  { key: "Shift-Alt-ArrowDown", run: yX },
  { key: "Escape", run: fX },
  { key: "Mod-Enter", run: wX },
  { key: "Alt-l", mac: "Ctrl-l", run: hX },
  { key: "Mod-i", run: QX, preventDefault: !0 },
  { key: "Mod-[", run: RX },
  { key: "Mod-]", run: WX },
  { key: "Mod-Alt-\\", run: kX },
  { key: "Shift-Mod-k", run: bX },
  { key: "Shift-Mod-\\", run: JS },
  { key: "Mod-/", run: XS },
  { key: "Alt-A", run: bS },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: vX }
].concat(YX);
function J() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, O = arguments[1];
  if (O && typeof O == "object" && O.nodeType == null && !Array.isArray(O)) {
    for (var i in O) if (Object.prototype.hasOwnProperty.call(O, i)) {
      var r = O[i];
      typeof r == "string" ? t.setAttribute(i, r) : r != null && (t[i] = r);
    }
    e++;
  }
  for (; e < arguments.length; e++) Qu(t, arguments[e]);
  return t;
}
function Qu(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    t.appendChild(e);
  else if (Array.isArray(e))
    for (var O = 0; O < e.length; O++) Qu(t, e[O]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
const Nc = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class Ct {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, O, i = 0, r = e.length, n, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, r), this.bufferStart = i, this.normalize = n ? (a) => n(Nc(a)) : Nc, this.query = this.normalize(O);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return ge(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let O = $o(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Fe(e);
      let r = this.normalize(O);
      for (let n = 0, s = i; ; n++) {
        let a = r.charCodeAt(n), o = this.match(a, s, this.bufferPos + this.bufferStart);
        if (n == r.length - 1) {
          if (o)
            return this.value = o, this;
          break;
        }
        s == i && n < O.length && O.charCodeAt(n) == a && s++;
      }
    }
  }
  match(e, O, i) {
    let r = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let s = this.matches[n], a = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? r = { from: this.matches[n + 1], to: i } : (this.matches[n]++, a = !0)), a || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: O, to: i } : this.matches.push(1, O)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && (Ct.prototype[Symbol.iterator] = function() {
  return this;
});
const fu = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Vo = "gm" + (/x/.unicode == null ? "" : "u");
class $u {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, O, i, r = 0, n = e.length) {
    if (this.text = e, this.to = n, this.curLine = "", this.done = !1, this.value = fu, /\\[sWDnr]|\n|\r|\[\^/.test(O))
      return new uu(e, O, i, r, n);
    this.re = new RegExp(O, Vo + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let s = e.lineAt(r);
    this.curLineStart = s.from, this.matchPos = un(e, r), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let O = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (O) {
        let i = this.curLineStart + O.index, r = i + O[0].length;
        if (this.matchPos = un(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, O)))
          return this.value = { from: i, to: r, match: O }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const hs = /* @__PURE__ */ new WeakMap();
class Yt {
  constructor(e, O) {
    this.from = e, this.text = O;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, O, i) {
    let r = hs.get(e);
    if (!r || r.from >= i || r.to <= O) {
      let a = new Yt(O, e.sliceString(O, i));
      return hs.set(e, a), a;
    }
    if (r.from == O && r.to == i)
      return r;
    let { text: n, from: s } = r;
    return s > O && (n = e.sliceString(O, s) + n, s = O), r.to < i && (n += e.sliceString(r.to, i)), hs.set(e, new Yt(s, n)), new Yt(O, n.slice(O - s, i - s));
  }
}
class uu {
  constructor(e, O, i, r, n) {
    this.text = e, this.to = n, this.done = !1, this.value = fu, this.matchPos = un(e, r), this.re = new RegExp(O, Vo + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Yt.get(e, r, this.chunkEnd(
      r + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, O = this.re.exec(this.flat.text);
      if (O && !O[0] && O.index == e && (this.re.lastIndex = e + 1, O = this.re.exec(this.flat.text)), O) {
        let i = this.flat.from + O.index, r = i + O[0].length;
        if ((this.flat.to >= this.to || O.index + O[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, r, O)))
          return this.value = { from: i, to: r, match: O }, this.matchPos = un(this.text, r + (i == r ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Yt.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && ($u.prototype[Symbol.iterator] = uu.prototype[Symbol.iterator] = function() {
  return this;
});
function qX(t) {
  try {
    return new RegExp(t, Vo), !0;
  } catch {
    return !1;
  }
}
function un(t, e) {
  if (e >= t.length)
    return e;
  let O = t.lineAt(e), i;
  for (; e < O.to && (i = O.text.charCodeAt(e - O.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function va(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), O = J("input", { class: "cm-textfield", name: "line", value: e }), i = J("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), t.dispatch({ effects: dn.of(!1) }), t.focus()) : n.keyCode == 13 && (n.preventDefault(), r());
    },
    onsubmit: (n) => {
      n.preventDefault(), r();
    }
  }, J("label", t.state.phrase("Go to line"), ": ", O), " ", J("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function r() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(O.value);
    if (!n)
      return;
    let { state: s } = t, a = s.doc.lineAt(s.selection.main.head), [, o, c, h, Q] = n, f = h ? +h.slice(1) : 0, $ = c ? +c : a.number;
    if (c && Q) {
      let p = $ / 100;
      o && (p = p * (o == "-" ? -1 : 1) + a.number / s.doc.lines), $ = Math.round(s.doc.lines * p);
    } else c && o && ($ = $ * (o == "-" ? -1 : 1) + a.number);
    let u = s.doc.line(Math.max(1, Math.min(s.doc.lines, $))), d = g.cursor(u.from + Math.max(0, Math.min(f, u.length)));
    t.dispatch({
      effects: [dn.of(!1), k.scrollIntoView(d.from, { y: "center" })],
      selection: d
    }), t.focus();
  }
  return { dom: i };
}
const dn = /* @__PURE__ */ z.define(), Ic = /* @__PURE__ */ pe.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let O of e.effects)
      O.is(dn) && (t = O.value);
    return t;
  },
  provide: (t) => qi.from(t, (e) => e ? va : null)
}), UX = (t) => {
  let e = zi(t, va);
  if (!e) {
    let O = [dn.of(!0)];
    t.state.field(Ic, !1) == null && O.push(z.appendConfig.of([Ic, VX])), t.dispatch({ effects: O }), e = zi(t, va);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, VX = /* @__PURE__ */ k.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), _X = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, jX = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, _X, {
      highlightWordAroundCursor: (e, O) => e || O,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function GX(t) {
  return [NX, DX];
}
const CX = /* @__PURE__ */ Z.mark({ class: "cm-selectionMatch" }), EX = /* @__PURE__ */ Z.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Mc(t, e, O, i) {
  return (O == 0 || t(e.sliceDoc(O - 1, O)) != te.Word) && (i == e.doc.length || t(e.sliceDoc(i, i + 1)) != te.Word);
}
function AX(t, e, O, i) {
  return t(e.sliceDoc(O, O + 1)) == te.Word && t(e.sliceDoc(i - 1, i)) == te.Word;
}
const DX = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(jX), { state: O } = t, i = O.selection;
    if (i.ranges.length > 1)
      return Z.none;
    let r = i.main, n, s = null;
    if (r.empty) {
      if (!e.highlightWordAroundCursor)
        return Z.none;
      let o = O.wordAt(r.head);
      if (!o)
        return Z.none;
      s = O.charCategorizer(r.head), n = O.sliceDoc(o.from, o.to);
    } else {
      let o = r.to - r.from;
      if (o < e.minSelectionLength || o > 200)
        return Z.none;
      if (e.wholeWords) {
        if (n = O.sliceDoc(r.from, r.to), s = O.charCategorizer(r.head), !(Mc(s, O, r.from, r.to) && AX(s, O, r.from, r.to)))
          return Z.none;
      } else if (n = O.sliceDoc(r.from, r.to), !n)
        return Z.none;
    }
    let a = [];
    for (let o of t.visibleRanges) {
      let c = new Ct(O.doc, n, o.from, o.to);
      for (; !c.next().done; ) {
        let { from: h, to: Q } = c.value;
        if ((!s || Mc(s, O, h, Q)) && (r.empty && h <= r.from && Q >= r.to ? a.push(EX.range(h, Q)) : (h >= r.to || Q <= r.from) && a.push(CX.range(h, Q)), a.length > e.maxMatches))
          return Z.none;
      }
    }
    return Z.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), NX = /* @__PURE__ */ k.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), IX = ({ state: t, dispatch: e }) => {
  let { selection: O } = t, i = g.create(O.ranges.map((r) => t.wordAt(r.head) || g.cursor(r.head)), O.mainIndex);
  return i.eq(O) ? !1 : (e(t.update({ selection: i })), !0);
};
function MX(t, e) {
  let { main: O, ranges: i } = t.selection, r = t.wordAt(O.head), n = r && r.from == O.from && r.to == O.to;
  for (let s = !1, a = new Ct(t.doc, e, i[i.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new Ct(t.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), s = !0;
    } else {
      if (s && i.some((o) => o.from == a.value.from))
        continue;
      if (n) {
        let o = t.wordAt(a.value.from);
        if (!o || o.from != a.value.from || o.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const LX = ({ state: t, dispatch: e }) => {
  let { ranges: O } = t.selection;
  if (O.some((n) => n.from === n.to))
    return IX({ state: t, dispatch: e });
  let i = t.sliceDoc(O[0].from, O[0].to);
  if (t.selection.ranges.some((n) => t.sliceDoc(n.from, n.to) != i))
    return !1;
  let r = MX(t, i);
  return r ? (e(t.update({
    selection: t.selection.addRange(g.range(r.from, r.to), !1),
    effects: k.scrollIntoView(r.to)
  })), !0) : !1;
}, Lt = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new sy(e),
      scrollToMatch: (e) => k.scrollIntoView(e)
    });
  }
});
class du {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || qX(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (O, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new KX(this) : new FX(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, O = 0, i) {
    let r = e.doc ? e : E.create({ doc: e });
    return i == null && (i = r.doc.length), this.regexp ? yt(this, r, O, i) : Xt(this, r, O, i);
  }
}
class pu {
  constructor(e) {
    this.spec = e;
  }
}
function Xt(t, e, O, i) {
  return new Ct(e.doc, t.unquoted, O, i, t.caseSensitive ? void 0 : (r) => r.toLowerCase(), t.wholeWord ? BX(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function BX(t, e) {
  return (O, i, r, n) => ((n > O || n + r.length < i) && (n = Math.max(0, O - 2), r = t.sliceString(n, Math.min(t.length, i + 2))), (e(pn(r, O - n)) != te.Word || e(mn(r, O - n)) != te.Word) && (e(mn(r, i - n)) != te.Word || e(pn(r, i - n)) != te.Word));
}
class FX extends pu {
  constructor(e) {
    super(e);
  }
  nextMatch(e, O, i) {
    let r = Xt(this.spec, e, i, e.doc.length).nextOverlapping();
    return r.done && (r = Xt(this.spec, e, 0, O).nextOverlapping()), r.done ? null : r.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, O, i) {
    for (let r = i; ; ) {
      let n = Math.max(O, r - 1e4 - this.spec.unquoted.length), s = Xt(this.spec, e, n, r), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (n == O)
        return null;
      r -= 1e4;
    }
  }
  prevMatch(e, O, i) {
    return this.prevMatchInRange(e, 0, O) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, O) {
    let i = Xt(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= O)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, O, i, r) {
    let n = Xt(this.spec, e, Math.max(0, O - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !n.next().done; )
      r(n.value.from, n.value.to);
  }
}
function yt(t, e, O, i) {
  return new $u(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? HX(e.charCategorizer(e.selection.main.head)) : void 0
  }, O, i);
}
function pn(t, e) {
  return t.slice(be(t, e, !1), e);
}
function mn(t, e) {
  return t.slice(e, be(t, e));
}
function HX(t) {
  return (e, O, i) => !i[0].length || (t(pn(i.input, i.index)) != te.Word || t(mn(i.input, i.index)) != te.Word) && (t(mn(i.input, i.index + i[0].length)) != te.Word || t(pn(i.input, i.index + i[0].length)) != te.Word);
}
class KX extends pu {
  nextMatch(e, O, i) {
    let r = yt(this.spec, e, i, e.doc.length).next();
    return r.done && (r = yt(this.spec, e, 0, O).next()), r.done ? null : r.value;
  }
  prevMatchInRange(e, O, i) {
    for (let r = 1; ; r++) {
      let n = Math.max(
        O,
        i - r * 1e4
        /* FindPrev.ChunkSize */
      ), s = yt(this.spec, e, n, i), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (n == O || a.from > n + 10))
        return a;
      if (n == O)
        return null;
    }
  }
  prevMatch(e, O, i) {
    return this.prevMatchInRange(e, 0, O) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (O, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : O);
  }
  matchAll(e, O) {
    let i = yt(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= O)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, O, i, r) {
    let n = yt(this.spec, e, Math.max(
      0,
      O - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !n.next().done; )
      r(n.value.from, n.value.to);
  }
}
const _i = /* @__PURE__ */ z.define(), _o = /* @__PURE__ */ z.define(), IO = /* @__PURE__ */ pe.define({
  create(t) {
    return new Qs(Za(t).create(), null);
  },
  update(t, e) {
    for (let O of e.effects)
      O.is(_i) ? t = new Qs(O.value.create(), t.panel) : O.is(_o) && (t = new Qs(t.query, O.value ? jo : null));
    return t;
  },
  provide: (t) => qi.from(t, (e) => e.panel)
});
class Qs {
  constructor(e, O) {
    this.query = e, this.panel = O;
  }
}
const JX = /* @__PURE__ */ Z.mark({ class: "cm-searchMatch" }), ey = /* @__PURE__ */ Z.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Oy = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(IO));
  }
  update(t) {
    let e = t.state.field(IO);
    (e != t.startState.field(IO) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return Z.none;
    let { view: O } = this, i = new BO();
    for (let r = 0, n = O.visibleRanges, s = n.length; r < s; r++) {
      let { from: a, to: o } = n[r];
      for (; r < s - 1 && o > n[r + 1].from - 2 * 250; )
        o = n[++r].to;
      t.highlight(O.state, a, o, (c, h) => {
        let Q = O.state.selection.ranges.some((f) => f.from == c && f.to == h);
        i.add(c, h, Q ? ey : JX);
      });
    }
    return i.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function ar(t) {
  return (e) => {
    let O = e.state.field(IO, !1);
    return O && O.query.spec.valid ? t(e, O) : gu(e);
  };
}
const Pn = /* @__PURE__ */ ar((t, { query: e }) => {
  let { to: O } = t.state.selection.main, i = e.nextMatch(t.state, O, O);
  if (!i)
    return !1;
  let r = g.single(i.from, i.to), n = t.state.facet(Lt);
  return t.dispatch({
    selection: r,
    effects: [Go(t, i), n.scrollToMatch(r.main, t)],
    userEvent: "select.search"
  }), Pu(t), !0;
}), gn = /* @__PURE__ */ ar((t, { query: e }) => {
  let { state: O } = t, { from: i } = O.selection.main, r = e.prevMatch(O, i, i);
  if (!r)
    return !1;
  let n = g.single(r.from, r.to), s = t.state.facet(Lt);
  return t.dispatch({
    selection: n,
    effects: [Go(t, r), s.scrollToMatch(n.main, t)],
    userEvent: "select.search"
  }), Pu(t), !0;
}), ty = /* @__PURE__ */ ar((t, { query: e }) => {
  let O = e.matchAll(t.state, 1e3);
  return !O || !O.length ? !1 : (t.dispatch({
    selection: g.create(O.map((i) => g.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), iy = ({ state: t, dispatch: e }) => {
  let O = t.selection;
  if (O.ranges.length > 1 || O.main.empty)
    return !1;
  let { from: i, to: r } = O.main, n = [], s = 0;
  for (let a = new Ct(t.doc, t.sliceDoc(i, r)); !a.next().done; ) {
    if (n.length > 1e3)
      return !1;
    a.value.from == i && (s = n.length), n.push(g.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: g.create(n, s),
    userEvent: "select.search.matches"
  })), !0;
}, Lc = /* @__PURE__ */ ar((t, { query: e }) => {
  let { state: O } = t, { from: i, to: r } = O.selection.main;
  if (O.readOnly)
    return !1;
  let n = e.nextMatch(O, i, i);
  if (!n)
    return !1;
  let s = [], a, o, c = [];
  if (n.from == i && n.to == r && (o = O.toText(e.getReplacement(n)), s.push({ from: n.from, to: n.to, insert: o }), n = e.nextMatch(O, n.from, n.to), c.push(k.announce.of(O.phrase("replaced match on line $", O.doc.lineAt(i).number) + "."))), n) {
    let h = s.length == 0 || s[0].from >= n.to ? 0 : n.to - n.from - o.length;
    a = g.single(n.from - h, n.to - h), c.push(Go(t, n)), c.push(O.facet(Lt).scrollToMatch(a.main, t));
  }
  return t.dispatch({
    changes: s,
    selection: a,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), ry = /* @__PURE__ */ ar((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let O = e.matchAll(t.state, 1e9).map((r) => {
    let { from: n, to: s } = r;
    return { from: n, to: s, insert: e.getReplacement(r) };
  });
  if (!O.length)
    return !1;
  let i = t.state.phrase("replaced $ matches", O.length) + ".";
  return t.dispatch({
    changes: O,
    effects: k.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function jo(t) {
  return t.state.facet(Lt).createPanel(t);
}
function Za(t, e) {
  var O, i, r, n, s;
  let a = t.selection.main, o = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !o)
    return e;
  let c = t.facet(Lt);
  return new du({
    search: ((O = e == null ? void 0 : e.literal) !== null && O !== void 0 ? O : c.literal) ? o : o.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal,
    regexp: (n = e == null ? void 0 : e.regexp) !== null && n !== void 0 ? n : c.regexp,
    wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : c.wholeWord
  });
}
function mu(t) {
  let e = zi(t, jo);
  return e && e.dom.querySelector("[main-field]");
}
function Pu(t) {
  let e = mu(t);
  e && e == t.root.activeElement && e.select();
}
const gu = (t) => {
  let e = t.state.field(IO, !1);
  if (e && e.panel) {
    let O = mu(t);
    if (O && O != t.root.activeElement) {
      let i = Za(t.state, e.query.spec);
      i.valid && t.dispatch({ effects: _i.of(i) }), O.focus(), O.select();
    }
  } else
    t.dispatch({ effects: [
      _o.of(!0),
      e ? _i.of(Za(t.state, e.query.spec)) : z.appendConfig.of(oy)
    ] });
  return !0;
}, Su = (t) => {
  let e = t.state.field(IO, !1);
  if (!e || !e.panel)
    return !1;
  let O = zi(t, jo);
  return O && O.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: _o.of(!1) }), !0;
}, ny = [
  { key: "Mod-f", run: gu, scope: "editor search-panel" },
  { key: "F3", run: Pn, shift: gn, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Pn, shift: gn, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: Su, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: iy },
  { key: "Mod-Alt-g", run: UX },
  { key: "Mod-d", run: LX, preventDefault: !0 }
];
class sy {
  constructor(e) {
    this.view = e;
    let O = this.query = e.state.field(IO).query.spec;
    this.commit = this.commit.bind(this), this.searchField = J("input", {
      value: O.search,
      placeholder: je(e, "Find"),
      "aria-label": je(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = J("input", {
      value: O.replace,
      placeholder: je(e, "Replace"),
      "aria-label": je(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = J("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: O.caseSensitive,
      onchange: this.commit
    }), this.reField = J("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: O.regexp,
      onchange: this.commit
    }), this.wordField = J("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: O.wholeWord,
      onchange: this.commit
    });
    function i(r, n, s) {
      return J("button", { class: "cm-button", name: r, onclick: n, type: "button" }, s);
    }
    this.dom = J("div", { onkeydown: (r) => this.keydown(r), class: "cm-search" }, [
      this.searchField,
      i("next", () => Pn(e), [je(e, "next")]),
      i("prev", () => gn(e), [je(e, "previous")]),
      i("select", () => ty(e), [je(e, "all")]),
      J("label", null, [this.caseField, je(e, "match case")]),
      J("label", null, [this.reField, je(e, "regexp")]),
      J("label", null, [this.wordField, je(e, "by word")]),
      ...e.state.readOnly ? [] : [
        J("br"),
        this.replaceField,
        i("replace", () => Lc(e), [je(e, "replace")]),
        i("replaceAll", () => ry(e), [je(e, "replace all")])
      ],
      J("button", {
        name: "close",
        onclick: () => Su(e),
        "aria-label": je(e, "close"),
        type: "button"
      }, ["Ã—"])
    ]);
  }
  commit() {
    let e = new du({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: _i.of(e) }));
  }
  keydown(e) {
    wP(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? gn : Pn)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Lc(this.view));
  }
  update(e) {
    for (let O of e.transactions)
      for (let i of O.effects)
        i.is(_i) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Lt).top;
  }
}
function je(t, e) {
  return t.state.phrase(e);
}
const Wr = 30, Rr = /[\s\.,:;?!]/;
function Go(t, { from: e, to: O }) {
  let i = t.state.doc.lineAt(e), r = t.state.doc.lineAt(O).to, n = Math.max(i.from, e - Wr), s = Math.min(r, O + Wr), a = t.state.sliceDoc(n, s);
  if (n != i.from) {
    for (let o = 0; o < Wr; o++)
      if (!Rr.test(a[o + 1]) && Rr.test(a[o])) {
        a = a.slice(o);
        break;
      }
  }
  if (s != r) {
    for (let o = a.length - 1; o > a.length - Wr; o--)
      if (!Rr.test(a[o - 1]) && Rr.test(a[o])) {
        a = a.slice(0, o);
        break;
      }
  }
  return k.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${i.number}.`);
}
const ay = /* @__PURE__ */ k.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), oy = [
  IO,
  /* @__PURE__ */ qO.low(Oy),
  ay
];
class Co {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, O, i, r) {
    this.state = e, this.pos = O, this.explicit = i, this.view = r, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let O = I(this.state).resolveInner(this.pos, -1);
    for (; O && e.indexOf(O.name) < 0; )
      O = O.parent;
    return O ? {
      from: O.from,
      to: this.pos,
      text: this.state.sliceDoc(O.from, this.pos),
      type: O.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let O = this.state.doc.lineAt(this.pos), i = Math.max(O.from, this.pos - 250), r = O.text.slice(i - O.from, this.pos - O.from), n = r.search(Xu(e, !1));
    return n < 0 ? null : { from: i + n, to: this.pos, text: r.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, O, i) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(O), i && i.onDocChange && (this.abortOnDocChange = !0));
  }
}
function Bc(t) {
  let e = Object.keys(t).join(""), O = /\w/.test(e);
  return O && (e = e.replace(/\w/g, "")), `[${O ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function ly(t) {
  let e = /* @__PURE__ */ Object.create(null), O = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of t) {
    e[r[0]] = !0;
    for (let n = 1; n < r.length; n++)
      O[r[n]] = !0;
  }
  let i = Bc(e) + Bc(O) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function Cn(t) {
  let e = t.map((r) => typeof r == "string" ? { label: r } : r), [O, i] = e.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : ly(e);
  return (r) => {
    let n = r.matchBefore(i);
    return n || r.explicit ? { from: n ? n.from : r.pos, options: e, validFor: O } : null;
  };
}
function Eo(t, e) {
  return (O) => {
    for (let i = I(O.state).resolveInner(O.pos, -1); i; i = i.parent) {
      if (t.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(O);
  };
}
class Fc {
  constructor(e, O, i, r) {
    this.completion = e, this.source = O, this.match = i, this.score = r;
  }
}
function MO(t) {
  return t.selection.main.from;
}
function Xu(t, e) {
  var O;
  let { source: i } = t, r = e && i[0] != "^", n = i[i.length - 1] != "$";
  return !r && !n ? t : new RegExp(`${r ? "^" : ""}(?:${i})${n ? "$" : ""}`, (O = t.flags) !== null && O !== void 0 ? O : t.ignoreCase ? "i" : "");
}
const Ao = /* @__PURE__ */ UO.define();
function cy(t, e, O, i) {
  let { main: r } = t.selection, n = O - r.from, s = i - r.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => a != r && O != i && t.sliceDoc(a.from + n, a.from + s) != t.sliceDoc(O, i) ? { range: a } : {
    changes: { from: a.from + n, to: i == r.from ? a.to : a.from + s, insert: e },
    range: g.cursor(a.from + n + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Hc = /* @__PURE__ */ new WeakMap();
function hy(t) {
  if (!Array.isArray(t))
    return t;
  let e = Hc.get(t);
  return e || Hc.set(t, e = Cn(t)), e;
}
const Sn = /* @__PURE__ */ z.define(), ji = /* @__PURE__ */ z.define();
class Qy {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let O = 0; O < e.length; ) {
      let i = ge(e, O), r = Fe(i);
      this.chars.push(i);
      let n = e.slice(O, O + r), s = n.toUpperCase();
      this.folded.push(ge(s == n ? n.toLowerCase() : s, 0)), O += r;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, O) {
    return this.score = e, this.matched = O, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: O, folded: i, any: r, precise: n, byWord: s } = this;
    if (O.length == 1) {
      let P = ge(e, 0), X = Fe(P), y = X == e.length ? 0 : -100;
      if (P != O[0]) if (P == i[0])
        y += -200;
      else
        return null;
      return this.ret(y, [0, X]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let o = O.length, c = 0;
    if (a < 0) {
      for (let P = 0, X = Math.min(e.length, 200); P < X && c < o; ) {
        let y = ge(e, P);
        (y == O[c] || y == i[c]) && (r[c++] = P), P += Fe(y);
      }
      if (c < o)
        return null;
    }
    let h = 0, Q = 0, f = !1, $ = 0, u = -1, d = -1, p = /[a-z]/.test(e), m = !0;
    for (let P = 0, X = Math.min(e.length, 200), y = 0; P < X && Q < o; ) {
      let S = ge(e, P);
      a < 0 && (h < o && S == O[h] && (n[h++] = P), $ < o && (S == O[$] || S == i[$] ? ($ == 0 && (u = P), d = P + 1, $++) : $ = 0));
      let w, T = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : (w = $o(S)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;
      (!P || T == 1 && p || y == 0 && T != 0) && (O[Q] == S || i[Q] == S && (f = !0) ? s[Q++] = P : s.length && (m = !1)), y = T, P += Fe(S);
    }
    return Q == o && s[0] == 0 && m ? this.result(-100 + (f ? -200 : 0), s, e) : $ == o && u == 0 ? this.ret(-200 - e.length + (d == e.length ? 0 : -100), [0, d]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : $ == o ? this.ret(-900 - e.length, [u, d]) : Q == o ? this.result(-100 + (f ? -200 : 0) + -700 + (m ? 0 : -1100), s, e) : O.length == 2 ? null : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
  }
  result(e, O, i) {
    let r = [], n = 0;
    for (let s of O) {
      let a = s + (this.astral ? Fe(ge(i, s)) : 1);
      n && r[n - 1] == s ? r[n - 1] = a : (r[n++] = s, r[n++] = a);
    }
    return this.ret(e - i.length, r);
  }
}
class fy {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let O = e.slice(0, this.pattern.length), i = O == this.pattern ? 0 : O.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, O.length], this.score = i + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const ye = /* @__PURE__ */ R.define({
  combine(t) {
    return XO(t, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: $y,
      filterStrict: !1,
      compareCompletions: (e, O) => e.label.localeCompare(O.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, O) => e && O,
      closeOnBlur: (e, O) => e && O,
      icons: (e, O) => e && O,
      tooltipClass: (e, O) => (i) => Kc(e(i), O(i)),
      optionClass: (e, O) => (i) => Kc(e(i), O(i)),
      addToOptions: (e, O) => e.concat(O),
      filterStrict: (e, O) => e || O
    });
  }
});
function Kc(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function $y(t, e, O, i, r, n) {
  let s = t.textDirection == Oe.RTL, a = s, o = !1, c = "top", h, Q, f = e.left - r.left, $ = r.right - e.right, u = i.right - i.left, d = i.bottom - i.top;
  if (a && f < Math.min(u, $) ? a = !1 : !a && $ < Math.min(u, f) && (a = !0), u <= (a ? f : $))
    h = Math.max(r.top, Math.min(O.top, r.bottom - d)) - e.top, Q = Math.min(400, a ? f : $);
  else {
    o = !0, Q = Math.min(
      400,
      (s ? e.right : r.right - e.left) - 30
      /* Info.Margin */
    );
    let P = r.bottom - e.bottom;
    P >= d || P > e.top ? h = O.bottom - e.top : (c = "bottom", h = e.bottom - O.top);
  }
  let p = (e.bottom - e.top) / n.offsetHeight, m = (e.right - e.left) / n.offsetWidth;
  return {
    style: `${c}: ${h / p}px; max-width: ${Q / m}px`,
    class: "cm-completionInfo-" + (o ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function uy(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(O) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), O.type && i.classList.add(...O.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(O, i, r, n) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = O.displayLabel || O.label, o = 0;
      for (let c = 0; c < n.length; ) {
        let h = n[c++], Q = n[c++];
        h > o && s.appendChild(document.createTextNode(a.slice(o, h)));
        let f = s.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(a.slice(h, Q))), f.className = "cm-completionMatchedText", o = Q;
      }
      return o < a.length && s.appendChild(document.createTextNode(a.slice(o))), s;
    },
    position: 50
  }, {
    render(O) {
      if (!O.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = O.detail, i;
    },
    position: 80
  }), e.sort((O, i) => O.position - i.position).map((O) => O.render);
}
function fs(t, e, O) {
  if (t <= O)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let r = Math.floor(e / O);
    return { from: r * O, to: (r + 1) * O };
  }
  let i = Math.floor((t - e) / O);
  return { from: t - (i + 1) * O, to: t - i * O };
}
class dy {
  constructor(e, O, i) {
    this.view = e, this.stateField = O, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (o) => this.placeInfo(o),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = e.state.field(O), { options: n, selected: s } = r.open, a = e.state.facet(ye);
    this.optionContent = uy(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = fs(n.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (o) => {
      let { options: c } = e.state.field(O).open;
      for (let h = o.target, Q; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (Q = /-(\d+)$/.exec(h.id)) && +Q[1] < c.length) {
          this.applyCompletion(e, c[+Q[1]]), o.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (o) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(ye).closeOnBlur && o.relatedTarget != e.contentDOM && e.dispatch({ effects: ji.of(null) });
    }), this.showOptions(n, r.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, O) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, O, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var O;
    let i = e.state.field(this.stateField), r = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != r) {
      let { options: n, selected: s, disabled: a } = i.open;
      (!r.open || r.open.options != n) && (this.range = fs(n.length, s, e.state.facet(ye).maxRenderedOptions), this.showOptions(n, i.id)), this.updateSel(), a != ((O = r.open) === null || O === void 0 ? void 0 : O.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let O = this.tooltipClass(e);
    if (O != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of O.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = O;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), O = e.open;
    if ((O.selected > -1 && O.selected < this.range.from || O.selected >= this.range.to) && (this.range = fs(O.options.length, O.selected, this.view.state.facet(ye).maxRenderedOptions), this.showOptions(O.options, e.id)), this.updateSelectedOption(O.selected)) {
      this.destroyInfo();
      let { completion: i } = O.options[O.selected], { info: r } = i;
      if (!r)
        return;
      let n = typeof r == "string" ? document.createTextNode(r) : r(i);
      if (!n)
        return;
      "then" in n ? n.then((s) => {
        s && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(s, i);
      }).catch((s) => Ue(this.view.state, s, "completion info")) : this.addInfoPane(n, i);
    }
  }
  addInfoPane(e, O) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: r, destroy: n } = e;
      i.appendChild(r), this.infoDestroy = n || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let O = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), O = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return O && my(this.list, O), O;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let O = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), n = this.space;
    if (!n) {
      let s = this.dom.ownerDocument.defaultView || window;
      n = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return r.top > Math.min(n.bottom, O.bottom) - 10 || r.bottom < Math.max(n.top, O.top) + 10 ? null : this.view.state.facet(ye).positionInfo(this.view, O, r, i, n, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, O, i) {
    const r = document.createElement("ul");
    r.id = O, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let n = null;
    for (let s = i.from; s < i.to; s++) {
      let { completion: a, match: o } = e[s], { section: c } = a;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != n && (s > i.from || i.from == 0))
          if (n = f, typeof c != "string" && c.header)
            r.appendChild(c.header(c));
          else {
            let $ = r.appendChild(document.createElement("completion-section"));
            $.textContent = f;
          }
      }
      const h = r.appendChild(document.createElement("li"));
      h.id = O + "-" + s, h.setAttribute("role", "option");
      let Q = this.optionClass(a);
      Q && (h.className = Q);
      for (let f of this.optionContent) {
        let $ = f(a, this.view.state, this.view, o);
        $ && h.appendChild($);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function py(t, e) {
  return (O) => new dy(O, t, e);
}
function my(t, e) {
  let O = t.getBoundingClientRect(), i = e.getBoundingClientRect(), r = O.height / t.offsetHeight;
  i.top < O.top ? t.scrollTop -= (O.top - i.top) / r : i.bottom > O.bottom && (t.scrollTop += (i.bottom - O.bottom) / r);
}
function Jc(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function Py(t, e) {
  let O = [], i = null, r = (c) => {
    O.push(c);
    let { section: h } = c.completion;
    if (h) {
      i || (i = []);
      let Q = typeof h == "string" ? h : h.name;
      i.some((f) => f.name == Q) || i.push(typeof h == "string" ? { name: Q } : h);
    }
  }, n = e.facet(ye);
  for (let c of t)
    if (c.hasResult()) {
      let h = c.result.getMatch;
      if (c.result.filter === !1)
        for (let Q of c.result.options)
          r(new Fc(Q, c.source, h ? h(Q) : [], 1e9 - O.length));
      else {
        let Q = e.sliceDoc(c.from, c.to), f, $ = n.filterStrict ? new fy(Q) : new Qy(Q);
        for (let u of c.result.options)
          if (f = $.match(u.label)) {
            let d = u.displayLabel ? h ? h(u, f.matched) : [] : f.matched;
            r(new Fc(u, c.source, d, f.score + (u.boost || 0)));
          }
      }
    }
  if (i) {
    let c = /* @__PURE__ */ Object.create(null), h = 0, Q = (f, $) => {
      var u, d;
      return ((u = f.rank) !== null && u !== void 0 ? u : 1e9) - ((d = $.rank) !== null && d !== void 0 ? d : 1e9) || (f.name < $.name ? -1 : 1);
    };
    for (let f of i.sort(Q))
      h -= 1e5, c[f.name] = h;
    for (let f of O) {
      let { section: $ } = f.completion;
      $ && (f.score += c[typeof $ == "string" ? $ : $.name]);
    }
  }
  let s = [], a = null, o = n.compareCompletions;
  for (let c of O.sort((h, Q) => Q.score - h.score || o(h.completion, Q.completion))) {
    let h = c.completion;
    !a || a.label != h.label || a.detail != h.detail || a.type != null && h.type != null && a.type != h.type || a.apply != h.apply || a.boost != h.boost ? s.push(c) : Jc(c.completion) > Jc(a) && (s[s.length - 1] = c), a = c.completion;
  }
  return s;
}
class wt {
  constructor(e, O, i, r, n, s) {
    this.options = e, this.attrs = O, this.tooltip = i, this.timestamp = r, this.selected = n, this.disabled = s;
  }
  setSelected(e, O) {
    return e == this.selected || e >= this.options.length ? this : new wt(this.options, eh(O, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, O, i, r, n) {
    let s = Py(e, O);
    if (!s.length)
      return r && e.some(
        (o) => o.state == 1
        /* State.Pending */
      ) ? new wt(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null;
    let a = O.facet(ye).selectOnOpen ? 0 : -1;
    if (r && r.selected != a && r.selected != -1) {
      let o = r.options[r.selected].completion;
      for (let c = 0; c < s.length; c++)
        if (s[c].completion == o) {
          a = c;
          break;
        }
    }
    return new wt(s, eh(i, a), {
      pos: e.reduce((o, c) => c.hasResult() ? Math.min(o, c.from) : o, 1e8),
      create: xy,
      above: n.aboveCursor
    }, r ? r.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new wt(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Xn {
  constructor(e, O, i) {
    this.active = e, this.id = O, this.open = i;
  }
  static start() {
    return new Xn(yy, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: O } = e, i = O.facet(ye), n = (i.override || O.languageDataAt("autocomplete", MO(O)).map(hy)).map((a) => (this.active.find((c) => c.source == a) || new Ae(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    n.length == this.active.length && n.every((a, o) => a == this.active[o]) && (n = this.active);
    let s = this.open;
    s && e.docChanged && (s = s.map(e.changes)), e.selection || n.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !gy(n, this.active) ? s = wt.build(n, O, this.id, s, i) : s && s.disabled && !n.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (s = null), !s && n.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && n.some((a) => a.hasResult()) && (n = n.map((a) => a.hasResult() ? new Ae(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(xu) && (s = s && s.setSelected(a.value, this.id));
    return n == this.active && s == this.open ? this : new Xn(n, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? Sy : Xy;
  }
}
function gy(t, e) {
  if (t == e)
    return !0;
  for (let O = 0, i = 0; ; ) {
    for (; O < t.length && !t[O].hasResult; )
      O++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let r = O == t.length, n = i == e.length;
    if (r || n)
      return r == n;
    if (t[O++].result != e[i++].result)
      return !1;
  }
}
const Sy = {
  "aria-autocomplete": "list"
}, Xy = {};
function eh(t, e) {
  let O = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (O["aria-activedescendant"] = t + "-" + e), O;
}
const yy = [];
function yu(t, e) {
  if (t.isUserEvent("input.complete")) {
    let i = t.annotation(Ao);
    if (i && e.activateOnCompletion(i))
      return 12;
  }
  let O = t.isUserEvent("input.type");
  return O && e.activateOnTyping ? 5 : O ? 1 : t.isUserEvent("delete.backward") ? 2 : t.selection ? 8 : t.docChanged ? 16 : 0;
}
class Ae {
  constructor(e, O, i = -1) {
    this.source = e, this.state = O, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, O) {
    let i = yu(e, O), r = this;
    (i & 8 || i & 16 && this.touches(e)) && (r = new Ae(
      r.source,
      0
      /* State.Inactive */
    )), i & 4 && r.state == 0 && (r = new Ae(
      this.source,
      1
      /* State.Pending */
    )), r = r.updateFor(e, i);
    for (let n of e.effects)
      if (n.is(Sn))
        r = new Ae(r.source, 1, n.value ? MO(e.state) : -1);
      else if (n.is(ji))
        r = new Ae(
          r.source,
          0
          /* State.Inactive */
        );
      else if (n.is(bu))
        for (let s of n.value)
          s.source == r.source && (r = s);
    return r;
  }
  updateFor(e, O) {
    return this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Ae(this.source, this.state, e.mapPos(this.explicitPos));
  }
  touches(e) {
    return e.changes.touchesRange(MO(e.state));
  }
}
class zt extends Ae {
  constructor(e, O, i, r, n) {
    super(e, 2, O), this.result = i, this.from = r, this.to = n;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, O) {
    var i;
    if (!(O & 3))
      return this.map(e.changes);
    let r = this.result;
    r.map && !e.changes.empty && (r = r.map(r, e.changes));
    let n = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = MO(e.state);
    if ((this.explicitPos < 0 ? a <= n : a < this.from) || a > s || !r || O & 2 && MO(e.startState) == this.from)
      return new Ae(
        this.source,
        O & 4 ? 1 : 0
        /* State.Inactive */
      );
    let o = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos);
    return by(r.validFor, e.state, n, s) ? new zt(this.source, o, r, n, s) : r.update && (r = r.update(r, n, s, new Co(e.state, a, o >= 0))) ? new zt(this.source, o, r, r.from, (i = r.to) !== null && i !== void 0 ? i : MO(e.state)) : new Ae(this.source, 1, o);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new zt(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Ae(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function by(t, e, O, i) {
  if (!t)
    return !1;
  let r = e.sliceDoc(O, i);
  return typeof t == "function" ? t(r, O, i, e) : Xu(t, !0).test(r);
}
const bu = /* @__PURE__ */ z.define({
  map(t, e) {
    return t.map((O) => O.map(e));
  }
}), xu = /* @__PURE__ */ z.define(), qe = /* @__PURE__ */ pe.define({
  create() {
    return Xn.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    ko.from(t, (e) => e.tooltip),
    k.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function Do(t, e) {
  const O = e.completion.apply || e.completion.label;
  let i = t.state.field(qe).active.find((r) => r.source == e.source);
  return i instanceof zt ? (typeof O == "string" ? t.dispatch(Object.assign(Object.assign({}, cy(t.state, O, i.from, i.to)), { annotations: Ao.of(e.completion) })) : O(t, e.completion, i.from, i.to), !0) : !1;
}
const xy = /* @__PURE__ */ py(qe, Do);
function vr(t, e = "option") {
  return (O) => {
    let i = O.state.field(qe, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < O.state.facet(ye).interactionDelay)
      return !1;
    let r = 1, n;
    e == "page" && (n = f$(O, i.open.tooltip)) && (r = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = i.open.options, a = i.open.selected > -1 ? i.open.selected + r * (t ? 1 : -1) : t ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), O.dispatch({ effects: xu.of(a) }), !0;
  };
}
const Ty = (t) => {
  let e = t.state.field(qe, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(ye).interactionDelay ? !1 : Do(t, e.open.options[e.open.selected]);
}, wy = (t) => t.state.field(qe, !1) ? (t.dispatch({ effects: Sn.of(!0) }), !0) : !1, ky = (t) => {
  let e = t.state.field(qe, !1);
  return !e || !e.active.some(
    (O) => O.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: ji.of(null) }), !0);
};
class Wy {
  constructor(e, O) {
    this.active = e, this.context = O, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Ry = 50, vy = 1e3, Zy = /* @__PURE__ */ Qe.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(qe).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(qe), O = t.state.facet(ye);
    if (!t.selectionSet && !t.docChanged && t.startState.field(qe) == e)
      return;
    let i = t.transactions.some((n) => {
      let s = yu(n, O);
      return s & 8 || (n.selection || n.docChanged) && !(s & 3);
    });
    for (let n = 0; n < this.running.length; n++) {
      let s = this.running[n];
      if (i || s.context.abortOnDocChange && t.docChanged || s.updates.length + t.transactions.length > Ry && Date.now() - s.time > vy) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (o) {
            Ue(this.view.state, o);
          }
        s.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((n) => n.effects.some((s) => s.is(Sn))) && (this.pendingStart = !0);
    let r = this.pendingStart ? 50 : O.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.state == 1 && !this.running.some((s) => s.active.source == n.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)
      for (let n of t.transactions)
        n.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(qe);
    for (let O of e.active)
      O.state == 1 && !this.running.some((i) => i.active.source == O.source) && this.startQuery(O);
  }
  startQuery(t) {
    let { state: e } = this.view, O = MO(e), i = new Co(e, O, t.explicitPos == O, this.view), r = new Wy(t, i);
    this.running.push(r), Promise.resolve(t.source(i)).then((n) => {
      r.context.aborted || (r.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: ji.of(null) }), Ue(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(ye).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], O = this.view.state.facet(ye);
    for (let i = 0; i < this.running.length; i++) {
      let r = this.running[i];
      if (r.done === void 0)
        continue;
      if (this.running.splice(i--, 1), r.done) {
        let s = new zt(r.active.source, r.active.explicitPos, r.done, r.done.from, (t = r.done.to) !== null && t !== void 0 ? t : MO(r.updates.length ? r.updates[0].startState : this.view.state));
        for (let a of r.updates)
          s = s.update(a, O);
        if (s.hasResult()) {
          e.push(s);
          continue;
        }
      }
      let n = this.view.state.field(qe).active.find((s) => s.source == r.active.source);
      if (n && n.state == 1)
        if (r.done == null) {
          let s = new Ae(
            r.active.source,
            0
            /* State.Inactive */
          );
          for (let a of r.updates)
            s = s.update(a, O);
          s.state != 1 && e.push(s);
        } else
          this.startQuery(n);
    }
    e.length && this.view.dispatch({ effects: bu.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(qe, !1);
      if (e && e.tooltip && this.view.state.facet(ye).closeOnBlur) {
        let O = e.open && f$(this.view, e.open.tooltip);
        (!O || !O.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: ji.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Sn.of(!1) }), 20), this.composing = 0;
    }
  }
}), Yy = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), zy = /* @__PURE__ */ qO.highest(/* @__PURE__ */ k.domEventHandlers({
  keydown(t, e) {
    let O = e.state.field(qe, !1);
    if (!O || !O.open || O.open.disabled || O.open.selected < 0 || t.key.length > 1 || t.ctrlKey && !(Yy && t.altKey) || t.metaKey)
      return !1;
    let i = O.open.options[O.open.selected], r = O.active.find((s) => s.source == i.source), n = i.completion.commitCharacters || r.result.commitCharacters;
    return n && n.indexOf(t.key) > -1 && Do(e, i), !1;
  }
})), Tu = /* @__PURE__ */ k.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class qy {
  constructor(e, O, i, r) {
    this.field = e, this.line = O, this.from = i, this.to = r;
  }
}
class No {
  constructor(e, O, i) {
    this.field = e, this.from = O, this.to = i;
  }
  map(e) {
    let O = e.mapPos(this.from, -1, Xe.TrackDel), i = e.mapPos(this.to, 1, Xe.TrackDel);
    return O == null || i == null ? null : new No(this.field, O, i);
  }
}
class Io {
  constructor(e, O) {
    this.lines = e, this.fieldPositions = O;
  }
  instantiate(e, O) {
    let i = [], r = [O], n = e.doc.lineAt(O), s = /^\s*/.exec(n.text)[0];
    for (let o of this.lines) {
      if (i.length) {
        let c = s, h = /^\t*/.exec(o)[0].length;
        for (let Q = 0; Q < h; Q++)
          c += e.facet(ir);
        r.push(O + c.length - h), o = c + o.slice(h);
      }
      i.push(o), O += o.length + 1;
    }
    let a = this.fieldPositions.map((o) => new No(o.field, r[o.line] + o.from, r[o.line] + o.to));
    return { text: i, ranges: a };
  }
  static parse(e) {
    let O = [], i = [], r = [], n;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(s); ) {
        let a = n[1] ? +n[1] : null, o = n[2] || n[3] || "", c = -1, h = o.replace(/\\[{}]/g, (Q) => Q[1]);
        for (let Q = 0; Q < O.length; Q++)
          (a != null ? O[Q].seq == a : h && O[Q].name == h) && (c = Q);
        if (c < 0) {
          let Q = 0;
          for (; Q < O.length && (a == null || O[Q].seq != null && O[Q].seq < a); )
            Q++;
          O.splice(Q, 0, { seq: a, name: h }), c = Q;
          for (let f of r)
            f.field >= c && f.field++;
        }
        r.push(new qy(c, i.length, n.index, n.index + h.length)), s = s.slice(0, n.index) + o + s.slice(n.index + n[0].length);
      }
      s = s.replace(/\\([{}])/g, (a, o, c) => {
        for (let h of r)
          h.line == i.length && h.from > c && (h.from--, h.to--);
        return o;
      }), i.push(s);
    }
    return new Io(i, r);
  }
}
let Uy = /* @__PURE__ */ Z.widget({ widget: /* @__PURE__ */ new class extends VO {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Vy = /* @__PURE__ */ Z.mark({ class: "cm-snippetField" });
class Bt {
  constructor(e, O) {
    this.ranges = e, this.active = O, this.deco = Z.set(e.map((i) => (i.from == i.to ? Uy : Vy).range(i.from, i.to)));
  }
  map(e) {
    let O = [];
    for (let i of this.ranges) {
      let r = i.map(e);
      if (!r)
        return null;
      O.push(r);
    }
    return new Bt(O, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((O) => this.ranges.some((i) => i.field == this.active && i.from <= O.from && i.to >= O.to));
  }
}
const or = /* @__PURE__ */ z.define({
  map(t, e) {
    return t && t.map(e);
  }
}), _y = /* @__PURE__ */ z.define(), Gi = /* @__PURE__ */ pe.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let O of e.effects) {
      if (O.is(or))
        return O.value;
      if (O.is(_y) && t)
        return new Bt(t.ranges, O.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => k.decorations.from(t, (e) => e ? e.deco : Z.none)
});
function Mo(t, e) {
  return g.create(t.filter((O) => O.field == e).map((O) => g.range(O.from, O.to)));
}
function jy(t) {
  let e = Io.parse(t);
  return (O, i, r, n) => {
    let { text: s, ranges: a } = e.instantiate(O.state, r), o = {
      changes: { from: r, to: n, insert: N.of(s) },
      scrollIntoView: !0,
      annotations: i ? [Ao.of(i), he.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (o.selection = Mo(a, 0)), a.some((c) => c.field > 0)) {
      let c = new Bt(a, 0), h = o.effects = [or.of(c)];
      O.state.field(Gi, !1) === void 0 && h.push(z.appendConfig.of([Gi, Dy, Ny, Tu]));
    }
    O.dispatch(O.state.update(o));
  };
}
function wu(t) {
  return ({ state: e, dispatch: O }) => {
    let i = e.field(Gi, !1);
    if (!i || t < 0 && i.active == 0)
      return !1;
    let r = i.active + t, n = t > 0 && !i.ranges.some((s) => s.field == r + t);
    return O(e.update({
      selection: Mo(i.ranges, r),
      effects: or.of(n ? null : new Bt(i.ranges, r)),
      scrollIntoView: !0
    })), !0;
  };
}
const Gy = ({ state: t, dispatch: e }) => t.field(Gi, !1) ? (e(t.update({ effects: or.of(null) })), !0) : !1, Cy = /* @__PURE__ */ wu(1), Ey = /* @__PURE__ */ wu(-1), Ay = [
  { key: "Tab", run: Cy, shift: Ey },
  { key: "Escape", run: Gy }
], Oh = /* @__PURE__ */ R.define({
  combine(t) {
    return t.length ? t[0] : Ay;
  }
}), Dy = /* @__PURE__ */ qO.highest(/* @__PURE__ */ Or.compute([Oh], (t) => t.facet(Oh)));
function L(t, e) {
  return Object.assign(Object.assign({}, e), { apply: jy(t) });
}
const Ny = /* @__PURE__ */ k.domEventHandlers({
  mousedown(t, e) {
    let O = e.state.field(Gi, !1), i;
    if (!O || (i = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let r = O.ranges.find((n) => n.from <= i && n.to >= i);
    return !r || r.field == O.active ? !1 : (e.dispatch({
      selection: Mo(O.ranges, r.field),
      effects: or.of(O.ranges.some((n) => n.field > r.field) ? new Bt(O.ranges, r.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Ci = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ct = /* @__PURE__ */ z.define({
  map(t, e) {
    let O = e.mapPos(t, -1, Xe.TrackAfter);
    return O ?? void 0;
  }
}), Lo = /* @__PURE__ */ new class extends ft {
}();
Lo.startSide = 1;
Lo.endSide = -1;
const ku = /* @__PURE__ */ pe.define({
  create() {
    return A.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let O = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (i) => i >= O.from && i <= O.to });
    }
    for (let O of e.effects)
      O.is(ct) && (t = t.update({ add: [Lo.range(O.value, O.value + 1)] }));
    return t;
  }
});
function Iy() {
  return [Ly, ku];
}
const $s = "()[]{}<>";
function Wu(t) {
  for (let e = 0; e < $s.length; e += 2)
    if ($s.charCodeAt(e) == t)
      return $s.charAt(e + 1);
  return $o(t < 128 ? t : t + 1);
}
function Ru(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || Ci;
}
const My = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Ly = /* @__PURE__ */ k.inputHandler.of((t, e, O, i) => {
  if ((My ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let r = t.state.selection.main;
  if (i.length > 2 || i.length == 2 && Fe(ge(i, 0)) == 1 || e != r.from || O != r.to)
    return !1;
  let n = Hy(t.state, i);
  return n ? (t.dispatch(n), !0) : !1;
}), By = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let i = Ru(t, t.selection.main.head).brackets || Ci.brackets, r = null, n = t.changeByRange((s) => {
    if (s.empty) {
      let a = Ky(t.doc, s.head);
      for (let o of i)
        if (o == a && En(t.doc, s.head) == Wu(ge(o, 0)))
          return {
            changes: { from: s.head - o.length, to: s.head + o.length },
            range: g.cursor(s.head - o.length)
          };
    }
    return { range: r = s };
  });
  return r || e(t.update(n, { scrollIntoView: !0, userEvent: "delete.backward" })), !r;
}, Fy = [
  { key: "Backspace", run: By }
];
function Hy(t, e) {
  let O = Ru(t, t.selection.main.head), i = O.brackets || Ci.brackets;
  for (let r of i) {
    let n = Wu(ge(r, 0));
    if (e == r)
      return n == r ? O1(t, r, i.indexOf(r + r + r) > -1, O) : Jy(t, r, n, O.before || Ci.before);
    if (e == n && vu(t, t.selection.main.from))
      return e1(t, r, n);
  }
  return null;
}
function vu(t, e) {
  let O = !1;
  return t.field(ku).between(0, t.doc.length, (i) => {
    i == e && (O = !0);
  }), O;
}
function En(t, e) {
  let O = t.sliceString(e, e + 2);
  return O.slice(0, Fe(ge(O, 0)));
}
function Ky(t, e) {
  let O = t.sliceString(e - 2, e);
  return Fe(ge(O, 0)) == O.length ? O : O.slice(1);
}
function Jy(t, e, O, i) {
  let r = null, n = t.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: O, from: s.to }],
        effects: ct.of(s.to + e.length),
        range: g.range(s.anchor + e.length, s.head + e.length)
      };
    let a = En(t.doc, s.head);
    return !a || /\s/.test(a) || i.indexOf(a) > -1 ? {
      changes: { insert: e + O, from: s.head },
      effects: ct.of(s.head + e.length),
      range: g.cursor(s.head + e.length)
    } : { range: r = s };
  });
  return r ? null : t.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function e1(t, e, O) {
  let i = null, r = t.changeByRange((n) => n.empty && En(t.doc, n.head) == O ? {
    changes: { from: n.head, to: n.head + O.length, insert: O },
    range: g.cursor(n.head + O.length)
  } : i = { range: n });
  return i ? null : t.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function O1(t, e, O, i) {
  let r = i.stringPrefixes || Ci.stringPrefixes, n = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: ct.of(a.to + e.length),
        range: g.range(a.anchor + e.length, a.head + e.length)
      };
    let o = a.head, c = En(t.doc, o), h;
    if (c == e) {
      if (th(t, o))
        return {
          changes: { insert: e + e, from: o },
          effects: ct.of(o + e.length),
          range: g.cursor(o + e.length)
        };
      if (vu(t, o)) {
        let f = O && t.sliceDoc(o, o + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: o, to: o + f.length, insert: f },
          range: g.cursor(o + f.length)
        };
      }
    } else {
      if (O && t.sliceDoc(o - 2 * e.length, o) == e + e && (h = ih(t, o - 2 * e.length, r)) > -1 && th(t, h))
        return {
          changes: { insert: e + e + e + e, from: o },
          effects: ct.of(o + e.length),
          range: g.cursor(o + e.length)
        };
      if (t.charCategorizer(o)(c) != te.Word && ih(t, o, r) > -1 && !t1(t, o, e, r))
        return {
          changes: { insert: e + e, from: o },
          effects: ct.of(o + e.length),
          range: g.cursor(o + e.length)
        };
    }
    return { range: n = a };
  });
  return n ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function th(t, e) {
  let O = I(t).resolveInner(e + 1);
  return O.parent && O.from == e;
}
function t1(t, e, O, i) {
  let r = I(t).resolveInner(e, -1), n = i.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = t.sliceDoc(r.from, Math.min(r.to, r.from + O.length + n)), o = a.indexOf(O);
    if (!o || o > -1 && i.indexOf(a.slice(0, o)) > -1) {
      let h = r.firstChild;
      for (; h && h.from == r.from && h.to - h.from > O.length + o; ) {
        if (t.sliceDoc(h.to - O.length, h.to) == O)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = r.to == e && r.parent;
    if (!c)
      break;
    r = c;
  }
  return !1;
}
function ih(t, e, O) {
  let i = t.charCategorizer(e);
  if (i(t.sliceDoc(e - 1, e)) != te.Word)
    return e;
  for (let r of O) {
    let n = e - r.length;
    if (t.sliceDoc(n, e) == r && i(t.sliceDoc(n - 1, n)) != te.Word)
      return n;
  }
  return -1;
}
function i1(t = {}) {
  return [
    zy,
    qe,
    ye.of(t),
    Zy,
    r1,
    Tu
  ];
}
const Zu = [
  { key: "Ctrl-Space", run: wy },
  { key: "Escape", run: ky },
  { key: "ArrowDown", run: /* @__PURE__ */ vr(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ vr(!1) },
  { key: "PageDown", run: /* @__PURE__ */ vr(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ vr(!1, "page") },
  { key: "Enter", run: Ty }
], r1 = /* @__PURE__ */ qO.highest(/* @__PURE__ */ Or.computeN([ye], (t) => t.facet(ye).defaultKeymap ? [Zu] : []));
class n1 {
  constructor(e, O, i) {
    this.from = e, this.to = O, this.diagnostic = i;
  }
}
class st {
  constructor(e, O, i) {
    this.diagnostics = e, this.panel = O, this.selected = i;
  }
  static init(e, O, i) {
    let r = e, n = i.facet(Ei).markerFilter;
    n && (r = n(r, i));
    let s = Z.set(r.map((a) => a.from == a.to || a.from == a.to - 1 && i.doc.lineAt(a.from).to == a.from ? Z.widget({
      widget: new $1(a),
      diagnostic: a
    }).range(a.from) : Z.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
      diagnostic: a
    }).range(a.from, a.to)), !0);
    return new st(s, O, Et(s));
  }
}
function Et(t, e = null, O = 0) {
  let i = null;
  return t.between(O, 1e9, (r, n, { spec: s }) => {
    if (!(e && s.diagnostic != e))
      return i = new n1(r, n, s.diagnostic), !1;
  }), i;
}
function s1(t, e) {
  let O = e.pos, i = e.end || O, r = t.state.facet(Ei).hideOn(t, O, i);
  if (r != null)
    return r;
  let n = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((s) => s.is(Yu)) || t.changes.touchesRange(n.from, Math.max(n.to, i)));
}
function a1(t, e) {
  return t.field(De, !1) ? e : e.concat(z.appendConfig.of(p1));
}
const Yu = /* @__PURE__ */ z.define(), Bo = /* @__PURE__ */ z.define(), zu = /* @__PURE__ */ z.define(), De = /* @__PURE__ */ pe.define({
  create() {
    return new st(Z.none, null, null);
  },
  update(t, e) {
    if (e.docChanged && t.diagnostics.size) {
      let O = t.diagnostics.map(e.changes), i = null, r = t.panel;
      if (t.selected) {
        let n = e.changes.mapPos(t.selected.from, 1);
        i = Et(O, t.selected.diagnostic, n) || Et(O, null, n);
      }
      !O.size && r && e.state.facet(Ei).autoPanel && (r = null), t = new st(O, r, i);
    }
    for (let O of e.effects)
      if (O.is(Yu)) {
        let i = e.state.facet(Ei).autoPanel ? O.value.length ? Ai.open : null : t.panel;
        t = st.init(O.value, i, e.state);
      } else O.is(Bo) ? t = new st(t.diagnostics, O.value ? Ai.open : null, t.selected) : O.is(zu) && (t = new st(t.diagnostics, t.panel, O.value));
    return t;
  },
  provide: (t) => [
    qi.from(t, (e) => e.panel),
    k.decorations.from(t, (e) => e.diagnostics)
  ]
}), o1 = /* @__PURE__ */ Z.mark({ class: "cm-lintRange cm-lintRange-active" });
function l1(t, e, O) {
  let { diagnostics: i } = t.state.field(De), r = [], n = 2e8, s = 0;
  i.between(e - (O < 0 ? 1 : 0), e + (O > 0 ? 1 : 0), (o, c, { spec: h }) => {
    e >= o && e <= c && (o == c || (e > o || O > 0) && (e < c || O < 0)) && (r.push(h.diagnostic), n = Math.min(o, n), s = Math.max(c, s));
  });
  let a = t.state.facet(Ei).tooltipFilter;
  return a && (r = a(r, t.state)), r.length ? {
    pos: n,
    end: s,
    above: t.state.doc.lineAt(n).to < s,
    create() {
      return { dom: c1(t, r) };
    }
  } : null;
}
function c1(t, e) {
  return J("ul", { class: "cm-tooltip-lint" }, e.map((O) => Uu(t, O, !1)));
}
const h1 = (t) => {
  let e = t.state.field(De, !1);
  (!e || !e.panel) && t.dispatch({ effects: a1(t.state, [Bo.of(!0)]) });
  let O = zi(t, Ai.open);
  return O && O.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, rh = (t) => {
  let e = t.state.field(De, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Bo.of(!1) }), !0);
}, Q1 = (t) => {
  let e = t.state.field(De, !1);
  if (!e)
    return !1;
  let O = t.state.selection.main, i = e.diagnostics.iter(O.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == O.from && i.to == O.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, f1 = [
  { key: "Mod-Shift-m", run: h1, preventDefault: !0 },
  { key: "F8", run: Q1 }
], Ei = /* @__PURE__ */ R.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, XO(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (e, O) => e ? O ? (i) => e(i) || O(i) : e : O
    }));
  }
});
function qu(t) {
  let e = [];
  if (t)
    e: for (let { name: O } of t) {
      for (let i = 0; i < O.length; i++) {
        let r = O[i];
        if (/[a-zA-Z]/.test(r) && !e.some((n) => n.toLowerCase() == r.toLowerCase())) {
          e.push(r);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function Uu(t, e, O) {
  var i;
  let r = O ? qu(e.actions) : [];
  return J("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, J("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(t) : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((n, s) => {
    let a = !1, o = (f) => {
      if (f.preventDefault(), a)
        return;
      a = !0;
      let $ = Et(t.state.field(De).diagnostics, e);
      $ && n.apply(t, $.from, $.to);
    }, { name: c } = n, h = r[s] ? c.indexOf(r[s]) : -1, Q = h < 0 ? c : [
      c.slice(0, h),
      J("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return J("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: o,
      onmousedown: o,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${r[s]})"`}.`
    }, Q);
  }), e.source && J("div", { class: "cm-diagnosticSource" }, e.source));
}
class $1 extends VO {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return J("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class nh {
  constructor(e, O) {
    this.diagnostic = O, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = Uu(e, O, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ai {
  constructor(e) {
    this.view = e, this.items = [];
    let O = (r) => {
      if (r.keyCode == 27)
        rh(this.view), this.view.focus();
      else if (r.keyCode == 38 || r.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (r.keyCode == 40 || r.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (r.keyCode == 36)
        this.moveSelection(0);
      else if (r.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (r.keyCode == 13)
        this.view.focus();
      else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], s = qu(n.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == r.keyCode) {
            let o = Et(this.view.state.field(De).diagnostics, n);
            o && n.actions[a].apply(e, o.from, o.to);
          }
      } else
        return;
      r.preventDefault();
    }, i = (r) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(r.target) && this.moveSelection(n);
    };
    this.list = J("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: O,
      onclick: i
    }), this.dom = J("div", { class: "cm-panel-lint" }, this.list, J("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => rh(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(De).selected;
    if (!e)
      return -1;
    for (let O = 0; O < this.items.length; O++)
      if (this.items[O].diagnostic == e.diagnostic)
        return O;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: O } = this.view.state.field(De), i = 0, r = !1, n = null;
    for (e.between(0, this.view.state.doc.length, (s, a, { spec: o }) => {
      let c = -1, h;
      for (let Q = i; Q < this.items.length; Q++)
        if (this.items[Q].diagnostic == o.diagnostic) {
          c = Q;
          break;
        }
      c < 0 ? (h = new nh(this.view, o.diagnostic), this.items.splice(i, 0, h), r = !0) : (h = this.items[c], c > i && (this.items.splice(i, c - i), r = !0)), O && h.diagnostic == O.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), n = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      r = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new nh(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), r = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: s, panel: a }) => {
        let o = a.height / this.list.offsetHeight;
        s.top < a.top ? this.list.scrollTop -= (a.top - s.top) / o : s.bottom > a.bottom && (this.list.scrollTop += (s.bottom - a.bottom) / o);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function O() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          O();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      O();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let O = this.view.state.field(De), i = Et(O.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: zu.of(i)
    });
  }
  static open(e) {
    return new Ai(e);
  }
}
function u1(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Zr(t) {
  return u1(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const d1 = /* @__PURE__ */ k.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Zr("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Zr("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Zr("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Zr("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), p1 = [
  De,
  /* @__PURE__ */ k.decorations.compute([De], (t) => {
    let { selected: e, panel: O } = t.field(De);
    return !e || !O || e.from == e.to ? Z.none : Z.set([
      o1.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ fg(l1, { hideOn: s1 }),
  d1
], m1 = [
  Xg(),
  xg(),
  DP(),
  vS(),
  tS(),
  YP(),
  _P(),
  E.allowMultipleSelections.of(!0),
  Dg(),
  Z$(sS, { fallback: !0 }),
  fS(),
  Iy(),
  i1(),
  tg(),
  ng(),
  FP(),
  GX(),
  Or.of([
    ...Fy,
    ...zX,
    ...ny,
    ...GS,
    ...Kg,
    ...Zu,
    ...f1
  ])
], We = ({ variant: t, settings: e, styles: O }) => {
  const i = k.theme({
    // eslint-disable-next-line @typescript-eslint/naming-convention
    "&": {
      backgroundColor: e.background,
      color: e.foreground
    },
    ".cm-content": {
      caretColor: e.caret
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: e.caret
    },
    "&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: e.selection
    },
    ".cm-activeLine": {
      backgroundColor: e.lineHighlight
    },
    ".cm-gutters": {
      backgroundColor: e.gutterBackground,
      color: e.gutterForeground
    },
    ".cm-activeLineGutter": {
      backgroundColor: e.lineHighlight
    }
  }, {
    dark: t === "dark"
  }), r = nr.define(O);
  return [i, Z$(r)];
};
We({
  variant: "dark",
  settings: {
    background: "#200020",
    foreground: "#D0D0FF",
    caret: "#7070FF",
    selection: "#80000080",
    gutterBackground: "#200020",
    gutterForeground: "#C080C0",
    lineHighlight: "#80000040"
  },
  styles: [
    {
      tag: l.comment,
      color: "#404080"
    },
    {
      tag: [l.string, l.regexp],
      color: "#999999"
    },
    {
      tag: l.number,
      color: "#7090B0"
    },
    {
      tag: [l.bool, l.null],
      color: "#8080A0"
    },
    {
      tag: [l.punctuation, l.derefOperator],
      color: "#805080"
    },
    {
      tag: l.keyword,
      color: "#60B0FF"
    },
    {
      tag: l.definitionKeyword,
      color: "#B0FFF0"
    },
    {
      tag: l.moduleKeyword,
      color: "#60B0FF"
    },
    {
      tag: l.operator,
      color: "#A0A0FF"
    },
    {
      tag: [l.variableName, l.self],
      color: "#008080"
    },
    {
      tag: l.operatorKeyword,
      color: "#A0A0FF"
    },
    {
      tag: l.controlKeyword,
      color: "#80A0FF"
    },
    {
      tag: l.className,
      color: "#70E080"
    },
    {
      tag: [l.function(l.propertyName), l.propertyName],
      color: "#50A0A0"
    },
    {
      tag: l.tagName,
      color: "#009090"
    },
    {
      tag: l.modifier,
      color: "#B0FFF0"
    },
    {
      tag: [l.squareBracket, l.attributeName],
      color: "#D0D0FF"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#fcfcfc",
    foreground: "#5c6166",
    caret: "#ffaa33",
    selection: "#036dd626",
    gutterBackground: "#fcfcfc",
    gutterForeground: "#8a919966",
    lineHighlight: "#8a91991a"
  },
  styles: [
    {
      tag: l.comment,
      color: "#787b8099"
    },
    {
      tag: l.string,
      color: "#86b300"
    },
    {
      tag: l.regexp,
      color: "#4cbf99"
    },
    {
      tag: [l.number, l.bool, l.null],
      color: "#ffaa33"
    },
    {
      tag: l.variableName,
      color: "#5c6166"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#fa8d3e"
    },
    {
      tag: [l.keyword, l.special(l.brace)],
      color: "#fa8d3e"
    },
    {
      tag: l.operator,
      color: "#ed9366"
    },
    {
      tag: l.separator,
      color: "#5c6166b3"
    },
    {
      tag: l.punctuation,
      color: "#5c6166"
    },
    {
      tag: [l.definition(l.propertyName), l.function(l.variableName)],
      color: "#f2ae49"
    },
    {
      tag: [l.className, l.definition(l.typeName)],
      color: "#22a4e6"
    },
    {
      tag: [l.tagName, l.typeName, l.self, l.labelName],
      color: "#55b4d4"
    },
    {
      tag: l.angleBracket,
      color: "#55b4d480"
    },
    {
      tag: l.attributeName,
      color: "#f2ae49"
    }
  ]
});
We({
  variant: "dark",
  settings: {
    background: "#15191EFA",
    foreground: "#EEF2F7",
    caret: "#C4C4C4",
    selection: "#90B2D557",
    gutterBackground: "#15191EFA",
    gutterForeground: "#aaaaaa95",
    lineHighlight: "#57575712"
  },
  styles: [
    {
      tag: l.comment,
      color: "#6E6E6E"
    },
    {
      tag: [l.string, l.regexp, l.special(l.brace)],
      color: "#5C81B3"
    },
    {
      tag: l.number,
      color: "#C1E1B8"
    },
    {
      tag: l.bool,
      color: "#53667D"
    },
    {
      tag: [l.definitionKeyword, l.modifier, l.function(l.propertyName)],
      color: "#A3D295",
      fontWeight: "bold"
    },
    {
      tag: [l.keyword, l.moduleKeyword, l.operatorKeyword, l.operator],
      color: "#697A8E",
      fontWeight: "bold"
    },
    {
      tag: [l.variableName, l.attributeName],
      color: "#708E67"
    },
    {
      tag: [
        l.function(l.variableName),
        l.definition(l.propertyName),
        l.derefOperator
      ],
      color: "#fff"
    },
    {
      tag: l.tagName,
      color: "#A3D295"
    }
  ]
});
We({
  variant: "dark",
  settings: {
    background: "#2e241d",
    foreground: "#BAAE9E",
    caret: "#A7A7A7",
    selection: "#DDF0FF33",
    gutterBackground: "#28211C",
    gutterForeground: "#BAAE9E90",
    lineHighlight: "#FFFFFF08"
  },
  styles: [
    {
      tag: l.comment,
      color: "#666666"
    },
    {
      tag: [l.string, l.special(l.brace)],
      color: "#54BE0D"
    },
    {
      tag: l.regexp,
      color: "#E9C062"
    },
    {
      tag: l.number,
      color: "#CF6A4C"
    },
    {
      tag: [l.keyword, l.operator],
      color: "#5EA6EA"
    },
    {
      tag: l.variableName,
      color: "#7587A6"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#F9EE98"
    },
    {
      tag: [l.propertyName, l.function(l.variableName)],
      color: "#937121"
    },
    {
      tag: [l.typeName, l.angleBracket, l.tagName],
      color: "#9B859D"
    }
  ]
});
We({
  variant: "dark",
  settings: {
    background: "#3b2627",
    foreground: "#E6E1C4",
    caret: "#E6E1C4",
    selection: "#16120E",
    gutterBackground: "#3b2627",
    gutterForeground: "#E6E1C490",
    lineHighlight: "#1F1611"
  },
  styles: [
    {
      tag: l.comment,
      color: "#6B4E32"
    },
    {
      tag: [l.keyword, l.operator, l.derefOperator],
      color: "#EF5D32"
    },
    {
      tag: l.className,
      color: "#EFAC32",
      fontWeight: "bold"
    },
    {
      tag: [
        l.typeName,
        l.propertyName,
        l.function(l.variableName),
        l.definition(l.variableName)
      ],
      color: "#EFAC32"
    },
    {
      tag: l.definition(l.typeName),
      color: "#EFAC32",
      fontWeight: "bold"
    },
    {
      tag: l.labelName,
      color: "#EFAC32",
      fontWeight: "bold"
    },
    {
      tag: [l.number, l.bool],
      color: "#6C99BB"
    },
    {
      tag: [l.variableName, l.self],
      color: "#7DAF9C"
    },
    {
      tag: [l.string, l.special(l.brace), l.regexp],
      color: "#D9D762"
    },
    {
      tag: [l.angleBracket, l.tagName, l.attributeName],
      color: "#EFCB43"
    }
  ]
});
We({
  variant: "dark",
  settings: {
    background: "#000205",
    foreground: "#FFFFFF",
    caret: "#E60065",
    selection: "#E60C6559",
    gutterBackground: "#000205",
    gutterForeground: "#ffffff90",
    lineHighlight: "#4DD7FC1A"
  },
  styles: [
    {
      tag: l.comment,
      color: "#404040"
    },
    {
      tag: [l.string, l.special(l.brace), l.regexp],
      color: "#00D8FF"
    },
    {
      tag: l.number,
      color: "#E62286"
    },
    {
      tag: [l.variableName, l.attributeName, l.self],
      color: "#E62286",
      fontWeight: "bold"
    },
    {
      tag: l.function(l.variableName),
      color: "#fff",
      fontWeight: "bold"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#fff",
    foreground: "#000",
    caret: "#000",
    selection: "#BDD5FC",
    gutterBackground: "#fff",
    gutterForeground: "#00000070",
    lineHighlight: "#FFFBD1"
  },
  styles: [
    {
      tag: l.comment,
      color: "#BCC8BA"
    },
    {
      tag: [l.string, l.special(l.brace), l.regexp],
      color: "#5D90CD"
    },
    {
      tag: [l.number, l.bool, l.null],
      color: "#46A609"
    },
    {
      tag: l.keyword,
      color: "#AF956F"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#C52727"
    },
    {
      tag: [l.angleBracket, l.tagName, l.attributeName],
      color: "#606060"
    },
    {
      tag: l.self,
      color: "#000"
    }
  ]
});
const P1 = We({
  variant: "dark",
  settings: {
    background: "#00254b",
    foreground: "#FFFFFF",
    caret: "#FFFFFF",
    selection: "#B36539BF",
    gutterBackground: "#00254b",
    gutterForeground: "#FFFFFF70",
    lineHighlight: "#00000059"
  },
  styles: [
    {
      tag: l.comment,
      color: "#0088FF"
    },
    {
      tag: l.string,
      color: "#3AD900"
    },
    {
      tag: l.regexp,
      color: "#80FFC2"
    },
    {
      tag: [l.number, l.bool, l.null],
      color: "#FF628C"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#FFEE80"
    },
    {
      tag: l.variableName,
      color: "#CCCCCC"
    },
    {
      tag: l.self,
      color: "#FF80E1"
    },
    {
      tag: [
        l.className,
        l.definition(l.propertyName),
        l.function(l.variableName),
        l.definition(l.typeName),
        l.labelName
      ],
      color: "#FFDD00"
    },
    {
      tag: [l.keyword, l.operator],
      color: "#FF9D00"
    },
    {
      tag: [l.propertyName, l.typeName],
      color: "#80FFBB"
    },
    {
      tag: l.special(l.brace),
      color: "#EDEF7D"
    },
    {
      tag: l.attributeName,
      color: "#9EFFFF"
    },
    {
      tag: l.derefOperator,
      color: "#fff"
    }
  ]
});
We({
  variant: "dark",
  settings: {
    background: "#060521",
    foreground: "#E0E0E0",
    caret: "#FFFFFFA6",
    selection: "#122BBB",
    gutterBackground: "#060521",
    gutterForeground: "#E0E0E090",
    lineHighlight: "#FFFFFF0F"
  },
  styles: [
    {
      tag: l.comment,
      color: "#AEAEAE"
    },
    {
      tag: [l.string, l.special(l.brace), l.regexp],
      color: "#8DFF8E"
    },
    {
      tag: [
        l.className,
        l.definition(l.propertyName),
        l.function(l.variableName),
        l.function(l.definition(l.variableName)),
        l.definition(l.typeName)
      ],
      color: "#A3EBFF"
    },
    {
      tag: [l.number, l.bool, l.null],
      color: "#62E9BD"
    },
    {
      tag: [l.keyword, l.operator],
      color: "#2BF1DC"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#F8FBB1"
    },
    {
      tag: [l.variableName, l.self],
      color: "#B683CA"
    },
    {
      tag: [l.angleBracket, l.tagName, l.typeName, l.propertyName],
      color: "#60A4F1"
    },
    {
      tag: l.derefOperator,
      color: "#E0E0E0"
    },
    {
      tag: l.attributeName,
      color: "#7BACCA"
    }
  ]
});
We({
  variant: "dark",
  settings: {
    background: "#2d2f3f",
    foreground: "#f8f8f2",
    caret: "#f8f8f0",
    selection: "#44475a",
    gutterBackground: "#282a36",
    gutterForeground: "rgb(144, 145, 148)",
    lineHighlight: "#44475a"
  },
  styles: [
    {
      tag: l.comment,
      color: "#6272a4"
    },
    {
      tag: [l.string, l.special(l.brace)],
      color: "#f1fa8c"
    },
    {
      tag: [l.number, l.self, l.bool, l.null],
      color: "#bd93f9"
    },
    {
      tag: [l.keyword, l.operator],
      color: "#ff79c6"
    },
    {
      tag: [l.definitionKeyword, l.typeName],
      color: "#8be9fd"
    },
    {
      tag: l.definition(l.typeName),
      color: "#f8f8f2"
    },
    {
      tag: [
        l.className,
        l.definition(l.propertyName),
        l.function(l.variableName),
        l.attributeName
      ],
      color: "#50fa7b"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#FFFFFF",
    foreground: "#000000",
    caret: "#000000",
    selection: "#80C7FF",
    gutterBackground: "#FFFFFF",
    gutterForeground: "#00000070",
    lineHighlight: "#C1E2F8"
  },
  styles: [
    {
      tag: l.comment,
      color: "#AAAAAA"
    },
    {
      tag: [l.keyword, l.operator, l.typeName, l.tagName, l.propertyName],
      color: "#2F6F9F",
      fontWeight: "bold"
    },
    {
      tag: [l.attributeName, l.definition(l.propertyName)],
      color: "#4F9FD0"
    },
    {
      tag: [l.className, l.string, l.special(l.brace)],
      color: "#CF4F5F"
    },
    {
      tag: l.number,
      color: "#CF4F5F",
      fontWeight: "bold"
    },
    {
      tag: l.variableName,
      fontWeight: "bold"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#f2f1f8",
    foreground: "#0c006b",
    caret: "#5c49e9",
    selection: "#d5d1f2",
    gutterBackground: "#f2f1f8",
    gutterForeground: "#0c006b70",
    lineHighlight: "#e1def3"
  },
  styles: [
    {
      tag: l.comment,
      color: "#9995b7"
    },
    {
      tag: l.keyword,
      color: "#ff5792",
      fontWeight: "bold"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#ff5792"
    },
    {
      tag: [l.className, l.tagName, l.definition(l.typeName)],
      color: "#0094f0"
    },
    {
      tag: [l.number, l.bool, l.null, l.special(l.brace)],
      color: "#5842ff"
    },
    {
      tag: [l.definition(l.propertyName), l.function(l.variableName)],
      color: "#0095a8"
    },
    {
      tag: l.typeName,
      color: "#b3694d"
    },
    {
      tag: [l.propertyName, l.variableName],
      color: "#fa8900"
    },
    {
      tag: l.operator,
      color: "#ff5792"
    },
    {
      tag: l.self,
      color: "#e64100"
    },
    {
      tag: [l.string, l.regexp],
      color: "#00b368"
    },
    {
      tag: [l.paren, l.bracket],
      color: "#0431fa"
    },
    {
      tag: l.labelName,
      color: "#00bdd6"
    },
    {
      tag: l.attributeName,
      color: "#e64100"
    },
    {
      tag: l.angleBracket,
      color: "#9995b7"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#faf4ed",
    foreground: "#575279",
    caret: "#575279",
    selection: "#6e6a8614",
    gutterBackground: "#faf4ed",
    gutterForeground: "#57527970",
    lineHighlight: "#6e6a860d"
  },
  styles: [
    {
      tag: l.comment,
      color: "#9893a5"
    },
    {
      tag: [l.bool, l.null],
      color: "#286983"
    },
    {
      tag: l.number,
      color: "#d7827e"
    },
    {
      tag: l.className,
      color: "#d7827e"
    },
    {
      tag: [l.angleBracket, l.tagName, l.typeName],
      color: "#56949f"
    },
    {
      tag: l.attributeName,
      color: "#907aa9"
    },
    {
      tag: l.punctuation,
      color: "#797593"
    },
    {
      tag: [l.keyword, l.modifier],
      color: "#286983"
    },
    {
      tag: [l.string, l.regexp],
      color: "#ea9d34"
    },
    {
      tag: l.variableName,
      color: "#d7827e"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#FFFFFF",
    foreground: "#000000",
    caret: "#000000",
    selection: "#FFFD0054",
    gutterBackground: "#FFFFFF",
    gutterForeground: "#00000070",
    lineHighlight: "#00000008"
  },
  styles: [
    {
      tag: l.comment,
      color: "#CFCFCF"
    },
    {
      tag: [l.number, l.bool, l.null],
      color: "#E66C29"
    },
    {
      tag: [
        l.className,
        l.definition(l.propertyName),
        l.function(l.variableName),
        l.labelName,
        l.definition(l.typeName)
      ],
      color: "#2EB43B"
    },
    {
      tag: l.keyword,
      color: "#D8B229"
    },
    {
      tag: l.operator,
      color: "#4EA44E",
      fontWeight: "bold"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#925A47"
    },
    {
      tag: l.string,
      color: "#704D3D"
    },
    {
      tag: l.typeName,
      color: "#2F8996"
    },
    {
      tag: [l.variableName, l.propertyName],
      color: "#77ACB0"
    },
    {
      tag: l.self,
      color: "#77ACB0",
      fontWeight: "bold"
    },
    {
      tag: l.regexp,
      color: "#E3965E"
    },
    {
      tag: [l.tagName, l.angleBracket],
      color: "#BAA827"
    },
    {
      tag: l.attributeName,
      color: "#B06520"
    },
    {
      tag: l.derefOperator,
      color: "#000"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#fef7e5",
    foreground: "#586E75",
    caret: "#000000",
    selection: "#073642",
    gutterBackground: "#fef7e5",
    gutterForeground: "#586E7580",
    lineHighlight: "#EEE8D5"
  },
  styles: [
    {
      tag: l.comment,
      color: "#93A1A1"
    },
    {
      tag: l.string,
      color: "#2AA198"
    },
    {
      tag: l.regexp,
      color: "#D30102"
    },
    {
      tag: l.number,
      color: "#D33682"
    },
    {
      tag: l.variableName,
      color: "#268BD2"
    },
    {
      tag: [l.keyword, l.operator, l.punctuation],
      color: "#859900"
    },
    {
      tag: [l.definitionKeyword, l.modifier],
      color: "#073642",
      fontWeight: "bold"
    },
    {
      tag: [l.className, l.self, l.definition(l.propertyName)],
      color: "#268BD2"
    },
    {
      tag: l.function(l.variableName),
      color: "#268BD2"
    },
    {
      tag: [l.bool, l.null],
      color: "#B58900"
    },
    {
      tag: l.tagName,
      color: "#268BD2",
      fontWeight: "bold"
    },
    {
      tag: l.angleBracket,
      color: "#93A1A1"
    },
    {
      tag: l.attributeName,
      color: "#93A1A1"
    },
    {
      tag: l.typeName,
      color: "#859900"
    }
  ]
});
We({
  variant: "light",
  settings: {
    background: "#FFFFFF",
    foreground: "#4D4D4C",
    caret: "#AEAFAD",
    selection: "#D6D6D6",
    gutterBackground: "#FFFFFF",
    gutterForeground: "#4D4D4C80",
    lineHighlight: "#EFEFEF"
  },
  styles: [
    {
      tag: l.comment,
      color: "#8E908C"
    },
    {
      tag: [l.variableName, l.self, l.propertyName, l.attributeName, l.regexp],
      color: "#C82829"
    },
    {
      tag: [l.number, l.bool, l.null],
      color: "#F5871F"
    },
    {
      tag: [l.className, l.typeName, l.definition(l.typeName)],
      color: "#C99E00"
    },
    {
      tag: [l.string, l.special(l.brace)],
      color: "#718C00"
    },
    {
      tag: l.operator,
      color: "#3E999F"
    },
    {
      tag: [l.definition(l.propertyName), l.function(l.variableName)],
      color: "#4271AE"
    },
    {
      tag: l.keyword,
      color: "#8959A8"
    },
    {
      tag: l.derefOperator,
      color: "#4D4D4C"
    }
  ]
});
class yn {
  /**
  @internal
  */
  constructor(e, O, i, r, n, s, a, o, c, h = 0, Q) {
    this.p = e, this.stack = O, this.state = i, this.reducePos = r, this.pos = n, this.score = s, this.buffer = a, this.bufferBase = o, this.curContext = c, this.lookAhead = h, this.parent = Q;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, O) => O % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, O, i = 0) {
    let r = e.parser.context;
    return new yn(e, [], O, i, i, 0, [], 0, r ? new sh(r, r.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, O) {
    this.stack.push(this.state, O, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var O;
    let i = e >> 19, r = e & 65535, { parser: n } = this.p, s = this.reducePos < this.pos - 25;
    s && this.setLookAhead(this.pos);
    let a = n.dynamicPrecedence(r);
    if (a && (this.score += a), i == 0) {
      this.pushState(n.getGoto(this.state, r, !0), this.reducePos), r < n.minRepeatTerm && this.storeNode(r, this.reducePos, this.reducePos, s ? 8 : 4, !0), this.reduceContext(r, this.reducePos);
      return;
    }
    let o = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), c = o ? this.stack[o - 2] : this.p.ranges[0].from, h = this.reducePos - c;
    h >= 2e3 && !(!((O = this.p.parser.nodeSet.types[r]) === null || O === void 0) && O.isAnonymous) && (c == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = c, this.p.lastBigReductionSize = h));
    let Q = o ? this.stack[o - 1] : 0, f = this.bufferBase + this.buffer.length - Q;
    if (r < n.minRepeatTerm || e & 131072) {
      let $ = n.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(r, c, $, f + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[o];
    else {
      let $ = this.stack[o - 3];
      this.state = n.getGoto($, r, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(r, c);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, O, i, r = 4, n = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (O == i)
          return;
        if (s.buffer[a - 2] >= O) {
          s.buffer[a - 2] = i;
          return;
        }
      }
    }
    if (!n || this.pos == i)
      this.buffer.push(e, O, i, r);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0) {
        let a = !1;
        for (let o = s; o > 0 && this.buffer[o - 2] > i; o -= 4)
          if (this.buffer[o - 1] >= 0) {
            a = !0;
            break;
          }
        if (a)
          for (; s > 0 && this.buffer[s - 2] > i; )
            this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, r > 4 && (r -= 4);
      }
      this.buffer[s] = e, this.buffer[s + 1] = O, this.buffer[s + 2] = i, this.buffer[s + 3] = r;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, O, i, r) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = r, this.shiftContext(O, i), O <= this.p.parser.maxNode && this.buffer.push(O, i, r, 4);
    else {
      let n = e, { parser: s } = this.p;
      (r > this.pos || O <= s.maxNode) && (this.pos = r, s.stateFlag(
        n,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = r)), this.pushState(n, i), this.shiftContext(O, i), O <= s.maxNode && this.buffer.push(O, i, r, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, O, i, r) {
    e & 65536 ? this.reduce(e) : this.shift(e, O, i, r);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, O) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let r = this.pos;
    this.reducePos = this.pos = r + e.length, this.pushState(O, r), this.buffer.push(
      i,
      r,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, O = e.buffer.length;
    for (; O > 0 && e.buffer[O - 2] > e.reducePos; )
      O -= 4;
    let i = e.buffer.slice(O), r = e.bufferBase + O;
    for (; e && r == e.bufferBase; )
      e = e.parent;
    return new yn(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, r, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, O) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, O, 4), this.storeNode(0, this.pos, O, i ? 8 : 4), this.pos = this.reducePos = O, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let O = new g1(this); ; ) {
      let i = this.p.parser.stateSlot(
        O.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(O.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      O.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let O = this.p.parser.nextStates(this.state);
    if (O.length > 8 || this.stack.length >= 120) {
      let r = [];
      for (let n = 0, s; n < O.length; n += 2)
        (s = O[n + 1]) != this.state && this.p.parser.hasAction(s, e) && r.push(O[n], s);
      if (this.stack.length < 120)
        for (let n = 0; r.length < 8 && n < O.length; n += 2) {
          let s = O[n + 1];
          r.some((a, o) => o & 1 && a == s) || r.push(O[n], s);
        }
      O = r;
    }
    let i = [];
    for (let r = 0; r < O.length && i.length < 4; r += 2) {
      let n = O[r + 1];
      if (n == this.state)
        continue;
      let s = this.split();
      s.pushState(n, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(O[r], this.pos), s.reducePos = this.pos, s.score -= 200, i.push(s);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, O = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(O & 65536))
      return !1;
    if (!e.validAction(this.state, O)) {
      let i = O >> 19, r = O & 65535, n = this.stack.length - i * 3;
      if (n < 0 || e.getGoto(this.stack[n], r, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        O = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(O), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, O = [], i = (r, n) => {
      if (!O.includes(r))
        return O.push(r), e.allActions(r, (s) => {
          if (!(s & 393216)) if (s & 65536) {
            let a = (s >> 19) - n;
            if (a > 1) {
              let o = s & 65535, c = this.stack.length - a * 3;
              if (c >= 0 && e.getGoto(this.stack[c], o, !1) >= 0)
                return a << 19 | 65536 | o;
            }
          } else {
            let a = i(s, n + 1);
            if (a != null)
              return a;
          }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let O = 0; O < this.stack.length; O += 3)
      if (this.stack[O] != e.stack[O])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, O) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(O)));
  }
  reduceContext(e, O) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(O)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let O = new sh(this.curContext.tracker, e);
      O.hash != this.curContext.hash && this.emitContext(), this.curContext = O;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class sh {
  constructor(e, O) {
    this.tracker = e, this.context = O, this.hash = e.strict ? e.hash(O) : 0;
  }
}
class g1 {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let O = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let r = this.start.p.parser.getGoto(this.stack[this.base - 3], O, !0);
    this.state = r;
  }
}
class bn {
  constructor(e, O, i) {
    this.stack = e, this.pos = O, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, O = e.bufferBase + e.buffer.length) {
    return new bn(e, O, O - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new bn(this.stack, this.pos, this.index);
  }
}
function Qi(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let O = null;
  for (let i = 0, r = 0; i < t.length; ) {
    let n = 0;
    for (; ; ) {
      let s = t.charCodeAt(i++), a = !1;
      if (s == 126) {
        n = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let o = s - 32;
      if (o >= 46 && (o -= 46, a = !0), n += o, a)
        break;
      n *= 46;
    }
    O ? O[r++] = n : O = new e(n);
  }
  return O;
}
class Mr {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const ah = new Mr();
class S1 {
  /**
  @internal
  */
  constructor(e, O) {
    this.input = e, this.ranges = O, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = ah, this.rangeIndex = 0, this.pos = this.chunkPos = O[0].from, this.range = O[0], this.end = O[O.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, O) {
    let i = this.range, r = this.rangeIndex, n = this.pos + e;
    for (; n < i.from; ) {
      if (!r)
        return null;
      let s = this.ranges[--r];
      n -= i.from - s.to, i = s;
    }
    for (; O < 0 ? n > i.to : n >= i.to; ) {
      if (r == this.ranges.length - 1)
        return null;
      let s = this.ranges[++r];
      n += s.from - i.to, i = s;
    }
    return n;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let O of this.ranges)
      if (O.to > e)
        return Math.max(e, O.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingâ€”when looking forwardâ€”or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let O = this.chunkOff + e, i, r;
    if (O >= 0 && O < this.chunk.length)
      i = this.pos + e, r = this.chunk.charCodeAt(O);
    else {
      let n = this.resolveOffset(e, 1);
      if (n == null)
        return -1;
      if (i = n, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        r = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= i; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - i)), r = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), r;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, O = 0) {
    let i = O ? this.resolveOffset(O, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, O) {
    this.token.value = e, this.token.end = O;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: O } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = O, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), O = this.pos + e.length;
      this.chunk = O > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, O) {
    if (O ? (this.token = O, O.start = e, O.lookAhead = e + 1, O.value = O.extended = -1) : this.token = ah, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, O) {
    if (e >= this.chunkPos && O <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, O - this.chunkPos);
    if (e >= this.chunk2Pos && O <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, O - this.chunk2Pos);
    if (e >= this.range.from && O <= this.range.to)
      return this.input.read(e, O);
    let i = "";
    for (let r of this.ranges) {
      if (r.from >= O)
        break;
      r.to > e && (i += this.input.read(Math.max(r.from, e), Math.min(r.to, O)));
    }
    return i;
  }
}
class qt {
  constructor(e, O) {
    this.data = e, this.id = O;
  }
  token(e, O) {
    let { parser: i } = O.p;
    Vu(this.data, e, O, this.id, i.data, i.tokenPrecTable);
  }
}
qt.prototype.contextual = qt.prototype.fallback = qt.prototype.extend = !1;
class nO {
  constructor(e, O, i) {
    this.precTable = O, this.elseToken = i, this.data = typeof e == "string" ? Qi(e) : e;
  }
  token(e, O) {
    let i = e.pos, r = 0;
    for (; ; ) {
      let n = e.next < 0, s = e.resolveOffset(1, 1);
      if (Vu(this.data, e, O, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (n || r++, s == null)
        break;
      e.reset(s, e.token);
    }
    r && (e.reset(i, e.token), e.acceptToken(this.elseToken, r));
  }
}
nO.prototype.contextual = qt.prototype.fallback = qt.prototype.extend = !1;
class q {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, O = {}) {
    this.token = e, this.contextual = !!O.contextual, this.fallback = !!O.fallback, this.extend = !!O.extend;
  }
}
function Vu(t, e, O, i, r, n) {
  let s = 0, a = 1 << i, { dialect: o } = O.p.parser;
  e: for (; a & t[s]; ) {
    let c = t[s + 1];
    for (let $ = s + 3; $ < c; $ += 2)
      if ((t[$ + 1] & a) > 0) {
        let u = t[$];
        if (o.allows(u) && (e.token.value == -1 || e.token.value == u || X1(u, e.token.value, r, n))) {
          e.acceptToken(u);
          break;
        }
      }
    let h = e.next, Q = 0, f = t[s + 2];
    if (e.next < 0 && f > Q && t[c + f * 3 - 3] == 65535) {
      s = t[c + f * 3 - 1];
      continue e;
    }
    for (; Q < f; ) {
      let $ = Q + f >> 1, u = c + $ + ($ << 1), d = t[u], p = t[u + 1] || 65536;
      if (h < d)
        f = $;
      else if (h >= p)
        Q = $ + 1;
      else {
        s = t[u + 2], e.advance();
        continue e;
      }
    }
    break;
  }
}
function oh(t, e, O) {
  for (let i = e, r; (r = t[i]) != 65535; i++)
    if (r == O)
      return i - e;
  return -1;
}
function X1(t, e, O, i) {
  let r = oh(O, i, e);
  return r < 0 || oh(O, i, t) < r;
}
const Ge = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let us = null;
function lh(t, e, O) {
  let i = t.cursor(H.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(O < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((O < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return O < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Lookahead.Margin */
          )) : Math.min(t.length, Math.max(
            i.from + 1,
            e + 25
            /* Lookahead.Margin */
          ));
        if (O < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return O < 0 ? 0 : t.length;
      }
}
let y1 = class {
  constructor(e, O) {
    this.fragments = e, this.nodeSet = O, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? lh(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? lh(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let O = this.trees.length - 1;
      if (O < 0)
        return this.nextFragment(), null;
      let i = this.trees[O], r = this.index[O];
      if (r == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = i.children[r], s = this.start[O] + i.positions[r];
      if (s > e)
        return this.nextStart = s, null;
      if (n instanceof M) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + n.length;
          if (a <= this.safeTo) {
            let o = n.prop(Y.lookAhead);
            if (!o || a + o < this.fragment.to)
              return n;
          }
        }
        this.index[O]++, s + n.length >= Math.max(this.safeFrom, e) && (this.trees.push(n), this.start.push(s), this.index.push(0));
      } else
        this.index[O]++, this.nextStart = s + n.length;
    }
  }
};
class b1 {
  constructor(e, O) {
    this.stream = O, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new Mr());
  }
  getActions(e) {
    let O = 0, i = null, { parser: r } = e.p, { tokenizers: n } = r, s = r.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, o = 0;
    for (let c = 0; c < n.length; c++) {
      if (!(1 << c & s))
        continue;
      let h = n[c], Q = this.tokens[c];
      if (!(i && !h.fallback) && ((h.contextual || Q.start != e.pos || Q.mask != s || Q.context != a) && (this.updateCachedToken(Q, h, e), Q.mask = s, Q.context = a), Q.lookAhead > Q.end + 25 && (o = Math.max(Q.lookAhead, o)), Q.value != 0)) {
        let f = O;
        if (Q.extended > -1 && (O = this.addActions(e, Q.extended, Q.end, O)), O = this.addActions(e, Q.value, Q.end, O), !h.extend && (i = Q, O > f))
          break;
      }
    }
    for (; this.actions.length > O; )
      this.actions.pop();
    return o && e.setLookAhead(o), !i && e.pos == this.stream.end && (i = new Mr(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, O = this.addActions(e, i.value, i.end, O)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let O = new Mr(), { pos: i, p: r } = e;
    return O.start = i, O.end = Math.min(i + 1, r.stream.end), O.value = i == r.stream.end ? r.parser.eofTerm : 0, O;
  }
  updateCachedToken(e, O, i) {
    let r = this.stream.clipPos(i.pos);
    if (O.token(this.stream.reset(r, e), i), e.value > -1) {
      let { parser: n } = i.p;
      for (let s = 0; s < n.specialized.length; s++)
        if (n.specialized[s] == e.value) {
          let a = n.specializers[s](this.stream.read(e.start, e.end), i);
          if (a >= 0 && i.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(r + 1);
  }
  putAction(e, O, i, r) {
    for (let n = 0; n < r; n += 3)
      if (this.actions[n] == e)
        return r;
    return this.actions[r++] = e, this.actions[r++] = O, this.actions[r++] = i, r;
  }
  addActions(e, O, i, r) {
    let { state: n } = e, { parser: s } = e.p, { data: a } = s;
    for (let o = 0; o < 2; o++)
      for (let c = s.stateSlot(
        n,
        o ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = xO(a, c + 2);
          else {
            r == 0 && a[c + 1] == 2 && (r = this.putAction(xO(a, c + 2), O, i, r));
            break;
          }
        a[c] == O && (r = this.putAction(xO(a, c + 1), O, i, r));
      }
    return r;
  }
}
class x1 {
  constructor(e, O, i, r) {
    this.parser = e, this.input = O, this.ranges = r, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new S1(O, r), this.tokens = new b1(e, this.stream), this.topTerm = e.top[1];
    let { from: n } = r[0];
    this.stacks = [yn.start(this, e.top[0], n)], this.fragments = i.length && this.stream.end - n > e.bufferLength * 4 ? new y1(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, O = this.minStackPos, i = this.stacks = [], r, n;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > O)
          i.push(a);
        else {
          if (this.advanceStack(a, i, e))
            continue;
          {
            r || (r = [], n = []), r.push(a);
            let o = this.tokens.getMainToken(a);
            n.push(o.value, o.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let s = r && w1(r);
      if (s)
        return Ge && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw Ge && r && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + O);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && r) {
      let s = this.stoppedAt != null && r[0].pos > this.stoppedAt ? r[0] : this.runRecovery(r, n, i);
      if (s)
        return Ge && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > s)
        for (i.sort((a, o) => o.score - a.score); i.length > s; )
          i.pop();
      i.some((a) => a.reducePos > O) && this.recovering--;
    } else if (i.length > 1) {
      e: for (let s = 0; s < i.length - 1; s++) {
        let a = i[s];
        for (let o = s + 1; o < i.length; o++) {
          let c = i[o];
          if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
            if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
              i.splice(o--, 1);
            else {
              i.splice(s--, 1);
              continue e;
            }
        }
      }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let s = 1; s < i.length; s++)
      i[s].pos < this.minStackPos && (this.minStackPos = i[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, O, i) {
    let r = e.pos, { parser: n } = this, s = Ge ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && r > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let Q = this.fragments.nodeAt(r); Q; ) {
        let f = this.parser.nodeSet.types[Q.type.id] == Q.type ? n.getGoto(e.state, Q.type.id) : -1;
        if (f > -1 && Q.length && (!c || (Q.prop(Y.contextHash) || 0) == h))
          return e.useNode(Q, f), Ge && console.log(s + this.stackID(e) + ` (via reuse of ${n.getName(Q.type.id)})`), !0;
        if (!(Q instanceof M) || Q.children.length == 0 || Q.positions[0] > 0)
          break;
        let $ = Q.children[0];
        if ($ instanceof M && Q.positions[0] == 0)
          Q = $;
        else
          break;
      }
    }
    let a = n.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), Ge && console.log(s + this.stackID(e) + ` (via always-reduce ${n.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let o = this.tokens.getActions(e);
    for (let c = 0; c < o.length; ) {
      let h = o[c++], Q = o[c++], f = o[c++], $ = c == o.length || !i, u = $ ? e : e.split(), d = this.tokens.mainToken;
      if (u.apply(h, Q, d ? d.start : u.pos, f), Ge && console.log(s + this.stackID(u) + ` (via ${h & 65536 ? `reduce of ${n.getName(
        h & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${n.getName(Q)} @ ${r}${u == e ? "" : ", split"})`), $)
        return !0;
      u.pos > r ? O.push(u) : i.push(u);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, O) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return ch(e, O), !0;
    }
  }
  runRecovery(e, O, i) {
    let r = null, n = !1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], o = O[s << 1], c = O[(s << 1) + 1], h = Ge ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (n || (n = !0, a.restart(), Ge && console.log(h + this.stackID(a) + " (restarted)"), this.advanceFully(a, i))))
        continue;
      let Q = a.split(), f = h;
      for (let $ = 0; Q.forceReduce() && $ < 10 && (Ge && console.log(f + this.stackID(Q) + " (via force-reduce)"), !this.advanceFully(Q, i)); $++)
        Ge && (f = this.stackID(Q) + " -> ");
      for (let $ of a.recoverByInsert(o))
        Ge && console.log(h + this.stackID($) + " (via recover-insert)"), this.advanceFully($, i);
      this.stream.end > a.pos ? (c == a.pos && (c++, o = 0), a.recoverByDelete(o, c), Ge && console.log(h + this.stackID(a) + ` (via recover-delete ${this.parser.getName(o)})`), ch(a, i)) : (!r || r.score < a.score) && (r = a);
    }
    return r;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), M.build({
      buffer: bn.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let O = (us || (us = /* @__PURE__ */ new WeakMap())).get(e);
    return O || us.set(e, O = String.fromCodePoint(this.nextStackID++)), O + e;
  }
}
function ch(t, e) {
  for (let O = 0; O < e.length; O++) {
    let i = e[O];
    if (i.pos == t.pos && i.sameState(t)) {
      e[O].score < t.score && (e[O] = t);
      return;
    }
  }
  e.push(t);
}
class T1 {
  constructor(e, O, i) {
    this.source = e, this.flags = O, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const ds = (t) => t;
class Ft {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || ds, this.reduce = e.reduce || ds, this.reuse = e.reuse || ds, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class ne extends fo {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let O = e.nodeNames.split(" ");
    this.minRepeatTerm = O.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      O.push("");
    let i = Object.keys(e.topRules).map((a) => e.topRules[a][1]), r = [];
    for (let a = 0; a < O.length; a++)
      r.push([]);
    function n(a, o, c) {
      r[a].push([o, o.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let o = a[0];
        typeof o == "string" && (o = Y[o]);
        for (let c = 1; c < a.length; ) {
          let h = a[c++];
          if (h >= 0)
            n(h, o, a[c++]);
          else {
            let Q = a[c + -h];
            for (let f = -h; f > 0; f--)
              n(a[c++], o, Q);
            c++;
          }
        }
      }
    this.nodeSet = new Hi(O.map((a, o) => de.define({
      name: o >= this.minRepeatTerm ? void 0 : a,
      id: o,
      props: r[o],
      top: i.indexOf(o) > -1,
      error: o == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(o) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = 1024;
    let s = Qi(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(hh), this.states = Qi(e.states, Uint32Array), this.data = Qi(e.stateData), this.goto = Qi(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new qt(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, O, i) {
    let r = new x1(this, e, O, i);
    for (let n of this.wrappers)
      r = n(r, e, O, i);
    return r;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, O, i = !1) {
    let r = this.goto;
    if (O >= r[0])
      return -1;
    for (let n = r[O + 1]; ; ) {
      let s = r[n++], a = s & 1, o = r[n++];
      if (a && i)
        return o;
      for (let c = n + (s >> 1); n < c; n++)
        if (r[n] == e)
          return o;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, O) {
    let i = this.data;
    for (let r = 0; r < 2; r++)
      for (let n = this.stateSlot(
        e,
        r ? 2 : 1
        /* ParseState.Actions */
      ), s; ; n += 3) {
        if ((s = i[n]) == 65535)
          if (i[n + 1] == 1)
            s = i[n = xO(i, n + 2)];
          else {
            if (i[n + 1] == 2)
              return xO(i, n + 2);
            break;
          }
        if (s == O || s == 0)
          return xO(i, n + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, O) {
    return this.states[e * 6 + O];
  }
  /**
  @internal
  */
  stateFlag(e, O) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & O) > 0;
  }
  /**
  @internal
  */
  validAction(e, O) {
    return !!this.allActions(e, (i) => i == O ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, O) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), r = i ? O(i) : void 0;
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); r == null; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = xO(this.data, n + 2);
        else
          break;
      r = O(xO(this.data, n + 1));
    }
    return r;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let O = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = xO(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let r = this.data[i + 1];
        O.some((n, s) => s & 1 && n == r) || O.push(this.data[i], r);
      }
    }
    return O;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let O = Object.assign(Object.create(ne.prototype), this);
    if (e.props && (O.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      O.top = i;
    }
    return e.tokenizers && (O.tokenizers = this.tokenizers.map((i) => {
      let r = e.tokenizers.find((n) => n.from == i);
      return r ? r.to : i;
    })), e.specializers && (O.specializers = this.specializers.slice(), O.specializerSpecs = this.specializerSpecs.map((i, r) => {
      let n = e.specializers.find((a) => a.from == i.external);
      if (!n)
        return i;
      let s = Object.assign(Object.assign({}, i), { external: n.to });
      return O.specializers[r] = hh(s), s;
    })), e.contextTracker && (O.context = e.contextTracker), e.dialect && (O.dialect = this.parseDialect(e.dialect)), e.strict != null && (O.strict = e.strict), e.wrap && (O.wrappers = O.wrappers.concat(e.wrap)), e.bufferLength != null && (O.bufferLength = e.bufferLength), O;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let O = this.dynamicPrecedences;
    return O == null ? 0 : O[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let O = Object.keys(this.dialects), i = O.map(() => !1);
    if (e)
      for (let n of e.split(" ")) {
        let s = O.indexOf(n);
        s >= 0 && (i[s] = !0);
      }
    let r = null;
    for (let n = 0; n < O.length; n++)
      if (!i[n])
        for (let s = this.dialects[O[n]], a; (a = this.data[s++]) != 65535; )
          (r || (r = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new T1(e, i, r);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new ne(e);
  }
}
function xO(t, e) {
  return t[e] | t[e + 1] << 16;
}
function w1(t) {
  let e = null;
  for (let O of t) {
    let i = O.p.stoppedAt;
    (O.pos == O.p.stream.end || i != null && O.pos > i) && O.p.parser.stateFlag(
      O.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < O.score) && (e = O);
  }
  return e;
}
function hh(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (O, i) => t.external(O, i) << 1 | e;
  }
  return t.get;
}
const k1 = 54, W1 = 1, R1 = 55, v1 = 2, Z1 = 56, Y1 = 3, Qh = 4, z1 = 5, xn = 6, _u = 7, ju = 8, Gu = 9, Cu = 10, q1 = 11, U1 = 12, V1 = 13, ps = 57, _1 = 14, fh = 58, Eu = 20, j1 = 22, Au = 23, G1 = 24, Ya = 26, Du = 27, C1 = 28, E1 = 31, A1 = 34, D1 = 36, N1 = 37, I1 = 0, M1 = 1, L1 = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, B1 = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, $h = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function F1(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function Nu(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let uh = null, dh = null, ph = 0;
function za(t, e) {
  let O = t.pos + e;
  if (ph == O && dh == t) return uh;
  let i = t.peek(e);
  for (; Nu(i); ) i = t.peek(++e);
  let r = "";
  for (; F1(i); )
    r += String.fromCharCode(i), i = t.peek(++e);
  return dh = t, ph = O, uh = r ? r.toLowerCase() : i == H1 || i == K1 ? void 0 : null;
}
const Iu = 60, Tn = 62, Fo = 47, H1 = 63, K1 = 33, J1 = 45;
function mh(t, e) {
  this.name = t, this.parent = e;
}
const eb = [xn, Cu, _u, ju, Gu], Ob = new Ft({
  start: null,
  shift(t, e, O, i) {
    return eb.indexOf(e) > -1 ? new mh(za(i, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == Eu && t ? t.parent : t;
  },
  reuse(t, e, O, i) {
    let r = e.type.id;
    return r == xn || r == D1 ? new mh(za(i, 1) || "", t) : t;
  },
  strict: !1
}), tb = new q((t, e) => {
  if (t.next != Iu) {
    t.next < 0 && e.context && t.acceptToken(ps);
    return;
  }
  t.advance();
  let O = t.next == Fo;
  O && t.advance();
  let i = za(t, 0);
  if (i === void 0) return;
  if (!i) return t.acceptToken(O ? _1 : xn);
  let r = e.context ? e.context.name : null;
  if (O) {
    if (i == r) return t.acceptToken(q1);
    if (r && B1[r]) return t.acceptToken(ps, -2);
    if (e.dialectEnabled(I1)) return t.acceptToken(U1);
    for (let n = e.context; n; n = n.parent) if (n.name == i) return;
    t.acceptToken(V1);
  } else {
    if (i == "script") return t.acceptToken(_u);
    if (i == "style") return t.acceptToken(ju);
    if (i == "textarea") return t.acceptToken(Gu);
    if (L1.hasOwnProperty(i)) return t.acceptToken(Cu);
    r && $h[r] && $h[r][i] ? t.acceptToken(ps, -1) : t.acceptToken(xn);
  }
}, { contextual: !0 }), ib = new q((t) => {
  for (let e = 0, O = 0; ; O++) {
    if (t.next < 0) {
      O && t.acceptToken(fh);
      break;
    }
    if (t.next == J1)
      e++;
    else if (t.next == Tn && e >= 2) {
      O >= 3 && t.acceptToken(fh, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function rb(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math") return !0;
  return !1;
}
const nb = new q((t, e) => {
  if (t.next == Fo && t.peek(1) == Tn) {
    let O = e.dialectEnabled(M1) || rb(e.context);
    t.acceptToken(O ? z1 : Qh, 2);
  } else t.next == Tn && t.acceptToken(Qh, 1);
});
function Ho(t, e, O) {
  let i = 2 + t.length;
  return new q((r) => {
    for (let n = 0, s = 0, a = 0; ; a++) {
      if (r.next < 0) {
        a && r.acceptToken(e);
        break;
      }
      if (n == 0 && r.next == Iu || n == 1 && r.next == Fo || n >= 2 && n < i && r.next == t.charCodeAt(n - 2))
        n++, s++;
      else if ((n == 2 || n == i) && Nu(r.next))
        s++;
      else if (n == i && r.next == Tn) {
        a > s ? r.acceptToken(e, -s) : r.acceptToken(O, -(s - 2));
        break;
      } else if ((r.next == 10 || r.next == 13) && a) {
        r.acceptToken(e, 1);
        break;
      } else
        n = s = 0;
      r.advance();
    }
  });
}
const sb = Ho("script", k1, W1), ab = Ho("style", R1, v1), ob = Ho("textarea", Z1, Y1), lb = se({
  "Text RawText": l.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": l.angleBracket,
  TagName: l.tagName,
  "MismatchedCloseTag/TagName": [l.tagName, l.invalid],
  AttributeName: l.attributeName,
  "AttributeValue UnquotedAttributeValue": l.attributeValue,
  Is: l.definitionOperator,
  "EntityReference CharacterReference": l.character,
  Comment: l.blockComment,
  ProcessingInst: l.processingInstruction,
  DoctypeDecl: l.documentMeta
}), cb = ne.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Ob,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [lb],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [sb, ab, ob, nb, tb, ib, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function Mu(t, e) {
  let O = /* @__PURE__ */ Object.create(null);
  for (let i of t.getChildren(Au)) {
    let r = i.getChild(G1), n = i.getChild(Ya) || i.getChild(Du);
    r && (O[e.read(r.from, r.to)] = n ? n.type.id == Ya ? e.read(n.from + 1, n.to - 1) : e.read(n.from, n.to) : "");
  }
  return O;
}
function Ph(t, e) {
  let O = t.getChild(j1);
  return O ? e.read(O.from, O.to) : " ";
}
function ms(t, e, O) {
  let i;
  for (let r of O)
    if (!r.attrs || r.attrs(i || (i = Mu(t.node.parent.firstChild, e))))
      return { parser: r.parser };
  return null;
}
function Lu(t = [], e = []) {
  let O = [], i = [], r = [], n = [];
  for (let a of t)
    (a.tag == "script" ? O : a.tag == "style" ? i : a.tag == "textarea" ? r : n).push(a);
  let s = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e) (s[a.name] || (s[a.name] = [])).push(a);
  return SO((a, o) => {
    let c = a.type.id;
    if (c == C1) return ms(a, o, O);
    if (c == E1) return ms(a, o, i);
    if (c == A1) return ms(a, o, r);
    if (c == Eu && n.length) {
      let h = a.node, Q = h.firstChild, f = Q && Ph(Q, o), $;
      if (f) {
        for (let u of n)
          if (u.tag == f && (!u.attrs || u.attrs($ || ($ = Mu(Q, o))))) {
            let d = h.lastChild, p = d.type.id == N1 ? d.from : h.to;
            if (p > Q.to)
              return { parser: u.parser, overlay: [{ from: Q.to, to: p }] };
          }
      }
    }
    if (s && c == Au) {
      let h = a.node, Q;
      if (Q = h.firstChild) {
        let f = s[o.read(Q.from, Q.to)];
        if (f) for (let $ of f) {
          if ($.tagName && $.tagName != Ph(h.parent, o)) continue;
          let u = h.lastChild;
          if (u.type.id == Ya) {
            let d = u.from + 1, p = u.lastChild, m = u.to - (p && p.isError ? 0 : 1);
            if (m > d) return { parser: $.parser, overlay: [{ from: d, to: m }] };
          } else if (u.type.id == Du)
            return { parser: $.parser, overlay: [{ from: u.from, to: u.to }] };
        }
      }
    }
    return null;
  });
}
const hb = 99, gh = 1, Qb = 100, fb = 101, Sh = 2, Bu = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], $b = 58, ub = 40, Fu = 95, db = 91, Lr = 45, pb = 46, mb = 35, Pb = 37, gb = 38, Sb = 92, Xb = 10;
function Di(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function Hu(t) {
  return t >= 48 && t <= 57;
}
const yb = new q((t, e) => {
  for (let O = !1, i = 0, r = 0; ; r++) {
    let { next: n } = t;
    if (Di(n) || n == Lr || n == Fu || O && Hu(n))
      !O && (n != Lr || r > 0) && (O = !0), i === r && n == Lr && i++, t.advance();
    else if (n == Sb && t.peek(1) != Xb)
      t.advance(), t.next > -1 && t.advance(), O = !0;
    else {
      O && t.acceptToken(n == ub ? Qb : i == 2 && e.canShift(Sh) ? Sh : fb);
      break;
    }
  }
}), bb = new q((t) => {
  if (Bu.includes(t.peek(-1))) {
    let { next: e } = t;
    (Di(e) || e == Fu || e == mb || e == pb || e == db || e == $b && Di(t.peek(1)) || e == Lr || e == gb) && t.acceptToken(hb);
  }
}), xb = new q((t) => {
  if (!Bu.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == Pb && (t.advance(), t.acceptToken(gh)), Di(e)) {
      do
        t.advance();
      while (Di(t.next) || Hu(t.next));
      t.acceptToken(gh);
    }
  }
}), Tb = se({
  "AtKeyword import charset namespace keyframes media supports": l.definitionKeyword,
  "from to selector": l.keyword,
  NamespaceName: l.namespace,
  KeyframeName: l.labelName,
  KeyframeRangeName: l.operatorKeyword,
  TagName: l.tagName,
  ClassName: l.className,
  PseudoClassName: l.constant(l.className),
  IdName: l.labelName,
  "FeatureName PropertyName": l.propertyName,
  AttributeName: l.attributeName,
  NumberLiteral: l.number,
  KeywordQuery: l.keyword,
  UnaryQueryOp: l.operatorKeyword,
  "CallTag ValueName": l.atom,
  VariableName: l.variableName,
  Callee: l.operatorKeyword,
  Unit: l.unit,
  "UniversalSelector NestingSelector": l.definitionOperator,
  MatchOp: l.compareOperator,
  "ChildOp SiblingOp, LogicOp": l.logicOperator,
  BinOp: l.arithmeticOperator,
  Important: l.modifier,
  Comment: l.blockComment,
  ColorLiteral: l.color,
  "ParenthesizedContent StringLiteral": l.string,
  ":": l.punctuation,
  "PseudoOp #": l.derefOperator,
  "; ,": l.separator,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace
}), wb = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, kb = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, Wb = { __proto__: null, not: 132, only: 132 }, Rb = ne.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: "âš  Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [Tb],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [bb, xb, yb, 1, 2, 3, 4, new nO("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t) => wb[t] || -1 }, { term: 58, get: (t) => kb[t] || -1 }, { term: 101, get: (t) => Wb[t] || -1 }],
  tokenPrec: 1200
});
let Ps = null;
function gs() {
  if (!Ps && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], O = /* @__PURE__ */ new Set();
    for (let i in t)
      i != "cssText" && i != "cssFloat" && typeof t[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (r) => "-" + r.toLowerCase())), O.has(i) || (e.push(i), O.add(i)));
    Ps = e.sort().map((i) => ({ type: "property", label: i }));
  }
  return Ps || [];
}
const Xh = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), yh = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), vb = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), _O = /^(\w[\w-]*|-\w[\w-]*|)$/, Zb = /^-(-[\w-]*)?$/;
function Yb(t, e) {
  var O;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let i = (O = t.parent) === null || O === void 0 ? void 0 : O.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
}
const bh = /* @__PURE__ */ new Qo(), zb = ["Declaration"];
function qb(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function Ku(t, e, O) {
  if (e.to - e.from > 4096) {
    let i = bh.get(e);
    if (i)
      return i;
    let r = [], n = /* @__PURE__ */ new Set(), s = e.cursor(H.IncludeAnonymous);
    if (s.firstChild())
      do
        for (let a of Ku(t, s.node, O))
          n.has(a.label) || (n.add(a.label), r.push(a));
      while (s.nextSibling());
    return bh.set(e, r), r;
  } else {
    let i = [], r = /* @__PURE__ */ new Set();
    return e.cursor().iterate((n) => {
      var s;
      if (O(n) && n.matchContext(zb) && ((s = n.node.nextSibling) === null || s === void 0 ? void 0 : s.name) == ":") {
        let a = t.sliceString(n.from, n.to);
        r.has(a) || (r.add(a), i.push({ label: a, type: "variable" }));
      }
    }), i;
  }
}
const Ko = (t) => (e) => {
  let { state: O, pos: i } = e, r = I(O).resolveInner(i, -1), n = r.type.isError && r.from == r.to - 1 && O.doc.sliceString(r.from, r.to) == "-";
  if (r.name == "PropertyName" || (n || r.name == "TagName") && /^(Block|Styles)$/.test(r.resolve(r.to).name))
    return { from: r.from, options: gs(), validFor: _O };
  if (r.name == "ValueName")
    return { from: r.from, options: yh, validFor: _O };
  if (r.name == "PseudoClassName")
    return { from: r.from, options: Xh, validFor: _O };
  if (t(r) || (e.explicit || n) && Yb(r, O.doc))
    return {
      from: t(r) || n ? r.from : i,
      options: Ku(O.doc, qb(r), t),
      validFor: Zb
    };
  if (r.name == "TagName") {
    for (let { parent: o } = r; o; o = o.parent)
      if (o.name == "Block")
        return { from: r.from, options: gs(), validFor: _O };
    return { from: r.from, options: vb, validFor: _O };
  }
  if (!e.explicit)
    return null;
  let s = r.resolve(i), a = s.childBefore(i);
  return a && a.name == ":" && s.name == "PseudoClassSelector" ? { from: i, options: Xh, validFor: _O } : a && a.name == ":" && s.name == "Declaration" || s.name == "ArgList" ? { from: i, options: yh, validFor: _O } : s.name == "Block" || s.name == "Styles" ? { from: i, options: gs(), validFor: _O } : null;
}, Ub = /* @__PURE__ */ Ko((t) => t.name == "VariableName"), wn = /* @__PURE__ */ re.define({
  name: "css",
  parser: /* @__PURE__ */ Rb.configure({
    props: [
      /* @__PURE__ */ me.add({
        Declaration: /* @__PURE__ */ ae()
      }),
      /* @__PURE__ */ fe.add({
        "Block KeyframeList": Ie
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Ju() {
  return new le(wn, wn.data.of({ autocomplete: Ub }));
}
const Vb = 312, xh = 1, _b = 2, jb = 3, Gb = 4, Cb = 313, Eb = 315, Ab = 316, Db = 5, Nb = 6, Ib = 0, qa = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], ed = 125, Mb = 59, Ua = 47, Lb = 42, Bb = 43, Fb = 45, Hb = 60, Kb = 44, Jb = 63, ex = 46, Ox = new Ft({
  start: !1,
  shift(t, e) {
    return e == Db || e == Nb || e == Eb ? t : e == Ab;
  },
  strict: !1
}), tx = new q((t, e) => {
  let { next: O } = t;
  (O == ed || O == -1 || e.context) && t.acceptToken(Cb);
}, { contextual: !0, fallback: !0 }), ix = new q((t, e) => {
  let { next: O } = t, i;
  qa.indexOf(O) > -1 || O == Ua && ((i = t.peek(1)) == Ua || i == Lb) || O != ed && O != Mb && O != -1 && !e.context && t.acceptToken(Vb);
}, { contextual: !0 }), rx = new q((t, e) => {
  let { next: O } = t;
  if (O == Bb || O == Fb) {
    if (t.advance(), O == t.next) {
      t.advance();
      let i = !e.context && e.canShift(xh);
      t.acceptToken(i ? xh : _b);
    }
  } else O == Jb && t.peek(1) == ex && (t.advance(), t.advance(), (t.next < 48 || t.next > 57) && t.acceptToken(jb));
}, { contextual: !0 });
function Ss(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const nx = new q((t, e) => {
  if (t.next != Hb || !e.dialectEnabled(Ib) || (t.advance(), t.next == Ua)) return;
  let O = 0;
  for (; qa.indexOf(t.next) > -1; )
    t.advance(), O++;
  if (Ss(t.next, !0)) {
    for (t.advance(), O++; Ss(t.next, !1); )
      t.advance(), O++;
    for (; qa.indexOf(t.next) > -1; )
      t.advance(), O++;
    if (t.next == Kb) return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!Ss(t.next, !0)) return;
        break;
      }
      if (t.next != "extends".charCodeAt(i)) break;
      t.advance(), O++;
    }
  }
  t.acceptToken(Gb, -O);
}), sx = se({
  "get set async static": l.modifier,
  "for while do if else switch try catch finally return throw break continue default case": l.controlKeyword,
  "in of await yield void typeof delete instanceof": l.operatorKeyword,
  "let var const using function class extends": l.definitionKeyword,
  "import export from": l.moduleKeyword,
  "with debugger as new": l.keyword,
  TemplateString: l.special(l.string),
  super: l.atom,
  BooleanLiteral: l.bool,
  this: l.self,
  null: l.null,
  Star: l.modifier,
  VariableName: l.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": l.function(l.variableName),
  VariableDefinition: l.definition(l.variableName),
  Label: l.labelName,
  PropertyName: l.propertyName,
  PrivatePropertyName: l.special(l.propertyName),
  "CallExpression/MemberExpression/PropertyName": l.function(l.propertyName),
  "FunctionDeclaration/VariableDefinition": l.function(l.definition(l.variableName)),
  "ClassDeclaration/VariableDefinition": l.definition(l.className),
  PropertyDefinition: l.definition(l.propertyName),
  PrivatePropertyDefinition: l.definition(l.special(l.propertyName)),
  UpdateOp: l.updateOperator,
  "LineComment Hashbang": l.lineComment,
  BlockComment: l.blockComment,
  Number: l.number,
  String: l.string,
  Escape: l.escape,
  ArithOp: l.arithmeticOperator,
  LogicOp: l.logicOperator,
  BitOp: l.bitwiseOperator,
  CompareOp: l.compareOperator,
  RegExp: l.regexp,
  Equals: l.definitionOperator,
  Arrow: l.function(l.punctuation),
  ": Spread": l.punctuation,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace,
  "InterpolationStart InterpolationEnd": l.special(l.brace),
  ".": l.derefOperator,
  ", ;": l.separator,
  "@": l.meta,
  TypeName: l.typeName,
  TypeDefinition: l.definition(l.typeName),
  "type enum interface implements namespace module declare": l.definitionKeyword,
  "abstract global Privacy readonly override": l.modifier,
  "is keyof unique infer": l.operatorKeyword,
  JSXAttributeValue: l.attributeValue,
  JSXText: l.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": l.angleBracket,
  "JSXIdentifier JSXNameSpacedName": l.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": l.attributeName,
  "JSXBuiltin/JSXIdentifier": l.standard(l.tagName)
}), ax = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, extends: 54, this: 58, true: 66, false: 66, null: 78, void: 82, typeof: 86, super: 102, new: 136, delete: 148, yield: 157, await: 161, class: 166, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 290, keyof: 345, unique: 349, infer: 355, is: 391, abstract: 411, implements: 413, type: 415, let: 418, var: 420, using: 423, interface: 429, enum: 433, namespace: 439, module: 441, declare: 445, global: 449, for: 468, of: 477, while: 480, with: 484, do: 488, if: 492, else: 494, switch: 498, case: 504, try: 510, catch: 514, finally: 518, return: 522, throw: 526, break: 530, continue: 534, debugger: 538 }, ox = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 395 }, lx = { __proto__: null, "<": 187 }, cx = ne.deserialize({
  version: 14,
  states: "$@QO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#CiO+RO!bO'#CjO+aO#tO'#CjO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DwO0fQ^O'#EPOOQ?Mr'#EX'#EXO1PQWO'#EUOOQO'#Em'#EmOOQO'#Ih'#IhO1XQWO'#GpO1dQWO'#ElO1iQWO'#ElO3hQ?NdO'#JmO6[Q?NdO'#JnO6uQWO'#F[O6zQ&jO'#FsOOQ?Mr'#Fe'#FeO7VO,YO'#FeO7eQ7[O'#FzO9RQWO'#FyOOQ?Mr'#Jn'#JnOOQ?Mp'#Jm'#JmO9WQWO'#GtOOQU'#KZ'#KZO9cQWO'#IUO9hQ?MxO'#IVOOQU'#JZ'#JZOOQU'#IZ'#IZQ`Q^OOO`Q^OOO9pQMnO'#DsO9wQ^O'#D{O:OQ^O'#D}O9^QWO'#GpO:VQ7[O'#CoO:eQWO'#EkO:pQWO'#EvO:uQ7[O'#FdO;dQWO'#GpOOQO'#K['#K[O;iQWO'#K[O;wQWO'#GxO;wQWO'#GyO;wQWO'#G{O9^QWO'#HOO<nQWO'#HRO>VQWO'#CeO>gQWO'#H_O>oQWO'#HeO>oQWO'#HgO`Q^O'#HiO>oQWO'#HkO>oQWO'#HnO>tQWO'#HtO>yQ?MyO'#HzO%[Q^O'#H|O?UQ?MyO'#IOO?aQ?MyO'#IQO9hQ?MxO'#ISO?lQ?NdO'#CiO@nQ`O'#DiQOQWOOO%[Q^O'#D}OAUQWO'#EQO:VQ7[O'#EkOAaQWO'#EkOAlQpO'#FdOOQU'#Cg'#CgOOQ?Mp'#Dn'#DnOOQ?Mp'#Jq'#JqO%[Q^O'#JqOOQO'#Jt'#JtOOQO'#Id'#IdOBlQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Jx'#JxOChQ?NQO'#EdOCrQ`O'#ETOOQO'#Js'#JsODWQ`O'#JtOEeQ`O'#ETOCrQ`O'#EdPErO#@ItO'#CbPOOO)CDx)CDxOOOO'#I['#I[OE}O!bO,59UOOQ?Mr,59U,59UOOOO'#I]'#I]OF]O#tO,59UO%[Q^O'#D`OOOO'#I_'#I_OFkO!0LbO,59xOOQ?Mr,59x,59xOFyQ^O'#I`OG^QWO'#JoOI]QrO'#JoO+}Q^O'#JoOIdQWO,5:OOIzQWO'#EmOJXQWO'#KOOJdQWO'#J}OJdQWO'#J}OJlQWO,5;ZOJqQWO'#J|OOQ?Mv,5:Z,5:ZOJxQ^O,5:ZOLvQ?NdO,5:cOMgQWO,5:kONQQ?MxO'#J{ONXQWO'#JzO9WQWO'#JzONmQWO'#JzONuQWO,5;YONzQWO'#JzO!#PQrO'#JnOOQ?Mr'#Ci'#CiO%[Q^O'#EPO!#oQrO,5:pOOQQ'#Ju'#JuOOQO-E<f-E<fO9^QWO,5=[O!$VQWO,5=[O!$[Q^O,5;WO!&_Q7[O'#EhO!'xQWO,5;WO!'}Q^O'#DvO!(XQ`O,5;aO!(aQ`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!(oQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yOOQ?Mr,5;{,5;{O%[Q^O'#IlO!*rQ?MxO,5<gO%[Q^O,5;bO!&_Q7[O,5;bO!+aQ7[O,5;bO!-RQ7[O'#EZO%[Q^O,5;vOOQ?Mr,5;z,5;zO!-YQ&jO'#FiO!.VQ&jO'#KSO!-qQ&jO'#KSO!.^Q&jO'#KSOOQO'#KS'#KSO!.rQ&jO,5<ROOOS,5<_,5<_O!/TQ^O'#FuOOOS'#Ik'#IkO7VO,YO,5<PO!/[Q&jO'#FwOOQ?Mr,5<P,5<PO!/{Q!LQO'#CvOOQ?Mr'#Cz'#CzO!0`O!0LbO'#DOO!0|Q7[O,5<dO!1TQWO,5<fO!2pQ$ISO'#GVO!2}QWO'#GWO!3SQWO'#GWO!4rQ$ISO'#G[O!5nQ`O'#G`OOQO'#Gk'#GkO!+hQ7[O'#GjOOQO'#Gm'#GmO!+hQ7[O'#GlO!6aQ!LQO'#JgOOQ?Mr'#Jg'#JgO!6kQWO'#JfO!6yQWO'#JeO!7RQWO'#CuOOQ?Mr'#Cx'#CxO!7ZQWO'#CzOOQ?Mr'#DS'#DSOOQ?Mr'#DU'#DUO1SQWO'#DWO!+hQ7[O'#F}O!+hQ7[O'#GPO!7`QWO'#GRO!7eQWO'#GSO!3SQWO'#GYO!+hQ7[O'#G_O!7jQWO'#EnO!8XQWO,5<eOOQ?Mp'#Cr'#CrO!8aQWO'#EoO!9ZQ`O'#EpOOQ?Mp'#J|'#J|O!9bQ?MxO'#K]O9hQ?MxO,5=`O`Q^O,5>pOOQU'#Jc'#JcOOQU,5>q,5>qOOQU-E<X-E<XO!;aQ?NdO,5:_O!9UQ`O,5:]O!=zQ?NdO,5:gO%[Q^O,5:gO!@bQ?NdO,5:iOOQO,5@v,5@vO!ARQ7[O,5=[O!AaQ?MxO'#JdO9RQWO'#JdO!ArQ?MxO,59ZO!A}Q`O,59ZO!BVQ7[O,59ZO:VQ7[O,59ZO!BbQWO,5;WO!BjQWO'#H^O!COQWO'#K`O%[Q^O,5;|O!9UQ`O,5<OO!CWQWO,5=wO!C]QWO,5=wO!CbQWO,5=wO9hQ?MxO,5=wO;wQWO,5=gOOQO'#Cv'#CvO!CpQ`O,5=dO!CxQ7[O,5=eO!DTQWO,5=gO!DYQpO,5=jO!DbQWO'#K[O>tQWO'#HTO9^QWO'#HVO!DgQWO'#HVO:VQ7[O'#HXO!DlQWO'#HXOOQU,5=m,5=mO!DqQWO'#HYO!ESQWO'#CoO!EXQWO,59PO!EcQWO,59PO!GhQ^O,59POOQU,59P,59PO!GxQ?MxO,59PO%[Q^O,59PO!JTQ^O'#HaOOQU'#Hb'#HbOOQU'#Hc'#HcO`Q^O,5=yO!JkQWO,5=yO`Q^O,5>PO`Q^O,5>RO!JpQWO,5>TO`Q^O,5>VO!JuQWO,5>YO!JzQ^O,5>`OOQU,5>f,5>fO%[Q^O,5>fO9hQ?MxO,5>hOOQU,5>j,5>jO# UQWO,5>jOOQU,5>l,5>lO# UQWO,5>lOOQU,5>n,5>nO# rQ`O'#D[O%[Q^O'#JqO# |Q`O'#JqO#!kQ`O'#DjO#!|Q`O'#DjO#%_Q^O'#DjO#%fQWO'#JpO#%nQWO,5:TO#%sQWO'#EqO#&RQWO'#KPO#&ZQWO,5;[O#&`Q`O'#DjO#&mQ`O'#ESOOQ?Mr,5:l,5:lO%[Q^O,5:lO#&tQWO,5:lO>tQWO,5;VO!A}Q`O,5;VO!BVQ7[O,5;VO:VQ7[O,5;VO#&|QWO,5@]O#'RQ(CYO,5:pOOQO-E<b-E<bO#(XQ?NQO,5;OOCrQ`O,5:oO#(cQ`O,5:oOCrQ`O,5;OO!ArQ?MxO,5:oOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#(pQ?MxO,5;OO#({Q?MxO,5;OO!A}Q`O,5:oOOQO,5;U,5;UO#)ZQ?MxO,5;OPOOO'#IY'#IYP#)oO#@ItO,58|POOO,58|,58|OOOO-E<Y-E<YOOQ?Mr1G.p1G.pOOOO-E<Z-E<ZO#)zQpO,59zOOOO-E<]-E<]OOQ?Mr1G/d1G/dO#*PQrO,5>zO+}Q^O,5>zOOQO,5?Q,5?QO#*ZQ^O'#I`OOQO-E<^-E<^O#*hQWO,5@ZO#*pQrO,5@ZO#*wQWO,5@iOOQ?Mr1G/j1G/jO%[Q^O,5@jO#+PQWO'#IfOOQO-E<d-E<dO#*wQWO,5@iOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0V1G0VO%[Q^O,5@gO#+eQ?MxO,5@gO#+vQ?MxO,5@gO#+}QWO,5@fO9WQWO,5@fO#,VQWO,5@fO#,eQWO'#IiO#+}QWO,5@fOOQ?Mp1G0t1G0tO!(XQ`O,5:rO!(dQ`O,5:rOOQQ,5:t,5:tO#-VQYO,5:tO#-_Q7[O1G2vO9^QWO1G2vOOQ?Mr1G0r1G0rO#-mQ?NdO1G0rO#.rQ?NbO,5;SOOQ?Mr'#GU'#GUO#/`Q?NdO'#JgO!$[Q^O1G0rO#1hQrO'#JrO%[Q^O'#JrO#1rQWO,5:bOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#1wQWO1G0{O#4]Q?NdO1G0|O#4dQ?NdO1G0|O#6zQ?NdO1G0|O#7RQ?NdO1G0|O#9iQ?NdO1G0|O#<PQ?NdO1G0|O#<WQ?NdO1G0|O#<_Q?NdO1G0|O#>uQ?NdO1G0|O#>|Q?NdO1G0|O#AZQ07bO'#CiO#CUQ07bO1G1_O#C]Q07bO'#JnO#CpQ?NdO,5?WOOQ?Mp-E<j-E<jO#E}Q?NdO1G0|O#FzQ?NdO1G0|OOQ?Mr1G0|1G0|O#GzQ7[O'#JwO#HUQWO,5:uO#HZQ?NdO1G1bO#H}Q&jO,5<VO#IVQ&jO,5<WO#I_Q&jO'#FnO#IvQWO'#FmOOQO'#KT'#KTOOQO'#Ij'#IjO#I{Q&jO1G1mOOQ?Mr1G1m1G1mOOOS1G1x1G1xO#J^Q07bO'#JmO#JhQWO,5<aO!(oQ^O,5<aOOOS-E<i-E<iOOQ?Mr1G1k1G1kO#JmQ`O'#KSOOQ?Mr,5<c,5<cO#JuQ`O,5<cO!&_Q7[O'#DQOOOO'#I^'#I^O#JzO!0LbO,59jOOQ?Mr,59j,59jO%[Q^O1G2OO!7eQWO'#InO#KVQ7[O,5<xOOQ?Mr,5<u,5<uO!+hQ7[O'#IqO#KuQ7[O,5=UO!+hQ7[O'#IsO#LhQ7[O,5=WO!&_Q7[O,5=YOOQO1G2Q1G2QO#LrQpO'#CrO#MVQ$ISO'#EoO#NUQ`O'#G`O#NrQpO,5<qO#NyQWO'#KWO9WQWO'#KWO$ XQWO,5<sO!+hQ7[O,5<rO$ ^QWO'#GXO$ oQWO,5<rO$ tQpO'#GUO$!RQpO'#KXO$!]QWO'#KXO!&_Q7[O'#KXO$!bQWO,5<vO$!gQ`O'#GaO!5iQ`O'#GaO$!xQWO'#GcO$!}QWO'#GeO!3SQWO'#GhO$#SQ?MxO'#IpO$#_Q`O,5<zOOQ?Mv,5<z,5<zO$#fQ`O'#GaO$#tQ`O'#GbO$#|Q`O'#GbO$$RQ7[O,5=UO$$cQ7[O,5=WOOQ?Mr,5=Z,5=ZO!+hQ7[O,5@QO!+hQ7[O,5@QO$$sQWO'#IuO$%OQWO,5@PO$%WQWO,59aOOQ?Mr,59f,59fO$%zQ!LSO,59rOOQ?Mr'#Jk'#JkO$&mQ7[O,5<iO$'`Q7[O,5<kO@fQWO,5<mOOQ?Mr,5<n,5<nO$'jQWO,5<tO$'oQ7[O,5<yO$(PQWO'#JzO!$[Q^O1G2PO$(UQWO1G2PO9WQWO'#J}O9WQWO'#EqO%[Q^O'#EqO9WQWO'#IwO$(ZQ?MxO,5@wOOQU1G2z1G2zOOQU1G4[1G4[OOQ?Mr1G/y1G/yOOQ?Mr1G/w1G/wO$*]Q?NdO1G0ROOQU1G2v1G2vO!&_Q7[O1G2vO%[Q^O1G2vO#-bQWO1G2vO$,aQ7[O'#EhOOQ?Mp,5@O,5@OO$,kQ?MxO,5@OOOQU1G.u1G.uO!ArQ?MxO1G.uO!A}Q`O1G.uO!BVQ7[O1G.uO$,|QWO1G0rO$-RQWO'#CiO$-^QWO'#KaO$-fQWO,5=xO$-kQWO'#KaO$-pQWO'#KaO$.OQWO'#I}O$.^QWO,5@zO$.fQrO1G1hOOQ?Mr1G1j1G1jO9^QWO1G3cO@fQWO1G3cO$.mQWO1G3cO$.rQWO1G3cOOQU1G3c1G3cO!DTQWO1G3RO!&_Q7[O1G3OO$.wQWO1G3OOOQU1G3P1G3PO!&_Q7[O1G3PO$.|QWO1G3PO$/UQ`O'#G}OOQU1G3R1G3RO!5iQ`O'#IyO!DYQpO1G3UOOQU1G3U1G3UOOQU,5=o,5=oO$/^Q7[O,5=qO9^QWO,5=qO$!}QWO,5=sO9RQWO,5=sO!A}Q`O,5=sO!BVQ7[O,5=sO:VQ7[O,5=sO$/lQWO'#K_O$/wQWO,5=tOOQU1G.k1G.kO$/|Q?MxO1G.kO@fQWO1G.kO$0XQWO1G.kO9hQ?MxO1G.kO$2aQrO,5@|O$2nQWO,5@|O9WQWO,5@|O$2yQ^O,5={O$3QQWO,5={OOQU1G3e1G3eO`Q^O1G3eOOQU1G3k1G3kOOQU1G3m1G3mO>oQWO1G3oO$3VQ^O1G3qO$7ZQ^O'#HpOOQU1G3t1G3tO$7hQWO'#HvO>tQWO'#HxOOQU1G3z1G3zO$7pQ^O1G3zO9hQ?MxO1G4QOOQU1G4S1G4SOOQ?Mp'#G]'#G]O9hQ?MxO1G4UO9hQ?MxO1G4WO$;wQWO,5@]O!(oQ^O,5;]O9WQWO,5;]O>tQWO,5:UO!(oQ^O,5:UO!A}Q`O,5:UO$;|Q07bO,5:UOOQO,5;],5;]O$<WQ`O'#IaO$<nQWO,5@[OOQ?Mr1G/o1G/oO$<vQ`O'#IgO$=QQWO,5@kOOQ?Mp1G0v1G0vO#!|Q`O,5:UOOQO'#Ic'#IcO$=YQ`O,5:nOOQ?Mv,5:n,5:nO#&wQWO1G0WOOQ?Mr1G0W1G0WO%[Q^O1G0WOOQ?Mr1G0q1G0qO>tQWO1G0qO!A}Q`O1G0qO!BVQ7[O1G0qOOQ?Mp1G5w1G5wO!ArQ?MxO1G0ZOOQO1G0j1G0jO%[Q^O1G0jO$=aQ?MxO1G0jO$=lQ?MxO1G0jO!A}Q`O1G0ZOCrQ`O1G0ZO$=zQ?MxO1G0jOOQO1G0Z1G0ZO$>`Q?NdO1G0jPOOO-E<W-E<WPOOO1G.h1G.hOOOO1G/f1G/fO$>jQpO,5<gO$>rQrO1G4fOOQO1G4l1G4lO%[Q^O,5>zO$>|QWO1G5uO$?UQWO1G6TO$?^QrO1G6UO9WQWO,5?QO$?hQ?NdO1G6RO%[Q^O1G6RO$?xQ?MxO1G6RO$@ZQWO1G6QO$@ZQWO1G6QO9WQWO1G6QO$@cQWO,5?TO9WQWO,5?TOOQO,5?T,5?TO$@wQWO,5?TO$(PQWO,5?TOOQO-E<g-E<gOOQQ1G0^1G0^OOQQ1G0`1G0`O#-YQWO1G0`OOQU7+(b7+(bO!&_Q7[O7+(bO%[Q^O7+(bO$AVQWO7+(bO$AbQ7[O7+(bO$ApQ?NdO,5=UO$CxQ?NdO,5=WO$FQQ?NdO,5=UO$H`Q?NdO,5=WO$JnQ?NdO,59rO$LsQ?NdO,5<iO$N{Q?NdO,5<kO%#TQ?NdO,5<yOOQ?Mr7+&^7+&^O%%cQ?NdO7+&^O%&VQ^O'#IbO%&dQWO,5@^O%&lQrO,5@^OOQ?Mr1G/|1G/|O%&vQWO7+&gOOQ?Mr7+&g7+&gO%&{Q07bO,5:cO%[Q^O7+&yO%'VQ07bO,5:_O%'dQ07bO,5:gO%'nQ07bO,5:iO%'xQ7[O'#IeO%(SQWO,5@cOOQ?Mr1G0a1G0aOOQO1G1q1G1qOOQO1G1r1G1rO%([QtO,5<YO!(oQ^O,5<XOOQO-E<h-E<hOOQ?Mr7+'X7+'XOOOS7+'d7+'dOOOS1G1{1G1{O%(gQWO1G1{OOQ?Mr1G1}1G1}O%(lQpO,59lOOOO-E<[-E<[OOQ?Mr1G/U1G/UO%(sQ?NdO7+'jOOQ?Mr,5?Y,5?YO%)gQpO,5?YOOQ?Mr1G2d1G2dP!&_Q7[O'#InPOQ?Mr-E<l-E<lO%*VQ7[O,5?]OOQ?Mr-E<o-E<oO%*xQ7[O,5?_OOQ?Mr-E<q-E<qO%+SQpO1G2tO%+ZQpO'#CrO%+qQ7[O'#J}O%+xQ^O'#EqOOQ?Mr1G2]1G2]O%,SQWO'#ImO%,hQWO,5@rO%,hQWO,5@rO%,pQWO,5@rO%,{QWO,5@rOOQO1G2_1G2_O%-ZQ7[O1G2^O!+hQ7[O1G2^O%-kQ$ISO'#IoO%-xQWO,5@sO!&_Q7[O,5@sO%.QQpO,5@sOOQ?Mr1G2b1G2bOOQ?Mp,5<{,5<{OOQ?Mp,5<|,5<|O$(PQWO,5<|OCcQWO,5<|O!A}Q`O,5<{OOQO'#Gd'#GdO%.[QWO,5<}OOQ?Mp,5=P,5=PO$(PQWO,5=SOOQO,5?[,5?[OOQO-E<n-E<nOOQ?Mv1G2f1G2fO!5iQ`O,5<{O%.dQWO,5<|O$!xQWO,5<}O%.oQ`O,5<|O!+hQ7[O'#IqO%/`Q7[O1G2pO!+hQ7[O'#IsO%0RQ7[O1G2rO%0]Q7[O1G5lO%0gQ7[O1G5lOOQO,5?a,5?aOOQO-E<s-E<sOOQO1G.{1G.{O!9UQ`O,59tO%[Q^O,59tOOQ?Mr,5<h,5<hO%0tQWO1G2XO!+hQ7[O1G2`O%0yQ?NdO7+'kOOQ?Mr7+'k7+'kO!$[Q^O7+'kO%1mQWO,5;]OOQ?Mp,5?c,5?cOOQ?Mp-E<u-E<uO%1rQpO'#KYO#&wQWO7+(bO4UQrO7+(bO$AYQWO7+(bO%1|Q?NbO'#CiO%2aQ?NbO,5=QO%3RQWO,5=QOOQ?Mp1G5j1G5jOOQU7+$a7+$aO!ArQ?MxO7+$aO!A}Q`O7+$aO!$[Q^O7+&^O%3WQWO'#I|O%3oQWO,5@{OOQO1G3d1G3dO9^QWO,5@{O%3oQWO,5@{O%3wQWO,5@{OOQO,5?i,5?iOOQO-E<{-E<{OOQ?Mr7+'S7+'SO%3|QWO7+(}O9hQ?MxO7+(}O9^QWO7+(}O@fQWO7+(}OOQU7+(m7+(mO%4RQ?NbO7+(jO!&_Q7[O7+(jO%4]QpO7+(kOOQU7+(k7+(kO!&_Q7[O7+(kO%4dQWO'#K^O%4oQWO,5=iOOQO,5?e,5?eOOQO-E<w-E<wOOQU7+(p7+(pO%6RQ`O'#HWOOQU1G3]1G3]O!&_Q7[O1G3]O%[Q^O1G3]O%6YQWO1G3]O%6eQ7[O1G3]O9hQ?MxO1G3_O$!}QWO1G3_O9RQWO1G3_O!A}Q`O1G3_O!BVQ7[O1G3_O%6sQWO'#I{O%7XQWO,5@yO%7aQ`O,5@yOOQ?Mp1G3`1G3`OOQU7+$V7+$VO@fQWO7+$VO9hQ?MxO7+$VO%7lQWO7+$VO%[Q^O1G6hO%[Q^O1G6iO%7qQ?MxO1G6hO%7{Q^O1G3gO%8SQWO1G3gO%8XQ^O1G3gOOQU7+)P7+)PO9hQ?MxO7+)ZO`Q^O7+)]OOQU'#Kd'#KdOOQU'#JO'#JOO%8`Q^O,5>[OOQU,5>[,5>[O%[Q^O'#HqO%8mQWO'#HsOOQU,5>b,5>bO9WQWO,5>bOOQU,5>d,5>dOOQU7+)f7+)fOOQU7+)l7+)lOOQU7+)p7+)pOOQU7+)r7+)rO%8rQ`O1G5wO%9WQ07bO1G0wO%9bQWO1G0wOOQO1G/p1G/pO%9mQ07bO1G/pO>tQWO1G/pO!(oQ^O'#DjOOQO,5>{,5>{OOQO-E<_-E<_OOQO,5?R,5?ROOQO-E<e-E<eO!A}Q`O1G/pOOQO-E<a-E<aOOQ?Mv1G0Y1G0YOOQ?Mr7+%r7+%rO#&wQWO7+%rOOQ?Mr7+&]7+&]O>tQWO7+&]O!A}Q`O7+&]OOQO7+%u7+%uO$>`Q?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%9wQ?MxO7+&UO!ArQ?MxO7+%uO!A}Q`O7+%uO%:SQ?MxO7+&UO%:bQ?NdO7++mO%[Q^O7++mO%:rQWO7++lO%:rQWO7++lOOQO1G4o1G4oO9WQWO1G4oO%:zQWO1G4oOOQQ7+%z7+%zO#&wQWO<<K|O4UQrO<<K|O%;YQWO<<K|OOQU<<K|<<K|O!&_Q7[O<<K|O%[Q^O<<K|O%;bQWO<<K|O%;mQ?NdO,5?]O%=uQ?NdO,5?_O%?}Q?NdO1G2^O%B]Q?NdO1G2pO%DeQ?NdO1G2rO%FmQrO,5>|O%[Q^O,5>|OOQO-E<`-E<`O%FwQWO1G5xOOQ?Mr<<JR<<JRO%GPQ07bO1G0rO%IWQ07bO1G0|O%I_Q07bO1G0|O%K`Q07bO1G0|O%KgQ07bO1G0|O%MhQ07bO1G0|O& iQ07bO1G0|O& pQ07bO1G0|O& wQ07bO1G0|O&#xQ07bO1G0|O&$PQ07bO1G0|O&$WQ?NdO<<JeO&&OQ07bO1G0|O&&{Q07bO1G0|O&'{Q07bO'#JgO&*OQ07bO1G1bO&*]Q07bO1G0RO&*gQ7[O,5?POOQO-E<c-E<cO!(oQ^O'#FpOOQO'#KU'#KUOOQO1G1t1G1tO&*qQWO1G1sO&*vQ07bO,5?WOOOS7+'g7+'gOOOO1G/W1G/WOOQ?Mr1G4t1G4tO!+hQ7[O7+(`O&-WQrO'#CiO&-bQWO,5?XO9WQWO,5?XOOQO-E<k-E<kO&-pQWO1G6^O&-pQWO1G6^O&-xQWO1G6^O&.TQ7[O7+'xO&.eQpO,5?ZO&.oQWO,5?ZO!&_Q7[O,5?ZOOQO-E<m-E<mO&.tQpO1G6_O&/OQWO1G6_OOQ?Mp1G2h1G2hO$(PQWO1G2hOOQ?Mp1G2g1G2gO&/WQWO1G2iO!&_Q7[O1G2iOOQ?Mp1G2n1G2nO!A}Q`O1G2gOCcQWO1G2hO&/]QWO1G2iO&/eQWO1G2hO$!xQWO1G2iO&0XQ7[O,5?]OOQ?Mr-E<p-E<pO&0zQ7[O,5?_OOQ?Mr-E<r-E<rO!+hQ7[O7++WOOQ?Mr1G/`1G/`O&1UQWO1G/`OOQ?Mr7+'s7+'sO&1ZQ7[O7+'zO&1kQ?NdO<<KVOOQ?Mr<<KV<<KVO&2_QWO1G0wO!&_Q7[O'#IvO&2dQWO,5@tO&4fQrO<<K|O!&_Q7[O1G2lOOQU<<G{<<G{O!ArQ?MxO<<G{O&4mQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?h,5?hO&5aQWO,5?hO&5fQWO,5?hOOQO-E<z-E<zO&5tQWO1G6gO&5tQWO1G6gO9^QWO1G6gO@fQWO<<LiOOQU<<Li<<LiO&5|QWO<<LiO9hQ?MxO<<LiOOQU<<LU<<LUO%4RQ?NbO<<LUOOQU<<LV<<LVO%4]QpO<<LVO&6RQ`O'#IxO&6^QWO,5@xO!(oQ^O,5@xOOQU1G3T1G3TO%+xQ^O'#JqOOQO'#Iz'#IzO9hQ?MxO'#IzO&6fQ`O,5=rOOQU,5=r,5=rO&6mQ`O'#EdO&7RQ`O'#GcO&7WQWO7+(wO&7]QWO7+(wOOQU7+(w7+(wO!&_Q7[O7+(wO%[Q^O7+(wO&7eQWO7+(wOOQU7+(y7+(yO9hQ?MxO7+(yO$!}QWO7+(yO9RQWO7+(yO!A}Q`O7+(yO&7pQWO,5?gOOQO-E<y-E<yOOQO'#HZ'#HZO&7{QWO1G6eO9hQ?MxO<<GqOOQU<<Gq<<GqO@fQWO<<GqO&8TQWO7+,SO&8YQWO7+,TO%[Q^O7+,SO%[Q^O7+,TOOQU7+)R7+)RO&8_QWO7+)RO&8dQ^O7+)RO&8kQWO7+)ROOQU<<Lu<<LuOOQU<<Lw<<LwOOQU-E<|-E<|OOQU1G3v1G3vO&8pQWO,5>]OOQU,5>_,5>_O&8uQWO1G3|O9WQWO7+&cO!(oQ^O7+&cOOQO7+%[7+%[O&8zQ07bO1G6UO>tQWO7+%[OOQ?Mr<<I^<<I^OOQ?Mr<<Iw<<IwO>tQWO<<IwOOQO<<Ip<<IpO$>`Q?NdO<<IpO%[Q^O<<IpOOQO<<Ia<<IaO!ArQ?MxO<<IaO&9UQ?MxO<<IpO&9aQ?NdO<= XO&9qQWO<= WOOQO7+*Z7+*ZO9WQWO7+*ZOOQUANAhANAhO&9yQrOANAhO!&_Q7[OANAhO#&wQWOANAhO4UQrOANAhO&:QQWOANAhO%[Q^OANAhO&:YQ?NdO7+'xO&<hQ?NdO,5?]O&>pQ?NdO,5?_O&@xQ?NdO7+'zO&CWQrO1G4hO&CbQ07bO7+&^O&EcQ07bO,5=UO&GgQ07bO,5=WO&GwQ07bO,5=UO&HXQ07bO,5=WO&HiQ07bO,59rO&JlQ07bO,5<iO&LlQ07bO,5<kO&N}Q07bO,5<yO'!pQ07bO7+'jO'!}Q07bO7+'kO'#[QWO,5<[OOQO7+'_7+'_O'#aQ7[O<<KzOOQO1G4s1G4sO'#hQWO1G4sO'#sQWO1G4sO'$RQWO7++xO'$RQWO7++xO!&_Q7[O1G4uO'$ZQpO1G4uO'$eQWO7++yOOQ?Mp7+(S7+(SO'$mQWO7+(TO'$xQpO7+(TOOQ?Mp7+(R7+(RO$(PQWO7+(SO'%PQWO7+(TO!&_Q7[O7+(TOCcQWO7+(SO'%UQWO7+(TO'%^Q7[O<<NrOOQ?Mr7+$z7+$zO'%hQpO,5?bOOQO-E<t-E<tO'%rQ?NbO7+(WOOQUAN=gAN=gO9^QWO1G5SOOQO1G5S1G5SO'&SQWO1G5SO'&XQWO7+,RO'&XQWO7+,RO9hQ?MxOANBTO@fQWOANBTOOQUANBTANBTOOQUANApANApOOQUANAqANAqO'&aQWO,5?dOOQO-E<v-E<vO'&lQ07bO1G6dOOQO,5?f,5?fOOQO-E<x-E<xOOQU1G3^1G3^O%+xQ^O,5<}O'&vQWO,5<}OOQU<<Lc<<LcO!&_Q7[O<<LcO&7WQWO<<LcO'&{QWO<<LcO%[Q^O<<LcOOQU<<Le<<LeO9hQ?MxO<<LeO$!}QWO<<LeO9RQWO<<LeO''TQ`O1G5RO''`QWO7+,POOQUAN=]AN=]O9hQ?MxOAN=]OOQU<= n<= nOOQU<= o<= oO''hQWO<= nO''mQWO<= oOOQU<<Lm<<LmO''rQWO<<LmO''wQ^O<<LmOOQU1G3w1G3wO>tQWO7+)hO'(OQWO<<I}O'(ZQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$>`Q?NdOAN?[OOQOAN>{AN>{O%[Q^OAN?[OOQO<<Mu<<MuOOQUG27SG27SO!&_Q7[OG27SO#&wQWOG27SO'(eQrOG27SO4UQrOG27SO'(lQWOG27SO'(tQ07bO<<JeO')RQ07bO1G2^O'*tQ07bO,5?]O',tQ07bO,5?_O'.tQ07bO1G2pO'0tQ07bO1G2rO'2tQ07bO<<KVO'3RQ07bO<<IxOOQO1G1v1G1vO!+hQ7[OANAfOOQO7+*_7+*_O'3`QWO7+*_O'3kQWO<= dO'3sQpO7+*aOOQ?Mp<<Ko<<KoO$(PQWO<<KoOCcQWO<<KoO'3}QWO<<KoOOQ?Mp<<Kn<<KnO'4YQpO<<KoO$(PQWO<<KnO'4aQWO<<KoO!&_Q7[O<<KoOOQO7+*n7+*nO9^QWO7+*nO'4fQWO<= mOOQUG27oG27oO9hQ?MxOG27oO!(oQ^O1G5OO'4nQWO7+,OO&7WQWOANA}OOQUANA}ANA}O!&_Q7[OANA}O'4vQWOANA}OOQUANBPANBPO9hQ?MxOANBPO$!}QWOANBPOOQO'#H['#H[OOQO7+*m7+*mOOQUG22wG22wOOQUANEYANEYOOQUANEZANEZOOQUANBXANBXO'5OQWOANBXOOQU<<MS<<MSO!(oQ^OAN?iOOQOG24vG24vO$>`Q?NdOG24vO#&wQWOLD,nOOQULD,nLD,nO!&_Q7[OLD,nO'5TQrOLD,nO'5[Q07bO7+'xO'6}Q07bO,5?]O'8}Q07bO,5?_O':}Q07bO7+'zO'<pQ7[OG27QOOQO<<My<<MyOOQ?MpANAZANAZO$(PQWOANAZOCcQWOANAZO'=QQWOANAZOOQ?MpANAYANAYO'=]QpOANAZOOQO<<NY<<NYOOQULD-ZLD-ZO'=dQ07bO7+*jOOQUG27iG27iO&7WQWOG27iO!&_Q7[OG27iOOQUG27kG27kO9hQ?MxOG27kOOQUG27sG27sO'=nQ07bOG25TOOQOLD*bLD*bOOQU!$(!Y!$(!YO#&wQWO!$(!YO!&_Q7[O!$(!YO'=xQ?NdOG27QOOQ?MpG26uG26uO$(PQWOG26uOCcQWOG26uO'@WQWOG26uOOQULD-TLD-TO&7WQWOLD-TOOQULD-VLD-VOOQU!)9Et!)9EtO#&wQWO!)9EtOOQ?MpLD,aLD,aO$(PQWOLD,aOCcQWOLD,aOOQU!$(!o!$(!oOOQU!.K;`!.K;`O'@cQ07bOG27QOOQ?Mp!$( {!$( {O$(PQWO!$( {OOQ?Mp!)9Eg!)9EgO!(oQ^O'#DwO1PQWO'#EUO'BUQrO'#JmO'B]QMnO'#DsO'BdQ^O'#D{O'BkQrO'#CiO'ERQrO'#CiO!(oQ^O'#D}O'EcQ^O,5;WO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O,5;bO!(oQ^O'#IlO'GfQWO,5<gO!(oQ^O,5;bO'GnQ7[O,5;bO'IXQ7[O,5;bO!(oQ^O,5;vO!&_Q7[O'#GjO'GnQ7[O'#GjO!&_Q7[O'#GlO'GnQ7[O'#GlO1SQWO'#DWO1SQWO'#DWO!&_Q7[O'#F}O'GnQ7[O'#F}O!&_Q7[O'#GPO'GnQ7[O'#GPO!&_Q7[O'#G_O'GnQ7[O'#G_O!(oQ^O,5:gO'I`Q`O'#D[O!(oQ^O,5@jO'EcQ^O1G0rO'IjQ07bO'#CiO!(oQ^O1G2OO!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO'ItQpO'#CrO!&_Q7[O,5<rO'GnQ7[O,5<rO'EcQ^O1G2PO!(oQ^O7+&yO!&_Q7[O1G2^O'GnQ7[O1G2^O!&_Q7[O'#IqO'GnQ7[O'#IqO!&_Q7[O'#IsO'GnQ7[O'#IsO!&_Q7[O1G2`O'GnQ7[O1G2`O'EcQ^O7+'kO'EcQ^O7+&^O!&_Q7[OANAfO'GnQ7[OANAfO'JXQWO'#ElO'J^QWO'#ElO'JfQWO'#F[O'JkQWO'#EvO'JpQWO'#KOO'J{QWO'#J|O'KWQWO,5;WO'K]Q7[O,5<dO'KdQWO'#GWO'KiQWO'#GWO'KnQWO,5<eO'KvQWO,5;WO'LOQ07bO1G1_O'LVQWO,5<rO'L[QWO,5<rO'LaQWO,5<tO'LfQWO,5<tO'LkQWO1G2PO'LpQWO1G0rO'LuQ7[O<<KzO'L|Q7[O<<KzO7eQ7[O'#FzO9RQWO'#FyOAaQWO'#EkO!(oQ^O,5;sO!3SQWO'#GWO!3SQWO'#GWO!3SQWO'#GYO!3SQWO'#GYO!+hQ7[O7+(`O!+hQ7[O7+(`O%+SQpO1G2tO%+SQpO1G2tO!&_Q7[O,5=YO!&_Q7[O,5=Y",
  stateData: "'NQ~O'wOS'xOSTOS'yRQ~OPYOQYOSfOY!VOaqOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!rwO!uxO!y]O#t!PO$V|O%e}O%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO&S!WO&Y!XO&[!YO&^!ZO&`![O&c!]O&i!^O&o!_O&q!`O&s!aO&u!bO&w!cO(OSO(QTO(TUO([VO(j[O(yiO~OWtO~P`OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa!wOp!nO!P!oO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O'y!{O~OP]XR]X[]Xa]Xo]X}]X!P]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X'u]X([]X(m]X(t]X(u]X~O!d%PX~P(qO_!}O(Q#PO(R!}O(S#PO~O_#QO(S#PO(T#PO(U#QO~Ou#SO!R#TO(]#TO(^#VO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O;UO(QTO(TUO([VO(j[O(yiO~O!X#ZO!Y#WO!V(cP!V(qP~P+}O!Z#cO~P`OPYOQYOSfOd!jOe!iOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(QTO(TUO([VO(j[O(yiO~Om#mO!X#iO!y]O#f#lO#g#iO(O;VO!h(nP~P.iO!i#oO(O#nO~O!u#sO!y]O%e#tO~O#h#uO~O!d#vO#h#uO~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y$_O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa(aX'u(aX's(aX!h(aX!V(aX![(aX%f(aX!d(aX~P1qO#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX![(bX%f(bX~Oa(bX'u(bX's(bX!V(bX!h(bXs(bX!d(bX~P4UO#]$eO~O$[$hO$^$gO$e$mO~OSfO![$nO$h$oO$j$qO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O$sO(QTO(TUO([$uO(t$}O(u%POg(XP~O!i%cO~O!P%fO![%gO(O%eO~O!d%kO~Oa%lO'u%lO~O}%pO~P%[O(P!lO~P%[O%k%tO~P%[Oh%VO!i%cO(O%eO(P!lO~Oe%{O!i%cO(O%eO~O#s$RO~O}&QO![%}O!i&PO%g&TO(O%eO(P!lO(QTO(TUO`)SP~O!u#sO~O%p&VO!P)OX![)OX(O)OX~O(O&WO~O!r&]O#t!PO%g!QO%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO~Od&bOe&aO!u&_O%e&`O%x&^O~P;|Od&eOeyO![&dO!r&]O!uxO!y]O#t!PO%e}O%i!OO%j!OO%k!OO%n!RO%p!SO%s!TO%t!TO%v!UO~Ob&hO#]&kO%g&fO(P!lO~P=RO!i&lO!r&pO~O!i#oO~O![XO~Oa%lO't&xO'u%lO~Oa%lO't&{O'u%lO~Oa%lO't&}O'u%lO~O's]X!V]Xs]X!h]X&W]X![]X%f]X!d]X~P(qO!_'[O!`'TO!a'TO(P!lO(QTO(TUO~Op'RO!P'QO!X'UO(`'PO!Z(dP!Z(sP~P@YOk'_O![']O(O%eO~Oe'dO!i%cO(O%eO~O}&QO!i&PO~Op!nO!P!oO!y;QO#Q!pO#R!pO#T!pO#U!pO(P!lO(QTO(TUO(`!mO(j!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAtOa%lOh%VO!d#vO!i%cO'u%lO(m'mO~O!m'qO#]'oO~PCSOp!nO!P!oO(QTO(TUO(`!mO(j!sO~O![XOp(hX!P(hX!_(hX!`(hX!a(hX!y(hX#Q(hX#R(hX#S(hX#T(hX#U(hX#X(hX#Y(hX(P(hX(Q(hX(T(hX(`(hX(j(hX~O!`'iO!a'iO(P!lO~PCrO'z'uO'{'uO'|'wO~O_!}O(Q'yO(R!}O(S'yO~O_#QO(S'yO(T'yO(U#QO~Ou#SO!R#TO(]#TO(^'}O~O!X(PO!V'SX!V'YX!Y'SX!Y'YX~P+}O!Y(RO!V(cX~OP$[OR#zO[$cOo$aO}#yO!P#{O!Y(RO!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~O!V(cX~PGfO!V(WO~O!V(pX!Y(pX!d(pX!h(pX(m(pX~O#](pX#h#aX!Z(pX~PIiO#](XO!V(rX!Y(rX~O!Y(YO!V(qX~O!V(]O~O#]$eO~PIiO!Z(^O~P`OR#zO}#yO!P#{O!i#xO([VOP!ka[!kao!ka!Y!ka!m!ka#O!ka#k!ka#l!ka#m!ka#n!ka#o!ka#p!ka#q!ka#r!ka#s!ka#u!ka#w!ka#y!ka#z!ka(m!ka(t!ka(u!ka~Oa!ka'u!ka's!ka!V!ka!h!kas!ka![!ka%f!ka!d!ka~PKPO!h(_O~O!d#vO#](`O(m'mO!Y(oXa(oX'u(oX~O!h(oX~PMlO!P%fO![%gO!y]O#f(eO#g(dO(O%eO~O!Y(fO!h(nX~O!h(hO~O!P%fO![%gO#g(dO(O%eO~OP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#s(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O!d#vO!h(bX~P! YOR(jO}(iO!i#xO#P$dO!y!xa!P!xa~O!u!xa%e!xa![!xa#f!xa#g!xa(O!xa~P!#ZO!u(nO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![XO!fuO!iZO!lYO!mYO!nYO!pvO!r!gO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#h(tO~O!X(vO!h(fP~P%[O(`(xO(j[O~O!P(zO!i#xO(`(xO(j[O~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y$_Oa$oa'u$oa's$oa!h$oa!V$oa![$oa%f$oa!d$oa~O#t)`O~P!&_Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{%[O!P${O![$|O!f%aO!i$xO#g%bO$V%_O$r%]O$t%^O$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~Og(kP~P!+hO})eO!d)dO![$]X$Y$]X$[$]X$^$]X$e$]X~O!d)dO![(vX$Y(vX$[(vX$^(vX$e(vX~O})eO~P!-qO})eO![(vX$Y(vX$[(vX$^(vX$e(vX~O![)gO$Y)kO$[)fO$^)fO$e)lO~O!X)oO~P!(oO$[$hO$^$gO$e)sO~Ok$xX}$xX!P$xX#P$xX(t$xX(u$xX~OgjXg$xXkjX!YjX#]jX~P!/gOu)uO(])vO(^)xO~Ok*RO})zO!P){O(t$}O(u%PO~Og)yO~P!0kOg*SO~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P*UO![*VO!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~O!X*YO(O*TO!h(zP~P!1YO#h*[O~O!i*]O~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(O*_O(QTO(TUO([$uO(t$}O(u%PO~O!X*bO!V({P~P!3XOo*nO!P*fO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO(`!mO~O!Z*kO~P!4|O#P$dOk(ZX}(ZX!P(ZX(t(ZX(u(ZX!Y(ZX#](ZX~Og(ZX#}(ZX~P!5uOk*sO#]*rOg(YX!Y(YX~O!Y*tOg(XX~O(O&WOg(XP~Op*wO~O!i*|O~O(O(rO~Om+QO!P%fO!X#iO![%gO!y]O#f#lO#g#iO(O%eO!h(nP~O!d#vO#h+RO~O!P%fO!X+TO!Y(YO![%gO(O%eO!V(qP~Op'XO!P+VO!X+UO(QTO(TUO(`(xO~O!Z(sP~P!8uO!Y+WOa)PX'u)PX~OP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO#y$WO#z$XO([VO(m$YO(t#|O(u#}O~Oa!ga!Y!ga'u!ga's!ga!V!ga!h!gas!ga![!ga%f!ga!d!ga~P!9mOR#zO}#yO!P#{O!i#xO([VOP!oa[!oao!oa!Y!oa!m!oa#O!oa#k!oa#l!oa#m!oa#n!oa#o!oa#p!oa#q!oa#r!oa#s!oa#u!oa#w!oa#y!oa#z!oa(m!oa(t!oa(u!oa~Oa!oa'u!oa's!oa!V!oa!h!oas!oa![!oa%f!oa!d!oa~P!<TOR#zO}#yO!P#{O!i#xO([VOP!qa[!qao!qa!Y!qa!m!qa#O!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#s!qa#u!qa#w!qa#y!qa#z!qa(m!qa(t!qa(u!qa~Oa!qa'u!qa's!qa!V!qa!h!qas!qa![!qa%f!qa!d!qa~P!>kOh%VOk+aO![']O%f+`O~O!d+cOa(WX![(WX'u(WX!Y(WX~Oa%lO![XO'u%lO~Oh%VO!i%cO~Oh%VO!i%cO(O%eO~O!d#vO#h(tO~Ob+nO%g+oO(O+kO(QTO(TUO!Z)TP~O!Y+pO`)SX~O[+tO~O`+uO~O![%}O(O%eO(P!lO`)SP~Oh%VO#]+zO~Oh%VOk+}O![$|O~O![,PO~O},RO![XO~O%k%tO~O!u,WO~Oe,]O~Ob,^O(O#nO(QTO(TUO!Z)RP~Oe%{O~O%g!QO(O&WO~P=RO[,cO`,bO~OPYOQYOSfOdzOeyOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO!fuO!iZO!lYO!mYO!nYO!pvO!uxO!y]O%e}O(QTO(TUO([VO(j[O(yiO~O![!eO!r!gO$V!kO(O!dO~P!EkO`,bOa%lO'u%lO~OPYOQYOSfOd!jOe!iOmkOoYOpkOqkOwkOyYO{YO!PWO!TkO!UkO![!eO!fuO!iZO!lYO!mYO!nYO!pvO!u!hO$V!kO(O!dO(QTO(TUO([VO(j[O(yiO~Oa,hO!rwO#t!OO%i!OO%j!OO%k!OO~P!HTO!i&lO~O&Y,nO~O![,pO~O&k,rO&m,sOP&haQ&haS&haY&haa&had&hae&ham&hao&hap&haq&haw&hay&ha{&ha!P&ha!T&ha!U&ha![&ha!f&ha!i&ha!l&ha!m&ha!n&ha!p&ha!r&ha!u&ha!y&ha#t&ha$V&ha%e&ha%g&ha%i&ha%j&ha%k&ha%n&ha%p&ha%s&ha%t&ha%v&ha&S&ha&Y&ha&[&ha&^&ha&`&ha&c&ha&i&ha&o&ha&q&ha&s&ha&u&ha&w&ha's&ha(O&ha(Q&ha(T&ha([&ha(j&ha(y&ha!Z&ha&a&hab&ha&f&ha~O(O,xO~Oh!bX!Y!OX!Z!OX!d!OX!d!bX!i!bX#]!OX~O!Y!bX!Z!bX~P# ZO!d,}O#],|Oh(eX!Y#eX!Y(eX!Z#eX!Z(eX!d(eX!i(eX~Oh%VO!d-PO!i%cO!Y!^X!Z!^X~Op!nO!P!oO(QTO(TUO(`!mO~OP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![!eO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(QTO(TUO([VO(j[O(y<xO~O(O;zO~P##_O!Y-TO!Z(dX~O!Z-VO~O!d,}O#],|O!Y#eX!Z#eX~O!Y-WO!Z(sX~O!Z-YO~O!`-ZO!a-ZO(P!lO~P#!|O!Z-^O~P'_Ok-aO![']O~O!V-fO~Op!xa!_!xa!`!xa!a!xa#Q!xa#R!xa#S!xa#T!xa#U!xa#X!xa#Y!xa(P!xa(Q!xa(T!xa(`!xa(j!xa~P!#ZO!m-kO#]-iO~PCSO!`-mO!a-mO(P!lO~PCrOa%lO#]-iO'u%lO~Oa%lO!d#vO#]-iO'u%lO~Oa%lO!d#vO!m-kO#]-iO'u%lO(m'mO~O'z'uO'{'uO'|-rO~Os-sO~O!V'Sa!Y'Sa~P!9mO!X-wO!V'SX!Y'SX~P%[O!Y(RO!V(ca~O!V(ca~PGfO!Y(YO!V(qa~O!P%fO!X-{O![%gO(O%eO!V'YX!Y'YX~O#]-}O!Y(oa!h(oaa(oa'u(oa~O!d#vO~P#+eO!Y(fO!h(na~O!P%fO![%gO#g.RO(O%eO~Om.WO!P%fO!X.TO![%gO!y]O#f.VO#g.TO(O%eO!Y']X!h']X~OR.[O!i#xO~Oh%VOk._O![']O%f.^O~Oa#`i!Y#`i'u#`i's#`i!V#`i!h#`is#`i![#`i%f#`i!d#`i~P!9mOk=UO})zO!P){O(t$}O(u%PO~O#h#[aa#[a#]#[a'u#[a!Y#[a!h#[a![#[a!V#[a~P#.aO#h(ZXP(ZXR(ZX[(ZXa(ZXo(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX'u(ZX([(ZX(m(ZX!h(ZX!V(ZX's(ZXs(ZX![(ZX%f(ZX!d(ZX~P!5uO!Y.lO!h(fX~P!9mO!h.oO~O!V.qO~OP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jia#jio#ji!Y#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#k#ji~P#1|O#k$OO~P#1|OP$[OR#zOo$aO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO[#jia#ji!Y#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#o#ji~P#4kO#o$QO~P#4kOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO([VOa#ji!Y#ji#w#ji#y#ji#z#ji'u#ji(m#ji(t#ji(u#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#u#ji~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO([VO(u#}Oa#ji!Y#ji#y#ji#z#ji'u#ji(m#ji(t#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#w$UO~P#9pO#w#ji~P#9pO#u$SO~P#7YOP$[OR#zO[$cOo$aO}#yO!P#{O!i#xO!m$[O#O$RO#k$OO#l$PO#m$PO#n$PO#o$QO#p$RO#q$RO#r$bO#s$RO#u$SO#w$UO([VO(t#|O(u#}Oa#ji!Y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~O#y#ji~P#<fO#y$WO~P#<fOP]XR]X[]Xo]X}]X!P]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X!Y]X!Z]X~O#}]X~P#?TOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O#y;bO#z;cO([VO(m$YO(t#|O(u#}O~O#}.sO~P#AbO#P$dO#];iO$P;iO#}(bX!Z(bX~P! YOa'`a!Y'`a'u'`a's'`a!h'`a!V'`as'`a!['`a%f'`a!d'`a~P!9mO[#jia#jio#ji!Y#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji'u#ji(m#ji's#ji!V#ji!h#jis#ji![#ji%f#ji!d#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k$OO#l$PO#m$PO#n$PO([VO(t#ji(u#ji~P#DdOk=UO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P#DdO!Y.wOg(kX~P!0kOg.yO~Oa$Oi!Y$Oi'u$Oi's$Oi!V$Oi!h$Ois$Oi![$Oi%f$Oi!d$Oi~P!9mO$[.zO$^.zO~O$[.{O$^.{O~O!d)dO#].|O![$bX$Y$bX$[$bX$^$bX$e$bX~O!X.}O~O![)gO$Y/PO$[)fO$^)fO$e/QO~O!Y;dO!Z(aX~P#AbO!Z/RO~O!d)dO$e(vX~O$e/TO~Ou)uO(])vO(^/WO~O!V/[O~P!&_O(t$}Ok%^a}%^a!P%^a(u%^a!Y%^a#]%^a~Og%^a#}%^a~P#K^O(u%POk%`a}%`a!P%`a(t%`a!Y%`a#]%`a~Og%`a#}%`a~P#LPO!YfX!dfX!hfX!h$xX(mfX~P!/gO!X/eO!Y(YO(O/dO!V(qP!V({P~P!1YOo*nO!_*lO!`*eO!a*eO!i*]O#X*mO%]*hO(P!lO~Op'XO!P/fO!X+UO!Z*kO(QTO(TUO(`;wO!Z(sP~P#MjO!h/gO~P#.aO!Y/hO!d#vO(m'mO!h(zX~O!h/mO~O!P%fO!X*YO![%gO(O%eO!h(zP~O#h/oO~O!V$xX!Y$xX!d%PX~P!/gO!Y/pO!V({X~P#.aO!d/rO~O!V/tO~Oh%VOo/xO!d#vO!i%cO(m'mO~O(O/zO~O!d+cO~Oa%lO!Y0OO'u%lO~O!Z0QO~P!4|O!`0RO!a0RO(P!lO(`!mO~O!P0TO(`!mO~O#X0UO~Og%^a!Y%^a#]%^a#}%^a~P!0kOg%`a!Y%`a#]%`a#}%`a~P!0kO(O&WOg'iX!Y'iX~O!Y*tOg(Xa~Og0_O~OR0`O}0`O!P0aO#P$dOkza(tza(uza!Yza#]za~Ogza#}za~P$%]O})zO!P){Ok$qa(t$qa(u$qa!Y$qa#]$qa~Og$qa#}$qa~P$&UO})zO!P){Ok$sa(t$sa(u$sa!Y$sa#]$sa~Og$sa#}$sa~P$&wO#h0dO~Og%Ra!Y%Ra#]%Ra#}%Ra~P!0kO!d#vO~O#h0gO~O!Y+WOa)Pa'u)Pa~OR#zO}#yO!P#{O!i#xO([VOP!oi[!oio!oi!Y!oi!m!oi#O!oi#k!oi#l!oi#m!oi#n!oi#o!oi#p!oi#q!oi#r!oi#s!oi#u!oi#w!oi#y!oi#z!oi(m!oi(t!oi(u!oi~Oa!oi'u!oi's!oi!V!oi!h!ois!oi![!oi%f!oi!d!oi~P$(fOh%VOo%XOp$tOq$tOw%YOy%ZO{;nO!P${O![$|O!f=OO!i$xO#g;tO$V%_O$r;pO$t;rO$w%`O(QTO(TUO([$uO(t$}O(u%PO~Om0pO(O0oO~P$*|O!d+cOa(Wa![(Wa'u(Wa!Y(Wa~O#h0vO~O[]X!YfX!ZfX~O!Y0wO!Z)TX~O!Z0yO~O[0zO~Ob0|O(O+kO(QTO(TUO~O![%}O(O%eO`'qX!Y'qX~O!Y+pO`)Sa~O!h1PO~P!9mO[1SO~O`1TO~O#]1WO~Ok1ZO![$|O~O(`(xO!Z)QP~Oh%VOk1dO![1aO%f1cO~O[1nO!Y1lO!Z)RX~O!Z1oO~O`1qOa%lO'u%lO~O(O#nO(QTO(TUO~O#P$dO#]$eO$P$eOP(bXR(bX[(bXo(bX}(bX!P(bX!Y(bX!i(bX!m(bX#O(bX#k(bX#l(bX#m(bX#n(bX#o(bX#p(bX#q(bX#r(bX#u(bX#w(bX#y(bX#z(bX([(bX(m(bX(t(bX(u(bX~O#s1tO&W1uOa(bX~P$0dO#]$eO#s1tO&W1uO~Oa1wO~P%[Oa1yO~O&a1|OP&_iQ&_iS&_iY&_ia&_id&_ie&_im&_io&_ip&_iq&_iw&_iy&_i{&_i!P&_i!T&_i!U&_i![&_i!f&_i!i&_i!l&_i!m&_i!n&_i!p&_i!r&_i!u&_i!y&_i#t&_i$V&_i%e&_i%g&_i%i&_i%j&_i%k&_i%n&_i%p&_i%s&_i%t&_i%v&_i&S&_i&Y&_i&[&_i&^&_i&`&_i&c&_i&i&_i&o&_i&q&_i&s&_i&u&_i&w&_i's&_i(O&_i(Q&_i(T&_i([&_i(j&_i(y&_i!Z&_ib&_i&f&_i~Ob2SO!Z2QO&f2RO~P`O![XO!i2UO~O&m,sOP&hiQ&hiS&hiY&hia&hid&hie&him&hio&hip&hiq&hiw&hiy&hi{&hi!P&hi!T&hi!U&hi![&hi!f&hi!i&hi!l&hi!m&hi!n&hi!p&hi!r&hi!u&hi!y&hi#t&hi$V&hi%e&hi%g&hi%i&hi%j&hi%k&hi%n&hi%p&hi%s&hi%t&hi%v&hi&S&hi&Y&hi&[&hi&^&hi&`&hi&c&hi&i&hi&o&hi&q&hi&s&hi&u&hi&w&hi's&hi(O&hi(Q&hi(T&hi([&hi(j&hi(y&hi!Z&hi&a&hib&hi&f&hi~O!V2[O~O!Y!^a!Z!^a~P#AbOp!nO!P!oO!X2bO(`!mO!Y'TX!Z'TX~P@YO!Y-TO!Z(da~O!Y'ZX!Z'ZX~P!8uO!Y-WO!Z(sa~O!Z2iO~P'_Oa%lO#]2rO'u%lO~Oa%lO!d#vO#]2rO'u%lO~Oa%lO!d#vO!m2vO#]2rO'u%lO(m'mO~Oa%lO'u%lO~P!9mO!Y$_Os$oa~O!V'Si!Y'Si~P!9mO!Y(RO!V(ci~O!Y(YO!V(qi~O!V(ri!Y(ri~P!9mO!Y(oi!h(oia(oi'u(oi~P!9mO#]2xO!Y(oi!h(oia(oi'u(oi~O!Y(fO!h(ni~O!P%fO![%gO!y]O#f2}O#g2|O(O%eO~O!P%fO![%gO#g2|O(O%eO~Ok3UO![']O%f3TO~Oh%VOk3UO![']O%f3TO~O#h%^aP%^aR%^a[%^aa%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^as%^a![%^a%f%^a!d%^a~P#K^O#h%`aP%`aR%`a[%`aa%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`as%`a![%`a%f%`a!d%`a~P#LPO#h%^aP%^aR%^a[%^aa%^ao%^a!Y%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a'u%^a([%^a(m%^a!h%^a!V%^a's%^a#]%^as%^a![%^a%f%^a!d%^a~P#.aO#h%`aP%`aR%`a[%`aa%`ao%`a!Y%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a'u%`a([%`a(m%`a!h%`a!V%`a's%`a#]%`as%`a![%`a%f%`a!d%`a~P#.aO#hzaPza[zaazaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza'uza([za(mza!hza!Vza'szasza![za%fza!dza~P$%]O#h$qaP$qaR$qa[$qaa$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa'u$qa([$qa(m$qa!h$qa!V$qa's$qas$qa![$qa%f$qa!d$qa~P$&UO#h$saP$saR$sa[$saa$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa'u$sa([$sa(m$sa!h$sa!V$sa's$sas$sa![$sa%f$sa!d$sa~P$&wO#h%RaP%RaR%Ra[%Raa%Rao%Ra!Y%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra'u%Ra([%Ra(m%Ra!h%Ra!V%Ra's%Ra#]%Ras%Ra![%Ra%f%Ra!d%Ra~P#.aOa#`q!Y#`q'u#`q's#`q!V#`q!h#`qs#`q![#`q%f#`q!d#`q~P!9mO!X3^O!Y'UX!h'UX~P%[O!Y.lO!h(fa~O!Y.lO!h(fa~P!9mO!V3aO~O#}!ka!Z!ka~PKPO#}!ga!Y!ga!Z!ga~P#AbO#}!oa!Z!oa~P!<TO#}!qa!Z!qa~P!>kOg'XX!Y'XX~P!+hO!Y.wOg(ka~OSfO![3uO$c3vO~O!Z3zO~Os3{O~P#.aOa$lq!Y$lq'u$lq's$lq!V$lq!h$lqs$lq![$lq%f$lq!d$lq~P!9mO!V3|O~P#.aO})zO!P){O(u%POk'ea(t'ea!Y'ea#]'ea~Og'ea#}'ea~P%)nO})zO!P){Ok'ga(t'ga(u'ga!Y'ga#]'ga~Og'ga#}'ga~P%*aO(m$YO~P#.aO!VfX!V$xX!YfX!Y$xX!d%PX#]fX~P!/gO(O<QO~P!1YOmkO(O4OO~P.iO!P%fO!X4QO![%gO(O%eO!Y'aX!h'aX~O!Y/hO!h(za~O!Y/hO!d#vO!h(za~O!Y/hO!d#vO(m'mO!h(za~Og$zi!Y$zi#]$zi#}$zi~P!0kO!X4YO!V'cX!Y'cX~P!3XO!Y/pO!V({a~O!Y/pO!V({a~P#.aO!d#vO#s4bO~Oo4eO!d#vO(m'mO~O!P4hO(`!mO~O(t$}Ok%^i}%^i!P%^i(u%^i!Y%^i#]%^i~Og%^i#}%^i~P%.wO(u%POk%`i}%`i!P%`i(t%`i!Y%`i#]%`i~Og%`i#}%`i~P%/jOg(Yi!Y(Yi~P!0kO#]4mOg(Yi!Y(Yi~P!0kO!h4pO~Oa$mq!Y$mq'u$mq's$mq!V$mq!h$mqs$mq![$mq%f$mq!d$mq~P!9mO!V4tO~O!Y4uO![(|X~P#.aOa$xX![$xX%Z]X'u$xX!Y$xX~P!/gO%Z4xOalXklX}lX!PlX![lX'ulX(tlX(ulX!YlX~O%Z4xO~Ob5OO%g5PO(O+kO(QTO(TUO!Y'pX!Z'pX~O!Y0wO!Z)Ta~O[5TO~O`5UO~Oa%lO'u%lO~P#.aO![$|O~P#.aO!Y5^O#]5`O!Z)QX~O!Z5aO~Oo5hOp!nO!P5bO!_!yO!`!vO!a!vO!y;QO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5gO#Y!zO(P!lO(QTO(TUO(`!mO(j!sO~O!Z5fO~P%4tOk5mO![1aO%f5lO~Oh%VOk5mO![1aO%f5lO~Ob5tO(O#nO(QTO(TUO!Y'oX!Z'oX~O!Y1lO!Z)Ra~O(QTO(TUO(`5vO~O`5zO~O#s5}O&W6OO~PMlO!h6PO~P%[Oa6RO~Oa6RO~P%[Ob2SO!Z6WO&f2RO~P`O!d6YO~O!d6[Oh(ei!Y(ei!Z(ei!d(ei!i(ei~O!Y#ei!Z#ei~P#AbO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#AbOa%lO#]6fO'u%lO~Oa%lO!d#vO#]6fO'u%lO~O!Y(oq!h(oqa(oq'u(oq~P!9mO!Y(fO!h(nq~O!P%fO![%gO#g6mO(O%eO~O![']O%f6pO~Ok6tO![']O%f6pO~O#h'eaP'eaR'ea['eaa'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea'u'ea(['ea(m'ea!h'ea!V'ea's'eas'ea!['ea%f'ea!d'ea~P%)nO#h'gaP'gaR'ga['gaa'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga'u'ga(['ga(m'ga!h'ga!V'ga's'gas'ga!['ga%f'ga!d'ga~P%*aO#h$ziP$ziR$zi[$zia$zio$zi!Y$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi'u$zi([$zi(m$zi!h$zi!V$zi's$zi#]$zis$zi![$zi%f$zi!d$zi~P#.aO#h%^iP%^iR%^i[%^ia%^io%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i'u%^i([%^i(m%^i!h%^i!V%^i's%^is%^i![%^i%f%^i!d%^i~P%.wO#h%`iP%`iR%`i[%`ia%`io%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i'u%`i([%`i(m%`i!h%`i!V%`i's%`is%`i![%`i%f%`i!d%`i~P%/jO!Y'Ua!h'Ua~P!9mO!Y.lO!h(fi~O#}#`i!Y#`i!Z#`i~P#AbOP$[OR#zO}#yO!P#{O!i#xO!m$[O([VO[#jio#ji#O#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#k#ji~P%G^O#k;YO~P%G^OP$[OR#zOo;fO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO[#ji#O#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#o#ji~P%IfO#o;[O~P%IfOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O([VO#w#ji#y#ji#z#ji#}#ji(m#ji(t#ji(u#ji!Y#ji!Z#ji~O#u#ji~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O([VO(u#}O#y#ji#z#ji#}#ji(m#ji(t#ji!Y#ji!Z#ji~O#w;`O~P%MoO#w#ji~P%MoO#u;^O~P%KnOP$[OR#zO[;hOo;fO}#yO!P#{O!i#xO!m$[O#O;]O#k;YO#l;ZO#m;ZO#n;ZO#o;[O#p;]O#q;]O#r;gO#s;]O#u;^O#w;`O([VO(t#|O(u#}O#z#ji#}#ji(m#ji!Y#ji!Z#ji~O#y#ji~P&!OO#y;bO~P&!OOa#{y!Y#{y'u#{y's#{y!V#{y!h#{ys#{y![#{y%f#{y!d#{y~P!9mO[#jio#ji#O#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(m#ji!Y#ji!Z#ji~OP$[OR#zO}#yO!P#{O!i#xO!m$[O#k;YO#l;ZO#m;ZO#n;ZO([VO(t#ji(u#ji~P&$zOk=VO})zO!P){O(t$}O(u%POP#jiR#ji!i#ji!m#ji#k#ji#l#ji#m#ji#n#ji([#ji~P&$zO#P$dOP(ZXR(ZX[(ZXk(ZXo(ZX}(ZX!P(ZX!i(ZX!m(ZX#O(ZX#k(ZX#l(ZX#m(ZX#n(ZX#o(ZX#p(ZX#q(ZX#r(ZX#s(ZX#u(ZX#w(ZX#y(ZX#z(ZX#}(ZX([(ZX(m(ZX(t(ZX(u(ZX!Y(ZX!Z(ZX~O#}$Oi!Y$Oi!Z$Oi~P#AbO#}!oi!Z!oi~P$(fOg'Xa!Y'Xa~P!0kO!Z7WO~O!Y'`a!Z'`a~P#AbOP]XR]X[]Xo]X}]X!P]X!V]X!Y]X!i]X!m]X#O]X#P]X#]]X#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!d%WX#s%WX~P&+QO!d#vO(m'mO!Y'aa!h'aa~O!Y/hO!h(zi~O!Y/hO!d#vO!h(zi~Og$zq!Y$zq#]$zq#}$zq~P!0kO!V'ca!Y'ca~P#.aO!d7_O~O!Y/pO!V({i~P#.aO!Y/pO!V({i~O!V7cO~O!d#vO#s7hO~Oo7iO!d#vO(m'mO~O})zO!P){O(u%POk'fa(t'fa!Y'fa#]'fa~Og'fa#}'fa~P&/pO})zO!P){Ok'ha(t'ha(u'ha!Y'ha#]'ha~Og'ha#}'ha~P&0cO!V7lO~Og$|q!Y$|q#]$|q#}$|q~P!0kOa$my!Y$my'u$my's$my!V$my!h$mys$my![$my%f$my!d$my~P!9mO!d6[O~O!Y4uO![(|a~O![']OP$SaR$Sa[$Sao$Sa}$Sa!P$Sa!Y$Sa!i$Sa!m$Sa#O$Sa#k$Sa#l$Sa#m$Sa#n$Sa#o$Sa#p$Sa#q$Sa#r$Sa#s$Sa#u$Sa#w$Sa#y$Sa#z$Sa([$Sa(m$Sa(t$Sa(u$Sa~O%f6pO~P&2lOa#`y!Y#`y'u#`y's#`y!V#`y!h#`ys#`y![#`y%f#`y!d#`y~P!9mO[7qO~Ob7sO(O+kO(QTO(TUO~O!Y0wO!Z)Ti~O`7wO~O(`(xO!Y'lX!Z'lX~O!Y5^O!Z)Qa~O!Z8QO~P%4tOp!nO!P8RO(QTO(TUO(`!mO(j!sO~O#X8SO~O![1aO~O![1aO%f8UO~Ok8XO![1aO%f8UO~O[8^O!Y'oa!Z'oa~O!Y1lO!Z)Ri~O!h8bO~O!h8cO~O!h8fO~O!h8fO~P%[Oa8hO~O!d8iO~O!h8jO~O!Y(ri!Z(ri~P#AbOa%lO#]8rO'u%lO~O!Y(oy!h(oya(oy'u(oy~P!9mO!Y(fO!h(ny~O%f8uO~P&2lO![']O%f8uO~O#h$zqP$zqR$zq[$zqa$zqo$zq!Y$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq'u$zq([$zq(m$zq!h$zq!V$zq's$zq#]$zqs$zq![$zq%f$zq!d$zq~P#.aO#h'faP'faR'fa['faa'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa'u'fa(['fa(m'fa!h'fa!V'fa's'fas'fa!['fa%f'fa!d'fa~P&/pO#h'haP'haR'ha['haa'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha'u'ha(['ha(m'ha!h'ha!V'ha's'has'ha!['ha%f'ha!d'ha~P&0cO#h$|qP$|qR$|q[$|qa$|qo$|q!Y$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q'u$|q([$|q(m$|q!h$|q!V$|q's$|q#]$|qs$|q![$|q%f$|q!d$|q~P#.aO!Y'Ui!h'Ui~P!9mO#}#`q!Y#`q!Z#`q~P#AbO(t$}OP%^aR%^a[%^ao%^a!i%^a!m%^a#O%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a([%^a(m%^a!Y%^a!Z%^a~Ok%^a}%^a!P%^a(u%^a~P&CoO(u%POP%`aR%`a[%`ao%`a!i%`a!m%`a#O%`a#k%`a#l%`a#m%`a#n%`a#o%`a#p%`a#q%`a#r%`a#s%`a#u%`a#w%`a#y%`a#z%`a#}%`a([%`a(m%`a!Y%`a!Z%`a~Ok%`a}%`a!P%`a(t%`a~P&EsOk=VO})zO!P){O(u%PO~P&CoOk=VO})zO!P){O(t$}O~P&EsOR0`O}0`O!P0aO#P$dOPza[zakzaoza!iza!mza#Oza#kza#lza#mza#nza#oza#pza#qza#rza#sza#uza#wza#yza#zza#}za([za(mza(tza(uza!Yza!Zza~O})zO!P){OP$qaR$qa[$qak$qao$qa!i$qa!m$qa#O$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa([$qa(m$qa(t$qa(u$qa!Y$qa!Z$qa~O})zO!P){OP$saR$sa[$sak$sao$sa!i$sa!m$sa#O$sa#k$sa#l$sa#m$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#u$sa#w$sa#y$sa#z$sa#}$sa([$sa(m$sa(t$sa(u$sa!Y$sa!Z$sa~Ok=VO})zO!P){O(t$}O(u%PO~OP%RaR%Ra[%Rao%Ra!i%Ra!m%Ra#O%Ra#k%Ra#l%Ra#m%Ra#n%Ra#o%Ra#p%Ra#q%Ra#r%Ra#s%Ra#u%Ra#w%Ra#y%Ra#z%Ra#}%Ra([%Ra(m%Ra!Y%Ra!Z%Ra~P&NlO#}$lq!Y$lq!Z$lq~P#AbO#}$mq!Y$mq!Z$mq~P#AbO!Z9SO~O#}9TO~P!0kO!d#vO!Y'ai!h'ai~O!d#vO(m'mO!Y'ai!h'ai~O!Y/hO!h(zq~O!V'ci!Y'ci~P#.aO!Y/pO!V({q~Oo9[O!d#vO(m'mO~O!V9]O~P#.aO!V9]O~O!d#vO#s9bO~Og(Yy!Y(Yy~P!0kO!Y'ja!['ja~P#.aOa%Yq![%Yq'u%Yq!Y%Yq~P#.aO[9dO~O!Y0wO!Z)Tq~O#]9hO!Y'la!Z'la~O!Y5^O!Z)Qi~P#AbO!P4hO~O![1aO%f9lO~O(QTO(TUO(`9qO~O!Y1lO!Z)Rq~O!h9tO~O!h9uO~O!h9vO~O!h9vO~P%[O#]9yO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#AbO%f:OO~P&2lO![']O%f:OO~O#}#{y!Y#{y!Z#{y~P#AbOP$ziR$zi[$zio$zi!i$zi!m$zi#O$zi#k$zi#l$zi#m$zi#n$zi#o$zi#p$zi#q$zi#r$zi#s$zi#u$zi#w$zi#y$zi#z$zi#}$zi([$zi(m$zi!Y$zi!Z$zi~P&NlO})zO!P){O(u%POP'eaR'ea['eak'eao'ea!i'ea!m'ea#O'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(['ea(m'ea(t'ea!Y'ea!Z'ea~O})zO!P){OP'gaR'ga['gak'gao'ga!i'ga!m'ga#O'ga#k'ga#l'ga#m'ga#n'ga#o'ga#p'ga#q'ga#r'ga#s'ga#u'ga#w'ga#y'ga#z'ga#}'ga(['ga(m'ga(t'ga(u'ga!Y'ga!Z'ga~O(t$}OP%^iR%^i[%^ik%^io%^i}%^i!P%^i!i%^i!m%^i#O%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i([%^i(m%^i(u%^i!Y%^i!Z%^i~O(u%POP%`iR%`i[%`ik%`io%`i}%`i!P%`i!i%`i!m%`i#O%`i#k%`i#l%`i#m%`i#n%`i#o%`i#p%`i#q%`i#r%`i#s%`i#u%`i#w%`i#y%`i#z%`i#}%`i([%`i(m%`i(t%`i!Y%`i!Z%`i~O#}$my!Y$my!Z$my~P#AbO#}#`y!Y#`y!Z#`y~P#AbO!d#vO!Y'aq!h'aq~O!Y/hO!h(zy~O!V'cq!Y'cq~P#.aOo:YO!d#vO(m'mO~O!V:ZO~P#.aO!V:ZO~O!Y0wO!Z)Ty~O!Y5^O!Z)Qq~O![1aO%f:cO~O!h:fO~O%f:kO~P&2lOP$zqR$zq[$zqo$zq!i$zq!m$zq#O$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq([$zq(m$zq!Y$zq!Z$zq~P&NlO})zO!P){O(u%POP'faR'fa['fak'fao'fa!i'fa!m'fa#O'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(['fa(m'fa(t'fa!Y'fa!Z'fa~O})zO!P){OP'haR'ha['hak'hao'ha!i'ha!m'ha#O'ha#k'ha#l'ha#m'ha#n'ha#o'ha#p'ha#q'ha#r'ha#s'ha#u'ha#w'ha#y'ha#z'ha#}'ha(['ha(m'ha(t'ha(u'ha!Y'ha!Z'ha~OP$|qR$|q[$|qo$|q!i$|q!m$|q#O$|q#k$|q#l$|q#m$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#u$|q#w$|q#y$|q#z$|q#}$|q([$|q(m$|q!Y$|q!Z$|q~P&NlOg%b!Z!Y%b!Z#]%b!Z#}%b!Z~P!0kOo:oO!d#vO(m'mO~O!V:pO~P#.aO!Y'lq!Z'lq~P#AbO!Y#e!Z!Z#e!Z~P#AbO#h%b!ZP%b!ZR%b!Z[%b!Za%b!Zo%b!Z!Y%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z'u%b!Z([%b!Z(m%b!Z!h%b!Z!V%b!Z's%b!Z#]%b!Zs%b!Z![%b!Z%f%b!Z!d%b!Z~P#.aOo:xO!d#vO(m'mO~OP%b!ZR%b!Z[%b!Zo%b!Z!i%b!Z!m%b!Z#O%b!Z#k%b!Z#l%b!Z#m%b!Z#n%b!Z#o%b!Z#p%b!Z#q%b!Z#r%b!Z#s%b!Z#u%b!Z#w%b!Z#y%b!Z#z%b!Z#}%b!Z([%b!Z(m%b!Z!Y%b!Z!Z%b!Z~P&NlOs(aX~P1qO}%pO~P!(oO(P!lO~P!(oO!VfX!YfX#]fX~P&+QOP]XR]X[]Xo]X}]X!P]X!Y]X!YfX!i]X!m]X#O]X#P]X#]]X#]fX#hfX#k]X#l]X#m]X#n]X#o]X#p]X#q]X#r]X#s]X#u]X#w]X#y]X#z]X$P]X([]X(m]X(t]X(u]X~O!dfX!h]X!hfX(mfX~P'BxOP;POQ;POSfOd<zOe!iOmkOo;POpkOqkOwkOy;PO{;PO!PWO!TkO!UkO![XO!f;SO!iZO!l;PO!m;PO!n;PO!p;TO!r;WO!u!hO$V!kO(O)XO(QTO(TUO([VO(j[O(y<xO~O!Y;dO!Z$oa~Oh%VOm%WOo%XOp$tOq$tOw%YOy%ZO{;oO!P${O![$|O!f=PO!i$xO#g;uO$V%_O$r;qO$t;sO$w%`O(O(rO(QTO(TUO([$uO(t$}O(u%PO~O#t)`O~P'GnOo!bX(m!bX~P# ZO!Z]X!ZfX~P'BxO!VfX!V$xX!YfX!Y$xX#]fX~P!/gO#h;XO~O!d#vO#h;XO~O#];iO~O#s;]O~O#];xO!Y(rX!Z(rX~O#];iO!Y(pX!Z(pX~O#h;yO~Og;{O~P!0kO#h<RO~O#h<SO~O!d#vO#h<TO~O!d#vO#h;yO~O#}<UO~P#AbO#h<VO~O#h<WO~O#h<]O~O#h<^O~O#h<_O~O#h<`O~O#}<aO~P!0kO#}<bO~P!0kO#P#Q#R#T#U#X#f#g#r(y$r$t$w%Z%e%f%g%n%p%s%t%v%x~'yT#l!U'w(P#mp#k#no}'x$['x(O$^(`~",
  goto: "$4Q)XPPPPPP)YPP)]P)nP+O/PPPPP5xPP6`PP<V?mP@QP@QPPP@QPBRP@QP@QP@QPBVPB[PByPGrPPPGvPPPPGvJxPPPKOKzPGvPGvPPNYGvPPPGvPGvP!!aGvP!%v!&{!'UP!'x!'|!'x!+YPPPPPPP!+y!&{PP!,Z!-gP!0jGvGv!0o!3z!8b!8b!<`PPP!<hGvPPPPPPPPPPP!?vP!ATPPGv!BfPGvPGvGvGvGvGvPGv!CxP!GRP!JWP!J[!Jf!Jj!JjP!GOP!Jn!JnP!MsP!MwGvGv!M}##RBV@QP@QP@Q@QP#$_@Q@Q#&j@Q#)Z@Q#+`@Q@Q#,O#.]#.]#.b#.k#.]#.wP#.]P@Q#/a@Q#3S@Q@Q5xPPP#6{PPP#7f#7fP#7fP#7|#7fPP#8SP#7yP#7y#8g#7y#9R#9X5u)]#9[)]P#9c#9c#9cP)]P)]P)]P)]PP)]P#9i#9lP#9l)]P#9pP#9sP)]P)]P)]P)]P)]P)])]PP#9y#:P#:[#:b#:h#:n#:t#;S#;Y#;d#;j#;t#;z#<[#<b#=S#=f#=l#=r#>Q#>g#@V#@e#@l#BR#Ba#C|#D[#Db#Dh#Dn#Dx#EO#EU#E`#Er#ExPPPPPPPPPP#FOPPPPPPP#Fs#Iz#KZ#Kb#KjPPP$!sP$!|$%t$,^$,a$,d$-P$-S$-Z$-cP$-i$-lP$.Y$.^$/U$0d$0i$1PPP$1U$1[$1`P$1c$1g$1k$2a$2x$3a$3e$3h$3k$3q$3t$3x$3|R!|RoqOXst!Z#d%k&o&q&r&t,k,p1|2PY!vQ']-]1a5eQ%rvQ%zyQ&R|Q&g!VS'T!e-TQ'c!iS'i!r!yU*e$|*V*jQ+i%{Q+v&TQ,[&aQ-Z'[Q-e'dQ-m'jQ0R*lQ1k,]R;v;T%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8rS#q];Q!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U*y%[;n;oQ+n%}Q,^&dQ,e&lQ0m+aQ0q+cQ0|+oQ1s,cQ3Q._Q5O0wQ5t1lQ6r3UQ7s5PR8x6t'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{t!nQ!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5g$|$ti#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ&U|Q'R!eU'X%g*V-WQ+n%}Q,^&dQ0c*|Q0|+oQ1R+uQ1r,bQ1s,cQ5O0wQ5X1TQ5t1lQ5w1nQ5x1qQ7s5PQ7v5UQ8a5zQ9g7wR9r8^rnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR,`&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<z<{[#]WZ#W#Z'U(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+h%z%{Q+l%}Q,V&_Q,Z&aS-d'c'dQ.a(nQ0u+iQ0{+oQ0}+pQ1Q+tQ1f,WS1j,[,]Q2n-eQ4}0wQ5R0zQ5W1SQ5s1kQ7r5PQ7u5TQ9c7qR:^9d!O$zi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R!S%wy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dQ+b%uQ+{&XQ,O&YQ,Y&aQ.`(mQ1e,VU1i,Z,[,]Q3V.aQ5n1fS5r1j1kQ8]5s#^<|#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo<};g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bW%Ti%V*t<xS&X!Q&fQ&Y!RQ&Z!SR+y&V$}%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VT)v$u)wV*y%[;n;oW'X!e%g*V-WS(y#y#zQ+]%pQ+s&QS.Y(i(jQ1[,PQ4n0`R7{5^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{$i$^c#Y#e%o%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.t.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q'V!eR2c-Tv!nQ!e!r!v!y!z'T'[']'i'j'k-T-Z-]-m1a5e5gU*d$|*V*jS/y*e*lQ0S*mQ1^,RQ4d0RR4g0UnqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&v!^Q's!xS(o#u;XQ+f%xQ,T&[Q,U&^Q-b'aQ-o'lS.j(t;yS0f+R<TQ0s+gQ1`,SQ2T,rQ2V,sQ2_-OQ2l-cQ2o-gS4s0g<_Q4y0tS4|0v<`Q6^2aQ6b2mQ6g2tQ7p4zQ8m6`Q8n6cQ8q6hR9x8j$d$]c#Y#e%q%s(O(U(p(u(})O)P)Q)R)S)T)U)V)W)Y)[)^)c)m+^+r-R-p-u-z-|.k.n.r.u.v/X0e2]2`2p2w3]3b3c3d3e3f3g3h3i3j3k3l3m3n3q3r3y4r4{6_6e6j6y6z7T7U7}8l8p8z9Q9R9{:`:g;R<oS(k#p'fQ({#zS+[%o.tS.Z(j(lR3O.['OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S#q];QQ&q!XQ&r!YQ&t![Q&u!]R1{,nQ'^!hQ+_%uQ-`'`S.](m+bQ2j-_W3S.`.a0l0nQ6a2kW6n3P3R3V4wU8t6o6q6sU9}8v8w8yS:i9|:PQ:t:jR:z:uU!wQ']-]T5c1a5e!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,k,p.S1|2P]!pQ!r']-]1a5eT#q];Q%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS(y#y#zS.Y(i(j!s<f$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{U$fd)Z,eS(l#p'fU*q%R(s3pU0b*x.f7PQ4w0mQ6o3QQ8w6rR:P8xm!tQ!r!v!y!z']'i'j'k-]-m1a5e5gQ'q!uS(b#g1vS-k'h'tQ/k*XQ/w*dQ2v-nQ4U/lS4_/x0SQ7Z4PS7f4e4gQ9V7[Q9Z7cQ9`7iS:X9[9]S:n:Y:ZS:w:o:pR:}:xQ#wbQ'p!uS(a#g1vS(c#m+QQ+S%dQ+d%vQ+j%|U-j'h'q'tQ.O(bQ/j*XQ/v*dQ/|*gQ0r+eQ1g,XS2s-k-nQ2{.WS4T/k/lS4^/w0SQ4a/{Q4c/}Q5p1hQ6i2vQ7Y4PQ7^4US7b4_4gQ7g4fQ8Z5qS9U7Z7[Q9Y7cQ9^7fQ9a7jQ9o8[Q:V9VS:W9Z9]Q:[9`Q:e9pS:m:X:ZS:v:n:pQ:|:wQ;O:}Q<i<dQ<t<mR<u<nV!wQ']-]%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rS#wz!j!r<c$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<i<z%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*d+h+i-Q-d-e-l/y0u2g2n2u4dS%|z!jQ+e%wQ,X&aW1h,Y,Z,[,]U5q1i1j1kS8[5r5sQ9p8]!r<d$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q<m<yR<n<z%OeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8rY#bWZ#W#Z(P!b%hm#h#i#l$x%c%f(Y(d(e(f*U*Y*]+T+U+W,g,}-{.R.S.T.V/e/h2U2|2}4Q6[6mQ,f&l!p<e$Z$n)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{R<h'UU'Y!e%g*VR2e-W%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V,h,k,p-a-i-w-}.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3^5b5m5}6O6R6f8R8X8h8r!r)Z$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{Q,e&lQ0m+aQ3Q._Q6r3UR8x6t!b$Tc#Y%o(O(U(p(u)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!P;_)Y)m-R.t2]2`3b3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!f$Vc#Y%o(O(U(p(u)S)T)V)W)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;R!T;a)Y)m-R.t2]2`3b3h3i3k3l3q3y6_6z7T7U7}8l8z9Q9R:`:g<o!^$Zc#Y%o(O(U(p(u)[)c+r-p-u-z-|.k.n/X0e2p2w3]3m4r4{6e6j6y8p9{;RQ3}/cz<{)Y)m-R.t2]2`3b3q3y6_6z7T7U7}8l8z9Q9R:`:g<oQ=Q=SR=R=T'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{S$oh$pR3v.|'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$kf$qQ$ifS)f$l)jR)r$qT$jf$qT)h$l)j'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(v(z)o)y+R+V+a,h,k,p,|-P-a-i-w-}._.l.s.|.}/f0a0g0v1d1t1u1w1y1|2P2R2b2r2x3U3^3u5`5b5m5}6O6R6]6f6t8R8X8h8r9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{T$oh$pQ$rhR)q$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(v(z)y+R+V+a,h,k,p-a-i-w-}._.l.s/f0a0g0v1d1t1u1w1y1|2P2R2r2x3U3^5b5m5}6O6R6f6t8R8X8h8r!s<y$Z$n'U)o,|-P.}2b3u5`6]9h9y;P;S;T;W;X;Y;Z;[;];^;_;`;a;b;c;d;f;i;v;x;y;{<T<U<_<`<{#elOPXZst!Z!`!o#S#d#o#{$n%k&h&k&l&o&q&r&t&x'Q'_(z)o+V+a,h,k,p-a._.}/f0a1d1t1u1w1y1|2P2R3U3u5b5m5}6O6R6t8R8X8h!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=VQ*}%`Q/Y)zo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!O$yi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=RQ*^$zU*g$|*V*jQ+O%aQ/}*h#^<k#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn<l;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bQ<p<|Q<q<}Q<r=OR<s=P!O%Ri$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=R#^(s#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vo3p;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<bnoOXst!Z#d%k&o&q&r&t,k,p1|2PS*a${*UQ,y&{Q,z&}R4X/p$|%Si#v$b$c$d$x${%O%Q%]%^%b)u){)}*P*R*U*[*b*r*s+`+c+z+}.^.w/]/e/o/p/r0V0X0d1W1Z1c3T3}4Y4b4m4u4x5l6p7_7h8U8u9T9b9l:O:c:k;g;h;j;k;l;m;p;q;r;s;t;u;|;}<O<P<R<S<V<W<X<Y<Z<[<]<^<a<b<x=Q=R=U=VQ+|&YQ1Y,OQ5[1XR7z5]V*i$|*V*jU*i$|*V*jT5d1a5eU/{*f/f5bS4f0T8RR7j4hQ+d%vQ/|*gQ0r+eQ1g,XQ5p1hQ8Z5qQ9o8[R:e9p!O%Oi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rr)}$v)a*O*p+P/n0Z0[3s4V4q7X7k:U<j<v<wS0V*o0W#^;j#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;k;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!`;|(q)_*W*`.b.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=T`;}3o6{7O7S8{:Q:T:{S<X.d3ZT<Y6}9O!O%Qi$d%O%Q%]%^%b)}*P*[*r*s.w/o0V0X0d3}4m9T<x=Q=Rv*P$v)a*Q*o+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<wS0X*p0Y#^;l#v$b$c$x${)u){*R*U*b+`+c+z+}.^/]/e/p/r1W1Z1c3T4Y4b4u4x5l6p7_7h8U8u9b9l:O:c:k;j;l;p;r;t;|<O<R<V<X<Z<]<a=U=Vn;m;g;h;k;m;q;s;u;}<P<S<W<Y<[<^<b!d<O(q)_*W*`.c.d.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=Td<P3o6|6}7S8{8|:Q:R:T:{S<Z.e3[T<[7O9PrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ&c!UR,h&lrnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PR&c!UQ,Q&ZR1U+ysnOXst!V!Z#d%k&f&o&q&r&t,k,p1|2PQ1b,VS5k1e1fU8T5i5j5nS9k8V8WS:a9j9mQ:q:bR:y:rQ&j!VR,a&fR5w1nS&O|&TR0}+pQ&o!WR,k&pR,q&uT1},p2PR,u&vQ,t&vR2W,uQ'v!{R-q'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)w$uR/V)wQ#UVR'|#UQ#XWU(S#X(T-xQ(T#YR-x(UQ-U'VR2d-UQ.m(uS3_.m3`R3`.nQ-]']R2h-]Y!rQ']-]1a5eR'g!rQ.x)aR3t.xU#_W%f*UU(Z#_([-yQ([#`R-y(VQ-X'YR2f-Xt`OXst!V!Z#d%k&f&h&o&q&r&t,k,p1|2PS#hZ%cU#r`#h.SR.S(fQ(g#jQ.P(cW.X(g.P2y6kQ2y.QR6k2zQ)j$lR/O)jQ$phR)p$pQ$`cU)]$`-t;eQ-t;RR;e)mQ/i*XW4R/i4S7]9WU4S/j/k/lS7]4T4UR9W7^$Z)|$v(q)_)a*W*`*o*p*z*{+P.d.e.g.h.i/U/Z/_/a/c/n/s0Z0[0k1V1X3W3X3Y3o3s4V4W4[4i4k4q5Z5]6u6v6w6x6}7O7Q7R7S7X7`7d7k7m7o8{8|8}9X9_:Q:R:S:T:U:]:l:{<j<v<w=S=TQ/q*`U4Z/q4]7aQ4]/sR7a4[S*j$|*VR0P*jr*O$v)a*o*p+P/n0Z0[3s4V4q7X7k:U<j<v<w!`.b(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3Y4W4[5Z5]6u6x7`7d7m7o9X9_:]:l=S=TU/`*O.b6{a6{3o6}7O7S8{:Q:T:{Q0W*oQ3Z.dU4j0W3Z9OR9O6}v*Q$v)a*o*p+P/_/n0Z0[3s4V4i4q7X7k:U<j<v<w!d.c(q)_*W*`.d.e.i/U/Z/c/s0k1V1X3W3Y4W4[5Z5]6u6v6x7`7d7m7o9X9_:]:l=S=TU/b*Q.c6|e6|3o6}7O7S8{8|:Q:R:T:{Q0Y*pQ3[.eU4l0Y3[9PR9P7OQ*u%UR0^*uQ4v0kR7n4vQ+X%iR0j+XQ5_1[S7|5_9iR9i7}Q,S&[R1_,SQ5e1aR8P5eQ1m,^S5u1m8_R8_5wQ0x+lW5Q0x5S7t9eQ5S0{Q7t5RR9e7uQ+q&OR1O+qQ2P,pR6V2PYrOXst#dQ&s!ZQ+Z%kQ,j&oQ,l&qQ,m&rQ,o&tQ1z,kS1},p2PR6U1|Q%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Y%jQ+f%xQ+x&UQ,`&jQ,w&yW-h'h'p'q'tQ-o'lQ0O*iQ0s+gS1p,a,dQ2X,vQ2Y,yQ2Z,zQ2o-gW2q-j-k-n-pQ4y0tQ5V1RQ5Y1VQ5o1gQ5y1rQ6T1{U6d2p2s2vQ6g2tQ7p4zQ7x5XQ7y5ZQ8O5dQ8Y5pQ8`5xS8o6e6iQ8q6hQ9f7vQ9n8ZQ9s8aQ9z8pQ:_9gQ:d9oQ:h9{R:s:eQ%xyQ'a!iQ'l!uU+g%y%z%{Q-O'SU-c'b'c'dS-g'h'rQ/u*dS0t+h+iQ2a-QS2m-d-eQ2t-lQ4`/yQ4z0uQ6`2gQ6c2nQ6h2uR7e4dS$wi<xR*v%VU%Ui%V<xR0]*tQ$viS(q#v+cS)_$b$cQ)a$dQ*W$xS*`${*UQ*o%OQ*p%QQ*z%]Q*{%^Q+P%bQ.d;jQ.e;lQ.g;pQ.h;rQ.i;tQ/U)uS/Z){/]Q/_)}Q/a*PQ/c*RQ/n*[S/s*b/eQ0Z*rQ0[*sh0k+`.^1c3T5l6p8U8u9l:O:c:kQ1V+zQ1X+}Q3W;|Q3X<OQ3Y<RS3o;g;hQ3s.wQ4V/oQ4W/pQ4[/rQ4i0VQ4k0XQ4q0dQ5Z1WQ5]1ZQ6u<VQ6v<XQ6w<ZQ6x<]Q6};kQ7O;mQ7Q;qQ7R;sQ7S;uQ7X3}Q7`4YQ7d4bQ7k4mQ7m4uQ7o4xQ8{<SQ8|;}Q8}<PQ9X7_Q9_7hQ:Q<WQ:R<YQ:S<[Q:T<^Q:U9TQ:]9bQ:l<aQ:{<bQ<j<xQ<v=QQ<w=RQ=S=UR=T=VQ*x%[Q.f;nR7P;onpOXst!Z#d%k&o&q&r&t,k,p1|2PQ!fPS#fZ#oQ&y!`U'e!o5b8RQ'{#SQ(|#{Q)n$nS,d&h&kQ,i&lQ,v&xQ,{'QQ-_'_Q.p(zQ/S)oS0h+V/fQ0n+aQ1x,hQ2k-aQ3R._Q3x.}Q4o0aQ5j1dQ5{1tQ5|1uQ6Q1wQ6S1yQ6X2RQ6s3UQ7V3uQ8W5mQ8d5}Q8e6OQ8g6RQ8y6tQ9m8XR9w8h#YcOPXZst!Z!`!o#d#o#{%k&h&k&l&o&q&r&t&x'Q'_(z+V+a,h,k,p-a._/f0a1d1t1u1w1y1|2P2R3U5b5m5}6O6R6t8R8X8hQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)Y$ZQ)[$_Q)^$aQ)c$eW)m$n)o.}3uQ+^%rQ+r&PS-R'U2bQ-p'oS-u(P-wQ-z(XQ-|(`Q.k(tQ.n(vQ.r;PQ.t;SQ.u;TQ.v;WQ/X)yQ0e+RQ2],|Q2`-PQ2p-iQ2w-}Q3].lQ3b;XQ3c;YQ3d;ZQ3e;[Q3f;]Q3g;^Q3h;_Q3i;`Q3j;aQ3k;bQ3l;cQ3m.sQ3n;fQ3q;iQ3r;vQ3y;dQ4r0gQ4{0vQ6_;xQ6e2rQ6j2xQ6y3^Q6z;yQ7T;{Q7U<TQ7}5`Q8l6]Q8p6fQ8z<UQ9Q<_Q9R<`Q9{8rQ:`9hQ:g9yQ;R#SR<o<{R#[WR'W!el!tQ!r!v!y!z']'i'j'k-]-m1a5e5gS'S!e-TS-Q'T'[R2g-ZR(w#xQ!fQT-[']-]]!qQ!r']-]1a5eQ#p]R'f;QR)b$dY!uQ']-]1a5eQ'h!rS'r!v!yS't!z5gS-l'i'jQ-n'kR2u-mT#kZ%cS#jZ%cS%im,gU(c#h#i#lS.Q(d(eQ.U(fQ0i+WQ2z.RU2{.S.T.VS6l2|2}R8s6md#^W#W#Z%f(P(Y*U+T-{/er#gZm#h#i#l%c(d(e(f+W.R.S.T.V2|2}6mS*X$x*]Q/l*YQ1v,gQ2^,}Q4P/hQ6Z2UQ7[4QQ8k6[T<g'U+UV#aW%f*UU#`W%f*US(Q#W(YU(V#Z+T/eS-S'U+UT-v(P-{V'Z!e%g*VQ$lfR)t$qT)i$l)jR3w.|T*Z$x*]T*c${*UQ0l+`Q3P.^Q5i1cQ6q3TQ8V5lQ8v6pQ9j8UQ9|8uQ:b9lQ:j:OQ:r:cR:u:knqOXst!Z#d%k&o&q&r&t,k,p1|2PQ&i!VR,`&ftmOXst!U!V!Z#d%k&f&o&q&r&t,k,p1|2PR,g&lT%jm,gR1],PR,_&dQ&S|R+w&TR+m%}T&m!W&pT&n!W&pT2O,p2P",
  nodeNames: "âš  ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 376,
  context: Ox,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 34, 36, 48, 50, 52, ""],
    ["group", -26, 9, 17, 19, 65, 204, 208, 212, 213, 215, 218, 221, 231, 233, 239, 241, 243, 245, 248, 254, 260, 262, 264, 266, 268, 270, 271, "Statement", -34, 13, 14, 29, 32, 33, 39, 48, 51, 52, 54, 59, 67, 69, 73, 77, 79, 81, 82, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 144, 146, 147, 166, 167, 169, "Expression", -23, 28, 30, 34, 38, 40, 42, 171, 173, 175, 176, 178, 179, 180, 182, 183, 184, 186, 187, 188, 198, 200, 202, 203, "Type", -3, 85, 100, 106, "ClassItem"],
    ["openedBy", 23, "<", 35, "InterpolationStart", 53, "[", 57, "{", 70, "(", 159, "JSXStartCloseTag"],
    ["closedBy", 24, ">", 37, "InterpolationEnd", 47, "]", 58, "}", 71, ")", 164, "JSXEndTag"]
  ],
  propSources: [sx],
  skippedNodes: [0, 5, 6, 274],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$h&j(Rp(U!b'w0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(S#S$h&j'x0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$h&j(Rp(U!b'x0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$h&j!m),Q(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(Q':f$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$h&j(U!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$h&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$c`$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$c``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$c`$h&j(U!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(U!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$c`(U!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$h&j(Rp(U!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$h&j(Rp(U!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$h&j(U!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$h&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(U!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$h&j(RpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(RpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Rp(U!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$h&j(j%1l(Rp(U!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$h&j(Rp(U!b$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$h&j(Rp(U!b$[#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$h&j(Rp(U!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$h&j$P(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(u+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$h&j#y(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(T';W$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$h&j(RpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$h&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$c`$h&j(RpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(RpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$c`(RpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!i/.^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!h!Lf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$h&j(Rp(U!b(P%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$h&j(Rp(U!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$h&j(Rp(U!bo+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$h&j(Rp(U!b}.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$h&j(Rp(U!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$h&j(U!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$h&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$h&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$h&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$h&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$h&j(U!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(U!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(U!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(U!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$h&j(U!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$h&j(Rp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$h&j(Rp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Rp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Rp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(RpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$h&j(RpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$h&j(Rp(U!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Rp(U!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Rp(U!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Rp(U!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$h&j(Rp(U!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$h&j(Rp(U!b'y0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$h&j(Rp(U!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$h&j(U!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$h&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(U!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$h&j(RpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(RpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Rp(U!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$h&j$P(Ch(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Y#t$h&j(Rp(U!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$h&j(Rp(U!bp'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$h&j#})Lv(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#O-<U(Rp(U!b(y7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$j&j(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#p(Ch$e#|$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(m(Ct$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$h&j#z(Ch(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!y$Ip$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!P0,v$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$h&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$h&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$h&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$h&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$h&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$h&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!V#)l$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#w(Ch$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$h&j(Rp(U!b([+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$h&j(Rp(U!b(O,2j$^#t(`$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$h&j(Rp(U!b$^#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X![#Hb(Rp(U!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(t+JY$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z(Kd$?V_!Z(Cds`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!n7`$h&j(Rp(U!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$h&j(Rp(U!b'w0/l$[#t(O,2j(`$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$h&j(Rp(U!b'x0/l$[#t(O,2j(`$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [ix, rx, nx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, tx, new nO("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOu~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(^~~", 141, 335), new nO("j~RQYZXz{^~^O'{~~aP!P!Qd~iO'|~~", 25, 318)],
  topRules: { Script: [0, 7], SingleExpression: [1, 272], SingleClassItem: [2, 273] },
  dialects: { jsx: 0, ts: 14725 },
  dynamicPrecedences: { 77: 1, 79: 1, 91: 1, 167: 1, 196: 1 },
  specialized: [{ term: 322, get: (t) => ax[t] || -1 }, { term: 338, get: (t) => ox[t] || -1 }, { term: 92, get: (t) => lx[t] || -1 }],
  tokenPrec: 14749
}), Od = [
  /* @__PURE__ */ L("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ L("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ L("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ L("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ L("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ L(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ L("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ L(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ L(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ L('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ L('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], hx = /* @__PURE__ */ Od.concat([
  /* @__PURE__ */ L("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ L("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ L("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), Th = /* @__PURE__ */ new Qo(), td = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ri(t) {
  return (e, O) => {
    let i = e.node.getChild("VariableDefinition");
    return i && O(i, t), !0;
  };
}
const Qx = ["FunctionDeclaration"], fx = {
  FunctionDeclaration: /* @__PURE__ */ ri("function"),
  ClassDeclaration: /* @__PURE__ */ ri("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ri("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ri("type"),
  NamespaceDeclaration: /* @__PURE__ */ ri("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(Qx) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function id(t, e) {
  let O = Th.get(e);
  if (O)
    return O;
  let i = [], r = !0;
  function n(s, a) {
    let o = t.sliceString(s.from, s.to);
    i.push({ label: o, type: a });
  }
  return e.cursor(H.IncludeAnonymous).iterate((s) => {
    if (r)
      r = !1;
    else if (s.name) {
      let a = fx[s.name];
      if (a && a(s, n) || td.has(s.name))
        return !1;
    } else if (s.to - s.from > 8192) {
      for (let a of id(t, s.node))
        i.push(a);
      return !1;
    }
  }), Th.set(e, i), i;
}
const wh = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, rd = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function $x(t) {
  let e = I(t.state).resolveInner(t.pos, -1);
  if (rd.indexOf(e.name) > -1)
    return null;
  let O = e.name == "VariableName" || e.to - e.from < 20 && wh.test(t.state.sliceDoc(e.from, e.to));
  if (!O && !t.explicit)
    return null;
  let i = [];
  for (let r = e; r; r = r.parent)
    td.has(r.name) && (i = i.concat(id(t.state.doc, r)));
  return {
    options: i,
    from: O ? e.from : t.pos,
    validFor: wh
  };
}
const Ne = /* @__PURE__ */ re.define({
  name: "javascript",
  parser: /* @__PURE__ */ cx.configure({
    props: [
      /* @__PURE__ */ me.add({
        IfStatement: /* @__PURE__ */ ae({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ae({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: qn,
        SwitchBody: (t) => {
          let e = t.textAfter, O = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (O ? 0 : i ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ YO({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ ae({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ fe.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Ie,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), nd = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ Wo({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, sd = /* @__PURE__ */ Ne.configure({ dialect: "ts" }, "typescript"), ad = /* @__PURE__ */ Ne.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Ro.add((t) => t.isTop ? [nd] : void 0)]
}), od = /* @__PURE__ */ Ne.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Ro.add((t) => t.isTop ? [nd] : void 0)]
}, "typescript");
let ld = (t) => ({ label: t, type: "keyword" });
const cd = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(ld), ux = /* @__PURE__ */ cd.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(ld));
function kt(t = {}) {
  let e = t.jsx ? t.typescript ? od : ad : t.typescript ? sd : Ne, O = t.typescript ? hx.concat(ux) : Od.concat(cd);
  return new le(e, [
    Ne.data.of({
      autocomplete: Eo(rd, Cn(O))
    }),
    Ne.data.of({
      autocomplete: $x
    }),
    t.jsx ? mx : []
  ]);
}
function dx(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function kh(t, e, O = t.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return t.sliceString(i.from, Math.min(i.to, O));
  return "";
}
const px = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), mx = /* @__PURE__ */ k.inputHandler.of((t, e, O, i, r) => {
  if ((px ? t.composing : t.compositionStarted) || t.state.readOnly || e != O || i != ">" && i != "/" || !Ne.isActiveAt(t.state, e, -1))
    return !1;
  let n = r(), { state: s } = n, a = s.changeByRange((o) => {
    var c;
    let { head: h } = o, Q = I(s).resolveInner(h - 1, -1), f;
    if (Q.name == "JSXStartTag" && (Q = Q.parent), !(s.doc.sliceString(h - 1, h) != i || Q.name == "JSXAttributeValue" && Q.to > h)) {
      if (i == ">" && Q.name == "JSXFragmentTag")
        return { range: o, changes: { from: h, insert: "</>" } };
      if (i == "/" && Q.name == "JSXStartCloseTag") {
        let $ = Q.parent, u = $.parent;
        if (u && $.from == h - 2 && ((f = kh(s.doc, u.firstChild, h)) || ((c = u.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let d = `${f}>`;
          return { range: g.cursor(h + d.length, -1), changes: { from: h, insert: d } };
        }
      } else if (i == ">") {
        let $ = dx(Q);
        if ($ && $.name == "JSXOpenTag" && !/^\/?>|^<\//.test(s.doc.sliceString(h, h + 2)) && (f = kh(s.doc, $, h)))
          return { range: o, changes: { from: h, insert: `</${f}>` } };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    n,
    s.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), ni = ["_blank", "_self", "_top", "_parent"], Xs = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], ys = ["get", "post", "put", "delete"], bs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ce = ["true", "false"], v = {}, Px = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: ni,
      hreflang: null
    }
  },
  abbr: v,
  address: v,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: v,
  aside: v,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: v,
  base: { attrs: { href: null, target: ni } },
  bdi: v,
  bdo: v,
  blockquote: { attrs: { cite: null } },
  body: v,
  br: v,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: bs,
      formmethod: ys,
      formnovalidate: ["novalidate"],
      formtarget: ni,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: v,
  center: v,
  cite: v,
  code: v,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: v,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: v,
  div: v,
  dl: v,
  dt: v,
  em: v,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: v,
  figure: v,
  footer: v,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Xs,
      autocomplete: ["on", "off"],
      enctype: bs,
      method: ys,
      novalidate: ["novalidate"],
      target: ni
    }
  },
  h1: v,
  h2: v,
  h3: v,
  h4: v,
  h5: v,
  h6: v,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: v,
  hgroup: v,
  hr: v,
  html: {
    attrs: { manifest: null }
  },
  i: v,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: bs,
      formmethod: ys,
      formnovalidate: ["novalidate"],
      formtarget: ni,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: v,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: v,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: v,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Xs,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: v,
  noscript: v,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: v,
  param: { attrs: { name: null, value: null } },
  pre: v,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: v,
  rt: v,
  ruby: v,
  samp: v,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Xs
    }
  },
  section: v,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: v,
  source: { attrs: { src: null, type: null, media: null } },
  span: v,
  strong: v,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: v,
  summary: v,
  sup: v,
  table: v,
  tbody: v,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: v,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: v,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: v,
  time: { attrs: { datetime: null } },
  title: v,
  tr: v,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: v,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: v
}, hd = {
  accesskey: null,
  class: null,
  contenteditable: Ce,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ce,
  autocorrect: Ce,
  autocapitalize: Ce,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ce,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ce,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ce,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ce,
  "aria-hidden": Ce,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ce,
  "aria-multiselectable": Ce,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ce,
  "aria-relevant": null,
  "aria-required": Ce,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, Qd = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of Qd)
  hd[t] = null;
class Ni {
  constructor(e, O) {
    this.tags = Object.assign(Object.assign({}, Px), e), this.globalAttrs = Object.assign(Object.assign({}, hd), O), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Ni.default = /* @__PURE__ */ new Ni();
function At(t, e, O = t.length) {
  if (!e)
    return "";
  let i = e.firstChild, r = i && i.getChild("TagName");
  return r ? t.sliceString(r.from, Math.min(r.to, O)) : "";
}
function Dt(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function fd(t, e, O) {
  let i = O.tags[At(t, Dt(e))];
  return (i == null ? void 0 : i.children) || O.allTags;
}
function Jo(t, e) {
  let O = [];
  for (let i = Dt(e); i && !i.type.isTop; i = Dt(i.parent)) {
    let r = At(t, i);
    if (r && i.lastChild.name == "CloseTag")
      break;
    r && O.indexOf(r) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && O.push(r);
  }
  return O;
}
const $d = /^[:\-\.\w\u00b7-\uffff]*$/;
function Wh(t, e, O, i, r) {
  let n = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">", s = Dt(O, !0);
  return {
    from: i,
    to: r,
    options: fd(t.doc, s, e).map((a) => ({ label: a, type: "type" })).concat(Jo(t.doc, O).map((a, o) => ({
      label: "/" + a,
      apply: "/" + a + n,
      type: "type",
      boost: 99 - o
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Rh(t, e, O, i) {
  let r = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: O,
    to: i,
    options: Jo(t.doc, e).map((n, s) => ({ label: n, apply: n + r, type: "type", boost: 99 - s })),
    validFor: $d
  };
}
function gx(t, e, O, i) {
  let r = [], n = 0;
  for (let s of fd(t.doc, O, e))
    r.push({ label: "<" + s, type: "type" });
  for (let s of Jo(t.doc, O))
    r.push({ label: "</" + s + ">", type: "type", boost: 99 - n++ });
  return { from: i, to: i, options: r, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function Sx(t, e, O, i, r) {
  let n = Dt(O), s = n ? e.tags[At(t.doc, n)] : null, a = s && s.attrs ? Object.keys(s.attrs) : [], o = s && s.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: r,
    options: o.map((c) => ({ label: c, type: "property" })),
    validFor: $d
  };
}
function Xx(t, e, O, i, r) {
  var n;
  let s = (n = O.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), a = [], o;
  if (s) {
    let c = t.sliceDoc(s.from, s.to), h = e.globalAttrs[c];
    if (!h) {
      let Q = Dt(O), f = Q ? e.tags[At(t.doc, Q)] : null;
      h = (f == null ? void 0 : f.attrs) && f.attrs[c];
    }
    if (h) {
      let Q = t.sliceDoc(i, r).toLowerCase(), f = '"', $ = '"';
      /^['"]/.test(Q) ? (o = Q[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", $ = t.sliceDoc(r, r + 1) == Q[0] ? "" : Q[0], Q = Q.slice(1), i++) : o = /^[^\s<>='"]*$/;
      for (let u of h)
        a.push({ label: u, apply: f + u + $, type: "constant" });
    }
  }
  return { from: i, to: r, options: a, validFor: o };
}
function ud(t, e) {
  let { state: O, pos: i } = e, r = I(O).resolveInner(i, -1), n = r.resolve(i);
  for (let s = i, a; n == r && (a = r.childBefore(s)); ) {
    let o = a.lastChild;
    if (!o || !o.type.isError || o.from < o.to)
      break;
    n = r = a, s = o.from;
  }
  return r.name == "TagName" ? r.parent && /CloseTag$/.test(r.parent.name) ? Rh(O, r, r.from, i) : Wh(O, t, r, r.from, i) : r.name == "StartTag" ? Wh(O, t, r, i, i) : r.name == "StartCloseTag" || r.name == "IncompleteCloseTag" ? Rh(O, r, i, i) : r.name == "OpenTag" || r.name == "SelfClosingTag" || r.name == "AttributeName" ? Sx(O, t, r, r.name == "AttributeName" ? r.from : i, i) : r.name == "Is" || r.name == "AttributeValue" || r.name == "UnquotedAttributeValue" ? Xx(O, t, r, r.name == "Is" ? i : r.from, i) : e.explicit && (n.name == "Element" || n.name == "Text" || n.name == "Document") ? gx(O, t, r, i) : null;
}
function yx(t) {
  return ud(Ni.default, t);
}
function bx(t) {
  let { extraTags: e, extraGlobalAttributes: O } = t, i = O || e ? new Ni(e, O) : Ni.default;
  return (r) => ud(i, r);
}
const xx = /* @__PURE__ */ Ne.parser.configure({ top: "SingleExpression" }), dd = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: sd.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: ad.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: od.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: xx
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: Ne.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: wn.parser
  }
], pd = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ wn.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ Qd.map((t) => ({ name: t, parser: Ne.parser }))), md = /* @__PURE__ */ re.define({
  name: "html",
  parser: /* @__PURE__ */ cb.configure({
    props: [
      /* @__PURE__ */ me.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, O;
          for (let i = t.node; ; ) {
            let r = i.lastChild;
            if (!r || r.name != "Element" || r.to != i.to)
              break;
            e = i = r;
          }
          return e && !((O = e.lastChild) && (O.name == "CloseTag" || O.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ fe.add({
        Element(t) {
          let e = t.firstChild, O = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: O.name == "CloseTag" ? O.from : t.to };
        }
      }),
      /* @__PURE__ */ Yo.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), Br = /* @__PURE__ */ md.configure({
  wrap: /* @__PURE__ */ Lu(dd, pd)
});
function Ht(t = {}) {
  let e = "", O;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (O = Lu((t.nestedLanguages || []).concat(dd), (t.nestedAttributes || []).concat(pd)));
  let i = O ? md.configure({ wrap: O, dialect: e }) : e ? Br.configure({ dialect: e }) : Br;
  return new le(i, [
    Br.data.of({ autocomplete: bx(t) }),
    t.autoCloseTags !== !1 ? Tx : [],
    kt().support,
    Ju().support
  ]);
}
const vh = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), Tx = /* @__PURE__ */ k.inputHandler.of((t, e, O, i, r) => {
  if (t.composing || t.state.readOnly || e != O || i != ">" && i != "/" || !Br.isActiveAt(t.state, e, -1))
    return !1;
  let n = r(), { state: s } = n, a = s.changeByRange((o) => {
    var c, h, Q;
    let f = s.doc.sliceString(o.from - 1, o.to) == i, { head: $ } = o, u = I(s).resolveInner($, -1), d;
    if (f && i == ">" && u.name == "EndTag") {
      let p = u.parent;
      if (((h = (c = p.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (d = At(s.doc, p.parent, $)) && !vh.has(d)) {
        let m = $ + (s.doc.sliceString($, $ + 1) === ">" ? 1 : 0), P = `</${d}>`;
        return { range: o, changes: { from: $, to: m, insert: P } };
      }
    } else if (f && i == "/" && u.name == "IncompleteCloseTag") {
      let p = u.parent;
      if (u.from == $ - 2 && ((Q = p.lastChild) === null || Q === void 0 ? void 0 : Q.name) != "CloseTag" && (d = At(s.doc, p, $)) && !vh.has(d)) {
        let m = $ + (s.doc.sliceString($, $ + 1) === ">" ? 1 : 0), P = `${d}>`;
        return {
          range: g.cursor($ + P.length, -1),
          changes: { from: $, to: m, insert: P }
        };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    n,
    s.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), wx = se({
  String: l.string,
  Number: l.number,
  "True False": l.bool,
  PropertyName: l.propertyName,
  Null: l.null,
  ",": l.separator,
  "[ ]": l.squareBracket,
  "{ }": l.brace
}), kx = ne.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "âš  JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [wx],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), Wx = /* @__PURE__ */ re.define({
  name: "json",
  parser: /* @__PURE__ */ kx.configure({
    props: [
      /* @__PURE__ */ me.add({
        Object: /* @__PURE__ */ ae({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ ae({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ fe.add({
        "Object Array": Ie
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function Zh() {
  return new le(Wx);
}
const Rx = 36, Yh = 1, vx = 2, gt = 3, xs = 4, Zx = 5, Yx = 6, zx = 7, qx = 8, Ux = 9, Vx = 10, _x = 11, jx = 12, Gx = 13, Cx = 14, Ex = 15, Ax = 16, Dx = 17, zh = 18, Nx = 19, Pd = 20, gd = 21, qh = 22, Ix = 23, Mx = 24;
function Va(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57;
}
function Lx(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function rt(t, e, O) {
  for (let i = !1; ; ) {
    if (t.next < 0)
      return;
    if (t.next == e && !i) {
      t.advance();
      return;
    }
    i = O && !i && t.next == 92, t.advance();
  }
}
function Bx(t, e) {
  e: for (; ; ) {
    if (t.next < 0)
      return console.log("exit at end", t.pos);
    if (t.next == 36) {
      t.advance();
      for (let O = 0; O < e.length; O++) {
        if (t.next != e.charCodeAt(O))
          continue e;
        t.advance();
      }
      if (t.next == 36) {
        t.advance();
        return;
      }
    } else
      t.advance();
  }
}
function Fx(t, e) {
  let O = "[{<(".indexOf(String.fromCharCode(e)), i = O < 0 ? e : "]}>)".charCodeAt(O);
  for (; ; ) {
    if (t.next < 0)
      return;
    if (t.next == i && t.peek(1) == 39) {
      t.advance(2);
      return;
    }
    t.advance();
  }
}
function _a(t, e) {
  for (; !(t.next != 95 && !Va(t.next)); )
    e != null && (e += String.fromCharCode(t.next)), t.advance();
  return e;
}
function Hx(t) {
  if (t.next == 39 || t.next == 34 || t.next == 96) {
    let e = t.next;
    t.advance(), rt(t, e, !1);
  } else
    _a(t);
}
function Uh(t, e) {
  for (; t.next == 48 || t.next == 49; )
    t.advance();
  e && t.next == e && t.advance();
}
function Vh(t, e) {
  for (; ; ) {
    if (t.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (t.next < 48 || t.next > 57)
      break;
    t.advance();
  }
  if (t.next == 69 || t.next == 101)
    for (t.advance(), (t.next == 43 || t.next == 45) && t.advance(); t.next >= 48 && t.next <= 57; )
      t.advance();
}
function _h(t) {
  for (; !(t.next < 0 || t.next == 10); )
    t.advance();
}
function tt(t, e) {
  for (let O = 0; O < e.length; O++)
    if (e.charCodeAt(O) == t)
      return !0;
  return !1;
}
const Ts = ` 	\r
`;
function Sd(t, e, O) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = Zx, i.null = i.unknown = Yx;
  for (let r of t.split(" "))
    r && (i[r] = Pd);
  for (let r of e.split(" "))
    r && (i[r] = gd);
  for (let r of (O || "").split(" "))
    r && (i[r] = Mx);
  return i;
}
const Kx = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", Jx = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", ja = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  doubleDollarQuotedStrings: !1,
  unquotedBitLiterals: !1,
  treatBitsAsBytes: !1,
  charSetCasts: !1,
  plsqlQuotingMechanism: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  caseInsensitiveIdentifiers: !1,
  words: /* @__PURE__ */ Sd(Jx, Kx)
};
function e0(t, e, O, i) {
  let r = {};
  for (let n in ja)
    r[n] = (t.hasOwnProperty(n) ? t : ja)[n];
  return e && (r.words = Sd(e, O || "", i)), r;
}
function Xd(t) {
  return new q((e) => {
    var O;
    let { next: i } = e;
    if (e.advance(), tt(i, Ts)) {
      for (; tt(e.next, Ts); )
        e.advance();
      e.acceptToken(Rx);
    } else if (i == 36 && t.doubleDollarQuotedStrings) {
      let r = _a(e, "");
      e.next == 36 && (e.advance(), Bx(e, r), e.acceptToken(gt));
    } else if (i == 39 || i == 34 && t.doubleQuotedStrings)
      rt(e, i, t.backslashEscapes), e.acceptToken(gt);
    else if (i == 35 && t.hashComments || i == 47 && e.next == 47 && t.slashComments)
      _h(e), e.acceptToken(Yh);
    else if (i == 45 && e.next == 45 && (!t.spaceAfterDashes || e.peek(1) == 32))
      _h(e), e.acceptToken(Yh);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let r = 1; ; ) {
        let n = e.next;
        if (e.next < 0)
          break;
        if (e.advance(), n == 42 && e.next == 47) {
          if (r--, e.advance(), !r)
            break;
        } else n == 47 && e.next == 42 && (r++, e.advance());
      }
      e.acceptToken(vx);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), rt(e, 39, !0), e.acceptToken(gt);
    else if ((i == 110 || i == 78) && e.next == 39 && t.charSetCasts)
      e.advance(), rt(e, 39, t.backslashEscapes), e.acceptToken(gt);
    else if (i == 95 && t.charSetCasts)
      for (let r = 0; ; r++) {
        if (e.next == 39 && r > 1) {
          e.advance(), rt(e, 39, t.backslashEscapes), e.acceptToken(gt);
          break;
        }
        if (!Va(e.next))
          break;
        e.advance();
      }
    else if (t.plsqlQuotingMechanism && (i == 113 || i == 81) && e.next == 39 && e.peek(1) > 0 && !tt(e.peek(1), Ts)) {
      let r = e.peek(1);
      e.advance(2), Fx(e, r), e.acceptToken(gt);
    } else if (i == 40)
      e.acceptToken(zx);
    else if (i == 41)
      e.acceptToken(qx);
    else if (i == 123)
      e.acceptToken(Ux);
    else if (i == 125)
      e.acceptToken(Vx);
    else if (i == 91)
      e.acceptToken(_x);
    else if (i == 93)
      e.acceptToken(jx);
    else if (i == 59)
      e.acceptToken(Gx);
    else if (t.unquotedBitLiterals && i == 48 && e.next == 98)
      e.advance(), Uh(e), e.acceptToken(qh);
    else if ((i == 98 || i == 66) && (e.next == 39 || e.next == 34)) {
      const r = e.next;
      e.advance(), t.treatBitsAsBytes ? (rt(e, r, t.backslashEscapes), e.acceptToken(Ix)) : (Uh(e, r), e.acceptToken(qh));
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let r = e.next == 39;
      for (e.advance(); Lx(e.next); )
        e.advance();
      r && e.next == 39 && e.advance(), e.acceptToken(xs);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      Vh(e, !0), e.acceptToken(xs);
    else if (i == 46)
      e.acceptToken(Cx);
    else if (i >= 48 && i <= 57)
      Vh(e, !1), e.acceptToken(xs);
    else if (tt(i, t.operatorChars)) {
      for (; tt(e.next, t.operatorChars); )
        e.advance();
      e.acceptToken(Ex);
    } else if (tt(i, t.specialVar))
      e.next == i && e.advance(), Hx(e), e.acceptToken(Dx);
    else if (tt(i, t.identifierQuotes))
      rt(e, i, !1), e.acceptToken(Nx);
    else if (i == 58 || i == 44)
      e.acceptToken(Ax);
    else if (Va(i)) {
      let r = _a(e, String.fromCharCode(i));
      e.acceptToken(e.next == 46 || e.peek(-r.length - 1) == 46 ? zh : (O = t.words[r.toLowerCase()]) !== null && O !== void 0 ? O : zh);
    }
  });
}
const yd = /* @__PURE__ */ Xd(ja), O0 = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: "âš  LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, yd],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function Ga(t) {
  let e = t.cursor().moveTo(t.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function Ii(t, e) {
  let O = t.sliceString(e.from, e.to), i = /^([`'"])(.*)\1$/.exec(O);
  return i ? i[2] : O;
}
function kn(t) {
  return t && (t.name == "Identifier" || t.name == "QuotedIdentifier");
}
function t0(t, e) {
  if (e.name == "CompositeIdentifier") {
    let O = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      kn(i) && O.push(Ii(t, i));
    return O;
  }
  return [Ii(t, e)];
}
function jh(t, e) {
  for (let O = []; ; ) {
    if (!e || e.name != ".")
      return O;
    let i = Ga(e);
    if (!kn(i))
      return O;
    O.unshift(Ii(t, i)), e = Ga(i);
  }
}
function i0(t, e) {
  let O = I(t).resolveInner(e, -1), i = n0(t.doc, O);
  return O.name == "Identifier" || O.name == "QuotedIdentifier" || O.name == "Keyword" ? {
    from: O.from,
    quoted: O.name == "QuotedIdentifier" ? t.doc.sliceString(O.from, O.from + 1) : null,
    parents: jh(t.doc, Ga(O)),
    aliases: i
  } : O.name == "." ? { from: e, quoted: null, parents: jh(t.doc, O), aliases: i } : { from: e, quoted: null, parents: [], empty: !0, aliases: i };
}
const r0 = /* @__PURE__ */ new Set(/* @__PURE__ */ "where group having order union intersect except all distinct limit offset fetch for".split(" "));
function n0(t, e) {
  let O;
  for (let r = e; !O; r = r.parent) {
    if (!r)
      return null;
    r.name == "Statement" && (O = r);
  }
  let i = null;
  for (let r = O.firstChild, n = !1, s = null; r; r = r.nextSibling) {
    let a = r.name == "Keyword" ? t.sliceString(r.from, r.to).toLowerCase() : null, o = null;
    if (!n)
      n = a == "from";
    else if (a == "as" && s && kn(r.nextSibling))
      o = Ii(t, r.nextSibling);
    else {
      if (a && r0.has(a))
        break;
      s && kn(r) && (o = Ii(t, r));
    }
    o && (i || (i = /* @__PURE__ */ Object.create(null)), i[o] = t0(t, s)), s = /Identifier$/.test(r.name) ? r : null;
  }
  return i;
}
function s0(t, e) {
  return t ? e.map((O) => Object.assign(Object.assign({}, O), { label: O.label[0] == t ? O.label : t + O.label + t, apply: void 0 })) : e;
}
const a0 = /^\w*$/, o0 = /^[`'"]?\w*[`'"]?$/;
function Gh(t) {
  return t.self && typeof t.self.label == "string";
}
class el {
  constructor(e, O) {
    this.idQuote = e, this.idCaseInsensitive = O, this.list = [], this.children = void 0;
  }
  child(e) {
    let O = this.children || (this.children = /* @__PURE__ */ Object.create(null)), i = O[e];
    return i || (e && !this.list.some((r) => r.label == e) && this.list.push(Ch(e, "type", this.idQuote, this.idCaseInsensitive)), O[e] = new el(this.idQuote, this.idCaseInsensitive));
  }
  maybeChild(e) {
    return this.children ? this.children[e] : null;
  }
  addCompletion(e) {
    let O = this.list.findIndex((i) => i.label == e.label);
    O > -1 ? this.list[O] = e : this.list.push(e);
  }
  addCompletions(e) {
    for (let O of e)
      this.addCompletion(typeof O == "string" ? Ch(O, "property", this.idQuote, this.idCaseInsensitive) : O);
  }
  addNamespace(e) {
    Array.isArray(e) ? this.addCompletions(e) : Gh(e) ? this.addNamespace(e.children) : this.addNamespaceObject(e);
  }
  addNamespaceObject(e) {
    for (let O of Object.keys(e)) {
      let i = e[O], r = null, n = O.replace(/\\?\./g, (a) => a == "." ? "\0" : a).split("\0"), s = this;
      Gh(i) && (r = i.self, i = i.children);
      for (let a = 0; a < n.length; a++)
        r && a == n.length - 1 && s.addCompletion(r), s = s.child(n[a].replace(/\\\./g, "."));
      s.addNamespace(i);
    }
  }
}
function Ch(t, e, O, i) {
  return new RegExp("^[a-z_][a-z_\\d]*$", i ? "i" : "").test(t) ? { label: t, type: e } : { label: t, type: e, apply: O + t + O };
}
function l0(t, e, O, i, r, n) {
  var s;
  let a = ((s = n == null ? void 0 : n.spec.identifierQuotes) === null || s === void 0 ? void 0 : s[0]) || '"', o = new el(a, !!(n != null && n.spec.caseInsensitiveIdentifiers)), c = r ? o.child(r) : null;
  return o.addNamespace(t), e && (c || o).addCompletions(e), O && o.addCompletions(O), c && o.addCompletions(c.list), i && o.addCompletions((c || o).child(i).list), (h) => {
    let { parents: Q, from: f, quoted: $, empty: u, aliases: d } = i0(h.state, h.pos);
    if (u && !h.explicit)
      return null;
    d && Q.length == 1 && (Q = d[Q[0]] || Q);
    let p = o;
    for (let X of Q) {
      for (; !p.children || !p.children[X]; )
        if (p == o && c)
          p = c;
        else if (p == c && i)
          p = p.child(i);
        else
          return null;
      let y = p.maybeChild(X);
      if (!y)
        return null;
      p = y;
    }
    let m = $ && h.state.sliceDoc(h.pos, h.pos + 1) == $, P = p.list;
    return p == o && d && (P = P.concat(Object.keys(d).map((X) => ({ label: X, type: "constant" })))), {
      from: f,
      to: m ? h.pos + 1 : void 0,
      options: s0($, P),
      validFor: $ ? o0 : a0
    };
  };
}
function c0(t, e) {
  let O = Object.keys(t).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: t[i] == gd ? "type" : t[i] == Pd ? "keyword" : "variable",
    boost: -1
  }));
  return Eo(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Cn(O));
}
let h0 = /* @__PURE__ */ O0.configure({
  props: [
    /* @__PURE__ */ me.add({
      Statement: /* @__PURE__ */ ae()
    }),
    /* @__PURE__ */ fe.add({
      Statement(t, e) {
        return { from: Math.min(t.from + 100, e.doc.lineAt(t.from).to), to: t.to };
      },
      BlockComment(t) {
        return { from: t.from + 2, to: t.to - 2 };
      }
    }),
    /* @__PURE__ */ se({
      Keyword: l.keyword,
      Type: l.typeName,
      Builtin: /* @__PURE__ */ l.standard(l.name),
      Bits: l.number,
      Bytes: l.string,
      Bool: l.bool,
      Null: l.null,
      Number: l.number,
      String: l.string,
      Identifier: l.name,
      QuotedIdentifier: /* @__PURE__ */ l.special(l.string),
      SpecialVar: /* @__PURE__ */ l.special(l.name),
      LineComment: l.lineComment,
      BlockComment: l.blockComment,
      Operator: l.operator,
      "Semi Punctuation": l.punctuation,
      "( )": l.paren,
      "{ }": l.brace,
      "[ ]": l.squareBracket
    })
  ]
});
class Ol {
  constructor(e, O, i) {
    this.dialect = e, this.language = O, this.spec = i;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let O = e0(e, e.keywords, e.types, e.builtin), i = re.define({
      name: "sql",
      parser: h0.configure({
        tokenizers: [{ from: yd, to: Xd(O) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new Ol(O, i, e);
  }
}
function Q0(t, e = !1) {
  return c0(t.dialect.words, e);
}
function f0(t, e = !1) {
  return t.language.data.of({
    autocomplete: Q0(t, e)
  });
}
function $0(t) {
  return t.schema ? l0(t.schema, t.tables, t.schemas, t.defaultTable, t.defaultSchema, t.dialect || tl) : () => null;
}
function u0(t) {
  return t.schema ? (t.dialect || tl).language.data.of({
    autocomplete: $0(t)
  }) : [];
}
function d0(t = {}) {
  let e = t.dialect || tl;
  return new le(e.language, [u0(t), f0(e, !!t.upperCaseKeywords)]);
}
const tl = /* @__PURE__ */ Ol.define({});
class Wn {
  static create(e, O, i, r, n) {
    let s = r + (r << 8) + e + (O << 4) | 0;
    return new Wn(e, O, i, s, n, [], []);
  }
  constructor(e, O, i, r, n, s, a) {
    this.type = e, this.value = O, this.from = i, this.hash = r, this.end = n, this.children = s, this.positions = a, this.hashProp = [[Y.contextHash, r]];
  }
  addChild(e, O) {
    e.prop(Y.contextHash) != this.hash && (e = new M(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(O);
  }
  toTree(e, O = this.end) {
    let i = this.children.length - 1;
    return i >= 0 && (O = Math.max(O, this.positions[i] + this.children[i].length + this.from)), new M(e.types[this.type], this.children, this.positions, O - this.from).balance({
      makeTree: (r, n, s) => new M(de.none, r, n, s, this.hashProp)
    });
  }
}
var b;
(function(t) {
  t[t.Document = 1] = "Document", t[t.CodeBlock = 2] = "CodeBlock", t[t.FencedCode = 3] = "FencedCode", t[t.Blockquote = 4] = "Blockquote", t[t.HorizontalRule = 5] = "HorizontalRule", t[t.BulletList = 6] = "BulletList", t[t.OrderedList = 7] = "OrderedList", t[t.ListItem = 8] = "ListItem", t[t.ATXHeading1 = 9] = "ATXHeading1", t[t.ATXHeading2 = 10] = "ATXHeading2", t[t.ATXHeading3 = 11] = "ATXHeading3", t[t.ATXHeading4 = 12] = "ATXHeading4", t[t.ATXHeading5 = 13] = "ATXHeading5", t[t.ATXHeading6 = 14] = "ATXHeading6", t[t.SetextHeading1 = 15] = "SetextHeading1", t[t.SetextHeading2 = 16] = "SetextHeading2", t[t.HTMLBlock = 17] = "HTMLBlock", t[t.LinkReference = 18] = "LinkReference", t[t.Paragraph = 19] = "Paragraph", t[t.CommentBlock = 20] = "CommentBlock", t[t.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", t[t.Escape = 22] = "Escape", t[t.Entity = 23] = "Entity", t[t.HardBreak = 24] = "HardBreak", t[t.Emphasis = 25] = "Emphasis", t[t.StrongEmphasis = 26] = "StrongEmphasis", t[t.Link = 27] = "Link", t[t.Image = 28] = "Image", t[t.InlineCode = 29] = "InlineCode", t[t.HTMLTag = 30] = "HTMLTag", t[t.Comment = 31] = "Comment", t[t.ProcessingInstruction = 32] = "ProcessingInstruction", t[t.Autolink = 33] = "Autolink", t[t.HeaderMark = 34] = "HeaderMark", t[t.QuoteMark = 35] = "QuoteMark", t[t.ListMark = 36] = "ListMark", t[t.LinkMark = 37] = "LinkMark", t[t.EmphasisMark = 38] = "EmphasisMark", t[t.CodeMark = 39] = "CodeMark", t[t.CodeText = 40] = "CodeText", t[t.CodeInfo = 41] = "CodeInfo", t[t.LinkTitle = 42] = "LinkTitle", t[t.LinkLabel = 43] = "LinkLabel", t[t.URL = 44] = "URL";
})(b || (b = {}));
class p0 {
  /// @internal
  constructor(e, O) {
    this.start = e, this.content = O, this.marks = [], this.parsers = [];
  }
}
class m0 {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  /// @internal
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  /// @internal
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  /// Skip whitespace after the given position, return the position of
  /// the next non-space character or the end of the line if there's
  /// only space after `from`.
  skipSpace(e) {
    return mi(this.text, e);
  }
  /// @internal
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  /// Move the line's base position forward to the given position.
  /// This should only be called by composite [block
  /// parsers](#BlockParser.parse) or [markup skipping
  /// functions](#NodeSpec.composite).
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  /// Move the line's base position forward to the given _column_.
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  /// Store a composite-block-level marker. Should be called from
  /// [markup skipping functions](#NodeSpec.composite) when they
  /// consume any non-whitespace characters.
  addMarker(e) {
    this.markers.push(e);
  }
  /// Find the column position at `to`, optionally starting at a given
  /// position and column.
  countIndent(e, O = 0, i = 0) {
    for (let r = O; r < e; r++)
      i += this.text.charCodeAt(r) == 9 ? 4 - i % 4 : 1;
    return i;
  }
  /// Find the position corresponding to the given column.
  findColumn(e) {
    let O = 0;
    for (let i = 0; O < this.text.length && i < e; O++)
      i += this.text.charCodeAt(O) == 9 ? 4 - i % 4 : 1;
    return O;
  }
  /// @internal
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let O = 0; O < this.basePos; O++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function Eh(t, e, O) {
  if (O.pos == O.text.length || t != e.block && O.indent >= e.stack[O.depth + 1].value + O.baseIndent)
    return !0;
  if (O.indent >= O.baseIndent + 4)
    return !1;
  let i = (t.type == b.OrderedList ? nl : rl)(O, e, !1);
  return i > 0 && (t.type != b.BulletList || il(O, e, !1) < 0) && O.text.charCodeAt(O.pos + i - 1) == t.value;
}
const bd = {
  [b.Blockquote](t, e, O) {
    return O.next != 62 ? !1 : (O.markers.push(C(b.QuoteMark, e.lineStart + O.pos, e.lineStart + O.pos + 1)), O.moveBase(O.pos + (rO(O.text.charCodeAt(O.pos + 1)) ? 2 : 1)), t.end = e.lineStart + O.text.length, !0);
  },
  [b.ListItem](t, e, O) {
    return O.indent < O.baseIndent + t.value && O.next > -1 ? !1 : (O.moveBaseColumn(O.baseIndent + t.value), !0);
  },
  [b.OrderedList]: Eh,
  [b.BulletList]: Eh,
  [b.Document]() {
    return !0;
  }
};
function rO(t) {
  return t == 32 || t == 9 || t == 10 || t == 13;
}
function mi(t, e = 0) {
  for (; e < t.length && rO(t.charCodeAt(e)); )
    e++;
  return e;
}
function Ah(t, e, O) {
  for (; e > O && rO(t.charCodeAt(e - 1)); )
    e--;
  return e;
}
function xd(t) {
  if (t.next != 96 && t.next != 126)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; )
    e++;
  if (e < t.pos + 3)
    return -1;
  if (t.next == 96) {
    for (let O = e; O < t.text.length; O++)
      if (t.text.charCodeAt(O) == 96)
        return -1;
  }
  return e;
}
function Td(t) {
  return t.next != 62 ? -1 : t.text.charCodeAt(t.pos + 1) == 32 ? 2 : 1;
}
function il(t, e, O) {
  if (t.next != 42 && t.next != 45 && t.next != 95)
    return -1;
  let i = 1;
  for (let r = t.pos + 1; r < t.text.length; r++) {
    let n = t.text.charCodeAt(r);
    if (n == t.next)
      i++;
    else if (!rO(n))
      return -1;
  }
  return O && t.next == 45 && Wd(t) > -1 && t.depth == e.stack.length || i < 3 ? -1 : 1;
}
function wd(t, e) {
  for (let O = t.stack.length - 1; O >= 0; O--)
    if (t.stack[O].type == e)
      return !0;
  return !1;
}
function rl(t, e, O) {
  return (t.next == 45 || t.next == 43 || t.next == 42) && (t.pos == t.text.length - 1 || rO(t.text.charCodeAt(t.pos + 1))) && (!O || wd(e, b.BulletList) || t.skipSpace(t.pos + 2) < t.text.length) ? 1 : -1;
}
function nl(t, e, O) {
  let i = t.pos, r = t.next;
  for (; r >= 48 && r <= 57; ) {
    i++;
    if (i == t.text.length)
      return -1;
    r = t.text.charCodeAt(i);
  }
  return i == t.pos || i > t.pos + 9 || r != 46 && r != 41 || i < t.text.length - 1 && !rO(t.text.charCodeAt(i + 1)) || O && !wd(e, b.OrderedList) && (t.skipSpace(i + 1) == t.text.length || i > t.pos + 1 || t.next != 49) ? -1 : i + 1 - t.pos;
}
function kd(t) {
  if (t.next != 35)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == 35; )
    e++;
  if (e < t.text.length && t.text.charCodeAt(e) != 32)
    return -1;
  let O = e - t.pos;
  return O > 6 ? -1 : O;
}
function Wd(t) {
  if (t.next != 45 && t.next != 61 || t.indent >= t.baseIndent + 4)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; )
    e++;
  let O = e;
  for (; e < t.text.length && rO(t.text.charCodeAt(e)); )
    e++;
  return e == t.text.length ? O : -1;
}
const Ca = /^[ \t]*$/, Rd = /-->/, vd = /\?>/, Ea = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, Rd],
  [/^\s*<\?/, vd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Ca],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Ca]
];
function Zd(t, e, O) {
  if (t.next != 60)
    return -1;
  let i = t.text.slice(t.pos);
  for (let r = 0, n = Ea.length - (O ? 1 : 0); r < n; r++)
    if (Ea[r][0].test(i))
      return r;
  return -1;
}
function Dh(t, e) {
  let O = t.countIndent(e, t.pos, t.indent), i = t.countIndent(t.skipSpace(e), e, O);
  return i >= O + 5 ? O + 1 : i;
}
function it(t, e, O) {
  let i = t.length - 1;
  i >= 0 && t[i].to == e && t[i].type == b.CodeText ? t[i].to = O : t.push(C(b.CodeText, e, O));
}
const Yr = {
  LinkReference: void 0,
  IndentedCode(t, e) {
    let O = e.baseIndent + 4;
    if (e.indent < O)
      return !1;
    let i = e.findColumn(O), r = t.lineStart + i, n = t.lineStart + e.text.length, s = [], a = [];
    for (it(s, r, n); t.nextLine() && e.depth >= t.stack.length; )
      if (e.pos == e.text.length) {
        it(a, t.lineStart - 1, t.lineStart);
        for (let o of e.markers)
          a.push(o);
      } else {
        if (e.indent < O)
          break;
        {
          if (a.length) {
            for (let c of a)
              c.type == b.CodeText ? it(s, c.from, c.to) : s.push(c);
            a = [];
          }
          it(s, t.lineStart - 1, t.lineStart);
          for (let c of e.markers)
            s.push(c);
          n = t.lineStart + e.text.length;
          let o = t.lineStart + e.findColumn(e.baseIndent + 4);
          o < n && it(s, o, n);
        }
      }
    return a.length && (a = a.filter((o) => o.type != b.CodeText), a.length && (e.markers = a.concat(e.markers))), t.addNode(t.buffer.writeElements(s, -r).finish(b.CodeBlock, n - r), r), !0;
  },
  FencedCode(t, e) {
    let O = xd(e);
    if (O < 0)
      return !1;
    let i = t.lineStart + e.pos, r = e.next, n = O - e.pos, s = e.skipSpace(O), a = Ah(e.text, e.text.length, s), o = [C(b.CodeMark, i, i + n)];
    s < a && o.push(C(b.CodeInfo, t.lineStart + s, t.lineStart + a));
    for (let c = !0; t.nextLine() && e.depth >= t.stack.length; c = !1) {
      let h = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; h < e.text.length && e.text.charCodeAt(h) == r; )
          h++;
      if (h - e.pos >= n && e.skipSpace(h) == e.text.length) {
        for (let Q of e.markers)
          o.push(Q);
        o.push(C(b.CodeMark, t.lineStart + e.pos, t.lineStart + h)), t.nextLine();
        break;
      } else {
        c || it(o, t.lineStart - 1, t.lineStart);
        for (let $ of e.markers)
          o.push($);
        let Q = t.lineStart + e.basePos, f = t.lineStart + e.text.length;
        Q < f && it(o, Q, f);
      }
    }
    return t.addNode(t.buffer.writeElements(o, -i).finish(b.FencedCode, t.prevLineEnd() - i), i), !0;
  },
  Blockquote(t, e) {
    let O = Td(e);
    return O < 0 ? !1 : (t.startContext(b.Blockquote, e.pos), t.addNode(b.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1), e.moveBase(e.pos + O), null);
  },
  HorizontalRule(t, e) {
    if (il(e, t, !1) < 0)
      return !1;
    let O = t.lineStart + e.pos;
    return t.nextLine(), t.addNode(b.HorizontalRule, O), !0;
  },
  BulletList(t, e) {
    let O = rl(e, t, !1);
    if (O < 0)
      return !1;
    t.block.type != b.BulletList && t.startContext(b.BulletList, e.basePos, e.next);
    let i = Dh(e, e.pos + 1);
    return t.startContext(b.ListItem, e.basePos, i - e.baseIndent), t.addNode(b.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + O), e.moveBaseColumn(i), null;
  },
  OrderedList(t, e) {
    let O = nl(e, t, !1);
    if (O < 0)
      return !1;
    t.block.type != b.OrderedList && t.startContext(b.OrderedList, e.basePos, e.text.charCodeAt(e.pos + O - 1));
    let i = Dh(e, e.pos + O);
    return t.startContext(b.ListItem, e.basePos, i - e.baseIndent), t.addNode(b.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + O), e.moveBaseColumn(i), null;
  },
  ATXHeading(t, e) {
    let O = kd(e);
    if (O < 0)
      return !1;
    let i = e.pos, r = t.lineStart + i, n = Ah(e.text, e.text.length, i), s = n;
    for (; s > i && e.text.charCodeAt(s - 1) == e.next; )
      s--;
    (s == n || s == i || !rO(e.text.charCodeAt(s - 1))) && (s = e.text.length);
    let a = t.buffer.write(b.HeaderMark, 0, O).writeElements(t.parser.parseInline(e.text.slice(i + O + 1, s), r + O + 1), -r);
    s < e.text.length && a.write(b.HeaderMark, s - i, n - i);
    let o = a.finish(b.ATXHeading1 - 1 + O, e.text.length - i);
    return t.nextLine(), t.addNode(o, r), !0;
  },
  HTMLBlock(t, e) {
    let O = Zd(e, t, !1);
    if (O < 0)
      return !1;
    let i = t.lineStart + e.pos, r = Ea[O][1], n = [], s = r != Ca;
    for (; !r.test(e.text) && t.nextLine(); ) {
      if (e.depth < t.stack.length) {
        s = !1;
        break;
      }
      for (let c of e.markers)
        n.push(c);
    }
    s && t.nextLine();
    let a = r == Rd ? b.CommentBlock : r == vd ? b.ProcessingInstructionBlock : b.HTMLBlock, o = t.prevLineEnd();
    return t.addNode(t.buffer.writeElements(n, -i).finish(a, o - i), i), !0;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
class P0 {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, O, i) {
    if (this.stage == -1)
      return !1;
    let r = i.content + `
` + O.scrub(), n = this.advance(r);
    return n > -1 && n < r.length ? this.complete(e, i, n) : !1;
  }
  finish(e, O) {
    return (this.stage == 2 || this.stage == 3) && mi(O.content, this.pos) == O.content.length ? this.complete(e, O, O.content.length) : !1;
  }
  complete(e, O, i) {
    return e.addLeafElement(O, C(b.LinkReference, this.start, this.start + i, this.elts)), !0;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(Cd(e, this.pos, this.start, !0)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(C(b.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(jd(e, mi(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let O = mi(e, this.pos), i = 0;
        if (O > this.pos) {
          let r = Gd(e, O, this.start);
          if (r) {
            let n = ws(e, r.to - this.start);
            n > 0 && (this.nextStage(r), i = n);
          }
        }
        return i || (i = ws(e, this.pos)), i > 0 && i < e.length ? i : -1;
      } else
        return ws(e, this.pos);
    }
  }
}
function ws(t, e) {
  for (; e < t.length; e++) {
    let O = t.charCodeAt(e);
    if (O == 10)
      break;
    if (!rO(O))
      return -1;
  }
  return e;
}
class g0 {
  nextLine(e, O, i) {
    let r = O.depth < e.stack.length ? -1 : Wd(O), n = O.next;
    if (r < 0)
      return !1;
    let s = C(b.HeaderMark, e.lineStart + O.pos, e.lineStart + r);
    return e.nextLine(), e.addLeafElement(i, C(n == 61 ? b.SetextHeading1 : b.SetextHeading2, i.start, e.prevLineEnd(), [
      ...e.parser.parseInline(i.content, i.start),
      s
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const S0 = {
  LinkReference(t, e) {
    return e.content.charCodeAt(0) == 91 ? new P0(e) : null;
  },
  SetextHeading() {
    return new g0();
  }
}, X0 = [
  (t, e) => kd(e) >= 0,
  (t, e) => xd(e) >= 0,
  (t, e) => Td(e) >= 0,
  (t, e) => rl(e, t, !0) >= 0,
  (t, e) => nl(e, t, !0) >= 0,
  (t, e) => il(e, t, !0) >= 0,
  (t, e) => Zd(e, t, !0) >= 0
], y0 = { text: "", end: 0 };
class b0 {
  /// @internal
  constructor(e, O, i, r) {
    this.parser = e, this.input = O, this.ranges = r, this.line = new m0(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = r[r.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = r[0].from, this.block = Wn.create(b.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = i.length ? new k0(i, O) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (let i = 0; ; ) {
        let r = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; i < e.markers.length && (!r || e.markers[i].from < r.end); ) {
          let n = e.markers[i++];
          this.addNode(n.type, n.from, n.to);
        }
        if (!r)
          break;
        this.finishContext();
      }
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e: for (; ; ) {
      for (let i of this.parser.blockParsers)
        if (i) {
          let r = i(this, e);
          if (r != !1) {
            if (r == !0)
              return null;
            e.forward();
            continue e;
          }
        }
      break;
    }
    let O = new p0(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let i of this.parser.leafBlockParsers)
      if (i) {
        let r = i(this, O);
        r && O.parsers.push(r);
      }
    e: for (; this.nextLine() && e.pos != e.text.length; ) {
      if (e.indent < e.baseIndent + 4) {
        for (let i of this.parser.endLeafBlock)
          if (i(this, e, O))
            break e;
      }
      for (let i of O.parsers)
        if (i.nextLine(this, e, O))
          return null;
      O.content += `
` + e.scrub();
      for (let i of e.markers)
        O.marks.push(i);
    }
    return this.finishLeaf(O), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let O = this.fragments.takeNodes(this);
    return O ? (this.absoluteLineStart += O, this.lineStart = Ed(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  /// The number of parent blocks surrounding the current block.
  get depth() {
    return this.stack.length;
  }
  /// Get the type of the parent block at the given depth. When no
  /// depth is passed, return the type of the innermost parent.
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  /// Move to the next input line. This should only be called by
  /// (non-composite) [block parsers](#BlockParser.parse) that consume
  /// the line directly, or leaf block parser
  /// [`nextLine`](#LeafBlockParser.nextLine) methods when they
  /// consume the current line (and return true).
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  /// @internal
  scanLine(e) {
    let O = y0;
    if (O.end = e, e >= this.to)
      O.text = "";
    else if (O.text = this.lineChunkAt(e), O.end += O.text.length, this.ranges.length > 1) {
      let i = this.absoluteLineStart, r = this.rangeI;
      for (; this.ranges[r].to < O.end; ) {
        r++;
        let n = this.ranges[r].from, s = this.lineChunkAt(n);
        O.end = n + s.length, O.text = O.text.slice(0, this.ranges[r - 1].to - i) + s, i = O.end - O.text.length;
      }
    }
    return O;
  }
  /// @internal
  readLine() {
    let { line: e } = this, { text: O, end: i } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = i, e.reset(O); e.depth < this.stack.length; e.depth++) {
      let r = this.stack[e.depth], n = this.parser.skipContextMarkup[r.type];
      if (!n)
        throw new Error("Unhandled block context " + b[r.type]);
      if (!n(r, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let O = this.input.chunk(e), i;
    if (this.input.lineChunks)
      i = O == `
` ? "" : O;
    else {
      let r = O.indexOf(`
`);
      i = r < 0 ? O : O.slice(0, r);
    }
    return e + i.length > this.to ? i.slice(0, this.to - e) : i;
  }
  /// The end position of the previous line.
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /// @internal
  startContext(e, O, i = 0) {
    this.block = Wn.create(e, i, this.lineStart + O, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  /// Start a composite block. Should only be called from [block
  /// parser functions](#BlockParser.parse) that return null.
  startComposite(e, O, i = 0) {
    this.startContext(this.parser.getNodeType(e), O, i);
  }
  /// @internal
  addNode(e, O, i) {
    typeof e == "number" && (e = new M(this.parser.nodeSet.types[e], Nt, Nt, (i ?? this.prevLineEnd()) - O)), this.block.addChild(e, O - this.block.from);
  }
  /// Add a block element. Can be called by [block
  /// parsers](#BlockParser.parse).
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  /// Add a block element from a [leaf parser](#LeafBlockParser). This
  /// makes sure any extra composite block markup (such as blockquote
  /// markers) inside the block are also added to the syntax tree.
  addLeafElement(e, O) {
    this.addNode(this.buffer.writeElements(Na(O.children, e.marks), -O.from).finish(O.type, O.to - O.from), O.from);
  }
  /// @internal
  finishContext() {
    let e = this.stack.pop(), O = this.stack[this.stack.length - 1];
    O.addChild(e.toTree(this.parser.nodeSet), e.from - O.from), this.block = O;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? Yd(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  /// @internal
  finishLeaf(e) {
    for (let i of e.parsers)
      if (i.finish(this, e))
        return;
    let O = Na(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(O, -e.start).finish(b.Paragraph, e.content.length), e.start);
  }
  elt(e, O, i, r) {
    return typeof e == "string" ? C(this.parser.getNodeType(e), O, i, r) : new Ud(e, O);
  }
  /// @internal
  get buffer() {
    return new qd(this.parser.nodeSet);
  }
}
function Yd(t, e, O, i, r) {
  let n = t[e].to, s = [], a = [], o = O.from + i;
  function c(h, Q) {
    for (; Q ? h >= n : h > n; ) {
      let f = t[e + 1].from - n;
      i += f, h += f, e++, n = t[e].to;
    }
  }
  for (let h = O.firstChild; h; h = h.nextSibling) {
    c(h.from + i, !0);
    let Q = h.from + i, f, $ = r.get(h.tree);
    $ ? f = $ : h.to + i > n ? (f = Yd(t, e, h, i, r), c(h.to + i, !1)) : f = h.toTree(), s.push(f), a.push(Q - o);
  }
  return c(O.to + i, !1), new M(O.type, s, a, O.to + i - o, O.tree ? O.tree.propValues : void 0);
}
class An extends fo {
  /// @internal
  constructor(e, O, i, r, n, s, a, o, c) {
    super(), this.nodeSet = e, this.blockParsers = O, this.leafBlockParsers = i, this.blockNames = r, this.endLeafBlock = n, this.skipContextMarkup = s, this.inlineParsers = a, this.inlineNames = o, this.wrappers = c, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let h of e.types)
      this.nodeTypes[h.name] = h.id;
  }
  createParse(e, O, i) {
    let r = new b0(this, e, O, i);
    for (let n of this.wrappers)
      r = n(r, e, O, i);
    return r;
  }
  /// Reconfigure the parser.
  configure(e) {
    let O = Aa(e);
    if (!O)
      return this;
    let { nodeSet: i, skipContextMarkup: r } = this, n = this.blockParsers.slice(), s = this.leafBlockParsers.slice(), a = this.blockNames.slice(), o = this.inlineParsers.slice(), c = this.inlineNames.slice(), h = this.endLeafBlock.slice(), Q = this.wrappers;
    if (si(O.defineNodes)) {
      r = Object.assign({}, r);
      let f = i.types.slice(), $;
      for (let u of O.defineNodes) {
        let { name: d, block: p, composite: m, style: P } = typeof u == "string" ? { name: u } : u;
        if (f.some((S) => S.name == d))
          continue;
        m && (r[f.length] = (S, w, T) => m(w, T, S.value));
        let X = f.length, y = m ? ["Block", "BlockContext"] : p ? X >= b.ATXHeading1 && X <= b.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        f.push(de.define({
          id: X,
          name: d,
          props: y && [[Y.group, y]]
        })), P && ($ || ($ = {}), Array.isArray(P) || P instanceof bO ? $[d] = P : Object.assign($, P));
      }
      i = new Hi(f), $ && (i = i.extend(se($)));
    }
    if (si(O.props) && (i = i.extend(...O.props)), si(O.remove))
      for (let f of O.remove) {
        let $ = this.blockNames.indexOf(f), u = this.inlineNames.indexOf(f);
        $ > -1 && (n[$] = s[$] = void 0), u > -1 && (o[u] = void 0);
      }
    if (si(O.parseBlock))
      for (let f of O.parseBlock) {
        let $ = a.indexOf(f.name);
        if ($ > -1)
          n[$] = f.parse, s[$] = f.leaf;
        else {
          let u = f.before ? zr(a, f.before) : f.after ? zr(a, f.after) + 1 : a.length - 1;
          n.splice(u, 0, f.parse), s.splice(u, 0, f.leaf), a.splice(u, 0, f.name);
        }
        f.endLeaf && h.push(f.endLeaf);
      }
    if (si(O.parseInline))
      for (let f of O.parseInline) {
        let $ = c.indexOf(f.name);
        if ($ > -1)
          o[$] = f.parse;
        else {
          let u = f.before ? zr(c, f.before) : f.after ? zr(c, f.after) + 1 : c.length - 1;
          o.splice(u, 0, f.parse), c.splice(u, 0, f.name);
        }
      }
    return O.wrap && (Q = Q.concat(O.wrap)), new An(i, n, s, a, h, r, o, c, Q);
  }
  /// @internal
  getNodeType(e) {
    let O = this.nodeTypes[e];
    if (O == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return O;
  }
  /// Parse the given piece of inline text at the given offset,
  /// returning an array of [`Element`](#Element) objects representing
  /// the inline content.
  parseInline(e, O) {
    let i = new T0(this, e, O);
    e: for (let r = O; r < i.end; ) {
      let n = i.char(r);
      for (let s of this.inlineParsers)
        if (s) {
          let a = s(i, n, r);
          if (a >= 0) {
            r = a;
            continue e;
          }
        }
      r++;
    }
    return i.resolveMarkers(0);
  }
}
function si(t) {
  return t != null && t.length > 0;
}
function Aa(t) {
  if (!Array.isArray(t))
    return t;
  if (t.length == 0)
    return null;
  let e = Aa(t[0]);
  if (t.length == 1)
    return e;
  let O = Aa(t.slice(1));
  if (!O || !e)
    return e || O;
  let i = (s, a) => (s || Nt).concat(a || Nt), r = e.wrap, n = O.wrap;
  return {
    props: i(e.props, O.props),
    defineNodes: i(e.defineNodes, O.defineNodes),
    parseBlock: i(e.parseBlock, O.parseBlock),
    parseInline: i(e.parseInline, O.parseInline),
    remove: i(e.remove, O.remove),
    wrap: r ? n ? (s, a, o, c) => r(n(s, a, o, c), a, o, c) : r : n
  };
}
function zr(t, e) {
  let O = t.indexOf(e);
  if (O < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return O;
}
let zd = [de.none];
for (let t = 1, e; e = b[t]; t++)
  zd[t] = de.define({
    id: t,
    name: e,
    props: t >= b.Escape ? [] : [[Y.group, t in bd ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document"
  });
const Nt = [];
class qd {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, O, i, r = 0) {
    return this.content.push(e, O, i, 4 + r * 4), this;
  }
  writeElements(e, O = 0) {
    for (let i of e)
      i.writeTo(this, O);
    return this;
  }
  finish(e, O) {
    return M.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: O
    });
  }
}
let Mi = class {
  /// @internal
  constructor(e, O, i, r = Nt) {
    this.type = e, this.from = O, this.to = i, this.children = r;
  }
  /// @internal
  writeTo(e, O) {
    let i = e.content.length;
    e.writeElements(this.children, O), e.content.push(this.type, this.from + O, this.to + O, e.content.length + 4 - i);
  }
  /// @internal
  toTree(e) {
    return new qd(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
class Ud {
  constructor(e, O) {
    this.tree = e, this.from = O;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Nt;
  }
  writeTo(e, O) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + O, this.to + O, -1);
  }
  toTree() {
    return this.tree;
  }
}
function C(t, e, O, i) {
  return new Mi(t, e, O, i);
}
const Vd = { resolve: "Emphasis", mark: "EmphasisMark" }, _d = { resolve: "Emphasis", mark: "EmphasisMark" }, bt = {}, Da = {};
class Be {
  constructor(e, O, i, r) {
    this.type = e, this.from = O, this.to = i, this.side = r;
  }
}
const Nh = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Li = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Li = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {
}
const ks = {
  Escape(t, e, O) {
    if (e != 92 || O == t.end - 1)
      return -1;
    let i = t.char(O + 1);
    for (let r = 0; r < Nh.length; r++)
      if (Nh.charCodeAt(r) == i)
        return t.append(C(b.Escape, O, O + 2));
    return -1;
  },
  Entity(t, e, O) {
    if (e != 38)
      return -1;
    let i = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(t.slice(O + 1, O + 31));
    return i ? t.append(C(b.Entity, O, O + 1 + i[0].length)) : -1;
  },
  InlineCode(t, e, O) {
    if (e != 96 || O && t.char(O - 1) == 96)
      return -1;
    let i = O + 1;
    for (; i < t.end && t.char(i) == 96; )
      i++;
    let r = i - O, n = 0;
    for (; i < t.end; i++)
      if (t.char(i) == 96) {
        if (n++, n == r && t.char(i + 1) != 96)
          return t.append(C(b.InlineCode, O, i + 1, [
            C(b.CodeMark, O, O + r),
            C(b.CodeMark, i + 1 - r, i + 1)
          ]));
      } else
        n = 0;
    return -1;
  },
  HTMLTag(t, e, O) {
    if (e != 60 || O == t.end - 1)
      return -1;
    let i = t.slice(O + 1, t.end), r = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(i);
    if (r)
      return t.append(C(b.Autolink, O, O + 1 + r[0].length, [
        C(b.LinkMark, O, O + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        C(b.URL, O + 1, O + r[0].length),
        C(b.LinkMark, O + r[0].length, O + 1 + r[0].length)
      ]));
    let n = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(i);
    if (n)
      return t.append(C(b.Comment, O, O + 1 + n[0].length));
    let s = /^\?[^]*?\?>/.exec(i);
    if (s)
      return t.append(C(b.ProcessingInstruction, O, O + 1 + s[0].length));
    let a = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(i);
    return a ? t.append(C(b.HTMLTag, O, O + 1 + a[0].length)) : -1;
  },
  Emphasis(t, e, O) {
    if (e != 95 && e != 42)
      return -1;
    let i = O + 1;
    for (; t.char(i) == e; )
      i++;
    let r = t.slice(O - 1, O), n = t.slice(i, i + 1), s = Li.test(r), a = Li.test(n), o = /\s|^$/.test(r), c = /\s|^$/.test(n), h = !c && (!a || o || s), Q = !o && (!s || c || a), f = h && (e == 42 || !Q || s), $ = Q && (e == 42 || !h || a);
    return t.append(new Be(e == 95 ? Vd : _d, O, i, (f ? 1 : 0) | ($ ? 2 : 0)));
  },
  HardBreak(t, e, O) {
    if (e == 92 && t.char(O + 1) == 10)
      return t.append(C(b.HardBreak, O, O + 2));
    if (e == 32) {
      let i = O + 1;
      for (; t.char(i) == 32; )
        i++;
      if (t.char(i) == 10 && i >= O + 2)
        return t.append(C(b.HardBreak, O, i + 1));
    }
    return -1;
  },
  Link(t, e, O) {
    return e == 91 ? t.append(new Be(
      bt,
      O,
      O + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(t, e, O) {
    return e == 33 && t.char(O + 1) == 91 ? t.append(new Be(
      Da,
      O,
      O + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(t, e, O) {
    if (e != 93)
      return -1;
    for (let i = t.parts.length - 1; i >= 0; i--) {
      let r = t.parts[i];
      if (r instanceof Be && (r.type == bt || r.type == Da)) {
        if (!r.side || t.skipSpace(r.to) == O && !/[(\[]/.test(t.slice(O + 1, O + 2)))
          return t.parts[i] = null, -1;
        let n = t.takeContent(i), s = t.parts[i] = x0(t, n, r.type == bt ? b.Link : b.Image, r.from, O + 1);
        if (r.type == bt)
          for (let a = 0; a < i; a++) {
            let o = t.parts[a];
            o instanceof Be && o.type == bt && (o.side = 0);
          }
        return s.to;
      }
    }
    return -1;
  }
};
function x0(t, e, O, i, r) {
  let { text: n } = t, s = t.char(r), a = r;
  if (e.unshift(C(b.LinkMark, i, i + (O == b.Image ? 2 : 1))), e.push(C(b.LinkMark, r - 1, r)), s == 40) {
    let o = t.skipSpace(r + 1), c = jd(n, o - t.offset, t.offset), h;
    c && (o = t.skipSpace(c.to), o != c.to && (h = Gd(n, o - t.offset, t.offset), h && (o = t.skipSpace(h.to)))), t.char(o) == 41 && (e.push(C(b.LinkMark, r, r + 1)), a = o + 1, c && e.push(c), h && e.push(h), e.push(C(b.LinkMark, o, a)));
  } else if (s == 91) {
    let o = Cd(n, r - t.offset, t.offset, !1);
    o && (e.push(o), a = o.to);
  }
  return C(O, i, a, e);
}
function jd(t, e, O) {
  if (t.charCodeAt(e) == 60) {
    for (let r = e + 1; r < t.length; r++) {
      let n = t.charCodeAt(r);
      if (n == 62)
        return C(b.URL, e + O, r + 1 + O);
      if (n == 60 || n == 10)
        return !1;
    }
    return null;
  } else {
    let r = 0, n = e;
    for (let s = !1; n < t.length; n++) {
      let a = t.charCodeAt(n);
      if (rO(a))
        break;
      if (s)
        s = !1;
      else if (a == 40)
        r++;
      else if (a == 41) {
        if (!r)
          break;
        r--;
      } else a == 92 && (s = !0);
    }
    return n > e ? C(b.URL, e + O, n + O) : n == t.length ? null : !1;
  }
}
function Gd(t, e, O) {
  let i = t.charCodeAt(e);
  if (i != 39 && i != 34 && i != 40)
    return !1;
  let r = i == 40 ? 41 : i;
  for (let n = e + 1, s = !1; n < t.length; n++) {
    let a = t.charCodeAt(n);
    if (s)
      s = !1;
    else {
      if (a == r)
        return C(b.LinkTitle, e + O, n + 1 + O);
      a == 92 && (s = !0);
    }
  }
  return null;
}
function Cd(t, e, O, i) {
  for (let r = !1, n = e + 1, s = Math.min(t.length, n + 999); n < s; n++) {
    let a = t.charCodeAt(n);
    if (r)
      r = !1;
    else {
      if (a == 93)
        return i ? !1 : C(b.LinkLabel, e + O, n + 1 + O);
      if (i && !rO(a) && (i = !1), a == 91)
        return !1;
      a == 92 && (r = !0);
    }
  }
  return null;
}
class T0 {
  /// @internal
  constructor(e, O, i) {
    this.parser = e, this.text = O, this.offset = i, this.parts = [];
  }
  /// Get the character code at the given (document-relative)
  /// position.
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  /// The position of the end of this inline section.
  get end() {
    return this.offset + this.text.length;
  }
  /// Get a substring of this inline section. Again uses
  /// document-relative positions.
  slice(e, O) {
    return this.text.slice(e - this.offset, O - this.offset);
  }
  /// @internal
  append(e) {
    return this.parts.push(e), e.to;
  }
  /// Add a [delimiter](#DelimiterType) at this given position. `open`
  /// and `close` indicate whether this delimiter is opening, closing,
  /// or both. Returns the end of the delimiter, for convenient
  /// returning from [parse functions](#InlineParser.parse).
  addDelimiter(e, O, i, r, n) {
    return this.append(new Be(e, O, i, (r ? 1 : 0) | (n ? 2 : 0)));
  }
  /// Returns true when there is an unmatched link or image opening
  /// token before the current position.
  get hasOpenLink() {
    for (let e = this.parts.length - 1; e >= 0; e--) {
      let O = this.parts[e];
      if (O instanceof Be && (O.type == bt || O.type == Da))
        return !0;
    }
    return !1;
  }
  /// Add an inline element. Returns the end of the element.
  addElement(e) {
    return this.append(e);
  }
  /// Resolve markers between this.parts.length and from, wrapping matched markers in the
  /// appropriate node and updating the content of this.parts. @internal
  resolveMarkers(e) {
    for (let i = e; i < this.parts.length; i++) {
      let r = this.parts[i];
      if (!(r instanceof Be && r.type.resolve && r.side & 2))
        continue;
      let n = r.type == Vd || r.type == _d, s = r.to - r.from, a, o = i - 1;
      for (; o >= e; o--) {
        let d = this.parts[o];
        if (d instanceof Be && d.side & 1 && d.type == r.type && // Ignore emphasis delimiters where the character count doesn't match
        !(n && (r.side & 1 || d.side & 2) && (d.to - d.from + s) % 3 == 0 && ((d.to - d.from) % 3 || s % 3))) {
          a = d;
          break;
        }
      }
      if (!a)
        continue;
      let c = r.type.resolve, h = [], Q = a.from, f = r.to;
      if (n) {
        let d = Math.min(2, a.to - a.from, s);
        Q = a.to - d, f = r.from + d, c = d == 1 ? "Emphasis" : "StrongEmphasis";
      }
      a.type.mark && h.push(this.elt(a.type.mark, Q, a.to));
      for (let d = o + 1; d < i; d++)
        this.parts[d] instanceof Mi && h.push(this.parts[d]), this.parts[d] = null;
      r.type.mark && h.push(this.elt(r.type.mark, r.from, f));
      let $ = this.elt(c, Q, f, h);
      this.parts[o] = n && a.from != Q ? new Be(a.type, a.from, Q, a.side) : null, (this.parts[i] = n && r.to != f ? new Be(r.type, f, r.to, r.side) : null) ? this.parts.splice(i, 0, $) : this.parts[i] = $;
    }
    let O = [];
    for (let i = e; i < this.parts.length; i++) {
      let r = this.parts[i];
      r instanceof Mi && O.push(r);
    }
    return O;
  }
  /// Find an opening delimiter of the given type. Returns `null` if
  /// no delimiter is found, or an index that can be passed to
  /// [`takeContent`](#InlineContext.takeContent) otherwise.
  findOpeningDelimiter(e) {
    for (let O = this.parts.length - 1; O >= 0; O--) {
      let i = this.parts[O];
      if (i instanceof Be && i.type == e)
        return O;
    }
    return null;
  }
  /// Remove all inline elements and delimiters starting from the
  /// given index (which you should get from
  /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  /// resolve delimiters inside of them, and return them as an array
  /// of elements.
  takeContent(e) {
    let O = this.resolveMarkers(e);
    return this.parts.length = e, O;
  }
  /// Skip space after the given (document) position, returning either
  /// the position of the next non-space character or the end of the
  /// section.
  skipSpace(e) {
    return mi(this.text, e - this.offset) + this.offset;
  }
  elt(e, O, i, r) {
    return typeof e == "string" ? C(this.parser.getNodeType(e), O, i, r) : new Ud(e, O);
  }
}
function Na(t, e) {
  if (!e.length)
    return t;
  if (!t.length)
    return e;
  let O = t.slice(), i = 0;
  for (let r of e) {
    for (; i < O.length && O[i].to < r.to; )
      i++;
    if (i < O.length && O[i].from < r.from) {
      let n = O[i];
      n instanceof Mi && (O[i] = new Mi(n.type, n.from, n.to, Na(n.children, [r])));
    } else
      O.splice(i++, 0, r);
  }
  return O;
}
const w0 = [b.CodeBlock, b.ListItem, b.OrderedList, b.BulletList];
class k0 {
  constructor(e, O) {
    this.fragments = e, this.input = O, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, O) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let n = this.fragment.to;
      for (; n > 0 && this.input.read(n - 1, n) != `
`; )
        n--;
      this.fragmentEnd = n ? n - 1 : 0;
    }
    let i = this.cursor;
    i || (i = this.cursor = this.fragment.tree.cursor(), i.firstChild());
    let r = e + this.fragment.offset;
    for (; i.to <= r; )
      if (!i.parent())
        return !1;
    for (; ; ) {
      if (i.from >= r)
        return this.fragment.from <= O;
      if (!i.childAfter(r))
        return !1;
    }
  }
  matches(e) {
    let O = this.cursor.tree;
    return O && O.prop(Y.contextHash) == e;
  }
  takeNodes(e) {
    let O = this.cursor, i = this.fragment.offset, r = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), n = e.absoluteLineStart, s = n, a = e.block.children.length, o = s, c = a;
    for (; ; ) {
      if (O.to - i > r) {
        if (O.type.isAnonymous && O.firstChild())
          continue;
        break;
      }
      let h = Ed(O.from - i, e.ranges);
      if (O.to - i <= e.ranges[e.rangeI].to)
        e.addNode(O.tree, h);
      else {
        let Q = new M(e.parser.nodeSet.types[b.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(Q, O.tree), e.addNode(Q, h);
      }
      if (O.type.is("Block") && (w0.indexOf(O.type.id) < 0 ? (s = O.to - i, a = e.block.children.length) : (s = o, a = c, o = O.to - i, c = e.block.children.length)), !O.nextSibling())
        break;
    }
    for (; e.block.children.length > a; )
      e.block.children.pop(), e.block.positions.pop();
    return s - n;
  }
}
function Ed(t, e) {
  let O = t;
  for (let i = 1; i < e.length; i++) {
    let r = e[i - 1].to, n = e[i].from;
    r < t && (O -= n - r);
  }
  return O;
}
const W0 = se({
  "Blockquote/...": l.quote,
  HorizontalRule: l.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": l.heading1,
  "ATXHeading2/... SetextHeading2/...": l.heading2,
  "ATXHeading3/...": l.heading3,
  "ATXHeading4/...": l.heading4,
  "ATXHeading5/...": l.heading5,
  "ATXHeading6/...": l.heading6,
  "Comment CommentBlock": l.comment,
  Escape: l.escape,
  Entity: l.character,
  "Emphasis/...": l.emphasis,
  "StrongEmphasis/...": l.strong,
  "Link/... Image/...": l.link,
  "OrderedList/... BulletList/...": l.list,
  "BlockQuote/...": l.quote,
  "InlineCode CodeText": l.monospace,
  "URL Autolink": l.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": l.processingInstruction,
  "CodeInfo LinkLabel": l.labelName,
  LinkTitle: l.string,
  Paragraph: l.content
}), R0 = new An(new Hi(zd).extend(W0), Object.keys(Yr).map((t) => Yr[t]), Object.keys(Yr).map((t) => S0[t]), Object.keys(Yr), X0, bd, Object.keys(ks).map((t) => ks[t]), Object.keys(ks), []);
function v0(t, e, O) {
  let i = [];
  for (let r = t.firstChild, n = e; ; r = r.nextSibling) {
    let s = r ? r.from : O;
    if (s > n && i.push({ from: n, to: s }), !r)
      break;
    n = r.to;
  }
  return i;
}
function Z0(t) {
  let { codeParser: e, htmlParser: O } = t;
  return { wrap: SO((r, n) => {
    let s = r.type.id;
    if (e && (s == b.CodeBlock || s == b.FencedCode)) {
      let a = "";
      if (s == b.FencedCode) {
        let c = r.node.getChild(b.CodeInfo);
        c && (a = n.read(c.from, c.to));
      }
      let o = e(a);
      if (o)
        return { parser: o, overlay: (c) => c.type.id == b.CodeText };
    } else if (O && (s == b.HTMLBlock || s == b.HTMLTag))
      return { parser: O, overlay: v0(r.node, r.from, r.to) };
    return null;
  }) };
}
const Y0 = { resolve: "Strikethrough", mark: "StrikethroughMark" }, z0 = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": l.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: l.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(t, e, O) {
      if (e != 126 || t.char(O + 1) != 126 || t.char(O + 2) == 126)
        return -1;
      let i = t.slice(O - 1, O), r = t.slice(O + 2, O + 3), n = /\s|^$/.test(i), s = /\s|^$/.test(r), a = Li.test(i), o = Li.test(r);
      return t.addDelimiter(Y0, O, O + 2, !s && (!o || n || a), !n && (!a || s || o));
    },
    after: "Emphasis"
  }]
};
function Pi(t, e, O = 0, i, r = 0) {
  let n = 0, s = !0, a = -1, o = -1, c = !1, h = () => {
    i.push(t.elt("TableCell", r + a, r + o, t.parser.parseInline(e.slice(a, o), r + a)));
  };
  for (let Q = O; Q < e.length; Q++) {
    let f = e.charCodeAt(Q);
    f == 124 && !c ? ((!s || a > -1) && n++, s = !1, i && (a > -1 && h(), i.push(t.elt("TableDelimiter", Q + r, Q + r + 1))), a = o = -1) : (c || f != 32 && f != 9) && (a < 0 && (a = Q), o = Q + 1), c = !c && f == 92;
  }
  return a > -1 && (n++, i && h()), n;
}
function Ih(t, e) {
  for (let O = e; O < t.length; O++) {
    let i = t.charCodeAt(O);
    if (i == 124)
      return !0;
    i == 92 && O++;
  }
  return !1;
}
const Ad = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class Mh {
  constructor() {
    this.rows = null;
  }
  nextLine(e, O, i) {
    if (this.rows == null) {
      this.rows = !1;
      let r;
      if ((O.next == 45 || O.next == 58 || O.next == 124) && Ad.test(r = O.text.slice(O.pos))) {
        let n = [];
        Pi(e, i.content, 0, n, i.start) == Pi(e, r, O.pos) && (this.rows = [
          e.elt("TableHeader", i.start, i.start + i.content.length, n),
          e.elt("TableDelimiter", e.lineStart + O.pos, e.lineStart + O.text.length)
        ]);
      }
    } else if (this.rows) {
      let r = [];
      Pi(e, O.text, O.pos, r, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + O.pos, e.lineStart + O.text.length, r));
    }
    return !1;
  }
  finish(e, O) {
    return this.rows ? (e.addLeafElement(O, e.elt("Table", O.start, O.start + O.content.length, this.rows)), !0) : !1;
  }
}
const q0 = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": l.heading } },
    "TableRow",
    { name: "TableCell", style: l.content },
    { name: "TableDelimiter", style: l.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(t, e) {
      return Ih(e.content, 0) ? new Mh() : null;
    },
    endLeaf(t, e, O) {
      if (O.parsers.some((r) => r instanceof Mh) || !Ih(e.text, e.basePos))
        return !1;
      let i = t.scanLine(t.absoluteLineEnd + 1).text;
      return Ad.test(i) && Pi(t, e.text, e.basePos) == Pi(t, i, e.basePos);
    },
    before: "SetextHeading"
  }]
};
class U0 {
  nextLine() {
    return !1;
  }
  finish(e, O) {
    return e.addLeafElement(O, e.elt("Task", O.start, O.start + O.content.length, [
      e.elt("TaskMarker", O.start, O.start + 3),
      ...e.parser.parseInline(O.content.slice(3), O.start + 3)
    ])), !0;
  }
}
const V0 = {
  defineNodes: [
    { name: "Task", block: !0, style: l.list },
    { name: "TaskMarker", style: l.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(t, e) {
      return /^\[[ xX]\][ \t]/.test(e.content) && t.parentType().name == "ListItem" ? new U0() : null;
    },
    after: "SetextHeading"
  }]
}, Lh = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy, Bh = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, _0 = /[\w-]+\.[\w-]+($|\/)/, Fh = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, Hh = /\/[a-zA-Z\d@.]+/gy;
function Kh(t, e, O, i) {
  let r = 0;
  for (let n = e; n < O; n++)
    t[n] == i && r++;
  return r;
}
function j0(t, e) {
  Bh.lastIndex = e;
  let O = Bh.exec(t);
  if (!O || _0.exec(O[0])[0].indexOf("_") > -1)
    return -1;
  let i = e + O[0].length;
  for (; ; ) {
    let r = t[i - 1], n;
    if (/[?!.,:*_~]/.test(r) || r == ")" && Kh(t, e, i, ")") > Kh(t, e, i, "("))
      i--;
    else if (r == ";" && (n = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(t.slice(e, i))))
      i = e + n.index;
    else
      break;
  }
  return i;
}
function Jh(t, e) {
  Fh.lastIndex = e;
  let O = Fh.exec(t);
  if (!O)
    return -1;
  let i = O[0][O[0].length - 1];
  return i == "_" || i == "-" ? -1 : e + O[0].length - (i == "." ? 1 : 0);
}
const G0 = {
  parseInline: [{
    name: "Autolink",
    parse(t, e, O) {
      let i = O - t.offset;
      Lh.lastIndex = i;
      let r = Lh.exec(t.text), n = -1;
      if (!r)
        return -1;
      if (r[1] || r[2]) {
        if (n = j0(t.text, i + r[0].length), n > -1 && t.hasOpenLink) {
          let s = /([^\[\]]|\[[^\]]*\])*/.exec(t.text.slice(i, n));
          n = i + s[0].length;
        }
      } else r[3] ? n = Jh(t.text, i) : (n = Jh(t.text, i + r[0].length), n > -1 && r[0] == "xmpp:" && (Hh.lastIndex = n, r = Hh.exec(t.text), r && (n = r.index + r[0].length)));
      return n < 0 ? -1 : (t.addElement(t.elt("URL", O, n + t.offset)), n + t.offset);
    }
  }]
}, C0 = [q0, V0, z0, G0];
function Dd(t, e, O) {
  return (i, r, n) => {
    if (r != t || i.char(n + 1) == t)
      return -1;
    let s = [i.elt(O, n, n + 1)];
    for (let a = n + 1; a < i.end; a++) {
      let o = i.char(a);
      if (o == t)
        return i.addElement(i.elt(e, n, a + 1, s.concat(i.elt(O, a, a + 1))));
      if (o == 92 && s.push(i.elt("Escape", a, a++ + 2)), rO(o))
        break;
    }
    return -1;
  };
}
const E0 = {
  defineNodes: [
    { name: "Superscript", style: l.special(l.content) },
    { name: "SuperscriptMark", style: l.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: Dd(94, "Superscript", "SuperscriptMark")
  }]
}, A0 = {
  defineNodes: [
    { name: "Subscript", style: l.special(l.content) },
    { name: "SubscriptMark", style: l.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: Dd(126, "Subscript", "SubscriptMark")
  }]
}, D0 = {
  defineNodes: [{ name: "Emoji", style: l.character }],
  parseInline: [{
    name: "Emoji",
    parse(t, e, O) {
      let i;
      return e != 58 || !(i = /^[a-zA-Z_0-9]+:/.exec(t.slice(O + 1, t.end))) ? -1 : t.addElement(t.elt("Emoji", O, O + 1 + i[0].length));
    }
  }]
}, Nd = /* @__PURE__ */ Wo({ commentTokens: { block: { open: "<!--", close: "-->" } } }), Id = /* @__PURE__ */ new Y(), Md = /* @__PURE__ */ R0.configure({
  props: [
    /* @__PURE__ */ fe.add((t) => !t.is("Block") || t.is("Document") || Ia(t) != null || N0(t) ? void 0 : (e, O) => ({ from: O.doc.lineAt(e.from).to, to: e.to })),
    /* @__PURE__ */ Id.add(Ia),
    /* @__PURE__ */ me.add({
      Document: () => null
    }),
    /* @__PURE__ */ lt.add({
      Document: Nd
    })
  ]
});
function Ia(t) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(t.name);
  return e ? +e[1] : void 0;
}
function N0(t) {
  return t.name == "OrderedList" || t.name == "BulletList";
}
function I0(t, e) {
  let O = t;
  for (; ; ) {
    let i = O.nextSibling, r;
    if (!i || (r = Ia(i.type)) != null && r <= e)
      break;
    O = i;
  }
  return O.to;
}
const M0 = /* @__PURE__ */ y$.of((t, e, O) => {
  for (let i = I(t).resolveInner(O, -1); i && !(i.from < e); i = i.parent) {
    let r = i.type.prop(Id);
    if (r == null)
      continue;
    let n = I0(i, r);
    if (n > O)
      return { from: O, to: n };
  }
  return null;
});
function sl(t) {
  return new Je(Nd, t, [M0], "markdown");
}
const L0 = /* @__PURE__ */ sl(Md), B0 = /* @__PURE__ */ Md.configure([C0, A0, E0, D0, {
  props: [
    /* @__PURE__ */ fe.add({
      Table: (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })
    })
  ]
}]), Ld = /* @__PURE__ */ sl(B0);
function F0(t, e) {
  return (O) => {
    if (O && t) {
      let i = null;
      if (O = /\S*/.exec(O)[0], typeof t == "function" ? i = t(O) : i = cn.matchLanguageName(t, O, !0), i instanceof cn)
        return i.support ? i.support.language.parser : Ui.getSkippingParser(i.load());
      if (i)
        return i.parser;
    }
    return e ? e.parser : null;
  };
}
let qr = class {
  constructor(e, O, i, r, n, s, a) {
    this.node = e, this.from = O, this.to = i, this.spaceBefore = r, this.spaceAfter = n, this.type = s, this.item = a;
  }
  blank(e, O = !0) {
    let i = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; i.length < e; )
        i += " ";
      return i;
    } else {
      for (let r = this.to - this.from - i.length - this.spaceAfter.length; r > 0; r--)
        i += " ";
      return i + (O ? this.spaceAfter : "");
    }
  }
  marker(e, O) {
    let i = this.node.name == "OrderedList" ? String(+Fd(this.item, e)[2] + O) : "";
    return this.spaceBefore + i + this.type + this.spaceAfter;
  }
};
function Bd(t, e) {
  let O = [];
  for (let r = t; r && r.name != "Document"; r = r.parent)
    (r.name == "ListItem" || r.name == "Blockquote" || r.name == "FencedCode") && O.push(r);
  let i = [];
  for (let r = O.length - 1; r >= 0; r--) {
    let n = O[r], s, a = e.lineAt(n.from), o = n.from - a.from;
    if (n.name == "FencedCode")
      i.push(new qr(n, o, o, "", "", "", null));
    else if (n.name == "Blockquote" && (s = /^ *>( ?)/.exec(a.text.slice(o))))
      i.push(new qr(n, o, o + s[0].length, "", s[1], ">", null));
    else if (n.name == "ListItem" && n.parent.name == "OrderedList" && (s = /^( *)\d+([.)])( *)/.exec(a.text.slice(o)))) {
      let c = s[3], h = s[0].length;
      c.length >= 4 && (c = c.slice(0, c.length - 4), h -= 4), i.push(new qr(n.parent, o, o + h, s[1], c, s[2], n));
    } else if (n.name == "ListItem" && n.parent.name == "BulletList" && (s = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(a.text.slice(o)))) {
      let c = s[4], h = s[0].length;
      c.length > 4 && (c = c.slice(0, c.length - 4), h -= 4);
      let Q = s[2];
      s[3] && (Q += s[3].replace(/[xX]/, " ")), i.push(new qr(n.parent, o, o + h, s[1], c, Q, n));
    }
  }
  return i;
}
function Fd(t, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(t.from, t.from + 10));
}
function Ws(t, e, O, i = 0) {
  for (let r = -1, n = t; ; ) {
    if (n.name == "ListItem") {
      let a = Fd(n, e), o = +a[2];
      if (r >= 0) {
        if (o != r + 1)
          return;
        O.push({ from: n.from + a[1].length, to: n.from + a[0].length, insert: String(r + 2 + i) });
      }
      r = o;
    }
    let s = n.nextSibling;
    if (!s)
      break;
    n = s;
  }
}
function al(t, e) {
  let O = /^[ \t]*/.exec(t)[0].length;
  if (!O || e.facet(ir) != "	")
    return t;
  let i = sO(t, 4, O), r = "";
  for (let n = i; n > 0; )
    n >= 4 ? (r += "	", n -= 4) : (r += " ", n--);
  return r + t.slice(O);
}
const H0 = ({ state: t, dispatch: e }) => {
  let O = I(t), { doc: i } = t, r = null, n = t.changeByRange((s) => {
    if (!s.empty || !Ld.isActiveAt(t, s.from))
      return r = { range: s };
    let a = s.from, o = i.lineAt(a), c = Bd(O.resolveInner(a, -1), i);
    for (; c.length && c[c.length - 1].from > a - o.from; )
      c.pop();
    if (!c.length)
      return r = { range: s };
    let h = c[c.length - 1];
    if (h.to - h.spaceAfter.length > a - o.from)
      return r = { range: s };
    let Q = a >= h.to - h.spaceAfter.length && !/\S/.test(o.text.slice(h.to));
    if (h.item && Q) {
      let p = h.node.firstChild, m = h.node.getChild("ListItem", "ListItem");
      if (p.to >= a || m && m.to < a || o.from > 0 && !/[^\s>]/.test(i.lineAt(o.from - 1).text)) {
        let P = c.length > 1 ? c[c.length - 2] : null, X, y = "";
        P && P.item ? (X = o.from + P.from, y = P.marker(i, 1)) : X = o.from + (P ? P.to : 0);
        let S = [{ from: X, to: a, insert: y }];
        return h.node.name == "OrderedList" && Ws(h.item, i, S, -2), P && P.node.name == "OrderedList" && Ws(P.item, i, S), { range: g.cursor(X + y.length), changes: S };
      } else {
        let P = OQ(c, t, o);
        return {
          range: g.cursor(a + P.length + 1),
          changes: { from: o.from, insert: P + t.lineBreak }
        };
      }
    }
    if (h.node.name == "Blockquote" && Q && o.from) {
      let p = i.lineAt(o.from - 1), m = />\s*$/.exec(p.text);
      if (m && m.index == h.from) {
        let P = t.changes([
          { from: p.from + m.index, to: p.to },
          { from: o.from + h.from, to: o.to }
        ]);
        return { range: s.map(P), changes: P };
      }
    }
    let f = [];
    h.node.name == "OrderedList" && Ws(h.item, i, f);
    let $ = h.item && h.item.from < o.from, u = "";
    if (!$ || /^[\s\d.)\-+*>]*/.exec(o.text)[0].length >= h.to)
      for (let p = 0, m = c.length - 1; p <= m; p++)
        u += p == m && !$ ? c[p].marker(i, 1) : c[p].blank(p < m ? sO(o.text, 4, c[p + 1].from) - u.length : null);
    let d = a;
    for (; d > o.from && /\s/.test(o.text.charAt(d - o.from - 1)); )
      d--;
    return u = al(u, t), K0(h.node, t.doc) && (u = OQ(c, t, o) + t.lineBreak + u), f.push({ from: d, to: a, insert: t.lineBreak + u }), { range: g.cursor(d + u.length + 1), changes: f };
  });
  return r ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function eQ(t) {
  return t.name == "QuoteMark" || t.name == "ListMark";
}
function K0(t, e) {
  if (t.name != "OrderedList" && t.name != "BulletList")
    return !1;
  let O = t.firstChild, i = t.getChild("ListItem", "ListItem");
  if (!i)
    return !1;
  let r = e.lineAt(O.to), n = e.lineAt(i.from), s = /^[\s>]*$/.test(r.text);
  return r.number + (s ? 0 : 1) < n.number;
}
function OQ(t, e, O) {
  let i = "";
  for (let r = 0, n = t.length - 2; r <= n; r++)
    i += t[r].blank(r < n ? sO(O.text, 4, t[r + 1].from) - i.length : null, r < n);
  return al(i, e);
}
function J0(t, e) {
  let O = t.resolveInner(e, -1), i = e;
  eQ(O) && (i = O.from, O = O.parent);
  for (let r; r = O.childBefore(i); )
    if (eQ(r))
      i = r.from;
    else if (r.name == "OrderedList" || r.name == "BulletList")
      O = r.lastChild, i = O.to;
    else
      break;
  return O;
}
const eT = ({ state: t, dispatch: e }) => {
  let O = I(t), i = null, r = t.changeByRange((n) => {
    let s = n.from, { doc: a } = t;
    if (n.empty && Ld.isActiveAt(t, n.from)) {
      let o = a.lineAt(s), c = Bd(J0(O, s), a);
      if (c.length) {
        let h = c[c.length - 1], Q = h.to - h.spaceAfter.length + (h.spaceAfter ? 1 : 0);
        if (s - o.from > Q && !/\S/.test(o.text.slice(Q, s - o.from)))
          return {
            range: g.cursor(o.from + Q),
            changes: { from: o.from + Q, to: s }
          };
        if (s - o.from == Q && // Only apply this if we're on the line that has the
        // construct's syntax, or there's only indentation in the
        // target range
        (!h.item || o.from <= h.item.from || !/\S/.test(o.text.slice(0, h.to)))) {
          let f = o.from + h.from;
          if (h.item && h.node.from < h.item.from && /\S/.test(o.text.slice(h.from, h.to))) {
            let $ = h.blank(sO(o.text, 4, h.to) - sO(o.text, 4, h.from));
            return f == o.from && ($ = al($, t)), {
              range: g.cursor(f + $.length),
              changes: { from: f, to: o.from + h.to, insert: $ }
            };
          }
          if (f < s)
            return { range: g.cursor(f), changes: { from: f, to: s } };
        }
      }
    }
    return i = { range: n };
  });
  return i ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, OT = [
  { key: "Enter", run: H0 },
  { key: "Backspace", run: eT }
], Ma = /* @__PURE__ */ Ht({ matchClosingTags: !1 });
function tT(t = {}) {
  let { codeLanguages: e, defaultCodeLanguage: O, addKeymap: i = !0, base: { parser: r } = L0, completeHTMLTags: n = !0 } = t;
  if (!(r instanceof An))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let s = t.extensions ? [t.extensions] : [], a = [Ma.support], o;
  O instanceof le ? (a.push(O.support), o = O.language) : O && (o = O);
  let c = e || o ? F0(e, o) : void 0;
  s.push(Z0({ codeParser: c, htmlParser: Ma.language.parser })), i && a.push(qO.high(Or.of(OT)));
  let h = sl(r.configure(s));
  return n && a.push(h.data.of({ autocomplete: iT })), new le(h, a);
}
function iT(t) {
  let { state: e, pos: O } = t, i = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(O - 25, O));
  if (!i)
    return null;
  let r = I(e).resolveInner(O, -1);
  for (; r && !r.type.isTop; ) {
    if (r.name == "CodeBlock" || r.name == "FencedCode" || r.name == "ProcessingInstructionBlock" || r.name == "CommentBlock" || r.name == "Link" || r.name == "Image")
      return null;
    r = r.parent;
  }
  return {
    from: O - i[0].length,
    to: O,
    options: rT(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let Rs = null;
function rT() {
  if (Rs)
    return Rs;
  let t = yx(new Co(E.create({ extensions: Ma }), 0, !0));
  return Rs = t ? t.options : [];
}
const nT = 177, sT = 179, aT = 184, oT = 12, lT = 13, cT = 17, hT = 20, QT = 25, fT = 53, $T = 95, uT = 142, dT = 144, pT = 145, mT = 148, PT = 10, gT = 13, ST = 32, XT = 9, tQ = 47, yT = 41, bT = 125, xT = new q((t, e) => {
  for (let O = 0, i = t.next; (e.context && (i < 0 || i == PT || i == gT || i == tQ && t.peek(O + 1) == tQ) || i == yT || i == bT) && t.acceptToken(nT), !(i != ST && i != XT); )
    i = t.peek(++O);
}, { contextual: !0 });
let TT = /* @__PURE__ */ new Set([
  $T,
  aT,
  hT,
  oT,
  cT,
  dT,
  pT,
  uT,
  mT,
  lT,
  fT,
  QT
]);
const wT = new Ft({
  start: !1,
  shift: (t, e) => e == sT ? t : TT.has(e)
}), kT = se({
  "func interface struct chan map const type var": l.definitionKeyword,
  "import package": l.moduleKeyword,
  "switch for go select return break continue goto fallthrough case if else defer": l.controlKeyword,
  range: l.keyword,
  Bool: l.bool,
  String: l.string,
  Rune: l.character,
  Number: l.number,
  Nil: l.null,
  VariableName: l.variableName,
  DefName: l.definition(l.variableName),
  TypeName: l.typeName,
  LabelName: l.labelName,
  FieldName: l.propertyName,
  "FunctionDecl/DefName": l.function(l.definition(l.variableName)),
  "TypeSpec/DefName": l.definition(l.typeName),
  "CallExpr/VariableName": l.function(l.variableName),
  LineComment: l.lineComment,
  BlockComment: l.blockComment,
  LogicOp: l.logicOperator,
  ArithOp: l.arithmeticOperator,
  BitOp: l.bitwiseOperator,
  "DerefOp .": l.derefOperator,
  "UpdateOp IncDecOp": l.updateOperator,
  CompareOp: l.compareOperator,
  "= :=": l.definitionOperator,
  "<-": l.operator,
  '~ "*"': l.modifier,
  "; ,": l.separator,
  "... :": l.punctuation,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace
}), WT = { __proto__: null, package: 10, import: 18, true: 380, false: 380, nil: 383, struct: 48, func: 68, interface: 78, chan: 94, map: 118, make: 157, new: 159, const: 204, type: 212, var: 224, if: 236, else: 238, switch: 242, case: 248, default: 250, for: 260, range: 266, go: 270, select: 274, return: 284, break: 288, continue: 290, goto: 292, fallthrough: 296, defer: 300 }, RT = ne.deserialize({
  version: 14,
  states: "!=xO#{QQOOP$SOQOOO&UQTO'#CbO&]QRO'#FlO]QQOOOOQP'#Cn'#CnOOQP'#Co'#CoO&eQQO'#C|O(kQQO'#C{O)]QRO'#GiO+tQQO'#D_OOQP'#Ge'#GeO+{QQO'#GeO.aQTO'#GaO.hQQO'#D`OOQP'#Gm'#GmO.mQRO'#GdO/hQQO'#DgOOQP'#Gd'#GdO/uQQO'#DrO2bQQO'#DsO4QQTO'#GqO,^QTO'#GaO4XQQO'#DxO4^QQO'#D{OOQO'#EQ'#EQOOQO'#ER'#EROOQO'#ES'#ESOOQO'#ET'#ETO4cQQO'#EPO5}QQO'#EPOOQP'#Ga'#GaO6UQQO'#E`O6^QQO'#EcOOQP'#G`'#G`O6cQQO'#EsOOQP'#G_'#G_O&]QRO'#FnOOQO'#Fn'#FnO9QQQO'#G^QOQQOOO&]QROOO9XQQO'#C`O9^QSO'#CdO9lQQO'#C}O9tQQO'#DSO9yQQO'#D[O:kQQO'#CsO:pQQO'#DhO:uQQO'#EeO:}QQO'#EiO;VQQO'#EoO;_QQO'#EuO<uQQO'#ExO<|QQO'#FRO4cQQO'#FWO=WQQO'#FYO=]QRO'#F_O=jQRO'#FaO=uQQO'#FaOOQP'#Fe'#FeO4cQQO'#FgP=zOWO'#C^POOO)CAz)CAzOOQO'#G]'#G]OOQO,5<W,5<WOOQO-E9j-E9jO?TQTO'#CqOOQO'#C|'#C|OOQP,59g,59gO?tQQO'#D_O@fQSO'#FuO@kQQO'#C}O@pQQO'#D[O9XQQO'#FqO@uQRO,5=TOAyQQO,59yOCVQSO,5:[O@kQQO'#C}OCaQQO'#DjOOQP,59^,59^OOQO,5<a,5<aO?tQQO'#DeOOQO,5:e,5:eOOQO-E9s-E9sOOQP,59z,59zOOQP,59|,59|OCqQSO,5:QO(kQQO,5:ROC{QQO,5:RO&]QRO'#FxOOQO'#Fx'#FxOFjQQO'#GpOFwQQO,5:^OF|QQO,5:_OHdQQO,5:`OHlQQO,5:aOHvQRO'#FyOIaQRO,5=]OIuQQO'#DzOOQP,5:d,5:dOOQO'#EV'#EVOOQO'#EW'#EWOOQO'#EX'#EXOOQO'#EZ'#EZOOQO'#E['#E[O4cQQO,5:pO4cQQO,5:pO4cQQO,5:pO4cQQO,5:pO4cQQO,5:pO4cQQO,5:wOOQP,5:x,5:xO?tQQO'#EOOOQP,5:g,5:gOOQP,5:k,5:kO9yQQO,59vO4cQQO,5:zO4cQQO,5:}OI|QRO,5;_OOQO,5<Y,5<YOOQO-E9l-E9lO]QQOOOOQP'#Cb'#CbOOQP,58z,58zOOQP'#Cf'#CfOJWQQO'#CfOJ]QSO'#CkOOQP,59O,59OOJkQQO'#DPOLZQQO,5<UOLbQQO,59iOLsQQO,5<TOMpQQO'#DUOOQP,59n,59nOOQP,59v,59vONfQQO,59vONmQQO'#CwOOQP,59_,59_O?tQQO,5:SONxQRO'#EgO! VQQO'#EhOOQP,5;P,5;PO! |QQO'#EkO!!WQQO'#EnOOQP,5;T,5;TO!!`QRO'#EqO!!mQQO'#ErOOQP,5;Z,5;ZO!!uQTO'#CbO!!|QTO,5;aO&]QRO,5;aO!#WQQO,5;jO!$yQTO,5;dO!%WQQO'#EzOOQP,5;d,5;dO&]QRO,5;dO!%cQSO,5;mO!%mQQO'#E`O!%uQQO'#EcO!%zQQO'#FTO!&UQQO'#FTOOQP,5;m,5;mO!&ZQQO,5;mO!&`QTO,5;rO!&mQQO'#F[OOQP,5;t,5;tO!&xQTO'#GqOOQP,5;y,5;yOOQP'#Et'#EtOOQP,5;{,5;{O!']QTO,5<RPOOO'#Fk'#FkP!'jOWO,58xPOOO,58x,58xO!'uQQO,59yO!'zQQO'#GgOOQP,59i,59iO(kQQO,59vOOQP,5<],5<]OOQP-E9o-E9oOOQP1G/e1G/eOOQP1G/v1G/vO!([QSO'#DlO!(lQQO'#DlO!(wQQO'#DkOOQO'#Go'#GoO!(|QQO'#GoO!)UQQO,5:UO!)ZQQO'#GnO!)fQQO,5:PPOQO'#Cq'#CqO(kQQO1G/lOOQP1G/m1G/mO(kQQO1G/mOOQO,5<d,5<dOOQO-E9v-E9vOOQP1G/x1G/xO!)kQSO1G/yOOQP'#Cy'#CyOOQP1G/z1G/zO?tQQO1G/}O!)xQSO1G/{O!*YQQO1G/|O!*gQTO,5<eOOQP-E9w-E9wOOQP,5:f,5:fO!+QQQO,5:fOOQP1G0[1G0[O!,vQTO1G0[O!.wQTO1G0[O!/OQTO1G0[O!0pQTO1G0[O!1QQTO1G0cO!1bQQO,5:jOOQP1G/b1G/bOOQP1G0f1G0fOOQP1G0i1G0iOOQP1G0y1G0yOOQP,59Q,59QO&]QRO'#FmO!1mQSO,59VOOQP,59V,59VOOQO'#DQ'#DQO?tQQO'#DQO!1{QQO'#DQOOQO'#Gh'#GhO!2SQQO'#GhO!2[QQO,59kO!2aQSO'#CqOJkQQO'#DPOOQP,5=R,5=RO@kQQO1G1pOOQP1G/w1G/wO.hQQO'#ElO!2rQRO1G1oO@kQQO1G1oO@kQQO'#DVO?tQQO'#DWOOQP'#Gk'#GkO!2}QRO'#GjOOQP'#Gj'#GjO&]QRO'#FsO!3`QQO,59pOOQP,59p,59pO!3gQRO'#CxO!3uQQO'#CxO!3|QRO'#CxO.hQQO'#CxO&]QRO'#FoO!4XQQO,59cOOQP,59c,59cO!4dQQO1G/nO4cQQO,5;RO!4iQQO,5;RO&]QRO'#FzO!4nQQO,5;SOOQP,5;S,5;SO!6aQQO'#DgO?tQQO,5;VOOQP,5;V,5;VO&]QRO'#F}O!6hQQO,5;YOOQP,5;Y,5;YO!6pQRO,5;]O4cQQO,5;]O&]QRO'#GOO!6{QQO,5;^OOQP,5;^,5;^O!7TQRO1G0{O!7`QQO1G0{O4cQQO1G1UO!8vQQO1G1UOOQP1G1O1G1OO!9OQQO'#GPO!9YQQO,5;fOOQP,5;f,5;fO4cQQO'#E{O!9eQQO'#E{O<uQQO1G1OOOQP1G1X1G1XO!9jQQO,5:zO!9jQQO,5:}O!9tQSO,5;oO!:OQQO,5;oO!:VQQO,5;oO!9OQQO'#GRO!:aQQO,5;vOOQP,5;v,5;vO!<PQQO'#F]O!<WQQO'#F]POOO-E9i-E9iPOOO1G.d1G.dO!<]QQO,5:VO!<gQQO,5=ZO!<tQQO,5=ZOOQP1G/p1G/pO!<|QQO,5=YO!=WQQO,5=YOOQP1G/k1G/kOOQP7+%W7+%WOOQP7+%X7+%XOOQP7+%e7+%eO!=cQQO7+%eO!=hQQO7+%iOOQP7+%g7+%gO!=mQQO7+%gO!=rQQO7+%hO!>PQSO7+%hOOQP7+%h7+%hO4cQQO7+%hOOQP1G0Q1G0QO!>^QQO1G0QOOQP1G0U1G0UO!>fQQO1G0UOF|QQO1G0UOOQO,5<X,5<XOOQO-E9k-E9kOOQP1G.q1G.qOOQO,59l,59lO?tQQO,59lO!?cQQO,5=SO!?jQQO,5=SOOQP1G/V1G/VO!?rQQO,59yO!?}QRO7+'[O!@YQQO'#EmO!@dQQO'#HOO!@lQQO,5;WOOQP7+'Z7+'ZO!@qQRO7+'ZOOQP,59q,59qOOQP,59r,59rOOQO'#DZ'#DZO!@]QQO'#FtO!@|QRO,59tOOQO,5<_,5<_OOQO-E9q-E9qOOQP1G/[1G/[OOQP,59d,59dOHgQQO'#FpO!3uQQO,59dO!A_QRO,59dO!AjQRO,59dOOQO,5<Z,5<ZOOQO-E9m-E9mOOQP1G.}1G.}O(kQQO7+%YOOQP1G0m1G0mO4cQQO1G0mOOQO,5<f,5<fOOQO-E9x-E9xOOQP1G0n1G0nO!AxQQO'#GdOOQP1G0q1G0qOOQO,5<i,5<iOOQO-E9{-E9{OOQP1G0t1G0tO4cQQO1G0wOOQP1G0w1G0wOOQO,5<j,5<jOOQO-E9|-E9|OOQP1G0x1G0xO!B]QQO7+&gO!BeQSO7+&gO!CsQSO7+&pO!CzQQO7+&pOOQO,5<k,5<kOOQO-E9}-E9}OOQP1G1Q1G1QO!DRQQO,5;gOOQO,5;g,5;gO!DWQSO7+&jOOQP7+&j7+&jO!DbQQO7+&pO!7`QQO1G1[O!DgQQO1G1ZOOQO1G1Z1G1ZO!DnQSO1G1ZOOQO,5<m,5<mOOQO-E:P-E:POOQP1G1b1G1bO!DxQSO'#GqO!E]QQO'#F^O!EbQQO'#F^O!EgQQO,5;wOOQO,5;w,5;wO!ElQSO1G/qOOQO1G/q1G/qO!EyQSO'#DoO!FZQQO'#DoO!FfQQO'#DnOOQO,5<c,5<cO!FkQQO1G2uOOQO-E9u-E9uOOQO,5<b,5<bO!FxQQO1G2tOOQO-E9t-E9tOOQP<<IP<<IPOOQP<<IT<<ITOOQP<<IR<<IRO!GSQSO<<ISOOQP<<IS<<ISO4cQQO<<ISO!GaQSO<<ISOOQP7+%l7+%lO!GkQQO7+%lOOQP7+%p7+%pO!GpQQO7+%pO!GuQQO7+%pOOQO1G/W1G/WOOQO,5<^,5<^O!G}QQO1G2nOOQO-E9p-E9pOOQP<<Jv<<JvO.hQQO'#F{O!@YQQO,5;XOOQO,5;X,5;XO!HUQQO,5=jO!H^QQO,5=jOOQO1G0r1G0rOOQP<<Ju<<JuOOQP,5<`,5<`OOQP-E9r-E9rOOQO,5<[,5<[OOQO-E9n-E9nO!HfQRO1G/OOOQP1G/O1G/OOOQP<<Ht<<HtOOQP7+&X7+&XO!HqQQO'#DeOOQP7+&c7+&cOOQP<<JR<<JRO!HxQRO<<JRO!ITQQO<<J[O!I]QQO<<J[OOQO1G1R1G1ROOQP<<JU<<JUO4cQQO<<J[O!IbQSO7+&vOOQO7+&u7+&uO!IlQQO7+&uO4cQQO,5;xOOQO1G1c1G1cO!<]QQO,5:YP!<]QQO'#FwP?tQQO'#FvOOQPAN>nAN>nO4cQQOAN>nO!IsQSOAN>nOOQP<<IW<<IWOOQP<<I[<<I[O!I}QQO<<I[P!>nQQO'#FrOOQO,5<g,5<gOOQO-E9y-E9yOOQO1G0s1G0sOOQO,5<h,5<hO!JVQQO1G3UOOQO-E9z-E9zOOQP7+$j7+$jO!J_QQO'#GnO!B]QQOAN?mO!JjQQOAN?vO!JqQQOAN?vO!KzQSOAN?vOOQO<<Ja<<JaO!LRQSO1G1dO!L]QSO1G/tOOQO1G/t1G/tO!LjQSOG24YOOQPG24YG24YOOQPAN>vAN>vO!LtQQOAN>vP.hQQO'#F|OOQPG25XG25XO!LyQQOG25bO!MOQQO'#FPOOQPG25bG25bO!MZQQOG25bOOQPLD)tLD)tOOQPG24bG24bO!JqQQOLD*|O!9OQQO'#GQO!McQQO,5;kOOQP,5;k,5;kO?tQQO'#FQO!MnQQO'#FQO!MsQQOLD*|OOQP!$'Nh!$'NhOOQO,5<l,5<lOOQO-E:O-E:OOOQP1G1V1G1VO!MzQQO,5;lOOQO,5;l,5;lO!NPQQO!$'NhOOQO1G1W1G1WO!JqQQO!)9DSOOQP!.K9n!.K9nO# {QTO'#CqO#!`QTO'#CqO##}QSO'#CqO#$XQSO'#CqO#&]QSO'#CqO#&gQQO'#FyO#&tQQO'#FyO#'OQQO,5=]O#'ZQQO,5=]O#'cQQO,5:pO!7`QQO,5:pOF|QQO,5:pO#'cQQO,5:pO!7`QQO,5:pOF|QQO,5:pO#'cQQO,5:pO!7`QQO,5:pOF|QQO,5:pO#'cQQO,5:pO!7`QQO,5:pOF|QQO,5:pO#'cQQO,5:pO!7`QQO,5:pOF|QQO,5:pO!7`QQO,5:wO!7`QQO,5:zO!7`QQO,5:}O#(yQSO'#CbO#)}QSO'#CbO#*bQSO'#GqO#*rQSO'#GqO#+PQRO'#GgO#+yQSO,5<eO#,ZQSO,5<eO#,hQSO1G0[O#-rQTO1G0[O#-yQSO1G0[O#.TQSO1G0[O#0{QTO1G0[O#1SQSO1G0[O#2eQSO1G0[O#2lQTO1G0[O#2sQSO1G0[O#4XQSO1G0[O#4`QTO1G0[O#4jQSO1G0[O#4wQSO1G0cO#5dQTO'#CqO#5kQTO'#CqO#6bQSO'#GqO#'cQQO'#EPO!7`QQO'#EPOF|QQO'#EPO#8]QQO'#EPO#8gQQO'#EPO#8qQQO'#EPO#8{QQO'#E`O#9TQQO'#EcO@kQQO'#C}O?tQQO,5:RO#9YQQO,59vO#:iQQO,59vO?tQQO,59vO?tQQO1G/lO?tQQO1G/mO?tQQO7+%YO?tQQO'#C{O#:pQQO'#DgO#9YQQO'#D[O#:wQQO'#D[O#:|QSO,5:QO#;WQQO,5:RO#;]QQO1G/nO?tQQO,5:SO#;bQQO'#Dh",
  stateData: "#;m~O$yOSPOS$zPQ~OVvOX{O[oO^YOaoOdoOh!POjcOr|Ow}O!P!OO!QnO!WaO!]!QO!phO!qhO#Y!RO#^!SO#d!TO#j!UO#m!VO#v!WO#{!XO#}!YO$S!ZO$U![O$V![O$W!]O$Y!^O$[!_O%OQO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO$v%QP~OTzO~P]O$z!`O~OVeXZeX^eX^!TXj!TXnUXneX!QeX!WeX!W!TX!|eX#ReX#TeX#UeX#WUX$weX%YeX%`eX%feX%geX%ieX%jeX%keX%leX%meX%neX%oeX%peX%qeX~O!a#hX~P$XOV!bO$w!bO~O[!wX^pX^!wXa!wXd!wXhpXh!wXrpXr!wXwpXw!wX!PpX!P!wX!QpX!Q!wX!WpX!W!wX!]pX!]!wX!p!wX!q!wX%OpX%O!wX%U!wX%V!wX%YpX%Y!wX%f!wX%g!wX%h!wX%i!wX%j!wX~O^!hOh!POr!jOw}O!P!OO!Q!kO!WaO!]!QO%O!eO%Y!fO~On!lO#W%]XV%]X^%]Xh%]Xr%]Xw%]X!P%]X!Q%]X!W%]X!]%]X#T%]X$w%]X%O%]X%Y%]Xu%]X~O[oO^YOaoOdoOh!POr!pOw}O!P!OO!WaO!]!QO!phO!qhO%O+wO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O!Q-OO~P*aOj!qO^%XX]%XXn%XX!V%XX~O!W!tOV%TXZ%TX^%TXn%TX!Q%TX!W%TX!|%TX#R%TX#T%TX#U%TX$w%TX%Y%TX%`%TX%f%TX%g%TX%i%TX%j%TX%k%TX%l%TX%m%TX%n%TX%o%TX%p%TX%q%TX]%TX!V%TXj%TXi%TX!a%TXu%TX~OZ!sO~P,^O%O!eO~O!W!tO^%WXj%WX]%WXn%WX!V%WXu%WXV%WX$w%WX%`%WX#T%WX[%WX!a%WX~Ou!{O!QnO!V!zO~P*aOV!}O[oO^YOaoOdoOh!POjcOr!pOw}O!P!OO!QnO!WaO!]!QO!phO!qhO#Y!RO#^!SO#d!TO#j!UO#m!VO#v!WO#{!XO#}!YO$S!ZO$U![O$V![O$W!]O$Y!^O$[!_O%OQO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlOi%dP~O^#QO~OZ#RO^#VOn#TO!Q#cO!W#SO#R#dO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[O%q#]OV`X#T%eX#U%eX$w`X~O!|#`O~P2gO^#VO~O^#eO~O!QnO~P*aO[oO^YOaoOdoOh!POr!pOw}O!QnO!WaO!]!QO!phO!qhO%O+wO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O!P#hO~P4jO#T#iO#U#iO~O#W#jO~O!a#kO~OVvO[oO^YOaoOdoOh!POjcOr|Ow}O!P!OO!QnO!WaO!]!QO!phO!qhO#Y!RO#^!SO#d!TO#j!UO#m!VO#v!WO#{!XO#}!YO$S!ZO$U![O$V![O$W!]O$Y!^O$[!_O%OQO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O$v%QX~P6hO%O#oO~OZ#rO[#qO^#sO%O#oO~O^#uO%O#oO~Oj#yO~O^!hOh!POr!jOw}O!P!OO!Q#|O!WaO!]!QO%O!eO%Y!fO~Oj#}O~O!W$PO~O^$RO%O#oO~O^$UO%O#oO~O^$XO%O#oO~O[oO^YOaoOdoOh!POr!pOw}O!P!OO!Q-PO!WaO!]!QO!phO!qhO%O$ZO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~Oj$`O~P;_OV$fOjcO~P;_Oj$kO~O!QnOV$RX$w$RX~P*aO%O$oOV$TX$w$TX~O%O$oO~O${$rO$|$rO$}$tO~OZeX^!TX!W!TXj!TXn!TXh!TXr!TXw!TX{!TX!P!TX!Q!TX!]!TX%O!TX%Y!TX~O]!TX!V!TXu!TX#T!TXV!TX$w!TX%`!TX[!TX!a!TX~P>VO^!hOh!POr-TOw}O!P-_O!Q-`O!W-^O!]-eO%O!eO%Y!fO~OZ!sO~O^#uO~O!P$xO~On!lO#W%]aV%]a^%]ah%]ar%]aw%]a!P%]a!Q%]a!W%]a!]%]a#T%]a$w%]a%O%]a%Y%]au%]a~O]${O^#QO~OZ#RO^#VO!W#SO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[O%q#]O~O]$|O!|,WO~PBROj!qOn%QO!QnOi%cP~P*aO!V%WO!|#`O~PBRO!V%YO~OV!}O[oO^YOaoOdoOh!POjcOr!pOw}O!P!OO!QnO!WaO!]!QO!phO!qhO#Y!RO#^!SO#d!TO#j!UO#m!VO#v!WO#{!XO#}!YO$S!ZO$U![O$V![O$W!]O$Y!^O$[!_O%OQO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~Oi%dX#p%dX#q%dX~PDQOi%]O~O[oO^YOaoOdoOh!POr!pOw}O!P!OO!Q-QO!WaO!]!QO!phO!qhO%O+{O%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O^%aO%O%_O~O!QnO!a%cO~P*aO!QnOn$mX#T$mX#U$mXV$mX$w$mX!a$mX~P*aOn#TO#T%ea#U%eaV%ea$w%ea!a%ea~O]%fO~PF|OV#ga$w#ga~PDTO[%sO~OZ#rO[#qO]%vO%O#oO~O^!hOh!POn%zOr-TOu%xOw}O!P-_O!Q-`O!W-^O!]-eO%O,dO%Y!fO]%[P~O^&OOh!POr!jOw}O!P!OO!Q!kO!WaO!]!QO%Y!fO^%ZXj%ZX~O%O%}O~PKfOjcO^qa]qanqa!Vqa~O^#uO!W&SO~O^!hOh!POr-TOw}O{&WO!P-_O!Q-`O!W-^O!]-eO%O,xO%Y!fO~Oi&^O~PL{O^!hOh!POr!jOw}O!Q!kO!WaO!]!QO%O!eO%Y!fO~O!P#hO~PMwOi&eO%O,yO%Y!fO~O#T&gOV#ZX$w#ZX~P?tO]&kO%O#oO~O^!hOh!POr-TOw}O!P-_O!Q-`O!]-eO%O!eO%Y!fO~O!W&lO#T&mO~P! _O]&qO%O#oO~O#T&sOV#eX$w#eX~P?tO]&vO%O#oO~OjeX~P$XOjcO!|,XO~P2gOn!lO#W&yO#W%]X~O^#VOn#TO!Q#cO!W#SO!|,XO#R#dO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[O%q#]OV`X#T%eX#U%eX~OZ&zOj$`O$w`X~P!#cOi'OO#p'PO#q'QO~OZ#ROjcO~P!#cO#T'TO#U#iO~O#W'UO~OV'WO!QnO~P*aOV'XO~OjcO~O!|#`OV#za$w#za~PBROi'[O#p']O#q'^O~On#TO!|#`OV%eX$w%eX!a%eX~PBRO!|#`OV$Za$w$Za~PBRO${$rO$|$rO$}'`O~O]${O~O%O!eO]%ZXn%ZX!V%ZX~PKfO!|#`Oi!_Xn!_X!a!`X~PBROi!_Xn!_X!a!`X~O!a'aO~On'bOi%cX~Oi'dO~On'eO!V%bX!a%bX~O!V'gO~O]'jOn'kO!|,YO~PBROn'nO!V'mO!a'oO!|#`O~PBRO!QnO!V'qO!a'rO~P*aO!|#`On$ma#T$ma#U$maV$ma$w$ma!a$ma~PBRO]'sOu'tO~O%Y#XO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YOV!xiZ!xi^!xin!xi!Q!xi!W!xi!|!xi#R!xi#T!xi#U!xi$w!xi%`!xi%f!xi%g!xi%i!xi%p!xi%q!xi~O!V!xii!xi!a!xi~P!+YO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YOV!xiZ!xi^!xin!xi!Q!xi!W!xi#R!xi#T!xi#U!xi$w!xi%p!xi%q!xi!V!xii!xi!a!xi~O!|!xi~P!-TO!|#`O~P!-TO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[OV!xiZ!xi^!xin!xi!Q!xi!W!xi#R!xi#T!xi#U!xi$w!xi%q!xi~O!|#`O!V!xii!xi!a!xi~P!/VO!|#`OV#Pi$w#Pi!a#Pi~PBRO]'uOn'wOu'vO~OZ#rO[#qO]'zO%O#oO~Ou'|O~P?tOn'}O]%[X~O](PO~OZeX^mX^!TXj!TX!W!TX~OjcOV$]i$w$]i~O%`(ZOV%^X$w%^Xn%^X!V%^X~Oi(`O~PL{O[(aO!W!tOVlX$wlX~On(bO~P?tO[(aOVlX$wlX~Oi(hO%O,yO%Y!fO~O!V(iO~O#T(kO~O](nO%O#oO~O[oO^YOaoOdoOh!POr!pOu-bOw}O!P!OO!QnO!V-UO!WaO!]!QO!phO!qhO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O%O+zO~P!4vO](sO%O#oO~O#T(tOV#ea$w#ea~O](xO%O#oO~O#k(yOV#ii$w#ii~O[oO^YOaoOdoOh!POr!pOw}O!P!OO!Q-PO!WaO!]!QO!phO!qhO%O+xO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O^(|O%O%_O~O#p%dP#q%dP~P/uOi)PO#p'PO#q'QO~O!a)RO~O!QnO#y)VO~P*aOV)WO!|#`O~PBROj#wa~P;_OV)WO!QnO~P*aOi)]O#p']O#q'^O~O[oO^YOaoOdoOh!POr!pOw}O!P!OO!QnO!WaO!]!QO!phO!qhO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O%O,eO~P!:lO!a)bO~Oj!qO!QnO~P*aOj!qO!QnOi%ca~P*aOn)iOi%ca~O!V%ba!a%ba~P?tOn)lO!V%ba!a%ba~O])nO~O])oO~O!V)pO~O!QnO!V)rO!a)sO~P*aO!V)rO!a)sO!|#`O~PBRO])uOn)vO~O])wOn)xO~O^!hOh!POr-TOu%xOw}O!P-_O!Q-`O!W-^O!]-eO%O,dO%Y!fO~O]%[a~P!>nOn)|O]%[a~O]${O]tXntX~OjcOV$^q$w$^q~On*PO{&WO~P?tOn*SO!V%rX~O!V*UO~OjcOV$]q$w$]q~O%`(ZOV|a$w|an|a!V|a~O[*]OVla$wla~O[*]O!W!tOVla$wla~On*PO{&WO!W*`O^%WXj%WX~P! _OjcO#j!UO~OjcO!|,XO~PBROZ*dO^#VO!W#SO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[O%q#]O~O!|#`O~P!BoO#^*eO~P?tO!a*fO~Oj$`O!|,XO~P!BoO#W*hO~Oj#wi~P;_OV*kO!|#`O~PBROn#TO!Q#cO!|#`O!a$QX#T%eX~PBRO#T*lO~O#W*lO~O!a*mO~O!|#`Oi!_in!_i~PBRO!|#`Oi!bXn!bX!a!cX~PBROi!bXn!bX!a!cX~O!a*nO~Oj!qO!QnOi%ci~P*aO!V%bi!a%bi~P?tO!V*qO!a*rO!|#`O~PBRO!V*qO!|#`O~PBRO]*tO~O]*uO~O]*uOu*vO~O]%[i~P!>nO%O!eO!V%ra~On*|O!V%ra~O[+OOVli$wli~O%O+yO~P!4vO#k+QOV#iy$w#iy~O^+RO%O%_O~O]+SO~O!|,XOj#xq~PBROj#wq~P;_O!V+ZO!|#`O~PBRO]+[On+]O~O%O!eO!V%ri~O^#QOn'eO!V%bX~O#^+`O~P?tOj+aO~O^#VO!W#SO!|#`O%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[O%q#]O~OZ+cO~P!JvO!|#`O!a$Qi~PBRO!|#`Oi!bin!bi~PBRO!V+dO!|#`O~PBRO]+eO~O]+fO~Oi+iO#p+jO#q+kO~O^+lO%O%_O~Oi+pO#p+jO#q+kO~O!a+rO~O#^+sO~P?tO!a+tO~O]+uO~OZeX^eX^!TXj!TX!WeX!W!TX!|eX%YeX%`eX%feX%geX%ieX%jeX%keX%leX%meX%neX%oeX%peX%qeXVeXneX!QeX#ReX#TeX#UeX$weX~O]eX]!TX!VeXieX!aeX~P!NUOjeX~P!NUOZeX^eX^!TXj!TX!WeX!W!TX!|eX%YeX%`eX%feX%geX%ieX%jeX%keX%leX%meX%neX%oeX%peX%qeXn!TX!VeX~O]eX!V!TX~P#!gOh!TXr!TXw!TX{!TX!P!TX!Q!TX!]!TX%O!TX%Y!TX~P#!gOZeX^eX^!TXj!TXneX!WeX!W!TX!|eX%YeX%`eX%feX%geX%ieX%jeX%keX%leX%meX%neX%oeX%peX%qeX~O]eXueX~P#$xO]$mXn$mXu$mX~PF|Oj$mXn$mX~P!7`On+|O]%eau%ea~On+}Oj%ea~O[oO^YOaoOdoOh!POr!pOw}O!P!OO!Q-OO!WaO!]!QO!phO!qhO%O+yO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~OZeX]!TX^UXhUXnUXn!TXrUXuUXwUX!PUX!QUX!WUX!W!TX!]UX%OUX%YUX~OnUX!QeX!aeX#TeX#WUX~P#$xOn+|O!|,YO]%eXu%eX~PBROn+}O!|,XOj%eX~PBRO^&OOV%ZXj%ZX$w%ZX]%ZXn%ZX!V%ZXu%ZX%`%ZX#T%ZX[%ZX!a%ZX~P?wO!|,YO]$man$mau$ma~PBRO!|,XOj$man$ma~PBRO%Y#XO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YOZ!xi]!xi^!xi!W!xi!|!xi%`!xi%f!xi%g!xi%i!xi%p!xi%q!xi~Oj!xi~P!+YOn!xiu!xi~P#,hO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YOZ!xi]!xi^!xi!W!xi!|!xi%p!xi%q!xi~O%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YOV!xiZ!xi^!xij!xin!xi!Q!xi!W!xi#R!xi#T!xi#U!xi$w!xi%p!xi%q!xi~O!|!xi~P#/_On!xiu!xi~P#.TO%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YOZ!xi]!xi^!xi!W!xi%p!xi%q!xi~O!|,WO~P#1^O!|,XO~P#/_O!|,YOn!xiu!xi~P#1^O%Y#XO%`#ZO%fiO%giO%i#ZO%j#YO%k#XO%l#XO%m#YO%n#YO%o#YO%p#[OZ!xi]!xi^!xi!W!xi%q!xi~O!|,WO~P#3QO!|,XOj!xi~P!/VO!|,YOn!xiu!xi~P#3QO!|,XOj#Pi~PBROV!TXZeX^mX!W!TX$w!TX~O%`!TX~P#5RO[!TXhmXnmXrmXwmX!PmX!QmX!WmX!]mX%OmX%YmX~P#5ROn#TO!Q,aO!|,XO#R#dOj`X#T%eX#U%eX~PBRO[oO^YOaoOdoOh!POr!pOw}O!P#hO!WaO!]!QO!phO!qhO%UTO%VUO%YVO%fiO%giO%hjO%ikO%jlO~O!Q-OO%O+yO~P#6{O!Q-PO%O+xO~P#6{O!Q-QO%O+{O~P#6{O#T,bO#U,bO~O#W,cO~O^!hOh!POr-TOw}O!P-_O!Q-WO!W-^O!]-eO%O!eO%Y!fO~O^!hOh!POr-TOw}O!Q-`O!W-^O!]-eO%O!eO%Y!fO~O!P-VO~P#9zO%O+wO~P!4vO!P-XO~O!V-YO!|#`O~PBRO!V-ZO~O!V-[O~O!W-dO~OP%ka%Oa~",
  goto: "!FW%sPP%tP%wP%zP'SP'XPPPP'`'cP'u'uP)w'u-_PPP0j0m0qP1V4b1VP7s8WP1VP8a8d8hP8p8w1VPP1V8{<`?vPPCY-_-_-_PCdCuCxPC{DQ'u'uDV'uES'u'u'u'uGUIW'uPPJR'uJUMjMjMj'u! r! r!#SP!$`!%d!&d'cP'cPP'cP!&yP!'V!'^!&yP!'a!'h!'n!'w!&yP!'z!(R!&y!(U!(fPP!&yP!(x!)UPP!&y!)Y!)c!&yP!)g!)gP!&yP!&yP!)j!)m!&v!&yP!&yPPP!&yP!&yP!)q!)q!)w!)}!*U!*[!*d!*j!*p!*w!*}!+T!+Z!.q!.x!/O!/X!/m!/s!/z!0Q!0W!0^!0d!0jPPPPPPPPP!0p!1f!1k!1{!2kPP!7P!:^P!>u!?Z!?_!@Z!@fP!@p!D_!Df!Di!DuPPPPPPPPPPPP!FSR!aPRyO!WXOScw!R!T!U!W#O#k#n#u$R$X&O&j&u&|'W'Y']'})W)|*k*w+gQ#pzU#r{#s%uQ#x|U$T!S$U&pQ$^!VQ$y!lR)U'RVROS#nQ#t{T%t#s%uR#t{qrOScw!U!V!W#O#k#n&|'W'Y)W*k+g%PoOSYacmnw!U!V!W!X!Z!_!q#O#Q#S#T#V#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(k(t)V)W)i)s*`*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^%O]OSYacmnw!U!V!W!X!Z!_!q#O#Q#S#T#V#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(k(t)V)W)i)s*`*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^#u!iW^!O!h!t!z#e#h#u#v#y#|#}$P$Q$T$W$v$x%W%Y%a%x%y&O&S&W&]&`&b&d&m'e'|'}(S([(c(i(o(|)l)|*P*Q*S*p*w*|+R+^+j+l,h-U-V-W-X-Y-Z-[-]-_-d'cbOSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&W&]&`&g&l&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*Q*`*h*k*l*n*o*p*r*w+R+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-dR$O!PT&c#}&dW%`#R&z*d+cQ&Q#vS&V#y&]S&`#}&dR*Y(b'cZOSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&W&]&`&g&l&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*Q*`*h*k*l*n*o*p*r*w+R+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-d%fWOSWYacmnw!O!U!V!W!X!Z!_!q!z#O#Q#S#T#V#^#_#`#a#b#c#h#i#j#k#n#v#|$f$v$x%W%Y%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(i(k(t)V)W)i)s*`*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^S&b#}&d!{-]!h!t#e#u#y$P$Q$T$W%a%x%y&O&W&]&`&m'e'|'}(S([(c(o(|)l)|*Q*p*w+R+j+l,h-U-V-W-X-Y-Z-[-]-_-dQ#v|S$v!j!pU&P#v$v,hZ,h#x&Q&U&V-TS%{#u&OV){'})|*wR#z}T&[#y&]]&X#y&](S([(o*QZ&Z#y&](S(o*QT([&Y(]'s_OSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|#}$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&S&W&]&`&b&d&g&l&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*P*Q*S*`*h*k*l*n*o*p*r*w*|+R+^+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-d'r_OSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|#}$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&S&W&]&`&b&d&g&l&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*P*Q*S*`*h*k*l*n*o*p*r*w*|+R+^+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-dR!w^'bbOSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&W&]&`&g&l&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*Q*`*h*k*l*n*o*p*r*w+R+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-dS&a#}&dR(d&bS!u]fX!x`&_(e(oQ!r[Q%O!qQ)d'aU)f'b)i*oR+X*nR%R!qR%P!qV)h'b)i*oV)g'b)i*odtOScw#O#k#n&|'Y+gQ$h!WQ&R#wQ&w$[S'S$c$iQ(V&TQ*O(RQ*V(WQ*b(yQ*c(zR+_+Q%PfOSYacmnw!U!V!W!X!Z!_!q#O#Q#S#T#V#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(k(t)V)W)i)s*`*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^%PgOSYacmnw!U!V!W!X!Z!_!q#O#Q#S#T#V#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(k(t)V)W)i)s*`*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^!q#Weg!o!y$[$_$c$j$m$q$}%^%b%d%m'V'p(z({)S)Y)^)c)e)q)t*i*s+T+V+W+Y,f,g,i,j,w,z-aR#fh#^mOSacmnw!X!Z!_!q#O#S#T#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&y&|'P'T'U'X'Y']'a'b'o'r(k(t)i)s*`*h*l*n*o*r+g-^!W#_e!y$j$m$q$}%b%d%j%k%l%m'V'p({)Y)^)c)e)q)t*s+T+V+W+Y-aW,T!o,n,q,tj,U$[$_$c(z)S*i,g,j,o,r,u,w,z[,V%^,f,i,p,s,v`,{Y,Q,T,W,Z,^,{-Ox,|!U!V!W&x'R'W)V)W*k+},R,U,X,[,_,a,b,c,|-Pg,}#Q#V'w+|,S,V,Y,],`,}-Q#^mOSacmnw!X!Z!_!q#O#S#T#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&y&|'P'T'U'X'Y']'a'b'o'r(k(t)i)s*`*h*l*n*o*r+g-^`,{Y,Q,T,W,Z,^,{-Ox,|!U!V!W&x'R'W)V)W*k+},R,U,X,[,_,a,b,c,|-Pg,}#Q#V'w+|,S,V,Y,],`,}-Q!Y#^e!y$j$m$q$}%b%d%i%j%k%l%m'V'p({)Y)^)c)e)q)t*s+T+V+W+Y-aY,Q!o,k,n,q,tl,R$[$_$c(z)S*i,g,j,l,o,r,u,w,z_,S%^,f,i,m,p,s,v!W#_e!y$j$m$q$}%b%d%j%k%l%m'V'p({)Y)^)c)e)q)t*s+T+V+W+Y-aW,T!o,n,q,tj,U$[$_$c(z)S*i,g,j,o,r,u,w,z],V%^,f,i,p,s,v!S#ae!y$j$m$q$}%b%d%l%m'V'p({)Y)^)c)e)q)t*s+T+V+W+Y-aS,Z!o,tf,[$[$_$c(z)S*i,g,j,u,w,zX,]%^,f,i,v!Q#be!y$j$m$q$}%b%d%m'V'p({)Y)^)c)e)q)t*s+T+V+W+Y-aQ,^!od,_$[$_$c(z)S*i,g,j,w,zV,`%^,f,iprOScw!U!V!W#O#k#n&|'W'Y)W*k+gR)a']etOScw#O#k#n&|'Y+gQ$S!RT&i$R&jR$S!RQ$V!ST&o$U&pQ&U#xR&m$TS(T&S&lV*{*S*|+^R$V!SQ$Y!TT&t$X&uR$Y!TdsOScw#O#k#n&|'Y+gT$p![!]dtOScw#O#k#n&|'Y+gQ*b(yR+_+QQ$a!VQ&{$_Q)T'RR*g)ST&|$`&}Q+b+SQ+m+fR+v+uT+g+a+hR$i!WR$l!YT'Y$k'ZXuOSw#nQ$s!`R'_$sSSO#nR!dSQ%u#sR'y%uUwOS#nR#mwQ&d#}R(g&dQ(c&`R*Z(cS!mX$^R$z!mQ(O%{R)}(OQ&]#yR(_&]Q(]&YR*X(]'r^OSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|#}$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&S&W&]&`&b&d&g&l&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*P*Q*S*`*h*k*l*n*o*p*r*w*|+R+^+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-dR!v^S'f%T+PR)m'fQ'c%RR)j'cW#Oc&|'Y+gR%[#O^#Ue$[$_$c$m)^,zU%e#U,O,PQ,O,fR,P,gQ&j$RR(m&jS*Q(S(oR*y*QQ*T(TR*}*TQ&p$UR(r&pQ&u$XR(w&uQ&}$`R)O&}Q+h+aR+o+hQ'Z$kR)['ZQ!cRQ#luQ#nyQ%Z!|Q&x$]Q'R$bQ'x%tQ(^&[Q(f&cQ(l&iQ(q&oR(v&tVxOS#nWuOSw#nY!|c#O&|'Y+gR%r#kdtOScw#O#k#n&|'Y+gQ$]!UQ$b!VQ$g!WQ)X'WQ*j)WR+U*kdeOScw#O#k#n&|'Y+gQ!oYQ!ya`#gmn,{,|,}-O-P-QQ$[!UQ$_!VQ$c!WQ$j!Xd$m!Z#i#j&g&s'P'T'U(k(tQ$q!_Q$}!qQ%^#QQ%b#SQ%d#TW%h#^,Q,R,SQ%i#_Q%j#`Q%k#aQ%l#bQ%m#cQ'V$fQ'p%cQ(z&xQ({&yQ)S'RQ)Y'XQ)^']Q)c'aU)e'b)i*oQ)q'oQ)t'rQ*i)VQ*s)sQ+T*hQ+V*lQ+W*nQ+Y*rS,f#V'wS,g,b,cQ,i+|Q,j+}Q,k,TQ,l,UQ,m,VQ,n,WQ,o,XQ,p,YQ,q,ZQ,r,[Q,s,]Q,t,^Q,u,_Q,v,`Q,w,aU,z'W)W*kV-a&l*`-^#bZW!O!h!t!z#e#h#u#v#y#|$P$Q$T$W$v$x%W%Y%a%x%y&O&W&]&`&m'e'|'}(S([(c(i(o(|)l)|*Q*p*w+R+j+l,h-U-V-W-X-Y-Z-[-]-_-d%P[OSYacmnw!U!V!W!X!Z!_!q#O#Q#S#T#V#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(k(t)V)W)i)s*`*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^$zdOSacmnw!U!V!W!X!Z!_!q#O#Q#S#T#V#^#_#`#a#b#c#i#j#k#n$f%c&g&l&s&x&y&|'P'R'T'U'W'X'Y']'a'b'o'r'w(k(t)V)W)i)s*h*k*l*n*o*r+g+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,{,|,}-O-P-Q-^S!gW-]Q!nYS#{!O-_Q$u!hS%T!t+jS%X!z-UQ%n#e[%o#h#|$x-V-W-XW%w#u'})|*wU&P#v$v,h[&X#y&](S([(o*QQ&f$PQ&h$QQ&n$TQ&r$WS'h%W-YS'i%Y-ZW'l%a(|+R+lS'{%x%yQ(Q&OQ(Y&WQ(d&`Q(p&mU)k'e)l*pQ)z'|Q*[(cS*^(i-[Q+P*`R-c-dS#w|!pS$w!j-TQ&T#xQ(R&QQ(W&UR(X&VT%|#u&OhqOScw!U!V#O#k#n&|'Y+gU$Q!R$R&jU$W!T$X&uQ$e!WY%y#u&O'})|*wQ)`']V-S'W)W*kS&[#y&]S*R(S(oR*z*QY&Y#y&](S(o*QR*W(['``OSWYacmnw!O!U!V!W!X!Z!_!h!q!t!z#O#Q#S#T#V#^#_#`#a#b#c#e#h#i#j#k#n#u#v#y#|$P$Q$T$W$f$v$x%W%Y%a%c%x%y&O&W&]&`&g&m&s&x&y&|'P'R'T'U'W'X'Y']'a'b'e'o'r'w'|'}(S([(c(i(k(o(t(|)V)W)i)l)s)|*Q*`*h*k*l*n*o*p*r*w+R+g+j+l+|+},Q,R,S,T,U,V,W,X,Y,Z,[,],^,_,`,a,b,c,h,{,|,}-O-P-Q-U-V-W-X-Y-Z-[-]-^-_-dS&_#}&dW(S&S*S*|+^Q(e&bQ(o&lR*x*PS%U!t*`R+q+jR%S!qQ#PcQ(}&|Q)Z'YR+n+ghpOScw!U!V#O#k#n&|'Y+gQ$d!WQ$n!ZQ%g#VU%p#i'T,bU%q#j'U,cQ(j&gQ(u&sQ)Q'PQ)_']Q)y'wQ*_(kQ*a(tV-R'W)W*kT(U&S&l",
  nodeNames: "âš  LineComment BlockComment SourceFile PackageClause package DefName ; ImportDecl import ImportSpec . String ) ( SpecList ExprStatement Number Bool Nil Rune VariableName TypedLiteral StructType struct } { StructBody FieldDecl FieldName , PointerType * FunctionType func Parameters Parameter ... InterfaceType interface InterfaceBody MethodElem UnderlyingType ~ TypeElem LogicOp ChannelType chan <- ParenthesizedType QualifiedType TypeName ParameterizedType ] [ TypeArgs ArrayType SliceType MapType map LiteralValue Element Key : Element Key ParenthesizedExpr FunctionLiteral Block Conversion SelectorExpr IndexExpr SliceExpr TypeAssertion CallExpr ParameterizedExpr Arguments CallExpr make new Arguments UnaryExp ArithOp LogicOp BitOp DerefOp BinaryExp ArithOp BitOp BitOp CompareOp LogicOp LogicOp SendStatement IncDecStatement IncDecOp Assignment = UpdateOp VarDecl := ConstDecl const ConstSpec SpecList TypeDecl type TypeSpec TypeParams TypeParam SpecList VarDecl var VarSpec SpecList LabeledStatement LabelName IfStatement if else SwitchStatement switch SwitchBlock Case case default TypeSwitchStatement SwitchBlock Case ForStatement for ForClause RangeClause range GoStatement go SelectStatement select SelectBlock Case ReceiveStatement ReturnStatement return GotoStatement break continue goto FallthroughStatement fallthrough DeferStatement defer FunctionDecl MethodDecl",
  maxTerm: 218,
  context: wT,
  nodeProps: [
    ["isolate", -3, 2, 12, 20, ""],
    ["group", -18, 12, 17, 18, 19, 20, 21, 22, 66, 67, 69, 70, 71, 72, 73, 74, 77, 81, 86, "Expr", -20, 16, 68, 93, 94, 96, 99, 101, 105, 111, 115, 117, 120, 126, 129, 134, 136, 141, 143, 147, 149, "Statement", -12, 23, 31, 33, 38, 46, 49, 50, 51, 52, 56, 57, 58, "Type"],
    ["openedBy", 13, "(", 25, "{", 53, "["],
    ["closedBy", 14, ")", 26, "}", 54, "]"]
  ],
  propSources: [kT],
  skippedNodes: [0, 1, 2, 153],
  repeatNodeCount: 23,
  tokenData: ":b~RvXY#iYZ#i]^#ipq#iqr#zrs$Xuv&Pvw&^wx&yxy(qyz(vz{({{|)T|})e}!O)j!O!P)u!P!Q+}!Q!R,y!R![-t![!]2^!]!^2k!^!_2p!_!`3]!`!a3e!c!}3x!}#O4j#P#Q4o#Q#R4t#R#S4|#S#T9X#T#o3x#o#p9q#p#q9v#q#r:W#r#s:]$g;'S3x;'S;=`4d<%lO3x~#nS$y~XY#iYZ#i]^#ipq#iU$PP%hQ!_!`$SS$XO!|S~$^W[~OY$XZr$Xrs$vs#O$X#O#P${#P;'S$X;'S;=`%y<%lO$X~${O[~~%ORO;'S$X;'S;=`%X;=`O$X~%^X[~OY$XZr$Xrs$vs#O$X#O#P${#P;'S$X;'S;=`%y;=`<%l$X<%lO$X~%|P;=`<%l$X~&UP%l~!_!`&X~&^O#U~~&cR%j~vw&l!_!`&X#Q#R&q~&qO%p~~&vP%o~!_!`&X~'OWd~OY&yZw&ywx'hx#O&y#O#P'm#P;'S&y;'S;=`(k<%lO&y~'mOd~~'pRO;'S&y;'S;=`'y;=`O&y~(OXd~OY&yZw&ywx'hx#O&y#O#P'm#P;'S&y;'S;=`(k;=`<%l&y<%lO&y~(nP;=`<%l&y~(vO^~~({O]~~)QP%Y~!_!`&X~)YQ%f~{|)`!_!`&X~)eO#R~~)jOn~~)oQ%g~}!O)`!_!`&X~)zRZS!O!P*T!Q![*`#R#S+w~*WP!O!P*Z~*`Ou~Q*eTaQ!Q![*`!g!h*t#R#S+w#X#Y*t#]#^+rQ*wS{|+T}!O+T!Q![+^#R#S+lQ+WQ!Q![+^#R#S+lQ+cRaQ!Q![+^#R#S+l#]#^+rQ+oP!Q![+^Q+wOaQQ+zP!Q![*`~,SR%k~z{,]!P!Q,b!_!`&X~,bO$z~~,gSP~OY,bZ;'S,b;'S;=`,s<%lO,b~,vP;=`<%l,bQ-O[aQ!O!P*`!Q![-t!d!e.c!g!h*t!q!r/Z!z!{/x#R#S.]#U#V.c#X#Y*t#]#^+r#c#d/Z#l#m/xQ-yUaQ!O!P*`!Q![-t!g!h*t#R#S.]#X#Y*t#]#^+rQ.`P!Q![-tQ.fR!Q!R.o!R!S.o#R#S/QQ.tSaQ!Q!R.o!R!S.o#R#S/Q#]#^+rQ/TQ!Q!R.o!R!S.oQ/^Q!Q!Y/d#R#S/rQ/iRaQ!Q!Y/d#R#S/r#]#^+rQ/uP!Q!Y/dQ/{T!O!P0[!Q![1c!c!i1c#R#S2Q#T#Z1cQ0_S!Q![0k!c!i0k#R#S1V#T#Z0kQ0pVaQ!Q![0k!c!i0k!r!s*t#R#S1V#T#Z0k#]#^+r#d#e*tQ1YR!Q![0k!c!i0k#T#Z0kQ1hWaQ!O!P0k!Q![1c!c!i1c!r!s*t#R#S2Q#T#Z1c#]#^+r#d#e*tQ2TR!Q![1c!c!i1c#T#Z1c~2cP!a~!_!`2f~2kO#W~~2pOV~~2uR!|S}!O3O!^!_3T!_!`$S~3TO!Q~~3YP%m~!_!`&X~3bP#T~!_!`$S~3jQ!|S!_!`$S!`!a3p~3uP%n~!_!`&X~3}V%O~!Q![3x!c!}3x#R#S3x#T#o3x$g;'S3x;'S;=`4d<%lO3x~4gP;=`<%l3x~4oO!W~~4tO!V~~4yP%i~!_!`&X~5RV%O~!Q![5h!c!}3x#R#S3x#T#o3x$g;'S3x;'S;=`4d<%lO3x~5o^aQ%O~!O!P*`!Q![5h!c!g3x!g!h6k!h!}3x#R#S4|#T#X3x#X#Y6k#Y#]3x#]#^8k#^#o3x$g;'S3x;'S;=`4d<%lO3x~6pX%O~{|+T}!O+T!Q![7]!c!}3x#R#S8P#T#o3x$g;'S3x;'S;=`4d<%lO3x~7dXaQ%O~!Q![7]!c!}3x#R#S8P#T#]3x#]#^8k#^#o3x$g;'S3x;'S;=`4d<%lO3x~8UV%O~!Q![7]!c!}3x#R#S3x#T#o3x$g;'S3x;'S;=`4d<%lO3x~8rVaQ%O~!Q![3x!c!}3x#R#S3x#T#o3x$g;'S3x;'S;=`4d<%lO3x~9[TO#S9X#S#T$v#T;'S9X;'S;=`9k<%lO9X~9nP;=`<%l9X~9vOj~~9{Q%`~!_!`&X#p#q:R~:WO%q~~:]Oi~~:bO{~",
  tokenizers: [xT, 1, 2, new nO("j~RQYZXz{^~^O$|~~aP!P!Qd~iO$}~~", 25, 181)],
  topRules: { SourceFile: [0, 3] },
  dynamicPrecedences: { 19: 1, 51: -1, 55: 2, 69: -1, 108: -1 },
  specialized: [{ term: 184, get: (t) => WT[t] || -1 }],
  tokenPrec: 5451
}), vT = [
  /* @__PURE__ */ L("func ${name}(${params}) ${type} {\n	${}\n}", {
    label: "func",
    detail: "declaration",
    type: "keyword"
  }),
  /* @__PURE__ */ L("func (${receiver}) ${name}(${params}) ${type} {\n	${}\n}", {
    label: "func",
    detail: "method declaration",
    type: "keyword"
  }),
  /* @__PURE__ */ L("var ${name} = ${value}", {
    label: "var",
    detail: "declaration",
    type: "keyword"
  }),
  /* @__PURE__ */ L("type ${name} ${type}", {
    label: "type",
    detail: "declaration",
    type: "keyword"
  }),
  /* @__PURE__ */ L("const ${name} = ${value}", {
    label: "const",
    detail: "declaration",
    type: "keyword"
  }),
  /* @__PURE__ */ L("type ${name} = ${type}", {
    label: "type",
    detail: "alias declaration",
    type: "keyword"
  }),
  /* @__PURE__ */ L("for ${init}; ${test}; ${update} {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ L("for ${i} := range ${value} {\n	${}\n}", {
    label: "for",
    detail: "range",
    type: "keyword"
  }),
  /* @__PURE__ */ L(`select {
	\${}
}`, {
    label: "select",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ L("case ${}:\n${}", {
    label: "case",
    type: "keyword"
  }),
  /* @__PURE__ */ L("switch ${} {\n	${}\n}", {
    label: "switch",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ L("switch ${}.(${type}) {\n	${}\n}", {
    label: "switch",
    detail: "type statement",
    type: "keyword"
  }),
  /* @__PURE__ */ L("if ${} {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ L(`if \${} {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ L('import ${name} "${module}"\n${}', {
    label: "import",
    detail: "declaration",
    type: "keyword"
  })
], iQ = /* @__PURE__ */ new Qo(), Hd = /* @__PURE__ */ new Set([
  "SourceFile",
  "Block",
  "FunctionDecl",
  "MethodDecl",
  "FunctionLiteral",
  "ForStatement",
  "SwitchStatement",
  "TypeSwitchStatement",
  "IfStatement"
]);
function St(t, e) {
  return (O, i) => {
    e: for (let r = O.node.firstChild, n = 0, s = null; ; ) {
      for (; !r; ) {
        if (!n)
          break e;
        n--, r = s.nextSibling, s = s.parent;
      }
      e && r.name == e || r.name == "SpecList" ? (n++, s = r, r = r.firstChild) : (r.name == "DefName" && i(r, t), r = r.nextSibling);
    }
    return !0;
  };
}
const ZT = {
  FunctionDecl: /* @__PURE__ */ St("function"),
  VarDecl: /* @__PURE__ */ St("var", "VarSpec"),
  ConstDecl: /* @__PURE__ */ St("constant", "ConstSpec"),
  TypeDecl: /* @__PURE__ */ St("type", "TypeSpec"),
  ImportDecl: /* @__PURE__ */ St("constant", "ImportSpec"),
  Parameter: /* @__PURE__ */ St("var"),
  __proto__: null
};
function Kd(t, e) {
  let O = iQ.get(e);
  if (O)
    return O;
  let i = [], r = !0;
  function n(s, a) {
    let o = t.sliceString(s.from, s.to);
    i.push({ label: o, type: a });
  }
  return e.cursor(H.IncludeAnonymous).iterate((s) => {
    if (r)
      r = !1;
    else if (s.name) {
      let a = ZT[s.name];
      if (a && a(s, n) || Hd.has(s.name))
        return !1;
    } else if (s.to - s.from > 8192) {
      for (let a of Kd(t, s.node))
        i.push(a);
      return !1;
    }
  }), iQ.set(e, i), i;
}
const rQ = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, Jd = [
  "String",
  "LineComment",
  "BlockComment",
  "DefName",
  "LabelName",
  "FieldName",
  ".",
  "?."
], YT = (t) => {
  let e = I(t.state).resolveInner(t.pos, -1);
  if (Jd.indexOf(e.name) > -1)
    return null;
  let O = e.name == "VariableName" || e.to - e.from < 20 && rQ.test(t.state.sliceDoc(e.from, e.to));
  if (!O && !t.explicit)
    return null;
  let i = [];
  for (let r = e; r; r = r.parent)
    Hd.has(r.name) && (i = i.concat(Kd(t.state.doc, r)));
  return {
    options: i,
    from: O ? e.from : t.pos,
    validFor: rQ
  };
}, vs = /* @__PURE__ */ re.define({
  name: "go",
  parser: /* @__PURE__ */ RT.configure({
    props: [
      /* @__PURE__ */ me.add({
        IfStatement: /* @__PURE__ */ ae({ except: /^\s*({|else\b)/ }),
        LabeledStatement: qn,
        "SwitchBlock SelectBlock": (t) => {
          let e = t.textAfter, O = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (O || i ? 0 : t.unit);
        },
        Block: /* @__PURE__ */ YO({ closing: "}" }),
        BlockComment: () => null,
        Statement: /* @__PURE__ */ ae({ except: /^{/ })
      }),
      /* @__PURE__ */ fe.add({
        "Block SwitchBlock SelectBlock LiteralValue InterfaceType StructType SpecList": Ie,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case\b|default\b|\})$/
  }
});
let zT = (t) => ({ label: t, type: "keyword" });
const qT = /* @__PURE__ */ "interface struct chan map package go return break continue goto fallthrough else defer range true false nil".split(" ").map(zT);
function UT() {
  let t = vT.concat(qT);
  return new le(vs, [
    vs.data.of({
      autocomplete: Eo(Jd, Cn(t))
    }),
    vs.data.of({
      autocomplete: YT
    })
  ]);
}
const VT = 1, _T = 33, jT = 34, GT = 35, CT = 36, ET = /* @__PURE__ */ new q((t) => {
  let e = t.pos;
  for (; ; ) {
    if (t.next == 10) {
      t.advance();
      break;
    } else if (t.next == 123 && t.peek(1) == 123 || t.next < 0)
      break;
    t.advance();
  }
  t.pos > e && t.acceptToken(VT);
});
function Dn(t, e, O) {
  return new q((i) => {
    let r = i.pos;
    for (; i.next != t && i.next >= 0 && (O || i.next != 38 && (i.next != 123 || i.peek(1) != 123)); )
      i.advance();
    i.pos > r && i.acceptToken(e);
  });
}
const AT = /* @__PURE__ */ Dn(39, _T, !1), DT = /* @__PURE__ */ Dn(34, jT, !1), NT = /* @__PURE__ */ Dn(39, GT, !0), IT = /* @__PURE__ */ Dn(34, CT, !0), MT = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "(jOVOqOOOeQpOOOvO!bO'#CaOOOP'#Cx'#CxQVOqOOO!OQpO'#CfO!WQpO'#ClO!]QpO'#CrO!bQpO'#CsOOQO'#Cv'#CvQ!gQpOOQ!lQpOOQ!qQpOOOOOV,58{,58{O!vOpO,58{OOOP-E6v-E6vO!{QpO,59QO#TQpO,59QOOQO,59W,59WO#YQpO,59^OOQO,59_,59_O#_QpOOO#_QpOOO#gQpOOOOOV1G.g1G.gO#oQpO'#CyO#tQpO1G.lOOQO1G.l1G.lO#|QpO1G.lOOQO1G.x1G.xO$UO`O'#DUO$ZOWO'#DUOOQO'#Co'#CoQOQpOOOOQO'#Cu'#CuO$`OtO'#CwO$qOrO'#CwOOQO,59e,59eOOQO-E6w-E6wOOQO7+$W7+$WO%SQpO7+$WO%[QpO7+$WOOOO'#Cp'#CpO%aOpO,59pOOOO'#Cq'#CqO%fOpO,59pOOOS'#Cz'#CzO%kOtO,59cOOQO,59c,59cOOOQ'#C{'#C{O%|OrO,59cO&_QpO<<GrOOQO<<Gr<<GrOOQO1G/[1G/[OOOS-E6x-E6xOOQO1G.}1G.}OOOQ-E6y-E6yOOQOAN=^AN=^",
  stateData: "&d~OvOS~OPROSQOVROWRO~OZTO[XO^VOaUOhWO~OR]OU^O~O[`O^aO~O[bO~O[cO~O[dO~ObeO~ObfO~ObgO~ORhO~O]kOwiO~O[lO~O_mO~OynOzoO~OysOztO~O[uO~O]wOwiO~O_yOwiO~OtzO~Os|O~OSQOV!OOW!OOr!OOy!QO~OSQOV!ROW!ROq!ROz!QO~O_!TOwiO~O]!UO~Oy!VO~Oz!VO~OSQOV!OOW!OOr!OOy!XO~OSQOV!ROW!ROq!ROz!XO~O]!ZO~O",
  goto: "#dyPPPPPzPPPP!WPPPPP!WPP!Z!^!a!d!dP!g!j!m!p!v#Q#WPPPPPPPP#^SROSS!Os!PT!Rt!SRYPRqeR{nR}oRZPRqfR[PRqgQSOR_SQj`SvjxRxlQ!PsR!W!PQ!StR!Y!SQpeRrf",
  nodeNames: "âš  Text Content }} {{ Interpolation InterpolationContent Entity InvalidEntity Attribute BoundAttributeName [ Identifier ] ( ) ReferenceName # Is ExpressionAttributeValue AttributeInterpolation AttributeInterpolation EventName DirectiveName * StatementAttributeValue AttributeName AttributeValue",
  maxTerm: 42,
  nodeProps: [
    ["openedBy", 3, "{{", 15, "("],
    ["closedBy", 4, "}}", 14, ")"],
    ["isolate", -4, 5, 19, 25, 27, ""]
  ],
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "0r~RyOX#rXY$mYZ$mZ]#r]^$m^p#rpq$mqr#rrs%jst&Qtv#rvw&hwx)zxy*byz*xz{+`{}#r}!O+v!O!P-]!P!Q#r!Q![+v![!]+v!]!_#r!_!`-s!`!c#r!c!}+v!}#O.Z#O#P#r#P#Q.q#Q#R#r#R#S+v#S#T#r#T#o+v#o#p/X#p#q#r#q#r0Z#r%W#r%W;'S+v;'S;:j-V;:j;=`$g<%lO+vQ#wTUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rQ$ZSO#q#r#r;'S#r;'S;=`$g<%lO#rQ$jP;=`<%l#rR$t[UQvPOX#rXY$mYZ$mZ]#r]^$m^p#rpq$mq#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR%qTyPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR&XTaPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR&oXUQWPOp'[pq#rq!]'[!]!^#r!^#q'[#q#r(d#r;'S'[;'S;=`)t<%lO'[R'aXUQOp'[pq#rq!]'[!]!^'|!^#q'[#q#r(d#r;'S'[;'S;=`)t<%lO'[R(TTVPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR(gXOp'[pq#rq!]'[!]!^'|!^#q'[#q#r)S#r;'S'[;'S;=`)t<%lO'[P)VUOp)Sq!])S!]!^)i!^;'S)S;'S;=`)n<%lO)SP)nOVPP)qP;=`<%l)SR)wP;=`<%l'[R*RTzPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR*iT^PUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR+PT_PUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR+gThPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR+}b[PUQO}#r}!O+v!O!Q#r!Q![+v![!]+v!]!c#r!c!}+v!}#R#r#R#S+v#S#T#r#T#o+v#o#q#r#q#r$W#r%W#r%W;'S+v;'S;:j-V;:j;=`$g<%lO+vR-YP;=`<%l+vR-dTwPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR-zTUQbPO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR.bTZPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR.xT]PUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR/^VUQO#o#r#o#p/s#p#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR/zTSPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#r~0^TO#q#r#q#r0m#r;'S#r;'S;=`$g<%lO#r~0rOR~",
  tokenizers: [ET, AT, DT, NT, IT, 0, 1],
  topRules: { Content: [0, 2], Attribute: [1, 9] },
  tokenPrec: 0
}), LT = /* @__PURE__ */ Ne.parser.configure({
  top: "SingleExpression"
}), ep = /* @__PURE__ */ MT.configure({
  props: [
    /* @__PURE__ */ se({
      Text: l.content,
      Is: l.definitionOperator,
      AttributeName: l.attributeName,
      "AttributeValue ExpressionAttributeValue StatementAttributeValue": l.attributeValue,
      Entity: l.character,
      InvalidEntity: l.invalid,
      "BoundAttributeName/Identifier": l.attributeName,
      "EventName/Identifier": /* @__PURE__ */ l.special(l.attributeName),
      "ReferenceName/Identifier": l.variableName,
      "DirectiveName/Identifier": l.keyword,
      "{{ }}": l.brace,
      "( )": l.paren,
      "[ ]": l.bracket,
      "# '*'": l.punctuation
    })
  ]
}), La = { parser: LT }, BT = { parser: Ne.parser }, FT = /* @__PURE__ */ ep.configure({
  wrap: /* @__PURE__ */ SO((t, e) => t.name == "InterpolationContent" ? La : null)
}), HT = /* @__PURE__ */ ep.configure({
  wrap: /* @__PURE__ */ SO((t, e) => {
    var O;
    return t.name == "InterpolationContent" ? La : t.name != "AttributeInterpolation" ? null : ((O = t.node.parent) === null || O === void 0 ? void 0 : O.name) == "StatementAttributeValue" ? BT : La;
  }),
  top: "Attribute"
}), KT = { parser: FT }, JT = { parser: HT }, Ba = /* @__PURE__ */ Ht();
function Op(t) {
  return t.configure({ wrap: SO(Ow) }, "angular");
}
const ew = /* @__PURE__ */ Op(Ba.language);
function Ow(t, e) {
  switch (t.name) {
    case "Attribute":
      return /^[*#(\[]|\{\{/.test(e.read(t.from, t.to)) ? JT : null;
    case "Text":
      return KT;
  }
  return null;
}
function tw(t = {}) {
  let e = Ba;
  if (t.base) {
    if (t.base.language.name != "html" || !(t.base.language instanceof re))
      throw new RangeError("The base option must be the result of calling html(...)");
    e = t.base;
  }
  return new le(e.language == Ba.language ? ew : Op(e.language), [e.support, e.language.data.of({
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  })]);
}
const nQ = 1, iw = 2, rw = 3, nw = 82, sw = 76, aw = 117, ow = 85, lw = 97, cw = 122, hw = 65, Qw = 90, fw = 95, Fa = 48, sQ = 34, $w = 40, aQ = 41, uw = 32, oQ = 62, dw = new q((t) => {
  if (t.next == sw || t.next == ow ? t.advance() : t.next == aw && (t.advance(), t.next == Fa + 8 && t.advance()), t.next != nw || (t.advance(), t.next != sQ)) return;
  t.advance();
  let e = "";
  for (; t.next != $w; ) {
    if (t.next == uw || t.next <= 13 || t.next == aQ) return;
    e += String.fromCharCode(t.next), t.advance();
  }
  for (t.advance(); ; ) {
    if (t.next < 0)
      return t.acceptToken(nQ);
    if (t.next == aQ) {
      let O = !0;
      for (let i = 0; O && i < e.length; i++)
        t.peek(i + 1) != e.charCodeAt(i) && (O = !1);
      if (O && t.peek(e.length + 1) == sQ)
        return t.acceptToken(nQ, 2 + e.length);
    }
    t.advance();
  }
}), pw = new q((t) => {
  if (t.next == oQ)
    t.peek(1) == oQ && t.acceptToken(iw, 1);
  else {
    let e = !1, O = 0;
    for (; ; O++) {
      if (t.next >= hw && t.next <= Qw) e = !0;
      else {
        if (t.next >= lw && t.next <= cw) return;
        if (t.next != fw && !(t.next >= Fa && t.next <= Fa + 9)) break;
      }
      t.advance();
    }
    e && O > 1 && t.acceptToken(rw);
  }
}, { extend: !0 }), mw = se({
  "typedef struct union enum class typename decltype auto template operator friend noexcept namespace using requires concept import export module __attribute__ __declspec __based": l.definitionKeyword,
  "extern MsCallModifier MsPointerModifier extern static register thread_local inline const volatile restrict _Atomic mutable constexpr constinit consteval virtual explicit VirtualSpecifier Access": l.modifier,
  "if else switch for while do case default return break continue goto throw try catch": l.controlKeyword,
  "co_return co_yield co_await": l.controlKeyword,
  "new sizeof delete static_assert": l.operatorKeyword,
  "NULL nullptr": l.null,
  this: l.self,
  "True False": l.bool,
  "TypeSize PrimitiveType": l.standard(l.typeName),
  TypeIdentifier: l.typeName,
  FieldIdentifier: l.propertyName,
  "CallExpression/FieldExpression/FieldIdentifier": l.function(l.propertyName),
  "ModuleName/Identifier": l.namespace,
  PartitionName: l.labelName,
  StatementIdentifier: l.labelName,
  "Identifier DestructorName": l.variableName,
  "CallExpression/Identifier": l.function(l.variableName),
  "CallExpression/ScopedIdentifier/Identifier": l.function(l.variableName),
  "FunctionDeclarator/Identifier FunctionDeclarator/DestructorName": l.function(l.definition(l.variableName)),
  NamespaceIdentifier: l.namespace,
  OperatorName: l.operator,
  ArithOp: l.arithmeticOperator,
  LogicOp: l.logicOperator,
  BitOp: l.bitwiseOperator,
  CompareOp: l.compareOperator,
  AssignOp: l.definitionOperator,
  UpdateOp: l.updateOperator,
  LineComment: l.lineComment,
  BlockComment: l.blockComment,
  Number: l.number,
  String: l.string,
  "RawString SystemLibString": l.special(l.string),
  CharLiteral: l.character,
  EscapeSequence: l.escape,
  "UserDefinedLiteral/Identifier": l.literal,
  PreProcArg: l.meta,
  "PreprocDirectiveName #include #ifdef #ifndef #if #define #else #endif #elif": l.processingInstruction,
  MacroName: l.special(l.name),
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace,
  "< >": l.angleBracket,
  ". ->": l.derefOperator,
  ", ;": l.separator
}), Pw = { __proto__: null, bool: 34, char: 34, int: 34, float: 34, double: 34, void: 34, size_t: 34, ssize_t: 34, intptr_t: 34, uintptr_t: 34, charptr_t: 34, int8_t: 34, int16_t: 34, int32_t: 34, int64_t: 34, uint8_t: 34, uint16_t: 34, uint32_t: 34, uint64_t: 34, char8_t: 34, char16_t: 34, char32_t: 34, char64_t: 34, const: 68, volatile: 70, restrict: 72, _Atomic: 74, mutable: 76, constexpr: 78, constinit: 80, consteval: 82, struct: 86, __declspec: 90, final: 148, override: 148, public: 152, private: 152, protected: 152, virtual: 154, extern: 160, static: 162, register: 164, inline: 166, thread_local: 168, __attribute__: 172, __based: 178, __restrict: 180, __uptr: 180, __sptr: 180, _unaligned: 180, __unaligned: 180, noexcept: 194, requires: 198, TRUE: 784, true: 784, FALSE: 786, false: 786, typename: 218, class: 220, template: 234, throw: 248, __cdecl: 256, __clrcall: 256, __stdcall: 256, __fastcall: 256, __thiscall: 256, __vectorcall: 256, try: 260, catch: 264, export: 282, import: 286, case: 296, default: 298, if: 308, else: 314, switch: 318, do: 322, while: 324, for: 330, return: 334, break: 338, continue: 342, goto: 346, co_return: 350, co_yield: 354, using: 362, typedef: 366, namespace: 380, new: 398, delete: 400, co_await: 402, concept: 406, enum: 410, static_assert: 414, friend: 422, union: 424, explicit: 430, operator: 444, module: 456, signed: 518, unsigned: 518, long: 518, short: 518, decltype: 528, auto: 530, sizeof: 566, NULL: 572, nullptr: 586, this: 588 }, gw = { __proto__: null, "<": 131 }, Sw = { __proto__: null, ">": 135 }, Xw = { __proto__: null, operator: 388, new: 576, delete: 582 }, yw = ne.deserialize({
  version: 14,
  states: "$:|Q!QQVOOP'gOUOOO(XOWO'#CdO,RQUO'#CgO,]QUO'#FjO-sQbO'#CwO.UQUO'#CwO0TQUO'#KZO0[QUO'#CvO0gOpO'#DvO0oQ!dO'#D]OOQR'#JO'#JOO5XQVO'#GUO5fQUO'#JVOOQQ'#JV'#JVO8zQUO'#KmO<eQUO'#KmO>{QVO'#E^O?]QUO'#E^OOQQ'#Ed'#EdOOQQ'#Ee'#EeO?bQVO'#EfO@XQVO'#EiOBUQUO'#FPOBvQUO'#FhOOQR'#Fj'#FjOB{QUO'#FjOOQR'#LQ'#LQOOQR'#LP'#LPOETQVO'#KQOFxQUO'#LVOGVQUO'#KqOGkQUO'#LVOH]QUO'#LXOOQR'#HU'#HUOOQR'#HV'#HVOOQR'#HW'#HWOOQR'#K|'#K|OOQR'#J_'#J_Q!QQVOOOHkQVO'#FOOIWQUO'#EhOI_QUOOOKZQVO'#HgOKkQUO'#HgONVQUO'#KqONaQUO'#KqOOQQ'#Kq'#KqO!!_QUO'#KqOOQQ'#Jq'#JqO!!lQUO'#HxOOQQ'#KZ'#KZO!&^QUO'#KZO!&zQUO'#KQO!(zQVO'#I]O!(zQVO'#I`OCQQUO'#KQOOQQ'#Ip'#IpOOQQ'#KQ'#KQO!,}QUO'#KZOOQR'#KY'#KYO!-UQUO'#DYO!/mQUO'#KnOOQQ'#Kn'#KnO!/tQUO'#KnO!/{QUO'#ETO!0QQUO'#EWO!0VQUO'#FRO8zQUO'#FPO!QQVO'#F^O!0[Q#vO'#F`O!0gQUO'#FkO!0oQUO'#FpO!0tQVO'#FrO!0oQUO'#FuO!3sQUO'#FvO!3xQVO'#FxO!4SQUO'#FzO!4XQUO'#F|O!4^QUO'#GOO!4cQVO'#GQO!(zQVO'#GSO!4jQUO'#GpO!4xQUO'#GYO!(zQVO'#FeO!6VQUO'#FeO!6[QVO'#G`O!6cQUO'#GaO!6nQUO'#GnO!6sQUO'#GrO!6xQUO'#GzO!7jQ&lO'#HiO!:mQUO'#GuO!:}QUO'#HXO!;YQUO'#HZO!;bQUO'#DWO!;bQUO'#HuO!;bQUO'#HvO!;yQUO'#HwO!<[QUO'#H|O!=PQUO'#H}O!>uQVO'#IbO!(zQVO'#IdO!?PQUO'#IgO!?WQVO'#IjP!@}{,UO'#CbP!6n{,UO'#CbP!AY{7[O'#CbP!6n{,UO'#CbP!A_{,UO'#CbP!AjOSO'#IzPOOO)CEn)CEnOOOO'#I|'#I|O!AtOWO,59OOOQR,59O,59OO!(zQVO,59UOOQQ,59W,59WO!(zQVO,5;ROOQR,5<U,5<UO!BPQUO,59YO!(zQVO,5>qOOQR'#IX'#IXOOQR'#IY'#IYOOQR'#IZ'#IZOOQR'#I['#I[O!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!(zQVO,5>rO!DOQVO,5>zOOQQ,5?W,5?WO!EqQVO'#ChO!IjQUO'#CyOOQQ,59c,59cOOQQ,59b,59bOOQQ,5<},5<}O!IwQ&lO,5=mO!?PQUO,5?RO!LkQVO,5?UO!LrQbO,59cO!L}QVO'#FYOOQQ,5?P,5?PO!M_QVO,59VO!MfO`O,5:bO!MkQbO'#D^O!M|QbO'#K^O!N[QbO,59wO!NdQbO'#CwO!NuQUO'#CwO!NzQUO'#KZO# UQUO'#CvOOQR-E<|-E<|O# aQUO,5AoO# hQVO'#EfO@XQVO'#EiOBUQUO,5;kOOQR,5<p,5<pO#$aQUO'#KQO#$hQUO'#KQO!(zQVO'#IUO8zQUO,5;kO#${Q&lO'#HiO#(SQUO'#CsO#*wQbO'#CwO#*|QUO'#CvO#.jQUO'#KZOOQQ-E=T-E=TO#0}QUO,5AXO#1XQUO'#KZO#1cQUO,5AXOOQR,5Ao,5AoOOQQ,5>l,5>lO#3gQUO'#CgO#4]QUO,5>pO#6OQUO'#IeOOQR'#I}'#I}O#6WQUO,5:xO#6tQUO,5:xO#7eQUO,5:xO#8YQUO'#CtO!0QQUO'#ClOOQQ'#JW'#JWO#6tQUO,5:xO#8bQUO,5;QO!4xQUO'#C}O#9kQUO,5;QO#9pQUO,5>QO#:|QUO'#C}O#;dQUO,5>{O#;iQUO'#KwO#<rQUO,5;TO#<zQVO,5;TO#=UQUO,5;TOOQQ,5;T,5;TO#>}QUO'#L[O#?UQUO,5>UO#?ZQbO'#CwO#?fQUO'#GcO#?kQUO'#E^O#@[QUO,5;kO#@sQUO'#K}O#@{QUO,5;rOKkQUO'#HfOBUQUO'#HgO#AQQUO'#KqO!6nQUO'#HjO#AxQUO'#CtO!0tQVO,5<SOOQQ'#Cg'#CgOOQR'#Jh'#JhO#A}QVO,5=`OOQQ,5?Z,5?ZO#DWQbO'#CwO#DcQUO'#GcOOQQ'#Ji'#JiOOQQ-E=g-E=gOGVQUO,5AqOGkQUO,5AqO#DhQUO,5AsO#DsQUO'#G|OOQR,5Aq,5AqO#DhQUO,5AqO#EOQUO'#HOO#EWQUO,5AsOOQR,5As,5AsOOQR,5At,5AtO#EfQVO,5AtOOQR-E=]-E=]O#G`QVO,5;jOOQR,5;j,5;jO#IaQUO'#EjO#JfQUO'#EwO#K]QVO'#ExO#MoQUO'#EvO#MwQUO'#EyO#NvQUO'#EzOOQQ'#Kz'#KzO$ mQUO,5;SO$!sQUO'#EvOOQQ,5;S,5;SO$#pQUO,5;SO$%cQUO,5:yO$'|QVO,5>PO$(WQUO'#E[O$(eQUO,5>ROOQQ,5>S,5>SO$,RQVO'#C{OOQQ-E=o-E=oOOQQ,5>d,5>dOOQQ,59`,59`O$,]QUO,5>wO$.]QUO,5>zO!6nQUO,59tO$.pQUO,5;qO$.}QUO,5<{O!0QQUO,5:oOOQQ,5:r,5:rO$/YQUO,5;mO$/_QUO'#KmOBUQUO,5;kOOQR,5;x,5;xO$0OQUO'#FbO$0^QUO'#FbO$0cQUO,5;zO$3|QVO'#FmO!0tQVO,5<VO!0oQUO,5<VO!0VQUO,5<[O$4TQVO'#GUO$7PQUO,5<^O!0tQVO,5<aO$:gQVO,5<bO$:tQUO,5<dOOQR,5<d,5<dO$;}QUO,5<dOOQR,5<f,5<fOOQR,5<h,5<hOOQQ'#Fi'#FiO$<SQUO,5<jO$<XQUO,5<lOOQR,5<l,5<lO$=_QUO,5<nO$>eQUO,5<rO$>pQUO,5=[O$>uQUO,5=[O!4xQUO,5<tO$>}QUO,5<tO$?cQUO,5<PO$@iQVO,5<PO$BzQUO,5<zOOQR,5<z,5<zOOQR,5<{,5<{O$>uQUO,5<{O$DQQUO,5<{O$D]QUO,5=YO!(zQVO,5=^O!(zQVO,5=fO#NeQUO,5=mOOQQ,5>T,5>TO$FbQUO,5>TO$FlQUO,5>TO$FqQUO,5>TO$FvQUO,5>TO!6nQUO,5>TO$HtQUO'#KZO$H{QUO,5=oO$IWQUO,5=aOKkQUO,5=oO$JQQUO,5=sOOQR,5=s,5=sO$JYQUO,5=sO$LeQVO'#H[OOQQ,5=u,5=uO!;]QUO,5=uO%#`QUO'#KjO%#gQUO'#K[O%#{QUO'#KjO%$VQUO'#DyO%$hQUO'#D|O%'eQUO'#K[OOQQ'#K['#K[O%)WQUO'#K[O%#gQUO'#K[O%)]QUO'#K[OOQQ,59r,59rOOQQ,5>a,5>aOOQQ,5>b,5>bO%)eQUO'#HzO%)mQUO,5>cOOQQ,5>c,5>cO%-XQUO,5>cO%-dQUO,5>hO%1OQVO,5>iO%1VQUO,5>|O# hQVO'#EfO%4]QUO,5>|OOQQ,5>|,5>|O%4|QUO,5?OO%7QQUO,5?RO!<[QUO,5?RO%8|QUO,5?UO%<iQVO,5?UP!A_{,UO,58|P%<p{,UO,58|P%=O{7[O,58|P%=U{,UO,58|PO{O'#Ju'#JuP%=Z{,UO'#LcPOOO'#Lc'#LcP%=a{,UO'#LcPOOO,58|,58|POOO,5?f,5?fP%=fOSO,5?fOOOO-E<z-E<zOOQR1G.j1G.jO%=mQUO1G.pO%>sQUO1G0mOOQQ1G0m1G0mO%@PQUO'#CoO%B`QbO'#CwO%BkQUO'#CrO%BpQUO'#CrO%BuQUO1G.tO#AxQUO'#CqOOQQ1G.t1G.tO%DxQUO1G4]O%FOQUO1G4^O%GqQUO1G4^O%IdQUO1G4^O%KVQUO1G4^O%LxQUO1G4^O%NkQUO1G4^O&!^QUO1G4^O&$PQUO1G4^O&%rQUO1G4^O&'eQUO1G4^O&)WQUO1G4^O&*yQUO'#KPO&,SQUO'#KPO&,[QUO,59SOOQQ,5=P,5=PO&.dQUO,5=PO&.nQUO,5=PO&.sQUO,5=PO&.xQUO,5=PO!6nQUO,5=PO#NeQUO1G3XO&/SQUO1G4mO!<[QUO1G4mO&1OQUO1G4pO&2qQVO1G4pOOQQ1G.}1G.}OOQQ1G.|1G.|OOQQ1G2i1G2iO!IwQ&lO1G3XO&2xQUO'#LOO@XQVO'#EiO&4RQUO'#F]OOQQ'#Ja'#JaO&4WQUO'#FZO&4cQUO'#LOO&4kQUO,5;tO&4pQUO1G.qOOQQ1G.q1G.qOOQR1G/|1G/|O&6cQ!dO'#JPO&6hQbO,59xO&8yQ!eO'#D`O&9QQ!dO'#JRO&9VQbO,5@xO&9VQbO,5@xOOQR1G/c1G/cO&9bQbO1G/cO&9gQ&lO'#GeO&:eQbO,59cOOQR1G7Z1G7ZO#@[QUO1G1VO&:pQUO1G1^OBUQUO1G1VO&=RQUO'#CyO#*wQbO,59cO&@tQUO1G6sOOQR-E<{-E<{O&BWQUO1G0dO#6WQUO1G0dOOQQ-E=U-E=UO#6tQUO1G0dOOQQ1G0l1G0lO&B{QUO,59iOOQQ1G3l1G3lO&CcQUO,59iO&CyQUO,59iO!M_QVO1G4gO!(zQVO'#JYO&DeQUO,5AcOOQQ1G0o1G0oO!(zQVO1G0oO!6nQUO'#JnO&DmQUO,5AvOOQQ1G3p1G3pOOQR1G1V1G1VO&HjQVO'#FOO!M_QVO,5;sOOQQ,5;s,5;sOBUQUO'#JcO&JfQUO,5AiO&JnQVO'#E[OOQR1G1^1G1^O&M]QUO'#L[OOQR1G1n1G1nOOQR-E=f-E=fOOQR1G7]1G7]O#DhQUO1G7]OGVQUO1G7]O#DhQUO1G7_OOQR1G7_1G7_O&MeQUO'#G}O&MmQUO'#LWOOQQ,5=h,5=hO&M{QUO,5=jO&NQQUO,5=kOOQR1G7`1G7`O#EfQVO1G7`O&NVQUO1G7`O' ]QVO,5=kOOQR1G1U1G1UO$.vQUO'#E]O'!RQUO'#E]OOQQ'#Ky'#KyO'!lQUO'#KxO'!wQUO,5;UO'#PQUO'#ElO'#dQUO'#ElO'#wQUO'#EtOOQQ'#J['#J[O'#|QUO,5;cO'$sQUO,5;cO'%nQUO,5;dO'&tQVO,5;dOOQQ,5;d,5;dO''OQVO,5;dO'&tQVO,5;dO''VQUO,5;bO'(SQUO,5;eO'(_QUO'#KpO'(gQUO,5:vO'(lQUO,5;fOOQQ1G0n1G0nOOQQ'#J]'#J]O''VQUO,5;bO!4xQUO'#E}OOQQ,5;b,5;bO')gQUO'#E`O'+aQUO'#E{OHrQUO1G0nO'+fQUO'#EbOOQQ'#JX'#JXO'-OQUO'#KrOOQQ'#Kr'#KrO'-xQUO1G0eO'.pQUO1G3kO'/vQVO1G3kOOQQ1G3k1G3kO'0QQVO1G3kO'0XQUO'#L_O'1eQUO'#KXO'1sQUO'#KWO'2OQUO,59gO'2WQUO1G/`O'2]QUO'#FPOOQR1G1]1G1]OOQR1G2g1G2gO$>uQUO1G2gO'2gQUO1G2gO'2rQUO1G0ZOOQR'#J`'#J`O'2wQVO1G1XO'8pQUO'#FTO'8uQUO1G1VO!6nQUO'#JdO'9TQUO,5;|O$0^QUO,5;|OOQQ'#Fc'#FcOOQQ,5;|,5;|O'9cQUO1G1fOOQR1G1f1G1fO'9kQUO,5<XO$.vQUO'#FWOBUQUO'#FWO'9rQUO,5<XO!(zQVO,5<XO'9zQUO,5<XO':PQVO1G1qO!0tQVO1G1qOOQR1G1v1G1vO'?oQUO1G1xOOQR1G1{1G1{O'?tQUO1G1|OBUQUO1G2]O'@}QVO1G1|O'CcQUO1G1|O'ChQUO'#GWO8zQUO1G2]OOQR1G2O1G2OOOQR1G2U1G2UOOQR1G2W1G2WOOQR1G2Y1G2YO'CmQUO1G2^O!4xQUO1G2^OOQR1G2v1G2vO'CuQUO1G2vO$>}QUO1G2`OOQQ'#Cu'#CuO'CzQUO'#G[O'DuQUO'#G[O'DzQUO'#LRO'EYQUO'#G_OOQQ'#LS'#LSO'EhQUO1G2`O'EmQVO1G1kO'HOQVO'#GUOBUQUO'#FWOOQR'#Je'#JeO'EmQVO1G1kO'HYQUO'#FvOOQR1G2f1G2fO'H_QUO1G2gO'HdQUO'#JgO'2gQUO1G2gO!(zQVO1G2tO'HlQUO1G2xO'IuQUO1G3QO'J{QUO1G3XOOQQ1G3o1G3oO'KaQUO1G3oOOQR1G3Z1G3ZO'KfQUO'#KZO'2]QUO'#LTOGkQUO'#LVOOQR'#Gy'#GyO#DhQUO'#LXOOQR'#HQ'#HQO'KpQUO'#GvO'#wQUO'#GuOOQR1G2{1G2{O'LmQUO1G2{O'MdQUO1G3ZO'MoQUO1G3_O'MtQUO1G3_OOQR1G3_1G3_O'M|QUO'#H]OOQR'#H]'#H]O( VQUO'#H]O!(zQVO'#H`O!(zQVO'#H_OOQR'#LZ'#LZO( [QUO'#LZOOQR'#Jk'#JkO( aQVO,5=vOOQQ,5=v,5=vO( hQUO'#H^O( pQUO'#HZOOQQ1G3a1G3aO( zQUO,5@vOOQQ,5@v,5@vO%)WQUO,5@vO%)]QUO,5@vO%$VQUO,5:eO(%iQUO'#KkO(%wQUO'#KkOOQQ,5:e,5:eOOQQ'#JS'#JSO(&SQUO'#D}O(&^QUO'#KqOGkQUO'#LVO('YQUO'#D}OOQQ'#Hp'#HpOOQQ'#Hr'#HrOOQQ'#Hs'#HsOOQQ'#Kl'#KlOOQQ'#JU'#JUO('dQUO,5:hOOQQ,5:h,5:hO((aQUO'#LVO((nQUO'#HtO()UQUO,5@vO()]QUO'#H{O()hQUO'#L^O()pQUO,5>fO()uQUO'#L]OOQQ1G3}1G3}O(-lQUO1G3}O(-sQUO1G3}O(-zQUO1G4TO(/QQUO1G4TO(/VQUO,5A|O!6nQUO1G4hO!(zQVO'#IiOOQQ1G4m1G4mO(/[QUO1G4mO(1_QVO1G4pPOOO1G.h1G.hP!A_{,UO1G.hP(3_QUO'#LeP(3j{,UO1G.hP(3o{7[O1G.hPO{O-E=s-E=sPOOO,5A},5A}P(3w{,UO,5A}POOO1G5Q1G5QO!(zQVO7+$[O(3|QUO'#CyOOQQ,59^,59^O(4XQbO,59cO(4dQbO,59^OOQQ,59],59]OOQQ7+)w7+)wO!M_QVO'#JtO(4oQUO,5@kOOQQ1G.n1G.nOOQQ1G2k1G2kO(4wQUO1G2kO(4|QUO7+(sOOQQ7+*X7+*XO(7bQUO7+*XO(7iQUO7+*XO(1_QVO7+*[O#NeQUO7+(sO(7vQVO'#JbO(8ZQUO,5AjO(8cQUO,5;vOOQQ'#Co'#CoOOQQ,5;w,5;wO!(zQVO'#F[OOQQ-E=_-E=_O!M_QVO,5;uOOQQ1G1`1G1`OOQQ,5?k,5?kOOQQ-E<}-E<}OOQR'#Dg'#DgOOQR'#Di'#DiOOQR'#Dl'#DlO(9lQ!eO'#K_O(9sQMkO'#K_O(9zQ!eO'#K_OOQR'#K_'#K_OOQR'#JQ'#JQO(:RQ!eO,59zOOQQ,59z,59zO(:YQbO,5?mOOQQ-E=P-E=PO(:hQbO1G6dOOQR7+$}7+$}OOQR7+&q7+&qOOQR7+&x7+&xO'8uQUO7+&qO(:sQUO7+&OO#6WQUO7+&OO(;hQUO1G/TO(<OQUO1G/TO(<jQUO7+*ROOQQ7+*V7+*VO(>]QUO,5?tOOQQ-E=W-E=WO(?fQUO7+&ZOOQQ,5@Y,5@YOOQQ-E=l-E=lO(?kQUO'#LOO@XQVO'#EiO(@wQUO1G1_OOQQ1G1_1G1_O(BQQUO,5?}OOQQ,5?},5?}OOQQ-E=a-E=aO(BfQUO'#KpOOQR7+,w7+,wO#DhQUO7+,wOOQR7+,y7+,yO(BsQUO,5=iO#DsQUO'#JjO(CUQUO,5ArOOQR1G3U1G3UOOQR1G3V1G3VO(CdQUO7+,zOOQR7+,z7+,zO(E[QUO,5:wO(FyQUO'#EwO!(zQVO,5;VO(GlQUO,5:wO(GvQUO'#EpO(HXQUO'#EzOOQQ,5;Z,5;ZO#K]QVO'#ExO(HoQUO,5:wO(HvQUO'#EyO#GgQUO'#JZO(J`QUO,5AdOOQQ1G0p1G0pO(JkQUO,5;WO!<[QUO,5;^O(KUQUO,5;_O(KdQUO,5;WO(MvQUO,5;`OOQQ-E=Y-E=YO(NOQUO1G0}OOQQ1G1O1G1OO(NyQUO1G1OO)!PQVO1G1OO)!WQVO1G1OO)!bQUO1G0|OOQQ1G0|1G0|OOQQ1G1P1G1PO)#_QUO'#JoO)#iQUO,5A[OOQQ1G0b1G0bOOQQ-E=Z-E=ZO)#qQUO,5;iO!<[QUO,5;iO)$nQVO,5:zO)$uQUO,5;gO$ mQUO7+&YOOQQ7+&Y7+&YO!(zQVO'#EfO)$|QUO,5:|OOQQ'#Ks'#KsOOQQ-E=V-E=VOOQQ,5A^,5A^OOQQ'#Jl'#JlO)(qQUO7+&PPOQQ7+&P7+&POOQQ7+)V7+)VO))iQUO7+)VO)*oQVO7+)VOOQQ,5>m,5>mO$)YQVO'#JsO)*vQUO,5@rOOQQ1G/R1G/ROOQQ7+$z7+$zO)+RQUO7+(RO)+WQUO7+(ROOQR7+(R7+(RO$>uQUO7+(ROOQQ7+%u7+%uOOQR-E=^-E=^O!0VQUO,5;oOOQQ,5@O,5@OOOQQ-E=b-E=bO$0^QUO1G1hOOQQ1G1h1G1hOOQR7+'Q7+'QOOQR1G1s1G1sOBUQUO,5;rO)+tQUO,5<YO)+{QUO1G1sO)-UQUO1G1sO!0tQVO7+']O)-ZQVO7+']O)2yQUO7+'dO)3OQVO7+'hO)5dQUO7+'wO)5nQUO7+'hO)6tQVO7+'hOKkQUO7+'wO$>hQUO,5<rO!4xQUO7+'xO)6{QUO7+'xOOQR7+(b7+(bO)7QQUO7+'zO)7VQUO,5<vO'CzQUO,5<vO)7}QUO,5<vO'CzQUO,5<vOOQQ,5<w,5<wO)8`QVO,5<xO'EYQUO'#JfO)8jQUO,5AmO)8rQUO,5<yOOQR7+'z7+'zO)8}QVO7+'VO)5gQUO'#K}OOQR-E=c-E=cO);`QVO,5<bOOQQ,5@R,5@RO!6nQUO,5@ROOQQ-E=e-E=eO)=wQUO7+(`O)>}QUO7+(dO)?SQVO7+(dOOQQ7+(l7+(lOOQQ7+)Z7+)ZO)?[QUO'#KjO)?fQUO'#KjOOQR,5=b,5=bO)?sQUO,5=bO!;bQUO,5=bO!;bQUO,5=bO!;bQUO,5=bOOQR7+(g7+(gOOQR7+(u7+(uOOQR7+(y7+(yOOQR,5=w,5=wO)?xQUO,5=zO)AOQUO,5=yOOQR,5Au,5AuOOQR-E=i-E=iOOQQ1G3b1G3bO)BUQUO,5=xO)BZQVO'#EfOOQQ1G6b1G6bO%)WQUO1G6bO%)]QUO1G6bOOQQ1G0P1G0POOQQ-E=Q-E=QO)DrQUO,5AVO(%iQUO'#JTO)D}QUO,5AVO)D}QUO,5AVO)EVQUO,5:iO8zQUO,5:iOOQQ,5>],5>]O)EaQUO,5AqO)EhQUO'#EVO)FrQUO'#EVO)G]QUO,5:iO)GgQUO'#HlO)GgQUO'#HmOOQQ'#Ko'#KoO)HUQUO'#KoO!(zQVO'#HnOOQQ,5:i,5:iO)HvQUO,5:iO!M_QVO,5:iOOQQ-E=S-E=SOOQQ1G0S1G0SOOQQ,5>`,5>`O)H{QUO1G6bO!(zQVO,5>gO)LjQUO'#JrO)LuQUO,5AxOOQQ1G4Q1G4QO)L}QUO,5AwOOQQ,5Aw,5AwOOQQ7+)i7+)iO*!lQUO7+)iOOQQ7+)o7+)oO*'kQVO1G7hO*)mQUO7+*SO*)rQUO,5?TO**xQUO7+*[POOO7+$S7+$SP*,kQUO'#LfP*,sQUO,5BPP*,x{,UO7+$SPOOO1G7i1G7iO*,}QUO<<GvOOQQ1G.x1G.xOOQQ'#IT'#ITO*.pQUO,5@`OOQQ,5@`,5@`OOQQ-E=r-E=rOOQQ7+(V7+(VOOQQ<<Ms<<MsO*/yQUO<<MsO*1|QUO<<MvO*3oQUO<<L_O*4TQUO,5?|OOQQ,5?|,5?|OOQQ-E=`-E=`OOQQ1G1b1G1bO*5^QUO,5;vO*6dQUO1G1aOOQQ1G1a1G1aOOQR,5@y,5@yO*7mQ!eO,5@yO*7tQMkO,5@yO*7{Q!eO,5@yOOQR-E=O-E=OOOQQ1G/f1G/fO*8SQ!eO'#DwOOQQ1G5X1G5XOOQR<<J]<<J]O*8ZQUO<<IjO*9OQUO7+$oOOQQ<<Iu<<IuO(7vQVO,5;ROOQR<=!c<=!cOOQQ1G3T1G3TOOQQ,5@U,5@UOOQQ-E=h-E=hOOQR<=!f<=!fO*9{QUO1G0cO*:SQUO'#EzO*:dQUO1G0cO*:kQUO'#I}O*<RQUO1G0qO!(zQVO1G0qOOQQ,5;[,5;[OOQQ,5;],5;]OOQQ,5?u,5?uOOQQ-E=X-E=XO!<[QUO1G0xO*=bQUO1G0xOOQQ1G0y1G0yO*=sQUO'#ElOOQQ1G0z1G0zOOQQ7+&j7+&jO*>XQUO7+&jO*?_QVO7+&jOOQQ7+&h7+&hOOQQ,5@Z,5@ZOOQQ-E=m-E=mO*@ZQUO1G1TO*@eQUO1G1TO*AOQUO1G0fOOQQ1G0f1G0fO*BUQUO'#K{O*B^QUO1G1ROOQQ<<It<<ItOOQQ'#Hb'#HbO'+fQUO,5={OOQQ'#Hd'#HdO'+fQUO,5=}OOQQ-E=j-E=jPOQQ<<Ik<<IkPOQQ-E=k-E=kOOQQ<<Lq<<LqO*BcQUO'#LaO*CoQUO'#L`OOQQ,5@_,5@_OOQQ-E=q-E=qOOQR<<Km<<KmO$>uQUO<<KmO*C}QUO<<KmOOQR1G1Z1G1ZOOQQ7+'S7+'SO!M_QVO1G1tO*DSQUO1G1tOOQR7+'_7+'_OOQR<<Jw<<JwO!0tQVO<<JwOOQR<<KO<<KOO*D_QUO<<KSO*EeQVO<<KSOKkQUO<<KcO!M_QVO<<KcO*ElQUO<<KSO!0tQVO<<KSO*FuQUO<<KSO*FzQUO<<KcO*GVQUO<<KdOOQR<<Kd<<KdOOQR<<Kf<<KfO*G[QUO1G2bO)7VQUO1G2bO'CzQUO1G2bO*GmQUO1G2dO*HsQVO1G2dOOQQ1G2d1G2dO*H}QVO1G2dO*IUQUO,5@QOOQQ-E=d-E=dOOQQ1G2e1G2eO*IdQUO1G1|O*JmQVO1G1|O*JtQUO1G1|OOQQ1G5m1G5mOOQR<<Kz<<KzOOQR<<LO<<LOO*JyQVO<<LOO*KUQUO<<LOOOQR1G2|1G2|O*KZQUO1G2|O*KbQUO1G3eOOQR1G3d1G3dOOQQ7++|7++|O%)WQUO7++|O*KmQUO1G6qO*KmQUO1G6qO(%iQUO,5?oO*KuQUO,5?oOOQQ-E=R-E=RO*LQQUO1G0TOOQQ1G0T1G0TO*L[QUO1G0TO!M_QVO1G0TO*LaQUO1G0TOOQQ1G3w1G3wO*LkQUO,5:qO)EhQUO,5:qO*MXQUO,5:qO)EhQUO,5:qO$#uQUO,5:uO*MvQVO,5>VO)GgQUO'#JpO*NQQUO1G0TO*NcQVO1G0TOOQQ1G3u1G3uO*NjQUO,5>WO*NuQUO,5>XO+ dQUO,5>YO+!jQUO1G0TO%)]QUO7++|O+#pQUO1G4ROOQQ,5@^,5@^OOQQ-E=p-E=pOOQQ<<MT<<MTOOQQ<<Mn<<MnO+$yQUO1G4oP+&|QUO'#JvP+'UQUO,5BQPO{O1G7k1G7kPOOO<<Gn<<GnOOQQANC_ANC_OOQR1G6e1G6eO+'^Q!eO,5:cOOQQ,5:c,5:cO+'eQUO1G0mO+(qQUO7+&]O+*QQUO7+&dO+*cQUO,5;WOOQQ<<JU<<JUO+*qQUO7+&oOOQQ7+&Q7+&QO!4xQUO'#J^O++lQUO,5AgOOQQ7+&m7+&mOOQQ1G3g1G3gO++tQUO1G3iOOQQ,5>n,5>nO+/iQUOANAXOOQRANAXANAXO+/nQUO7+'`OOQRAN@cAN@cO+0zQVOAN@nO+1RQUOAN@nO!0tQVOAN@nO+2[QUOAN@nO+2aQUOAN@}O+2lQUOAN@}O+3rQUOAN@}OOQRAN@nAN@nO!M_QVOAN@}OOQRANAOANAOO+3wQUO7+'|O)7VQUO7+'|OOQQ7+(O7+(OO+4YQUO7+(OO+5`QVO7+(OO+5gQVO7+'hO+5nQUOANAjOOQR7+(h7+(hOOQR7+)P7+)PO+5sQUO7+)PO+5xQUO7+)POOQQ<= h<= hO+6QQUO7+,]O+6YQUO1G5ZOOQQ1G5Z1G5ZO+6eQUO7+%oOOQQ7+%o7+%oO+6vQUO7+%oO*NcQVO7+%oOOQQ7+)a7+)aO+6{QUO7+%oO+8RQUO7+%oO!M_QVO7+%oO+8]QUO1G0]O*LkQUO1G0]O)EhQUO1G0]OOQQ1G0a1G0aO+8zQUO1G3qO+:QQVO1G3qOOQQ1G3q1G3qO+:[QVO1G3qO+:cQUO,5@[OOQQ-E=n-E=nOOQQ1G3r1G3rO%)WQUO<= hOOQQ7+*Z7+*ZPOQQ,5@b,5@bPOQQ-E=t-E=tOOQQ1G/}1G/}OOQQ,5?x,5?xOOQQ-E=[-E=[OOQRG26sG26sO+:zQUOG26YO!0tQVOG26YO+<TQUOG26YOOQRG26YG26YO!M_QVOG26iO!0tQVOG26iO+<YQUOG26iO+=`QUOG26iO+=eQUO<<KhOOQQ<<Kj<<KjOOQRG27UG27UOOQR<<Lk<<LkO+=vQUO<<LkOOQQ7+*u7+*uOOQQ<<IZ<<IZO+={QUO<<IZO!M_QVO<<IZO+>QQUO<<IZO+?WQUO<<IZO*NcQVO<<IZOOQQ<<L{<<L{O+?iQUO7+%wO*LkQUO7+%wOOQQ7+)]7+)]O+@WQUO7+)]O+A^QVO7+)]OOQQANESANESO!0tQVOLD+tOOQRLD+tLD+tO+AeQUOLD,TO+BkQUOLD,TOOQRLD,TLD,TO!0tQVOLD,TOOQRANBVANBVOOQQAN>uAN>uO+BpQUOAN>uO+CvQUOAN>uO!M_QVOAN>uO+C{QUO<<IcOOQQ<<Lw<<LwOOQR!$( `!$( `O!0tQVO!$( oOOQR!$( o!$( oOOQQG24aG24aO+DjQUOG24aO+EpQUOG24aOOQR!)9EZ!)9EZOOQQLD){LD){O+EuQUO'#CgO(dQUO'#CgO+IrQUO'#CyO+LcQUO'#CyO!E{QUO'#CyO+M[QUO'#CyO+MoQUO'#CyO,#bQUO'#CyO,#rQUO'#CyO,$PQUO'#CyO,$[QbO,59cO,$gQbO,59cO,$rQbO,59cO,$}QbO'#CwO,%`QbO'#CwO,%qQbO'#CwO,&SQUO'#CgO,(gQUO'#CgO,(tQUO'#CgO,+iQUO'#CgO,.lQUO'#CgO,.|QUO'#CgO,2uQUO'#CgO,2|QUO'#CgO,3|QUO'#CgO,6VQUO,5:xO#?kQUO,5:xO#?kQUO,5:xO#=ZQUO'#L[O,6sQbO'#CwO,7OQbO'#CwO,7ZQbO'#CwO,7fQbO'#CwO#6tQUO'#E^O,7qQUO'#E^O,9OQUO'#HgO,9pQbO'#CwO,9{QbO'#CwO,:WQUO'#CvO,:]QUO'#CvO,:bQUO'#CoO,:pQbO,59cO,:{QbO,59cO,;WQbO,59cO,;cQbO,59cO,;nQbO,59cO,;yQbO,59cO,<UQbO,59cO,6VQUO1G0dO,<aQUO1G0dO#?kQUO1G0dO,7qQUO1G0dO,>nQUO'#KZO,?OQUO'#CyO,?^QbO,59cO,6VQUO7+&OO,<aQUO7+&OO,?iQUO'#EwO,@[QUO'#EzO,@{QUO'#E^O,AQQUO'#GcO,AVQUO'#CvO,A[QUO'#CwO,AaQUO'#CwO,AfQUO'#CvO,AkQUO'#GcO,ApQUO'#KZO,B^QUO'#KZO,BhQUO'#CvO,BsQUO'#CvO,COQUO'#CvO,<aQUO,5:xO,7qQUO,5:xO,7qQUO,5:xO,CZQUO'#KZO,CnQbO'#CwO,CyQUO'#CrO,DOQUO'#E^",
  stateData: ",Dt~O(nOSSOSTOSRPQVPQ'ePQ'gPQ'hPQ'iPQ'jPQ'kPQ'lPQ'mPQ~O*ZOS~OPmO]eOa!]Od!POlTOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!TxO!VfO!X!XO!Y!WO!i!YO!opO!r!`O!s!aO!t!aO!u!bO!v!aO!x!cO!{!dO#V#QO#a#VO#b#TO#i#OO#p!xO#t!fO#v!eO$R!gO$T!hO$Y!vO$Z!wO$`!iO$e!jO$g!kO$h!lO$k!mO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO${!tO$}!uO%U!yO%_#ZO%`#[O%a#YO%c!zO%e#UO%g!{O%l#SO%o!|O%v!}O%|#PO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(rRO)PYO)SaO)U|O)V{O)WiO)X!ZO)YXO)hcO)idO~OR#bOV#]O'e#^O'g#_O'h#`O'i#`O'j#aO'k#aO'l#_O'm#_O~OX#dO(p#dO(q#fO~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!TiX!VZX!ViX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX!riX!siX!tiX!uiX!viX!xiX!{iX%viX&riX&siX(riX(uZX(v$]X(wZX(xZX)SZX)SiX)TZX)UZX)UiX)VZX)ViX)WZX)XZX)jZX~O)WiX!UZX~P(dO]#}O!V#lO!X#{O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO(w#kO(x#kO)S#mO)T#oO)U#nO)V#pO)W#jO)X#|O~Od$RO%Y$SO'[$TO'_$UO(y$OO~Ol$VO~O!T$WO](}Xd(}Xr(}Xs(}Xt(}Xu(}Xv(}Xw(}Xx(}Xy(}X}(}X!V(}X!r(}X!s(}X!t(}X!u(}X!v(}X!x(}X!{(}X%v(}X&r(}X&s(}X(r(}X)S(}X)U(}X)V(}X)W(}X~Ol$VO~P.ZOl$VO!g$YO)j$YO~OX$ZO)Z$ZO~O!R$[O)X)QP)])QP~OPmO]$eOa!]Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!TxO!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO#v!eO$Y!vO$Z!wO$`!iO$e!jO$g!kO$h!lO$k!mO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO)PYO)S$kO)V$kO)WiO)X!ZO)YXO)hcO)idO~Ol$_O#t$lO(rRO~P0zO](]Xa'yXd(]Xl'yXl(]Xr'yXr(]Xs'yXs(]Xt'yXt(]Xu'yXu(]Xv'yXv(]Xw'yXw(]Xx'yXx(]Xy'yXy(]X{'yX}'yX!V(]X!o(]X!r'yX!r(]X!s'yX!s(]X!t'yX!t(]X!u'yX!u(]X!v'yX!v(]X!x'yX!x(]X!{(]X#a'yX#b'yX%e'yX%l'yX%o(]X%v(]X&m'yX&r'yX&s'yX(r'yX(r(]X)S(]X)U(]X)V(]X~Oa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#a#VO#b#TO%e#UO%l#SO&m!RO&r#WO&s!TO(r$nO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO&r#WO&s$wO])aXd)aXl)aX!V)aX!{)aX%v)aX(r)aX)S)aX)U)aX)V)aX~O)W$vO~P:nOPmO]eOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!VfO!X!XO!Y!WO!i!YO!{!dO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO)SaO)U|O)V{O)X!ZO)YXO)hcO)idO~Oa%QOl:zO!|%RO(r$xO~P<lO)S%SO~Oa!]Ol$_O{#RO#a#VO#b#TO%e#UO%l#SO&m!RO&r#WO&s!TO(r:}O~P<lOPmO]$eOa%QOl:zO!V$fO!W%_O!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V%]O)X!ZO)YXO)hcO)idO)j%[O~O]%hOd!POl%bO!V%kO!{!dO%v$mO(r;OO)S%dO)U%iO)V%iO~O(v%mO~O)W#jO~O(r%nO](tX!V(tX!X(tX!Y(tX![(tX!^(tX!_(tX!a(tX!b(tX!c(tX!e(tX!f(tX!h(tX(u(tX(w(tX(x(tX)S(tX)T(tX)U(tX)V(tX)W(tX)X(tX!g(tX)j(tX!O(tX!W(tX(v(tX!U(tXQ(tX!d(tX~OP%oO(oQO~PCQO]%hOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V%kO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO!{!dO%o!|O%v!}O)S;`O)U|O)V|O~Ol%rO!o%wO(r$xO~PE_O!TxO#v!eO(v%yO)j%|O])eX!V)eX~O]%hOd!POl%rO!V%kO!{!dO%v!}O(r$xO)S;`O)U|O)V|O~O!TxO#v!eO)W&PO)j&QO~O!U&TO~P!QO]&YO!TxO!V&WO)S&VO)U&ZO)V&ZO~Op&UO~PHrO]&cO!V&bO~OPmO]eOd!PO!VfO!X!XO!Y!WO!i!YO!{!dO#V#QO%_#ZO%`#[O%a#YO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO)SaO)U|O)V{O)X!ZO)YXO)hcO)idO~Oa%QOl:zO%v$mO(r$xO~PIgO]%hOd!POl;[O!V%kO!{!dO%v$mO(r$xO)S;`O)U|O)V|O~Op&fO](tX])eX!V(tX!V)eX!X(tX!Y(tX![(tX!^(tX!_(tX!a(tX!b(tX!c(tX!e(tX!f(tX!h(tX(u(tX(w(tX(x(tX)S(tX)T(tX)U(tX)V(tX)W(tX)X(tX!O(tX!O)eX!U(tX~O!g$YO)j$YO~PL]O!g(tX)j(tX~PL]O](tX!V(tX!X(tX!Y(tX![(tX!^(tX!_(tX!a(tX!b(tX!c(tX!e(tX!f(tX!h(tX(u(tX(w(tX(x(tX)S(tX)T(tX)U(tX)V(tX)W(tX)X(tX!g(tX)j(tX!O(tX!U(tX~O])eX!V)eX!O)eX~PNkOa&hO&m!RO]&lXd&lXl&lXr&lXs&lXt&lXu&lXv&lXw&lXx&lXy&lX}&lX!V&lX!r&lX!s&lX!t&lX!u&lX!v&lX!x&lX!{&lX%v&lX&r&lX&s&lX(r&lX)S&lX)U&lX)V&lX)W&lX!O&lX!T&lX!X&lX!Y&lX![&lX!^&lX!_&lX!a&lX!b&lX!c&lX!e&lX!f&lX!h&lX(u&lX(w&lX(x&lX)T&lX)X&lX!g&lX)j&lX!W&lXQ&lX!d&lX(v&lX!U&lX#v&lX~Op&fOl(}X!O(}XQ(}X!d(}X!h(}X)X(}X)j(}X~P.ZO!g$YO)j$YO](tX!V(tX!X(tX!Y(tX![(tX!^(tX!_(tX!a(tX!b(tX!c(tX!e(tX!f(tX!h(tX(u(tX(w(tX(x(tX)S(tX)T(tX)U(tX)V(tX)W(tX)X(tX!O(tX!W(tX(v(tX!U(tXQ(tX!d(tX~OPmO]$eOa%QOl:zO!V$fO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V$kO)X!ZO)YXO)hcO)idO~O](}Xd(}Xl(}Xr(}Xs(}Xt(}Xu(}Xv(}Xw(}Xx(}Xy(}X}(}X!V(}X!r(}X!s(}X!t(}X!u(}X!v(}X!x(}X!{(}X%v(}X&r(}X&s(}X(r(}X)S(}X)U(}X)V(}X)W(}X!O(}XQ(}X!d(}X!h(}X)X(}X)j(}X~O]#}O~P!*qO]&lO~O])bXa)bXd)bXl)bXr)bXs)bXt)bXu)bXv)bXw)bXx)bXy)bX{)bX})bX!V)bX!o)bX!r)bX!s)bX!t)bX!u)bX!v)bX!x)bX!{)bX#a)bX#b)bX%e)bX%l)bX%o)bX%v)bX&m)bX&r)bX&s)bX(r)bX)S)bX)U)bX)V)bX~O(oQO~P!-ZO%U&nO~P!-ZO]&oO~O]#}O~O!TxO~O$W&wO(r%nO(v&vO~O]&xOw&zO~O]&xO~OPmO]$eOa%QOl:zO!TxO!V$fO!X!XO!Y!WO!i!YO#V#QO#p!xO#v!eO$Y!vO$Z!wO$`!iO$e!jO$g!kO$h!lO$k!mO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r:mO)PYO)S$kO)V$kO)WiO)X!ZO)YXO)hcO)idO~O]'PO~O!T$WO)W'RO~P!(zO)W'TO~O)W'UO~O(r'VO~O)W'YO~P!(zOl;^O%U'^O%e'^O(r;PO~Oa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO#a#VO#b#TO%e#UO%l#SO&m!RO&r#WO&s!TO(r$nO~O(v'bO~O)W'dO~P!(zO!TxO(r%nO)j'fO~O(r%nO~O]'iO~O]'jOd%nXl%nX!V%nX!{%nX%v%nX(r%nX)S%nX)U%nX)V%nX~O]'nO!V'oO!X'lO!g'lO%Z'lO%['lO%]'lO%^'lO%_'pO%`'pO%a'lO(x'mO)j'lO)x'qO~P8zO]%hOa!TOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V%kO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO!{!dO#a#VO#b#TO%e#UO%l#SO&m!RO&r#WO&s!TO)S;`O)U|O)V|O~Ol;_Op&UO%v$mO(r;QO~P!8jO(r%nO(v'vO)W'wO~O]&cO!T'yO~Ol$oO}!_O!T(QO!l(VO(r$nO(v(PO)PYO~Ol$oO{(^O!T(ZO#b(^O(r$nO~Oa!TOl$oO{#RO#a#VO#b#TO%e#UO%l#SO&m!RO&r#WO&s!TO(r$nO~O](`O~OPmOa%QOl:zO!V$fO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V$kO)YXO)hcO)idO~O](bO)X(cO~P!=UO]#}O~P!<[OPmO]$eOa%QOl:zO!V(iO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V$kO)X!ZO)YXO)hcO)idO~OY(jO(oQO(r%nO~O'f(mO~OS(qOT(nO*W(pO~O]#}O(n(tO~Q'nXX#dO(p#dO(q(vO~Od)QOl({O&r#WO(r(zO~O!Y'Sa!['Sa!^'Sa!_'Sa!a'Sa!b'Sa!c'Sa!e'Sa!f'Sa!h'Sa(u'Sa)S'Sa)T'Sa)U'Sa)V'Sa)W'Sa)X'Sa!g'Sa)j'Sa!O'Sa!W'Sa(v'Sa!U'SaQ'Sa!d'Sa~OPmOa%QOl:zO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)YXO)hcO)idO]'Sa!V'Sa!X'Sa(w'Sa(x'Sa~P!B_O!T$WO!O(sP~P!(zO]nX]%WXdnXlmXpnXp%WXrnXsnXtnXunXvnXwnXxnXynX}nX!TnX!VnX!V%WX!X%WX!Y%WX![%WX!^%WX!_%WX!a%WX!b%WX!c%WX!e%WX!f%WX!gmX!h%WX!rnX!snX!tnX!unX!vnX!xnX!{nX%vnX&rnX&snX(rnX(u%WX(w%WX(x%WX)SnX)S%WX)T%WX)UnX)U%WX)VnX)V%WX)W%WX)X%WX)jmX!O%WX~O)WnX!OnX!U%WX~P!E{O])dO!V)eO!X)bO!g)bO%Z)bO%[)bO%])bO%^)bO%_)fO%`)fO%a)bO(x)cO)j)bO)x)gO~P8zOPmO]$eOa%QOl:zO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V$kO)X!ZO)YXO)hcO)idO~O!V)lO~P!JwOd)oO%Y)pO(y$OO~O!T$WO!V)rO(w)sO!U)rP~P!JwO!T$WO~P!(zO)[)zO~Ol){O]!QX!h!QX)X!QX)]!QX~O])}O!h*OO)X)QX)])QX~O)X*SO)]*RO~Od$RO%Y*TO'[$TO'_$UO(y$OO~Ol*UO~Ol*UO!O(}X~P.ZOl*UO!g$YO)j$YO~O)W*VO~P:nOPmO]$eOa!]Ol$_Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r:}O)S$kO)V$kO)X!ZO)YXO)hcO)idO~Op&fO~P!&zOp&fO!W(tX(v(tXQ(tX!d(tX~PNkO]'nO!V'oO!X'lO!g'lO%Z'lO%['lO%]'lO%^'lO%_'pO%`'pO%a'lO(x'mO)j'lO)x'qO~O]iXdiXlgXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%viX&riX&siX(riX)SiX)UiX)ViX!TiX!hiX)XiX)jiX!OiX~O!liX(viX)WiX!XiX!YiX![iX!^iX!_iX!aiX!biX!ciX!eiX!fiX(uiX(wiX(xiX)TiX!giX!WiXQiX!diX!UiX#viX#TiX#ViX#piXaiX{iX!oiX#aiX#biX#iiX#tiX${iX%ciX%eiX%kiX%liX%oiX&miX)PiX~P#%yO(y*ZO~Ol*[O~O](}Xd(}Xr(}Xs(}Xt(}Xu(}Xv(}Xw(}Xx(}Xy(}X}(}X!V(}X!r(}X!s(}X!t(}X!u(}X!v(}X!x(}X!{(}X%v(}X&r(}X&s(}X(r(}X)S(}X)U(}X)V(}X)W(}X!T(}X!X(}X!Y(}X![(}X!^(}X!_(}X!a(}X!b(}X!c(}X!e(}X!f(}X!h(}X(u(}X(w(}X(x(}X)T(}X)X(}X!g(}X)j(}X!O(}X!W(}XQ(}X!d(}X(v(}X!U(}X#v(}X~Ol*[O~P#+ROr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO])aad)aal)aa!V)aa!{)aa%v)aa(r)aa)S)aa)U)aa)V)aaQ)aa!d)aa!h)aa)X)aa)j)aa!O)aa!T)aa(v)aa)W)aa~O&r#WO&s$wO~P#.qOp&fOl(}X~P#+RO&r)aa~P#.qO]ZXlgXpZXpiX!TiX!VZX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX(uZX(wZX(xZX)SZX)TZX)UZX)VZX)WZX)XZX)jZX!OZX~O!WZX(vZX!UZXQZX!dZX~P#1jO]#}O!V#lO!X#{O(w#kO(x#kO~O!Y&xa![&xa!^&xa!_&xa!a&xa!b&xa!c&xa!e&xa!f&xa!g&xa!h&xa(u&xa)S&xa)T&xa)U&xa)V&xa)W&xa)X&xa)j&xa!O&xa!W&xa(v&xa!U&xaQ&xa!d&xa~P#3zOl;hO!T$WO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~PKkOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!|%RO~PKkO]&cO!V&bO!O#Qa!T#Qa!h#Qa#v#Qa)W#Qa)j#QaQ#Qa!d#Qa(v#Qa~Op&fO!T$WO~O!O*cO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O*cO~O]&cO!O*eO!V&bO~O]&YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V&WO&r#WO&s$wO)S&VO)U&ZO)V&ZO~O!OqXQqX!dqX!hqX)XqX)WqX~P#9{O!O*hO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h*iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!W)kX~P#3zO!W*kO!h*lO~O!W*kO!h*lO~P!(zO!W*kO~Op&fO!g$YO!h*mO)j$YO](tX!V(tX!W(tX!W*OX!X(tX!Y(tX![(tX!^(tX!_(tX!a(tX!b(tX!c(tX!e(tX!f(tX(u(tX(w(tX(x(tX)S(tX)T(tX)U(tX)V(tX)X(tX~O!h(tX~P#=ZO!W*oO~Od$RO%Y*TO(y:rO~Ol;kO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!|%RO~PBUO]*vO!T*qO!V&bO!h*tO#v!eO)j*rO)W)qX~O!h*tO)W)qX~O)W*wO~Op&fO])eX!T)eX!V)eX!h)eX#v)eX)W)eX)j)eX!O)eXQ)eX!d)eX(v)eX~Op&fO~OP%oO(oQO]%ha!V%ha!X%ha!Y%ha![%ha!^%ha!_%ha!a%ha!b%ha!c%ha!e%ha!f%ha!h%ha(r%ha(u%ha(w%ha(x%ha)S%ha)T%ha)U%ha)V%ha)W%ha)X%ha!g%ha)j%ha!O%ha!W%ha(v%ha!U%haQ%ha!d%ha~Od$RO%Y$SO(y:oO~Ol:wO~O!TxO#v!eO)j%|O~Ol<[O&r#WO(r;gO~O$Z+TO%`+UO~O!TxO#v!eO)W+VO)j+WO~OPmO]$eOa%QOl:zO!V$fO!X!XO!Y!WO!i!YO#V#QO$Z+TO%_#ZO%`+YO%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V$kO)X!ZO)YXO)hcO)idO~O!U+ZO~P!QOa!TOl$oOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#a+aO#b+bO#i+cO%e#UO%l#SO&m!RO&r#WO&s!TO(r$nO)PYO~OQ)lP!d)lP~P#GgO]&YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V&WO)S&VO)U&ZO)V&ZO~O!O#kX!T#kX#v#kX)W#kX)j#kXQ#kX!d#kX!h#kX)X#kX!x#kX(v#kX~P#IkOPmO]$eOa%QOl:zOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V$fO!W+iO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S+jO)V$kO)X!ZO)YXO)hcO)idO~O]&cO!V+kO~O]&YO!V&WO)PYO)S&VO)U&ZO)V&ZO)X+nO!O)dP~P8zO]&YO!V&WO)S&VO)U&ZO)V&ZO~O!O#nX!T#nX#v#nX)W#nX)j#nXQ#nX!d#nX!h#nX)X#nX!x#nX(v#nX~P#NeO!TxO])nX!V)nX~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O#T+vO#p+wO(x+tO)U+rO)V+rO~O]#jX!T#jX!V#jX!O#jX#v#jX)W#jX)j#jXQ#jX!d#jX!h#jX)X#jX!x#jX(v#jX~P$ xO#V+yO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!l+zO#T+vO#V+yO#p+wO(x+tO)U+zO)V+zO])fP!T)fP!V)fP#v)fP(v)fP)j)fP!O)fP!h)fP)W)fP~O!x)fPQ)fP!d)fP~P$#uOPmO]$eOa%QOl:zOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V$fO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)V$kO)X!ZO)YXO)hcO)idO~O!W,QO)S,RO~P$%pO)PYO)X+nO!O)dP~P8zO]&cO!V&bO!O&Za!T&Za!h&Za#v&Za)W&Za)j&ZaQ&Za!d&Za(v&Za~OPmO]$eOa!]Ol:|Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r;RO)S$kO)V$kO)X!ZO)YXO)hcO)idO~OQ(zP!d(zP~P$)YO]#}O!V#lO(w#kO(x#kO!X'Pa!Y'Pa!['Pa!^'Pa!_'Pa!a'Pa!b'Pa!c'Pa!e'Pa!f'Pa!h'Pa(u'Pa)S'Pa)T'Pa)U'Pa)V'Pa)W'Pa)X'Pa!g'Pa)j'Pa!O'Pa!W'Pa(v'Pa!U'PaQ'Pa!d'Pa~O]#}O!V#lO!X#{O(w#kO(x#kO~P!B_O!TxO#t!fO)PYO~P8zO!TxO(r%nO)j,[O~O#x,aO~OQ)aX!d)aX!h)aX)X)aX)j)aX!O)aX!T)aX(v)aX)W)aX~P:nO(v,eO(w,cO)P$UX)W$UX~O(r,fO~O)PYO)W,iO~OPmO]$eOa!]Ol:{Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO)PYO)S$kO)V$kO)WiO)X!ZO)YXO)hcO)idO~O(r;SO~P$0kOPmO]$eOa%QOl:zO!TxO!V$fO!X!XO!Y!WO!i!YO#V#QO#v!eO$Y!vO$Z!wO$`!iO$e!jO$g!kO$h!lO$k!mO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r:mO)PYO)S$kO)V$kO)WiO)X!ZO)YXO)hcO)idO~O$h,sO~OPmO]$eOa!]Ol:{Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!V$fO!X!XO!Y!WO!i!YO!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO#V#QO#a#VO#b#TO$}!uO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO)PYO)S$kO)V$kO)X!ZO)YXO)hcO)idO~O${,yO(r:}O)W,wO~P$7UO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)W,{O)X#|O~P#3zO)W,{O~O)W,|O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W,}O)X#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W-OO)X#|O~P#3zOp&fO)PYO)j-QO~O)W-RO~Ol;^O(r;PO~O]-YO!{!dO&r#WO&s$wO(r-UO)S-VO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO(v-]O)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!TxO$`!iO$e!jO$g!kO$h!lO$k-bO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO$}!uO(r:nOd$Xa!o$Xa!{$Xa#i$Xa#p$Xa#t$Xa#v$Xa$R$Xa$T$Xa$Y$Xa$Z$Xa${$Xa%U$Xa%c$Xa%g$Xa%o$Xa%|$Xa(k$Xa)U$Xa!U$Xa$c$Xa~P$0kO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W-cO)X#|O~P#3zOl-eO!TxO)j,[O~O)j-gO~O]&]a!X&]a!Y&]a![&]a!^&]a!_&]a!a&]a!b&]a!c&]a!e&]a!f&]a!h&]a(u&]a(w&]a(x&]a)T&]a)U&]a)V&]a)W&]a)X&]a!g&]a)j&]a!O&]a!W&]a!T&]a#v&]a(v&]a!U&]aQ&]a!d&]a~O)S-kO!V&]a~P$DbO!O-kO~O!W-kO~O!V-lO)S&]a~P$DbO](}Xd(}Xr(}Xs(}Xt(}Xu(}Xv(}Xw(}Xx(}Xy(}X}(}X!V(}X!r(}X!s(}X!t(}X!u(}X!v(}X!x(}X!{(}X%v(}X&r(}X&s(}X(r(}X)S(}X)U(}X)V(}X~Ol;mO~P$GQO]&cO!V&bO)W-mO~Ol;cO!o-pO#V+yO#i-uO#t!fO${,yO%c!zO%k-tO%o!|O%v!}O(r;TO)PYO~P!8jO!n-yO(r,fO~O)PYO)W-{O~OPmO]$eOa%QOl:zO!T.QO!V$fO!X!XO!Y!WO!i!YO#V.XO#a.WO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO(x.PO)S$kO)V$kO)W-}O)X!ZO)YXO)hcO)idO~O!U.VO~P$JbO])^Xd)^Xr)^Xs)^Xt)^Xu)^Xv)^Xw)^Xx)^Xy)^X})^X!T)^X!V)^X!l)^X!r)^X!s)^X!t)^X!u)^X!v)^X!x)^X!{)^X%v)^X&r)^X&s)^X(r)^X(v)^X)S)^X)U)^X)V)^X)W)^X!O)^X!h)^X)X)^X!X)^X!Y)^X![)^X!^)^X!_)^X!a)^X!b)^X!c)^X!e)^X!f)^X(u)^X(w)^X(x)^X)T)^X!g)^X)j)^X!W)^XQ)^X!d)^X#T)^X#V)^X#p)^X#v)^Xa)^X{)^X!o)^X#a)^X#b)^X#i)^X#t)^X${)^X%c)^X%e)^X%k)^X%l)^X%o)^X&m)^X)P)^X!U)^X~Ol*[O~P$LlOl$oO!T(QO!l.^O(r$nO(v(PO)PYO~Op&fOl)^X~P$LlOl$oO!n.cO!o.cO(r$nO)PYO~Ol;dO!U.nO!n.pO!o.oO#i-uO${!tO$}!uO%g!{O%k-tO%o!|O%v!}O(r;VO)PYO~P!8jO!T(QO!l.^O(v(PO])OXd)OXl)OXr)OXs)OXt)OXu)OXv)OXw)OXx)OXy)OX})OX!V)OX!r)OX!s)OX!t)OX!u)OX!v)OX!x)OX!{)OX%v)OX&r)OX&s)OX(r)OX)S)OX)U)OX)V)OX~O)W)OX!O)OX!X)OX!Y)OX![)OX!^)OX!_)OX!a)OX!b)OX!c)OX!e)OX!f)OX!h)OX(u)OX(w)OX(x)OX)T)OX)X)OX!g)OX)j)OX!W)OXQ)OX!d)OX!U)OX#v)OX~P%%eO!T(QO~O!T(QO(v(PO~O(r%nO!U*QP~O!T(ZO(v.uO]&kad&kal&kar&kas&kat&kau&kav&kaw&kax&kay&ka}&ka!V&ka!r&ka!s&ka!t&ka!u&ka!v&ka!x&ka!{&ka%v&ka&r&ka&s&ka(r&ka)S&ka)U&ka)V&ka)W&ka!O&ka!X&ka!Y&ka![&ka!^&ka!_&ka!a&ka!b&ka!c&ka!e&ka!f&ka!h&ka(u&ka(w&ka(x&ka)T&ka)X&ka!g&ka)j&ka!W&kaQ&ka!d&ka!U&ka#v&ka~Ol$oO!T(ZO(r$nO~O&r#WO&s$wO]&pad&pal&par&pas&pat&pau&pav&paw&pax&pay&pa}&pa!V&pa!r&pa!s&pa!t&pa!u&pa!v&pa!x&pa!{&pa%v&pa(r&pa)S&pa)U&pa)V&pa)W&pa!O&pa!T&pa!X&pa!Y&pa![&pa!^&pa!_&pa!a&pa!b&pa!c&pa!e&pa!f&pa!h&pa(u&pa(w&pa(x&pa)T&pa)X&pa!g&pa)j&pa!W&paQ&pa!d&pa(v&pa!U&pa#v&pa~O&s.zO~P!(zO!Y#qO![#rO!f#zO)S#mO!^'Ua!_'Ua!a'Ua!b'Ua!c'Ua!e'Ua!h'Ua(u'Ua)T'Ua)U'Ua)V'Ua)W'Ua)X'Ua!g'Ua)j'Ua!O'Ua!W'Ua(v'Ua!U'UaQ'Ua!d'Ua~P#3zO!V'dX!X'dX!Y'dX!['dX!^'dX!_'dX!a'dX!b'dX!c'dX!e'dX!f'dX!h'dX(u'dX(w'dX(x'dX)S'dX)T'dX)U'dX)V'dX)X'dX!O'dX~O].|O)W'dX!g'dX)j'dX!W'dX(v'dX!U'dXQ'dX!d'dX~P%2xO!Y#qO![#rO!f#zO)S#mO!^'Wa!_'Wa!a'Wa!b'Wa!c'Wa!e'Wa!h'Wa(u'Wa)T'Wa)U'Wa)V'Wa)W'Wa)X'Wa!g'Wa)j'Wa!O'Wa!W'Wa(v'Wa!U'WaQ'Wa!d'Wa~P#3zO]#}O!T$WO!V.}O&r#WO&s$wO~O!X'Za!Y'Za!['Za!^'Za!_'Za!a'Za!b'Za!c'Za!e'Za!f'Za!h'Za(u'Za(w'Za(x'Za)S'Za)T'Za)U'Za)V'Za)W'Za)X'Za!g'Za)j'Za!O'Za!W'Za(v'Za!U'ZaQ'Za!d'Za~P%6oO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h'^a)W'^a!g'^a)j'^a!O'^a!W'^a(v'^a!U'^aQ'^a!d'^a~P#3zOPmO]$eOa%QOl:zO!V$fO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)S$kO)V%]O)X!ZO)YXO)hcO)idO)j%[O~O!W/QO~P%:oOS(qOT(nO]#}O*W(pO~O]/TO'f/UO*W/RO~OS/YOT(nO*W/XO~O]#}O~Q'na!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO(v/[O)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O)W#Zi!O#Zi~P#3zO]cXlgXpcXpiX!VcX!XcX!YcX![cX!^cX!_cX!acX!bcX!ccX!ecX!fcX!gcX!hcX(ucX(wcX(xcX)ScX)TcX)UcX)VcX)WcX)XcX)jcX!OcX!WcX(vcX!TcX#vcX!UcXQcX!dcX~Od/^O%Y*TO(y/]O~Ol/_O~Ol/`O~Op&fO]bi!Vbi!Xbi!Ybi![bi!^bi!_bi!abi!bbi!cbi!ebi!fbi!gbi!hbi(ubi(wbi(xbi)Sbi)Tbi)Ubi)Vbi)Wbi)Xbi)jbi!Obi!Wbi(vbi!UbiQbi!dbi~O!W/bO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO![#rO)S#mO!Y&zi!^&zi!_&zi!a&zi!b&zi!c&zi!e&zi!f&zi!h&zi(u&zi)T&zi)U&zi)V&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y&zi![&zi!^&zi!_&zi!a&zi!b&zi!c&zi!e&zi!f&zi!h&zi(u&zi)S&zi)T&zi)U&zi)V&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO)V#pO!h&zi(u&zi)T&zi)U&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO)U#nO)V#pO!h&zi(u&zi)T&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO)V#pO!^&zi!h&zi(u&zi)T&zi)U&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO)V#pO!^&zi!_&zi!h&zi(u&zi)T&zi)U&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO!^&zi!_&zi!h&zi(u&zi)T&zi)U&zi)V&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!b#yO!c#yO!e#yO!f#zO)S#mO!^&zi!_&zi!a&zi!h&zi(u&zi)T&zi)U&zi)V&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!f#zO)S#mO!^&zi!_&zi!a&zi!b&zi!c&zi!e&zi!h&zi(u&zi)T&zi)U&zi)V&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO)S#mO!^&zi!_&zi!a&zi!b&zi!c&zi!e&zi!f&zi!h&zi(u&zi)T&zi)U&zi)V&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO)T#oO)U#nO)V#pO!h&zi(u&zi)W&zi)X&zi!g&zi)j&zi!O&zi!W&zi(v&zi!U&ziQ&zi!d&zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h/cO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!O(sX~P#3zO!h/cO!O(sX~O!O/eO~O]%Xap%Xa!X%Xa!Y%Xa![%Xa!^%Xa!_%Xa!a%Xa!b%Xa!c%Xa!e%Xa!f%Xa!h%Xa(u%Xa(w%Xa(x%Xa)T%Xa)U%Xa)V%Xa)W%Xa)X%Xa!g%Xa)j%Xa!O%Xa!W%Xa!T%Xa#v%Xa(v%Xa!U%XaQ%Xa!d%Xa~O)S/fO!V%Xa~P&,aO!O/fO~O!W/fO~O!V/gO)S%Xa~P&,aO!X'Zi!Y'Zi!['Zi!^'Zi!_'Zi!a'Zi!b'Zi!c'Zi!e'Zi!f'Zi!h'Zi(u'Zi(w'Zi(x'Zi)S'Zi)T'Zi)U'Zi)V'Zi)W'Zi)X'Zi!g'Zi)j'Zi!O'Zi!W'Zi(v'Zi!U'ZiQ'Zi!d'Zi~P%6oO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h'^i)W'^i!g'^i)j'^i!O'^i!W'^i(v'^i!U'^iQ'^i!d'^i~P#3zO!W/lO~P%:oO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h/nO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!U)rX~P#3zO(r/qO~O!V/sO(w)sO)j/uO~O!h/nO!U)rX~O!U/vO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO)S#mO)T#oO)U#nO)V#pO)X#|O!h_i(u_i)W_i!g_i)j_i!O_i!W_i(v_i!U_iQ_i!d_i~P#3zO!R/wO~Ol){O]!Qa!h!Qa)X!Qa)]!Qa~OP0PO]0OOl0PO!R0PO!T/|O!V/}O!X0PO!Y0PO![0PO!^0PO!_0PO!a0PO!b0PO!c0PO!e0PO!f0PO!g0PO!h0PO!i0PO(oQO(v0PO(w0PO(x0PO)S/yO)T/zO)U/zO)V/{O)W0PO)X0PO)YXO~O!O0SO~P&6yO!R$[O~O!h*OO)X)Qa)])Qa~O)]0WO~O])dO!V)eO!X)bO!g)bO%Z)bO%[)bO%])bO%^)bO%_)fO%`)fO%a)bO(x)cO)j)bO)x)gO~Od)oO%Y*TO(y$OO~O)W0YO~O]nXdnXlmXpnXrnXsnXtnXunXvnXwnXxnXynX}nX!VnX!rnX!snX!tnX!unX!vnX!xnX!{nX%vnX&rnX&snX(rnX)SnX)UnX)VnX!TnX!hnX)XnX!OnXQnX!dnX~O!lnX(vnX)WnX!XnX!YnX![nX!^nX!_nX!anX!bnX!cnX!enX!fnX(unX(wnX(xnX)TnX!gnX)jnX!WnX!UnX#vnX#TnX#VnX#pnXanX{nX!onX#anX#bnX#inX#tnX${nX%cnX%enX%knX%lnX%onX&mnX)PnX~P&:uOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O}!_O!r!aO!s!aO!t!aO!u!aO!v!aO!x!cO~O])aid)ail)ai!V)ai!{)ai%v)ai(r)ai)S)ai)U)ai)V)aiQ)ai!d)ai!h)ai)X)ai)j)ai!O)ai!T)ai&r)ai(v)ai)W)ai~P&?sO]&cO!V&bO!O#Qi!T#Qi!h#Qi#v#Qi)W#Qi)j#QiQ#Qi!d#Qi(v#Qi~O!OqaQqa!dqa!hqa)Xqa)Wqa~P#9{O!OqaQqa!dqa!hqa)Xqa)Wqa~P#IkO]&cO!V+kO!OqaQqa!dqa!hqa)Xqa)Wqa~O!h*iO!W)ka~O!h*mO!W*Oa~OPmOa!]Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O{#RO}!_O!X!XO!Y!WO!i!YO!s!aO!t!aO!v!aO!x!cO#V#QO#a#VO#b#TO#v!eO$Y!vO$Z!wO$`!iO$e!jO$g!kO$h!lO$k!mO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO%_#ZO%`#[O%a#YO%e#UO%l#SO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO)PYO)WiO)X!ZO)YXO)hcO)idO~O]eOd!POlTO!T*qO!U&TO!V0hO!opO!r!`O!u!bO!{!dO#i#OO#p!xO#t!fO$R!gO$T!hO${!tO$}!uO%U!yO%c!zO%g!{O%o!|O%v!}O%|#PO(rRO(w)sO)SaO)U|O)V{O~P&DuO!h*tO)W)qa~OPmO]$eOa!]Ol:|O{#RO!T$WO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r;UO)PYO)S$kO)V$kO)X0nO)YXO)hcO)idO!O(sP!O)dP~P&?sO!h*mO!W*OX~O]#}O!T$WO~O!h0sO!T)zX#v)zX)j)zX~O)W0uO~O)W0vO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W0xO)X#|O~P#3zO)W0vO~P!?WO]1SOd!POl%bO!V1QO!{!dO%v$mO(r$xO)S0zO)X0}O~O)U1OO)V1OO)j0{OQ#PX!d#PX!h#PX!O#PX~P' dO!h1TOQ)lX!d)lX~OQ1VO!d1VO~O)X1YO)j1XOQ#`X!d#`X!h#`X~P!<[O)X1YO)j1XOQ#`X!d#`X!h#`X~P!;bOp&UO~O!O#ka!T#ka#v#ka)W#ka)j#kaQ#ka!d#ka!h#ka)X#ka!x#ka(v#ka~P#IkO]&cO!V+kO!O#ka!T#ka#v#ka)W#ka)j#kaQ#ka!d#ka!h#ka)X#ka!x#ka(v#ka~O!W1_O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W1_O)S1aO~P$%pO!W1_O~P!(zO]#ja!T#ja!V#ja!O#ja#v#ja)W#ja)j#jaQ#ja!d#ja!h#ja)X#ja!x#ja(v#ja~P$ xO]&cO!O1eO!V+kO~O!h1fO!O)dX~O!O1hO~O]&cO!V+kO!O#na!T#na#v#na)W#na)j#naQ#na!d#na!h#na)X#na!x#na(v#na~O]1lOr#SXs#SXt#SXu#SXv#SXw#SXx#SXy#SX!T#SX!V#SX#T#SX#p#SX(x#SX)U#SX)V#SX!l#SX!x#SX#V#SX#v#SX(v#SX)j#SX!O#SX!h#SX)W#SXQ#SX!d#SX)X#SX~O]1mO~O]1pOl$oO!V$fO#V#QO(r$nO)hcO)idO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!l+zO#T+vO#V+yO#p+wO(x+tO)U+zO)V+zO~O])fX!T)fX!V)fX!x)fX#v)fX(v)fX)j)fX!O)fX!h)fX)W)fXQ)fX!d)fX~P'+}O!x!cO]#Ri!T#Ri!V#Ri#v#Ri(v#Ri)j#Ri!O#Ri!h#Ri)W#RiQ#Ri!d#Ri~O!W1xO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W1xO)S1zO~P$%pO!W1xO~P!(zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|OQ*RX!d*RX!h*RX~P#3zO)X1{OQ({X!d({X!h({X~O!h1|OQ(zX!d(zX~OQ2OO!d2OO~O!O2PO~O#t$lO)PYO~P8zOl-eO!TxO)j2TO~O!O2UO~O#x,aOP#ui]#uia#uid#uil#uir#uis#uit#uiu#uiv#uiw#uix#uiy#ui{#ui}#ui!T#ui!V#ui!X#ui!Y#ui!i#ui!o#ui!r#ui!s#ui!t#ui!u#ui!v#ui!x#ui!{#ui#V#ui#a#ui#b#ui#i#ui#p#ui#t#ui#v#ui$R#ui$T#ui$Y#ui$Z#ui$`#ui$e#ui$g#ui$h#ui$k#ui$m#ui$o#ui$q#ui$s#ui$u#ui$w#ui${#ui$}#ui%U#ui%_#ui%`#ui%a#ui%c#ui%e#ui%g#ui%l#ui%o#ui%v#ui%|#ui&m#ui&r#ui&s#ui'Q#ui'R#ui'V#ui'Y#ui'a#ui'b#ui(k#ui(o#ui(r#ui)P#ui)S#ui)U#ui)V#ui)W#ui)X#ui)Y#ui)h#ui)i#ui!U#ui$c#ui!n#ui%k#ui~O]&cO~O]&cO!TxO!V&bO#v!eO~O(v2ZO(w,cO)P$Ua)W$Ua~O)PYO)W2]O~O!O2^O~P,]O!O2^O)W#jO~O!O2^O~O$c2cOP$_i]$_ia$_id$_il$_ir$_is$_it$_iu$_iv$_iw$_ix$_iy$_i{$_i}$_i!T$_i!V$_i!X$_i!Y$_i!i$_i!o$_i!r$_i!s$_i!t$_i!u$_i!v$_i!x$_i!{$_i#V$_i#a$_i#b$_i#i$_i#p$_i#t$_i#v$_i$R$_i$T$_i$Y$_i$Z$_i$`$_i$e$_i$g$_i$h$_i$k$_i$m$_i$o$_i$q$_i$s$_i$u$_i$w$_i${$_i$}$_i%U$_i%_$_i%`$_i%a$_i%c$_i%e$_i%g$_i%l$_i%o$_i%v$_i%|$_i&m$_i&r$_i&s$_i'Q$_i'R$_i'V$_i'Y$_i'a$_i'b$_i(k$_i(o$_i(r$_i)P$_i)S$_i)U$_i)V$_i)W$_i)X$_i)Y$_i)h$_i)i$_i!U$_i~O]1pO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)W2fO)X#|O~P#3zOPmO]$eOa!]Ol:{O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r:}O)S$kO)V$kO)W2iO)X!ZO)YXO)hcO)idO~P&?sO)W2fO~O(r-UO~O)PYO)j2lO~O)W2nO~O]-YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO!|%RO(r-UO)S-VO~O)S2sO~O]&cO!V2uO!h2vO)W)uX~O]-YO!{!dO(r-UO)S-VO~O)W2yO~O!TxO$`!iO$e!jO$g!kO$h!lO$k-bO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO$}!uO(r:nOd$Xi!o$Xi!{$Xi#i$Xi#p$Xi#t$Xi#v$Xi$R$Xi$T$Xi$Y$Xi$Z$Xi${$Xi%U$Xi%c$Xi%g$Xi%o$Xi%|$Xi(k$Xi)U$Xi!U$Xi$c$Xi~P$0kOl:{O(r:nO~P0zO]2}O~O)W2SO~O!u3PO(r%nO~O!O3SO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h3TO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O3UO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO]&cO!V+kO!T%ui#v%ui)W%ui)j%ui~O!W3VO~Ol:yO)W(}X~P$GQOa!TOl$oO{3]O#a#VO#b3[O#t!fO%e#UO%l3^O&m!RO&r#WO&s!TO(r$nO)PYO~P&?sOl;cO!o-pO#i-uO#t!fO${,yO%c!zO%k-tO%o!|O%v!}O(r;TO)PYO~P!8jO]&cO!V&bO)W3`O~O)W3aO~O)PYO)W3aO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)W3bO)X#|O~P#3zO)W3bO~O)W3eO~O!U3gO~P$JbOl$oO(r$nO~O]3iO!T'yO~P'+iO!T(QO!l3lO(v(PO])Oad)Oal)Oar)Oas)Oat)Oau)Oav)Oaw)Oax)Oay)Oa})Oa!V)Oa!r)Oa!s)Oa!t)Oa!u)Oa!v)Oa!x)Oa!{)Oa%v)Oa&r)Oa&s)Oa(r)Oa)S)Oa)U)Oa)V)Oa)W)Oa!O)Oa!X)Oa!Y)Oa![)Oa!^)Oa!_)Oa!a)Oa!b)Oa!c)Oa!e)Oa!f)Oa!h)Oa(u)Oa(w)Oa(x)Oa)T)Oa)X)Oa!g)Oa)j)Oa!W)OaQ)Oa!d)Oa!U)Oa#v)Oa~Ol$oO!n.cO!o.cO(r$nO~O!h3pO)X3rO!T)_X~O!o3tO)PYO~P8zO)W3uO~PGVO]3zOl({O!T$WO!{!dO%v$mO&r#WO(r(zO(v4OO)S3wO)U3{O)V3{O~O)W4PO)j4RO~P(&eOl;dO!U4TO!n.pO!o.oO#i-uO${!tO$}!uO%g!{O%k-tO%o!|O%v!}O(r;VO)PYO~P!8jOl;dO%v!}O(r;VO~P!8jO(v4UO~Ol$oO!T(QO(r$nO(v(PO)PYO~O!l3lO~P((sO)j4WO!U&oX!h&oX~O!h4XO!U*QX~O!U4ZO~Oa4]Ol$oO&m!RO(r$nO~O!T(ZO]&kid&kil&kir&kis&kit&kiu&kiv&kiw&kix&kiy&ki}&ki!V&ki!r&ki!s&ki!t&ki!u&ki!v&ki!x&ki!{&ki%v&ki&r&ki&s&ki(r&ki)S&ki)U&ki)V&ki)W&ki!O&ki!X&ki!Y&ki![&ki!^&ki!_&ki!a&ki!b&ki!c&ki!e&ki!f&ki!h&ki(u&ki(w&ki(x&ki)T&ki)X&ki!g&ki)j&ki!W&kiQ&ki!d&ki!U&ki#v&ki~O(v&ki~P(*TO(v.uO~P(*TO!O4`O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O4`O~O!O4aO~O]#}O!T$WO!V'Zi!X'Zi!Y'Zi!['Zi!^'Zi!_'Zi!a'Zi!b'Zi!c'Zi!e'Zi!f'Zi!h'Zi(u'Zi(w'Zi(x'Zi)S'Zi)T'Zi)U'Zi)V'Zi)W'Zi)X'Zi!g'Zi)j'Zi!O'Zi!W'Zi(v'Zi!U'ZiQ'Zi!d'Zi~OPmOa%QOl:zO!X!XO!Y!WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)X!ZO)YXO)hcO)idO]#]ap#]a!T#]a!V#]a)S#]a)U#]a)V#]a~O(r%nO)X4fO!O*YP~O*W4eO~O'f4hO*W4eO~O*W4iO~OlmXpnXp&wX~Od4kO%Y*TO(y/]O~Od4kO%Y*TO(y4lO~O!h/cO!O(sa~O!W4pO~O]&cO!V+kO!T%uq#v%uq)W%uq)j%uq~O]#}O!T$WO!X'Zq!Y'Zq!['Zq!^'Zq!_'Zq!a'Zq!b'Zq!c'Zq!e'Zq!f'Zq!h'Zq(u'Zq(w'Zq(x'Zq)S'Zq)T'Zq)U'Zq)V'Zq)W'Zq)X'Zq!g'Zq)j'Zq!O'Zq!W'Zq(v'Zq!U'ZqQ'Zq!d'Zq~O!V'Zq~P(5bO!V.}O&r#WO&s$wO~P(5bO!T$WO!V)rO(w)sO!U(UX!h(UX~P!JwO!h/nO!U)ra~O!W4xO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h*iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!U4|O~P&6yO!W4|O~P&6yO!O4|O~P&6yO!O5RO~P&6yO]5SO!h'ua)X'ua)]'ua~O!h*OO)X)Qi)])Qi~O]&cO!V&bO!O#Qq!T#Qq!h#Qq#v#Qq)W#Qq)j#QqQ#Qq!d#Qq(v#Qq~O!OqiQqi!dqi!hqi)Xqi)Wqi~P#IkO]&cO!V+kO!OqiQqi!dqi!hqi)Xqi)Wqi~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h'Tq)W'Tq!g'Tq)j'Tq!O'Tq!W'Tq(v'Tq!U'TqQ'Tq!d'Tq~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!W'|a!h'|a~P#3zO!W5XO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h5YO(u#gO)S#mO)T#oO)U#nO)V#pO)W#jO)X#|O!U)rX~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h#{i)W#{i~P#3zO]*vO!T$WO!V&bO)j*rO!h(Va)W(Va~O!h1fO]'dX!O)dX~P%2xO)X5[O!T%qa!h%qa#v%qa)j%qa~O!h0sO!T)za#v)za)j)za~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W5_O)X#|O~P#3zO]1SOd!POl;[O!V1QO!{!dO%v$mO(r$xO)S;xO)U5aO)V5aO~OQ#Pa!d#Pa!h#Pa!O#Pa~P(DjO]1SOd!POr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V1QO!{!dO!|%RO%v$mO(r$xOQ#kX!d#kX!h#kX!O#kX~Ol%bO)S0zO)U;yO)V;yO~P(ElO]&cOQ#Pa!d#Pa!h#Pa!O#Pa~O!V&bO)j5eO~P(GZO(r%nOQ#dX!d#dX!h#dX!O#dX~O)U;yO)V;yOQ#nX!d#nX!h#nX!O#nX~P' dO!V+kO~P(GZO]1SOa!TOd!POl;]O{#RO!V1QO!{!dO#a#VO#b#TO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO(r;QO)PYO)S;xO)U5aO)V5aO)X+nO!O)dP~P&?sO!h1TOQ)la!d)la~Op&fO)j5jOQ#`al(}X!d#`a!h#`a)X(}X~P$GQO(r-UOQ#ga!d#ga!h#ga~Op&fO)j5jOQ#`a])^Xd)^Xl)^Xr)^Xs)^Xt)^Xu)^Xv)^Xw)^Xx)^Xy)^X})^X!T)^X!V)^X!d#`a!h#`a!l)^X!r)^X!s)^X!t)^X!u)^X!v)^X!x)^X!{)^X%v)^X&r)^X&s)^X(r)^X(v)^X)S)^X)U)^X)V)^X)X)^X~O#a5mO#b5mO~O]&cO!V+kO!O#ki!T#ki#v#ki)W#ki)j#kiQ#ki!d#ki!h#ki)X#ki!x#ki(v#ki~O!W5oO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W5oO~P!(zO!W5oO)S5qO~P$%pO]#ji!T#ji!V#ji!O#ji#v#ji)W#ji)j#jiQ#ji!d#ji!h#ji)X#ji!x#ji(v#ji~P$ xO)PYO)X5sO~P8zO!h1fO!O)da~O&r#WO&s$wO!T#qa!x#qa#v#qa(v#qa)j#qa!O#qa!h#qa)W#qaQ#qa!d#qa)X#qa~P#NeO!O5xO~P!(zO!O)oP~P!4xO)T6OO)U5|O]#Ua!T#Ua!V#Ua)S#Ua)V#Uar#Uas#Uat#Uau#Uav#Uaw#Uax#Uay#Ua!l#Ua!x#Ua#T#Ua#V#Ua#p#Ua#v#Ua(v#Ua(x#Ua)j#Uaa#Uad#Ual#Ua{#Ua}#Ua!o#Ua!r#Ua!s#Ua!t#Ua!u#Ua!v#Ua!{#Ua#a#Ua#b#Ua#i#Ua#t#Ua${#Ua%c#Ua%e#Ua%k#Ua%l#Ua%o#Ua%v#Ua&m#Ua&r#Ua&s#Ua(r#Ua)P#Ua)W#Ua!O#Ua!h#UaQ#Ua!d#Ua~O!x!cO]#Rq!T#Rq!V#Rq#v#Rq(v#Rq)j#Rq!O#Rq!h#Rq)W#RqQ#Rq!d#Rq~O!W6TO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W6TO~P!(zO!h1|OQ(za!d(za~O)W6YO~Ol-eO!TxO)j6ZO~O]*vO!T$WO!V&bO!h*tO)W)qX~O)j6_O~P)+cO!O6aO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O6aO~O$c6cOP$_q]$_qa$_qd$_ql$_qr$_qs$_qt$_qu$_qv$_qw$_qx$_qy$_q{$_q}$_q!T$_q!V$_q!X$_q!Y$_q!i$_q!o$_q!r$_q!s$_q!t$_q!u$_q!v$_q!x$_q!{$_q#V$_q#a$_q#b$_q#i$_q#p$_q#t$_q#v$_q$R$_q$T$_q$Y$_q$Z$_q$`$_q$e$_q$g$_q$h$_q$k$_q$m$_q$o$_q$q$_q$s$_q$u$_q$w$_q${$_q$}$_q%U$_q%_$_q%`$_q%a$_q%c$_q%e$_q%g$_q%l$_q%o$_q%v$_q%|$_q&m$_q&r$_q&s$_q'Q$_q'R$_q'V$_q'Y$_q'a$_q'b$_q(k$_q(o$_q(r$_q)P$_q)S$_q)U$_q)V$_q)W$_q)X$_q)Y$_q)h$_q)i$_q!U$_q~O)W6dO~OPmO]$eOa!]Ol:{O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r:}O)S$kO)V$kO)W6fO)X!ZO)YXO)hcO)idO~P&?sO(v6hO)j*rO~P)+cO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W6fO)X#|O~P#3zO!O6jO~P!(zO)W6nO~O)W6oO~O]-YOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO(r-UO)S-VO~O]&cO!V2uO!h%Oa)W%Oa!O%Oa~O!W6uO)S6vO~P$%pO!h2vO)W)ua~O]&cO!O6yO!V2uO~O!TxO$`!iO$e!jO$g!kO$h!lO$k-bO$m!nO$o!oO$q!pO$s!qO$u!rO$w!sO$}!uO(r:nOd$Xq!o$Xq!{$Xq#i$Xq#p$Xq#t$Xq#v$Xq$R$Xq$T$Xq$Y$Xq$Z$Xq${$Xq%U$Xq%c$Xq%g$Xq%o$Xq%|$Xq(k$Xq)U$Xq!U$Xq$c$Xq~P$0kOPmO]$eOa!]Ol:{O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r:}O)PYO)S$kO)V$kO)W6{O)X!ZO)YXO)hcO)idO~P&?sO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W7OO)X#|O~P#3zO)W7PO~OP7QO(oQO~Ol*[O)W)^X~P$GQOp&fOl(}X)W)^X~P$GQO)W7SO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O)W&Sa~P#3zO!U7UO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO)W7VO~OPmO]$eOa!]Ol:|O{#RO!V$fO!X!XO!Y!WO!i!YO#V#QO#a#VO#b#TO%_#ZO%`#[O%a#YO%e#UO%l#SO%v$mO&m!RO&r#WO&s!TO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r;UO)PYO)S$kO)V$kO)X0nO)YXO)hcO)idO!O)dP~P&?sO!h3pO)X7ZO!T)_a~O!h3pO!T)_a~O)W7`O)j7bO~P(&eO)W7dO~PGVO]3zOl({Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!{!dO!|%RO%v$mO&r#WO(r(zO)S3wO)U3{O)V3{O~O)S7hO~O]&cO!T*qO!V7jO!h7kO#v!eO(v4OO~O)W7`O)j7mO~P)FwO]3zOl({O!{!dO%v$mO&r#WO(r(zO)S3wO)U3{O)V3{O~Op&fO])cX!T)cX!V)cX!h)cX#v)cX(v)cX)W)cX)j)cX!O)cX~O)W7`O~O!T(QO!l7sO(v(PO])Oid)Oil)Oir)Ois)Oit)Oiu)Oiv)Oiw)Oix)Oiy)Oi})Oi!V)Oi!r)Oi!s)Oi!t)Oi!u)Oi!v)Oi!x)Oi!{)Oi%v)Oi&r)Oi&s)Oi(r)Oi)S)Oi)U)Oi)V)Oi)W)Oi!O)Oi!X)Oi!Y)Oi![)Oi!^)Oi!_)Oi!a)Oi!b)Oi!c)Oi!e)Oi!f)Oi!h)Oi(u)Oi(w)Oi(x)Oi)T)Oi)X)Oi!g)Oi)j)Oi!W)OiQ)Oi!d)Oi!U)Oi#v)Oi~O(r%nO!U(fX!h(fX~O!h4XO!U*Qa~Op&fO]*Pad*Pal*Par*Pas*Pat*Pau*Pav*Paw*Pax*Pay*Pa}*Pa!T*Pa!V*Pa!r*Pa!s*Pa!t*Pa!u*Pa!v*Pa!x*Pa!{*Pa%v*Pa&r*Pa&s*Pa(r*Pa)S*Pa)U*Pa)V*Pa)W*Pa!O*Pa!X*Pa!Y*Pa![*Pa!^*Pa!_*Pa!a*Pa!b*Pa!c*Pa!e*Pa!f*Pa!h*Pa(u*Pa(w*Pa(x*Pa)T*Pa)X*Pa!g*Pa)j*Pa!W*PaQ*Pa!d*Pa(v*Pa!U*Pa#v*Pa~O!T(ZO]&kqd&kql&kqr&kqs&kqt&kqu&kqv&kqw&kqx&kqy&kq}&kq!V&kq!r&kq!s&kq!t&kq!u&kq!v&kq!x&kq!{&kq%v&kq&r&kq&s&kq(r&kq)S&kq)U&kq)V&kq)W&kq!O&kq!X&kq!Y&kq![&kq!^&kq!_&kq!a&kq!b&kq!c&kq!e&kq!f&kq!h&kq(u&kq(w&kq(x&kq)T&kq)X&kq!g&kq)j&kq!W&kqQ&kq!d&kq(v&kq!U&kq#v&kq~OPmOa%QOl:zO!T$WO!i!YO#V#QO%_#ZO%`#[O%a#YO%v$mO'Q!WO'R!WO'V#XO'Y![O'a![O'b![O(oQO(r$xO)YXO)hcO)idO~O]*Ui!V*Ui!X*Ui!Y*Ui![*Ui!^*Ui!_*Ui!a*Ui!b*Ui!c*Ui!e*Ui!f*Ui!h*Ui(u*Ui(w*Ui(x*Ui)S*Ui)T*Ui)U*Ui)V*Ui)W*Ui)X*Ui!g*Ui)j*Ui!O*Ui!W*Ui(v*Ui!U*UiQ*Ui!d*Ui~P*&WO!O7xO~O!W7yO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h'^q)W'^q!g'^q)j'^q!O'^q!W'^q(v'^q!U'^qQ'^q!d'^q~P#3zO!h7zO!O*YX~O!O7|O~O*W7}O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h^y)W^y!g^y)j^y!O^y!W^y(v^y!U^yQ^y!d^y~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!O(ha!h(ha~P#3zO]#}O!T$WO!V'Zy!X'Zy!Y'Zy!['Zy!^'Zy!_'Zy!a'Zy!b'Zy!c'Zy!e'Zy!f'Zy!h'Zy(u'Zy(w'Zy(x'Zy)S'Zy)T'Zy)U'Zy)V'Zy)W'Zy)X'Zy!g'Zy)j'Zy!O'Zy!W'Zy(v'Zy!U'ZyQ'Zy!d'Zy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!h'^y)W'^y!g'^y)j'^y!O'^y!W'^y(v'^y!U'^yQ'^y!d'^y~P#3zO]&cO!V+kO!T%uy#v%uy)W%uy)j%uy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!U(Ua!h(Ua~P#3zO!W4xO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!U#}i!h#}i~P#3zO!U8PO~P&6yO!W8PO~P&6yO!O8PO~P&6yO!O8RO~P&6yO]&cO!V&bO!O#Qy!T#Qy!h#Qy#v#Qy)W#Qy)j#QyQ#Qy!d#Qy(v#Qy~O]&cO!V+kO!OqqQqq!dqq!hqq)Xqq)Wqq~O]&cOQ#Pi!d#Pi!h#Pi!O#Pi~O!V+kO~P*9jOQ#nX!d#nX!h#nX!O#nX~P(DjO!V&bO~P*9jOQ(OX](OXd'qXl'qXr(OXs(OXt(OXu(OXv(OXw(OXx(OXy(OX!V(OX!d(OX!h(OX!{'qX%v'qX(r'qX)S(OX)U(OX)V(OX!O(OX~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|OQ#_i!d#_i!h#_i!O#_i~P#3zO&r#WO&s$wOQ#fi!d#fi!h#fi~O(r-UO)X1YO)j1XOQ#`X!d#`X!h#`X~O!W8WO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W8WO~P!(zO!T#qi!x#qi#v#qi(v#qi)j#qi!O#qi!h#qi)W#qiQ#qi!d#qi)X#qi~O]&cO!V+kO~P*?fO]&YO!V&WO&r#WO&s$wO)S&VO)U&ZO)V&ZO~P*?fO!O8YO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!h8ZO!O)oX~O!O8]O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|OQ*TX!d*TX!h*TX~P#3zO)X8`OQ*SX!d*SX!h*SX~O)W8bO~O!O$bi!h#{a)W#{a~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W8eO)X#|O~P#3zO!O8gO~P!(zO!O8gO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O8gO~O]&cO!V&bO(v8mO~O)W8nO~O]&cO!V2uO!h%Oi)W%Oi!O%Oi~O!W8qO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W8qO)S8sO~P$%pO!W8qO~P!(zO]&cO!V2uO!h(Ya)W(Ya~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)W8tO)X#|O~P#3zO)W2iO~P!(zO)W8tO~OP%oO!O8uO(oQO~O!O8uO~O)W8vO~P%%eO#T8yO(x.PO)W8wO~O!h3pO!T)_i~O)X8}O!T'wa!h'wa~O)W9PO)j9RO~P)FwO)W9PO~O)W9PO)j9VO~P(&eOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~P)GgO]&cO!V7jO!T!ya!h!ya#v!ya(v!ya)W!ya)j!ya!O!ya~O!W9^O)S9_O~P$%pO!T$WO!h7kO(v4OO)W9PO)j9VO~O!T$WO~P#EfO]&cO!O9bO!V7jO~O]&cO!V7jO!T&aa!h&aa#v&aa(v&aa)W&aa)j&aa!O&aa~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O)W&ba~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W9PO)X#|O~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!U&oi!h&oi~P#3zO!V.}O]']i!T']i!X']i!Y']i![']i!^']i!_']i!a']i!b']i!c']i!e']i!f']i!h']i(u']i(w']i(x']i)S']i)T']i)U']i)V']i)W']i)X']i!g']i)j']i!O']i!W']i(v']i!U']iQ']i!d']i~O(r%nO)X9eO~O!h7zO!O*Ya~O!O9gO~P&6yO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!U(Ua)W#Zi~P#3zO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|OQ#_q!d#_q!h#_q!O#_q~P#3zO&r#WO&s$wOQ#fq!d#fq!h#fq~O)j5jOQ#`a!d#`a!h#`a~O]&cO!V+kO!T#qq!x#qq#v#qq(v#qq)j#qq!O#qq!h#qq)W#qqQ#qq!d#qq)X#qq~O!h8ZO!O)oa~O)U5|O]&Vi!T&Vi!V&Vi)S&Vi)T&Vi)V&Vir&Vis&Vit&Viu&Viv&Viw&Vix&Viy&Vi!l&Vi!x&Vi#T&Vi#V&Vi#p&Vi#v&Vi(v&Vi(x&Vi)j&Via&Vid&Vil&Vi{&Vi}&Vi!o&Vi!r&Vi!s&Vi!t&Vi!u&Vi!v&Vi!{&Vi#a&Vi#b&Vi#i&Vi#t&Vi${&Vi%c&Vi%e&Vi%k&Vi%l&Vi%o&Vi%v&Vi&m&Vi&r&Vi&s&Vi(r&Vi)P&Vi)W&Vi!O&Vi!h&ViQ&Vi!d&Vi~O)W9jO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O!O$bq!h#{i)W#{i~P#3zO!O9lO~P!(zO!O9lO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O9lO~O]&cO!V&bO(v9oO~O!O9pO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O9pO~O]&cO!V2uO!h%Oq)W%Oq!O%Oq~O!W9tO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W9tO~P!(zO)W6fO~P!(zO)W9uO~O)W9vO~O(x.PO)W9vO~O!h3pO!T)_q~O)X9xO!T'wi!h'wi~O!T$WO!h7kO(v4OO)W9yO)j9{O~O)W9yO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W9yO)X#|O~P#3zO)W9yO)j:OO~P)FwO]&cO!V7jO!T!yi!h!yi#v!yi(v!yi)W!yi)j!yi!O!yi~O!W:SO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W:SO)S:UO~P$%pO!W:SO~P!(zO]&cO!V7jO!T(da!h(da(v(da)W(da)j(da~O!O:WO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO!h#iO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O:WO~O!O:]O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O:]O~O]&cO!V2uO!h%Oy)W%Oy!O%Oy~O)W:^O~O)W:_O~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W:_O)X#|O~P#3zO!T$WO!h7kO(v4OO)W:_O)j:bO~O]&cO!V7jO!T!yq!h!yq#v!yq(v!yq)W!yq)j!yq!O!yq~O!W:dO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!W:dO~P!(zO!O:fO!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)X#|O~P#3zO!O:fO~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W:hO)X#|O~P#3zO)W:hO~O]&cO!V7jO!T!yy!h!yy#v!yy(v!yy)W!yy)j!yy!O!yy~O!Y#qO![#rO!^#uO!_#vO!a#xO!b#yO!c#yO!e#yO!f#zO(u#gO)S#mO)T#oO)U#nO)V#pO)W:lO)X#|O~P#3zO)W:lO~O]ZXlgXpZXpiX!TiX!VZX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX(uZX(v$]X(wZX(xZX)SZX)TZX)UZX)VZX)WZX)XZX)jZX~O]%WXlmXpnXp%WX!TnX!V%WX!X%WX!Y%WX![%WX!^%WX!_%WX!a%WX!b%WX!c%WX!e%WX!f%WX!gmX!h%WX(u%WX(w%WX(x%WX)S%WX)T%WX)U%WX)V%WX)X%WX)jmX!O%WXQ%WX!d%WX~O)W%WX!W%WX(v%WX!U%WX~P+GrO]nX]%WXdnXlmXpnXp%WXrnXsnXtnXunXvnXwnXxnXynX}nX!VnX!V%WX!rnX!snX!tnX!unX!vnX!xnX!{nX%vnX&rnX&snX(rnX)SnX)UnX)VnX!OnX!O%WX!hnX)XnX~O)WnX)jnX~P+JSO]%WXlmXpnXp%WX!V%WX!h%WXQ%WX!d%WX!O%WX~O!T%WX#v%WX)W%WX)j%WX(v%WX~P+LmOQnXQ%WX!TnX!X%WX!Y%WX![%WX!^%WX!_%WX!a%WX!b%WX!c%WX!dnX!d%WX!e%WX!f%WX!gmX!h%WX(u%WX(w%WX(x%WX)S%WX)T%WX)U%WX)V%WX)X%WX)jmX~P+JSO]nX]%WXlmXpnXp%WXrnXsnXtnXunXvnXwnXxnXynX}nX!V%WX!rnX!snX!tnX!unX!vnX!xnX!{nX%vnX&rnX&snX(rnX)SnX)UnX)VnX~O!TnX(vnX)WnX)jnX~P, eOdnX!VnX)W%WX~P, eOlmXpnX)W%WX~Od)oO%Y)pO(y:oO~Od)oO%Y)pO(y:tO~Od)oO%Y)pO(y:pO~Od$RO%Y*TO'[$TO'_$UO(y:oO~Od$RO%Y*TO'[$TO'_$UO(y:qO~Od$RO%Y*TO'[$TO'_$UO(y:sO~O]iXriXsiXtiXuiXviXwiXxiXyiX!OiX!ViX&riX&siX)SiX)UiX)ViXdiX}iX!riX!siX!tiX!uiX!viX!xiX!{iX%viX(riX~P#1jO]ZXlgXpZXpiX!VZX!hZX)WZX)jZX~O!TZX#vZX(vZX~P,'{OlgXpiX)PiX)WZX)jiX~O]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!VZX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%viX&riX&siX(riX)SiX)UiX)ViX!OZX!OiX!hiX)XiX)jiX~O)WZX~P,)VO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX!TiX!VZX!ViX!XZX!YZX![ZX!^ZX!_ZX!aZX!bZX!cZX!eZX!fZX!gZX!hZX!hiX&riX&siX(uZX(wZX(xZX)SZX)SiX)TZX)UZX)UiX)VZX)ViX)XZX)XiX)jZX~OQZXQiX!dZX!diX~P,+pO]iXdiXriXsiXtiXuiXviXwiXxiXyiX}iX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%viX&riX&siX(riX)SiX)UiX)ViX~P#1jO]ZX]iXdiXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!VZX!ViX!riX!siX!tiX!uiX!viX!xiX!{iX%viX&riX&siX(riX)SiX)UiX)ViX~O)WiX~P,0rOdiX}iX!OZX!OiX!riX!siX!tiX!uiX!viX!xiX!{iX%viX(riX)jiX~P,+pO]ZX]iXlgXpZXpiXriXsiXtiXuiXviXwiXxiXyiX}iX!TiX!VZX!riX!siX!tiX!uiX!viX!xiX!{iX%viX&riX&siX(riX(viX)SiX)UiX)ViX)WiX)jiX~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~PBUOd$RO%Y*TO(y:oO~Od$RO%Y*TO(y:pO~Od$RO%Y*TO(y:vO~Od$RO%Y*TO(y:uO~O]%hOd!POl%bOr!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O!V%kO!{!dO!|%RO%v$mO(r$xO)S;aO)U;bO)V;bO~O]%hOd!POl%bO!V%kO!{!dO%v$mO(r$xO)S;aO)U;bO)V;bO~Od$RO%Y$SO(y:pO~Od$RO%Y$SO(y:tO~Ol:yO~Ol:xO~O]cXlgXpiX!TcX~Od)oO%Y*TO(y:oO~Od)oO%Y*TO(y:pO~Od)oO%Y*TO(y:qO~Od)oO%Y*TO(y:rO~Od)oO%Y*TO(y:sO~Od)oO%Y*TO(y:uO~Od)oO%Y*TO(y:vO~Or!^Os!^Ot!^Ou!^Ov!^Ow!^Ox!^Oy!^O~P,9OO](}Xr(}Xs(}Xt(}Xu(}Xv(}Xw(}Xx(}Xy(}X}(}X!r(}X!s(}X!t(}X!u(}X!v(}X!x(}X!{(}X%v(}X&r(}X&s(}X(r(}X)S(}X)U(}X)V(}X)j(}X~Ol:xO!T(}X(v(}X)W(}X~P,<}O]&wXlmXpnX!T&wX~Od4kO%Y*TO(y;tO~Ol;[O)S;xO)U5aO)V5aO~P(ElOd!POl%bO!{!dO%v$mO(r$xO~O]1SO!V1QO)S0zO)U;yO)V;yOQ#nX!d#nX!h#nX!O#nX~P,?yO)S;YO~Ol;hO~Ol;iO~Ol;jO~Ol;lO~Ol;mO~Ol;nO~Ol;lO!T$WOQ(}X!d(}X!h(}X)X(}X!O(}X)j(}X~P$GQOl;jO!T$WO~P$GQOl;hO!g$YO)j$YO~Ol;jO!g$YO)j$YO~Ol;lO!g$YO)j$YO~Ol;iO!O(}X!h(}X)X(}X)j(}X~P$GQOd/^O%Y*TO(y;tO~Ol;uO~O)S<YO~OV'e'h'i'g(o)Y!R(rST%Z!Y!['jd%[!i'R!f]'f*Z'k(w!^!_'l'm'l~",
  goto: "%5]*ZPPPPPP*[P*_PP.T4iP7j7j:tP:t>OP>i>{?aFXMX!&]!,sP!3m!4b!5VP!5qPPPPPPPP!6[P!7tPP!9V!:oP!:uPPPPPP!:xP!:xPP!:xPPPPPPPPP!;U!>lP!>oPP!?]!@QPPPPP!@UP>l!AgPP>l!Cn!Eo!E}!Gd!ITP!I`P!Io!Io!MP#!`##v#'S#*^!Eo#*hPP!Eo#*o#*u#*h#*h#*xP#*|#+k#+k#+k#+k!ITP#,U#,g#.|P#/bP#0}P#1R#1Z#2O#2Z#4i#4q#4q#1RP#1RP#4x#5OP#5YPP#5u#6d#7U#5uP#7v#8SP#5uP#5uPP#5u#5uP#5uP#5uP#5uP#5uP#5uP#5uP#8V#5Y#8sP#9YP#9o#9o#9o#9o#9|#1RP#:d#?`#?}PPPPPPPP#@uP#ATP#ATP#Aa#Dn#9OPP#@}#EQP#Ee#Ep#Ev#Ev#@}#FlP#1R#1R#1R#1R#1RP!Io#GW#G_#G_#G_#Gc!Ly#Gm!Ly#Gq!E}!E}!E}#Gt#L^!E}>l>l>l$#V!@Q!@Q!@Q!@Q!@Q!@Q!6[!6[!6[$#jP$%V$%e!6[$%kPP!6[$'y$'|#@l$(P:t7j$+V$-Q$.q$0a7jPP7j$2T7jP7j7jP7jP$5Z7jP7jPP7j$5gPPPPPPPPP*[P$8o$8u$;^$=d$=j$>Q$>[$>g$>v$>|$@[$AZ$Ab$Ai$Ao$Aw$BR$BX$Bd$Bj$Bs$B{$CW$C^$Ch$Cn$Cx$DP$D`$Df$DlP$Dr$Dz$ER$Ea$F}$GT$GZ$Gb$GkPPPPPPPP$Gq$GuPPPPP$Nw$'y$Nz%$S%&[P%&i%&lPPPPPPPPPP%&x%'{%(R%(V%)|%+Z%+|%,T%.d%.jPPP%.t%/P%/S%/Y%0a%0d%0n%0x%0|%2Q%2s%2y#@uP%3d%3t%3w%4X%4e%4i%4o%4u$'y$'|$'|%4x%4{P%5V%5YR#cP'`mO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fU%om%p7QQ&m!`Q(j#]d0P)}/|/}0O0R4}5O5P5S8QR7Q3Tb}Oaewx{!g&S*q&v$i[!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0{1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fS%`f0h#d%jgnp|#O$g$|$}%S%d%h%i%w&s't'u(Q*Y*`*b*t+],l,v-_-p-w.f.m.o0]0y0z1O1S2_2j5a6g;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<YS%qm!YS&u!h#PQ']!tQ'g!yQ'h!zQ(j#`Q(k#]Q(l#^Q*x%kQ,W&lQ,]&nQ-S'^Q-d'fQ-k'qS.r(Z4XQ/f)gQ0e*mQ2Q,[Q2X,cQ3O-eQ4b.|Q4f/TQ5f0}Q6[2TQ6}3PQ8a6ZQ9e7zR;Z1Q$|#hS!]$y%Q%T%Z&j&k'Q'X'Z'a'c(a(e(h(w(x)R)S)T)U)V)W)X)Y)Z)[)])^)_)k)q)x+X+g,O,S,j,u-h-i-|.y/p0`0b0g0i0w1`1y2a2h3R3c3d4c4d4j4m4s4u4y4z5d5p5w6U6e6i6s6z7q7r7t8S8T8c8f8j8r9T9[9k9q9|:T:Y:`:iQ&p!dQ(g#ZQ(s#bQ)j$T[*s%e*W0k2`2g2{Q,^&oQ/O(fQ/S(kQ/Z(tS/i)i/PQ0r+QS4q/j/kR8O4r'a![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f'a!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fQ)O#kS+Q%y0sQ/r)sk3}.g3s3w3z3{7c7e7f7h7k9X9Y:RQ)Q#kk3|.g3s3w3z3{7c7e7f7h7k9X9Y:Rl)P#k.g3s3w3z3{7c7e7f7h7k9X9Y:RT+Q%y0s[UOwx!g&S*qW$`[e$e(b#l$p_!f!u!}#R#S#T#U#V#Z$S$T$l%U&U&Y&c&m'_'}(P(U(^(g)j)p+[+a+b+t+y,X,k,z-Q-o-t.W.X._.`.d.q.u1T1X1f1k1m2l3[3]3^3p3t5j5}6P7[8Z![%cg$g%d%i&s*Y*t+],l,v-_0z1O2_;W;X;Y;a;b;o;p;q;r;v;w;y<W<X<YY%snp%w-p.fl(|#k.g3s3w3z3{7c7e7f7h7k9X9Y:RS;e't-wU;f(Q.m.o&|;{af{|!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k$|$}%S%]%h%m&Q&W&b&y&|'O'i'j'u'y(`(i)l)r*`*b*h*i*l*r+W+Y+h+j+k,P,R,n,q-g.P.Q.U.}/Q/[/c/l/n/s/u0]0h0y0{1Q1a1b1l1p1z2c2i2j2u4O4R4W4a5Y5a5e5q6_6c6f6g6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f;`;xQ;|1Sd;}&x'P'b,w-]-^-a2f2z2}W<O&f*v1|3iQ<P#O[<Q!t'^'f,[2T6ZT<]%y0s[VOwx!g&S*qW$a[e$e(bQ$p.u!j$q_!f!u!}#V#Z$S$T$l%U&U&Y&c&m'_(g)j)p+[+a+t,X,k,z-Q-o.d1T1X1f1k1m2l3t5j8Z&^$zaf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'i'j'y(`(i)l)r*h*i*l*r+W+Y+h+j+k,P,R,n,q-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z2c2i2u4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f![%cg$g%d%i&s*Y*t+],l,v-_0z1O2_;W;X;Y;a;b;o;p;q;r;v;w;y<W<X<YY%snp%w-p.fQ'r#O|'|#R#S#T#U'}(P(U(^+b+y.W.X._.`.q3[3]3^3p5}6P7[l(|#k.g3s3w3z3{7c7e7f7h7k9X9Y:RS-n't-wQ3W-tU;s(Q.m.on;{|$|$}%S%h'u*`*b0]0y2j5a6g;`;x[<Q!t'^'f,[2T6ZW<R&f*v1|3id<S&x'P'b,w-]-^-a2f2z2}Q<Z1ST<]%y0s!Q!UO[ewx!g$e&S&f&x'P'b(b*q*v,w-]-^-a1|2f2z2}3i!v$t_!f!u!}#O#V#Z$S$T$l%U&U&Y&c&m'_'t(Q(g)j)p+[+t,X,k,z-Q-o-w.d.m.o1S1T1X1f1k1m2l3t5j8Z&^%Paf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'i'j'y(`(i)l)r*h*i*l*r+W+Y+h+j+k,P,R,n,q-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z2c2i2u4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f$Q%lgnp|#k$g$|$}%S%d%h%i%w%y&s'^'f'u*Y*`*b*t+],[,l,v-_-p.f.g0]0s0y0z1O2T2_2j3s3w3z3{5a6Z6g7c7e7f7h7k9X9Y:R;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<YQ'[!tz(O#R#S#T#U'}(P(U(^+y.W.X._.`.q3[3]3^3p5}6P7[f-Z'`-T-V-Y2p2q2s2v6q6r8pQ1W+aQ1Z+bQ2k,yQ3X-tQ4[.uQ5l1YR8V5m!Q!UO[ewx!g$e&S&f&x'P'b(b*q*v,w-]-^-a1|2f2z2}3i!x$t_!f!u!}#O#V#Z$S$T$l%U&U&Y&c&m'_'t(Q(g)j)p+[+a+t,X,k,z-Q-o-w.d.m.o1S1T1X1f1k1m2l3t5j8Z&^%Paf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'i'j'y(`(i)l)r*h*i*l*r+W+Y+h+j+k,P,R,n,q-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z2c2i2u4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f$S%lgnp|!t#k$g$|$}%S%d%h%i%w%y&s'^'f'u*Y*`*b*t+],[,l,v-_-p.f.g0]0s0y0z1O2T2_2j3s3w3z3{5a6Z6g7c7e7f7h7k9X9Y:R;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<Y|(O#R#S#T#U'}(P(U(^+b+y.W.X._.`.q3[3]3^3p5}6P7[Q3X-tR4[.u[WOwx!g&S*qW$b[e$e(b#l$p_!f!u!}#R#S#T#U#V#Z$S$T$l%U&U&Y&c&m'_'}(P(U(^(g)j)p+[+a+b+t+y,X,k,z-Q-o-t.W.X._.`.d.q.u1T1X1f1k1m2l3[3]3^3p3t5j5}6P7[8Z![%cg$g%d%i&s*Y*t+],l,v-_0z1O2_;W;X;Y;a;b;o;p;q;r;v;w;y<W<X<YY%snp%w-p.fl(|#k.g3s3w3z3{7c7e7f7h7k9X9Y:RS;e't-wU;f(Q.m.on;{|$|$}%S%h'u*`*b0]0y2j5a6g;`;xQ;|1SQ<P#O[<Q!t'^'f,[2T6Z&^<Taf{!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$f$k%]%m&Q&W&b&y&|'O'i'j'y(`(i)l)r*h*i*l*r+W+Y+h+j+k,P,R,n,q-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z2c2i2u4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fd<U&x'P'b,w-]-^-a2f2z2}W<V&f*v1|3iT<]%y0sp$PT$_$o%b%r({:z:{:|;[;];^;_;c;d<[o)m$V*U*[/_:w:x:y;h;i;j;k;l;m;n;up$QT$_$o%b%r({:z:{:|;[;];^;_;c;d<[o)n$V*U*[/_:w:x:y;h;i;j;k;l;m;n;u^&e}!O$i$j%`%j;Zd&i!U$t%P%l'[(O1W1Z3X4[V/a)O)P3}S%Ye$eQ,T&fQ.{(bQ2m-QQ5y1mQ6V1|Q6m2lR9h8Z#}!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b't(Q(b(g)j)p*q*v+[+a+t,X,k,w,z-Q-]-^-a-o-t-w.d.m.o1S1T1X1f1k1m1|2f2l2z2}3i3t5j8Z#[^O[_`wx!f!g!}#O$S$d$l$s$u&S&U&Y&c&m&r&x'P'b't(Q)p*]*q*v+[,X,k,w,z-]-^-a-o-t-w.d.m.o1S1T1f2f2z2}3i3t_(U#R#S#T+b3[3]3^#}ZO[wx!g!k#R#S#T%m&S&U&Y&c&m&w&x&y&|'O'P'['b't'x'}(P(Q(U*q*v+[+b,X,h,k,q-P-]-^-a-o-t-w-z._.d.m.q1S1T1f2c2k2z2}3[3]3^3i6c6j8g9l9p:W:]:fQ$]YR0T*OR*Q$]e0P)}/|/}0O0R4}5O5P5S8Q'`!YO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fe0P)}/|/}0O0R4}5O5P5S8QR5T0T^(T#R#S#T+b3[3]3^Y.]'}(R(U(V7TU3k.Z.^.qS7X3l4VR9c7s^(S#R#S#T+b3[3]3^[.['}(R(T(U(V7TW3j.Z.].^.qU7W3k3l4VS8z7X7sR:V9cT.k(Q.md]Owx!g&S't(Q*q-w.m!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)p*]*v+[,X,k,w,z-]-^-a-o-t.d.o1S1T1f2f2z2}3i3tQ%tnT1u+}1v!jbOaenpwx{|!g#O$|$}%S%h%w&S't'u(Q*`*b*q-p-w.f.m.o0]0y1S2j5a6g;`;xf-W'`-T-V-Y2p2q2s2v6q6r8pj3x.g3s3w3z3{7c7e7f7h7k9X9Y:Rr;zg$g%d%i&s*Y*t,l,v-_2_;W;X;Y;o;q;vi<^+]0z1O;a;b;p;r;w;y<W<X<Y!O&^y%X&V&Y&Z'k)h*d*f+]+e+x/m0^0y0z1O1S1j5a5v;x;yz&az%O%W%e&d's*W*_,b-x0Z0[0k0|2`2g2{5V5b6l8iS'{#Q.Xn+l&X*g+f+m+p-j/h0_1R1^4t5W5`5u8XQ2W,a^2t-X2r2x6p6w8o9se7i3y7_7g7o7p9U9W9`:Q:cS+^&U1TY+n&Y&c*v1S3iR5s1f#w!POaegnpwx{|!g#O$g$|$}%S%d%h%i%w&S&s't'u(Q*Y*`*b*q*t+],l,v-_-p-w.f.m.o0]0y0z1O1S2_2j5a6g;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<Y`oOwx!g&S't*q-w#U!Paeg{|#O$g$|$}%S%d%h%i&s'u*Y*`*b*t+],l,v-_0]0y0z1O1S2_2j5a6g;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<YU%vnp-pQ*}%wS.e(Q.mT3v.f.oW+r&^+l+s1cV+z&a+{7iQ+x&`U+z&a+{7iQ-w'tT.S'y.U'`![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fX1r+y.X5}6P'W!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/[/c/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fW1r+y.X5}6PR2e,s!WjO[wx!g!k%m&S&y&|'O'b*q,q-]-^-a2c2z6c6j8g9l9p:W:]:fY%Ve$e(b1p3iQ'S!nS(y#i5YQ,m&xQ,x'PS.O'y.UQ2b,nQ6k2iQ6|2}Q8h6fR9m8e'W![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/[/c/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fX1r+y.X5}6P'ayO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k+y,P,R,n,q,w-]-^-a-g.P.Q.U.X.}/[/c/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W5Y5e5q5}6P6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fQ&`yS't#O-uR1[+cS+^&U1TR5n1[Q1P+]R5g1OR1P+]T+^&U1Tz&[%X&V&Y&Z'k)h*d*f+]+e/m0^0y0z1O1S1j5a5v;x;yQ&]yR1n+x!P&[y%X&V&Y&Z'k)h*d*f+]+e+x/m0^0y0z1O1S1j5a5v;x;yQ+u&^S+|&a7iS1d+l+sQ1t+{R5r1c!WkO[wx!g!k%m&S&y&|'O'b*q,q-]-^-a2c2z6c6j8g9l9p:W:]:fS%zo.eS&Oq-rQ&_yQ&q!eQ'e!yQ*p%eU*{%v%{3vS+P%x%}Q+q&]Q,Y&mS,Z&n'gQ,r&{S0X*W,bS0o*|*}Q0q+OQ1o+xS2S,]-fQ5U0ZQ5Z0pQ5{1nQ6Y2RQ6]2WQ7n3yQ9S7_R:P9U[uOwx!g&S*qQ,Y&mQ-v'tQ3Y-tR3_-wxlOwx!g!k%m&S&y'O*q,q2c6c6j8g9l9p:W:]:fU$h[&|-^S%zo.eS&Oq-rQ*p%eU*{%v%{3vS+P%x%}S0X*W,bS0o*|*}Q0q+OQ5U0ZQ5Z0pQ7n3yQ9S7_R:P9UT,_&q,`]uOwx!g&S*q[uOwx!g&S*qQ,Y&mQ,n&xQ,w'PW-`'b-]-a2zQ-v'tQ3Y-tQ3_-wR6{2}[%fg$g,l,v-_2_R0l*t^$XV!U$a$z%P<R<SQ'S!nS)`#}*vS)v$W*qQ)y$YY*s%e*W0k2g2{Q/O(fS/i)i/PS0a*h4aS0j*r6_Q0r+QQ4Q.gQ4n/cS4q/j/kS4v/n5YQ4{/uQ6`2`U7a3s3y4RQ8O4rQ8k6hY9Q7_7b7c7l7mQ9r8mW9z9O9R9U9VQ:Z9oU:a9{9}:OR:j:bS)v$W*qT4v/n5YZ)t$W)u*q/n5YQ&w!hR'x#PS,g&v'vQ2[,eR6^2ZxlOwx!g!k%m&S&y'O*q,q2c6c6j8g9l9p:W:]:fV$h[&|-^!XkO[wx!g!k%m&S&y&|'O'b*q,q-]-^-a2c2z6c6j8g9l9p:W:]:f!WhO[wx!g!k%m&S&y&|'O'b*q,q-]-^-a2c2z6c6j8g9l9p:W:]:fR'W!q!WkO[wx!g!k%m&S&y&|'O'b*q,q-]-^-a2c2z6c6j8g9l9p:W:]:fR,n&xQ&y!iQ&{!jQ'O!lR,q&zR,o&xxlOwx!g!k%m&S&y'O*q,q2c6c6j8g9l9p:W:]:fX-`'b-]-a2z[uOwx!g&S*qQ,z'PQ-v'tS.k(Q.mR3_-w[uOwx!g&S*qQ,z'PW-`'b-]-a2zT.k(Q.mg-Z'`-T-V-Y2p2q2s2v6q6r8pylOwx!g!k%m&S&y'O*q,q2c6c6j8g9l9p:W:]:fb!OOaewx{!g&S*q&|$j[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f#d%jgnp|#O$g$|$}%S%d%h%i%w&s't'u(Q*Y*`*b*t+],l,v-_-p-w.f.m.o0]0y0z1O1S2_2j5a6g;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<YQ']!tQ-S'^Q-d'fQ2Q,[Q6[2TR8a6Zj$RT$_%b%r:z:{:|;[;];^;_;c;di)o$V*U:w:x:y;h;i;j;k;l;m;nj$RT$_%b%r:z:{:|;[;];^;_;c;dh)o$V*U:w:x:y;h;i;j;k;l;m;nS/^({<[V4k/_/`;u[uOwx!g&S*qQ-v'tR3_-w[uOwx!g&S*qT.k(Q.m'`!YO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fR7R3T[uOwx!g&S*qQ-v'tS.k(Q.mR3_-w[pOwx!g&S*qQ%wnS-p't-wT.f(Q.mS%{o.eS*|%v3vR0p*}Q+R%yR5]0sS%zo.eS&Oq-rU*{%v%{3vS+P%x%}S0o*|*}Q0q+OQ5Z0pQ7n3yQ9S7_R:P9U`qOwx!g&S(Q*q.mS%xn-pU%}p.f.oQ+O%wT-r't-wS'z#Q.XR.Y'{T.R'y.US.S'y.UQ8x7UR9w8yT5}1q8_R6P1q#d!Pgnp|#O$g$|$}%S%d%h%i%w&s't'u(Q*Y*`*b*t+],l,v-_-p-w.f.m.o0]0y0z1O1S2_2j5a6g;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<Yb!QOaewx{!g&S*q&}![[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f#d!Pgnp|#O$g$|$}%S%d%h%i%w&s't'u(Q*Y*`*b*t+],l,v-_-p-w.f.m.o0]0y0z1O1S2_2j5a6g;W;X;Y;`;a;b;o;p;q;r;v;w;x;y<W<X<Yb!QOaewx{!g&S*q&|![[f!W!X!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#{#}$U$W$Y$e$f$k%]%m&Q&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W4a5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fk3|.g3s3w3z3{7c7e7f7h7k9X9Y:RQ4Q.gS7a3s3yU9Q7_7c7lS9z9O9UR:a9}#|!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b't(Q(b(g)j)p*q*v+[+a+t,X,k,w,z-Q-]-^-a-o-t-w.d.m.o1S1T1X1f1k1m1|2f2l2z2}3i3t5j8ZR4].uQ(]#US.v([(^S4^.w.xR7w4_Q.s(ZR7u4X#|!TO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b't(Q(b(g)j)p*q*v+[+a+t,X,k,w,z-Q-]-^-a-o-t-w.d.m.o1S1T1X1f1k1m1|2f2l2z2}3i3t5j8Zp$w`$d$s%X&r'`(_(f)i*d-T/k1j5k5v8Uq(}#k%y.g0s3s3w3z3{7c7e7f7h7k9X9Y:RR,U&fR6W1|'X!VO[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/[/c/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:f$q#rS%T%Z'Q'X'Z'a'c(a(e(h(w(x)R)S)U)V)W)X)Y)Z)[)])^)_)k)q)x+X+g,O,S,j,u-h-i-|.y/p0`0b0g0i0w1`1y2a2h3R3c3d4c4d4j4m4s4u4y4z5d5p5w6U6e6i6s6z7q7r7t8S8T8c8f8j8r9T9[9k9q9|:T:Y:`:i$]#sS%T%Z'Q'X'Z'a'c(h(w(x)R)V)^)_)k)q)x+X+g,O,S,j,u-h-i-|.y/p0`0b0g0i0w1`1y2a2h3R3c3d4c4d4j4m4s4u4y4z5d5p5w6U6e6i6s6z7q7r7t8S8T8c8f8j8r9T9[9k9q9|:T:Y:`:i$Z#tS%T%Z'Q'X'Z'a'c(h(w(x)R)^)_)k)q)x+X+g,O,S,j,u-h-i-|.y/p0`0b0g0i0w1`1y2a2h3R3c3d4c4d4j4m4s4u4y4z5d5p5w6U6e6i6s6z7q7r7t8S8T8c8f8j8r9T9[9k9q9|:T:Y:`:i$c#wS%T%Z'Q'X'Z'a'c(h(w(x)R)U)V)W)X)^)_)k)q)x+X+g,O,S,j,u-h-i-|.y/p0`0b0g0i0w1`1y2a2h3R3c3d4c4d4j4m4s4u4y4z5d5p5w6U6e6i6s6z7q7r7t8S8T8c8f8j8r9T9[9k9q9|:T:Y:`:i'X![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/[/c/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fQ/P(fQ/j)iQ4r/kR9d7y']![O[aefwx{!W!X!g!k!n!r!s!v!x#X#Y#[#g#i#l#q#r#s#t#u#v#w#x#y#z#}$U$W$Y$e$f$k%]%m&Q&S&W&b&f&x&y&|'O'P'b'i'j'y(`(b(i)l)r*h*i*l*q*r*v+W+Y+h+j+k,P,R,n,q,w-]-^-a-g.P.Q.U.}/Q/[/c/l/n/s/u0h0{1Q1a1b1l1p1z1|2c2f2i2u2z2}3i4O4R4W5Y5e5q6_6c6f6h6j6t6v6{7b7j7m8e8g8m8s8t9R9V9]9_9l9o9p9{:O:U:W:]:b:fQ#eQR(u#eU$|a;`;xb%Ue$e&f(b-Q1m1|2l8ZQ'_!u!Q*^$|%U'_*`*f+h,P0]0^1b2p6q6t7e8p9X9]:R;W;o;p;v;w<WS*`$}%SQ*f%XS+h&W1QQ,P&bQ0]*bQ0^*dQ1b+kQ2p-VS6q2q2sQ6t2uQ7e3wQ8p6rS9X7f7hQ9]7jQ:R9YQ;W%dS;o;X;YS;p<X<YQ;v;qQ;w;rT<W0z;a[[Owx!g&S*ql$c[&|'}+[,X,h,k-P-^-o-z._.d.ql&|!k%m&y'O,q2c6c6j8g9l9p:W:]:f^'}#R#S#T+b3[3]3^`+[&U&Y&c*v1S1T1f3iS,X&m-tQ,h&wU,k&x'P2}S-P'[2kW-^'b-]-a2zS-o't-wQ-z'xQ._(PS.d(Q.mR.q(UQ)|$[R/x)|Q0R)}Q4}/|Q5O/}Q5P0OY5Q0R4}5O5P8QR8Q5SQ*P$]S0U*P0VR0V*QS.`(P._S3n.`7[R7[3pQ3q.aS7Y3o3rU7^3q7Y8{R8{7ZQ.m(QR4S.m!|_O[wx!f!g!}#O$S$l&S&U&Y&c&m&x'P'b't(Q)p*q*v+[,X,k,w,z-]-^-a-o-t-w.d.m.o1S1T1f2f2z2}3i3tU$r_$u*]U$u`$d&rR*]$sU$}a;`;xd*a$}*b2q6r7f9Y;X;q;r<XQ*b%SQ2q-VQ6r2sQ7f3wQ9Y7hQ;X%dQ;q;YQ;r<YT<X0z;aS+{&a7iR1s+{S*j%Z/pR0c*jQ1U+_R5i1UU+e&V0z;xR1]+eQ+s&^Q1c+lT1i+s1cQ8[5yR9i8[QwOS&Rw&ST&Sx*qQ,`&qR2V,`W)u$W*q/n5YR/t)uU/o)q)v0gR4w/o[*u%e%f*W2`2g2{R0m*uQ,d&uR2Y,dQ-a'bQ2z-]T2|-a2zQ2w-XR6x2wQ-f'gQ2R,]T3Q-f2RS%pm7QR*z%pdnOwx!g&S't(Q*q-w.mR%unQ0t+RR5^0tQ.U'yR3f.UQ1v+}R6Q1vU*n%`*x;ZR0f*nS1g+n0nR5t1gQ7l3yQ9O7_U9a7l9O9}R9}9U$O!SO[_ewx!f!g!u!}#O#V#Z$S$T$e$l%U&S&U&Y&c&f&m&x'P'_'b't(Q(b(g)j)p*q*v+[+a+t,X,k,w,z-Q-]-^-a-o-t-w.d.m.o.u1S1T1X1f1k1m1|2f2l2z2}3i3t5j8ZR&g!SQ4Y.sR7v4YQ1},UR6X1}S/d)_)`R4o/dW(o#a(j(k/SR/W(oQ7{4fR9f7{T)a#}*v!USO[wx!g!k%m&S&y&|'O'b,q-]-^-a2c2z6c6j8g9l9p:W:]:fj$ya{$k%]+j,R1a1z5q6v8s9_:UY%Te$e(b1p3iY%Zf$f(i)l*lQ&j!WQ&k!XQ'Q!nQ'X!rQ'Z!sQ'a!vQ'c!xQ(a#XQ(e#YS(h#[+YQ(w#gQ(x#iQ)R#lQ)S#qQ)T#rQ)U#sQ)V#tQ)W#uQ)X#vQ)Y#wQ)Z#xQ)[#yQ)]#zQ)^#{S)_#}*vQ)k$UQ)q$WQ)x$YQ+X&QS+g&W1QQ,O&bQ,S&fQ,j&xQ,u'PQ-h'iQ-i'jS-|'y.UQ.y(`S/p)r0hS0`*h4aQ0b*iQ0g*qQ0i*rQ0w+WS1`+h+kQ1y,PQ2a,nS2h,w6{Q3R-gQ3c.PQ3d.QQ4c.}Q4d/QQ4j/[Q4m/cQ4s/lQ4u/nQ4y/sQ4z/uQ5d0{Q5p1bQ5w1lQ6U1|S6e2f8tQ6i2iQ6s2uQ6z2}Q7q4OQ7r4RQ7t4WQ8S5YQ8T5eQ8c6_Q8f6fQ8j6hQ8r6tS9T7b7mQ9[7jQ9k8eQ9q8mS9|9R9VQ:T9]Q:Y9oS:`9{:OR:i:bR,V&fd]Owx!g&S't(Q*q-w.m!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)p*]*v+[,X,k,w,z-]-^-a-o-t.d.o1S1T1f2f2z2}3i3t#r${ae!u$e$|$}%S%U%X%d&W&b&f'_(b*`*b*d*f+h+k,P-Q-V0]0^1Q1b1m1|2l2p2q2s2u3w6q6r6t7e7f7h7j8Z8p9X9Y9]:R;W;X;Y;`;a;o;p;q;r;v;w<W<X<YQ%tnS+d&V+eW+r&^+l+s1cU+z&a+{7iQ1k+tT5c0z;x``Owx!g&S't*q-wS$d[-oQ$s_b%Xe$e&f(b-Q1m1|2l8Z!h&r!f!}#O$S$l&U&Y&c&m&x'P'b(Q)p*v+[,X,k,w,z-]-^-a-t.d.m.o1S1T1f2f2z2}3i3tQ'`!uS(_#V+aQ(f#ZS)i$T(gQ*d%UQ-T'_Q/k)jQ1j+tQ5k1XQ5v1kR8U5jS(W#R3]S(X#S3^V(Y#T+b3[R$^Ye0Q)}/|/}0O0R4}5O5P5S8QW(R#R#S#T+bQ([#US.Z'}(US.a(P._Q.x(^W1r+y.X5}6PQ3Z-tQ3h.WQ3o.`Q4V.qU7T3[3]3^Q7]3pR8|7[Q.b(PR3m._T.l(Q.mdgOwx!g&S&m't*q-t-wU$g[,X-oQ&s!fQ'k!}Q'u#OQ)h$SQ*Y$l`+]&U&Y&c*v1S1T1f3iQ,l&xQ,v'PY-_'b-]-a2z2}S.g(Q.mQ/m)pQ0y+[S2_,k-^S2j,w,zS3s.d.oQ6g2fR7c3td]Owx!g&S't(Q*q-w.m!v^[_`!f!}#O$S$d$l$s$u&U&Y&c&m&r&x'P'b)p*]*v+[,X,k,w,z-]-^-a-o-t.d.o1S1T1f2f2z2}3i3tR%tnQ3y.gQ7_3sQ7g3wQ7o3zQ7p3{Q9U7cU9W7e7f7hQ9`7kS:Q9X9YR:c:RZ+o&Y&c*v1S3ipzOnpwx!g%w&S't(Q*q-p-w.f.m.o[%Oa%d0z;`;a;xU%We%h1SQ%eg^&d{|%i1O5a;b;yQ's#OQ*W$gb*_$|$}%S;W;X;Y<W<X<YQ,b&sQ-x'uQ0Z*Y[0[*`*b;o;p;q;rQ0k*tQ0|+]Q2`,lQ2g,vS2{-_2_U5V0];v;wQ5b0yQ6l2jR8i6gQ+}&aR9Z7iS1q+y.XQ8^5}R8_6P[%^f$f(i)l)r0hR0d*lR+`&UQ+_&UR5h1TS&Xy+xQ*g%XU+f&V0z;xS+m&Y1SW+p&Z1O5a;yQ-j'kQ/h)hS0_*d*fQ1R+]Q1^+eQ4t/mQ5W0^Q5`0yQ5u1jR8X5vR5z1mYvOwx&S*qR&t!gW%gg,l,v-_T*X$g2_T)w$W*q[uOwx!g&S*qQ&}!kQ*y%mQ,p&yQ,t'OQ2d,qQ6b2cQ8d6cQ8l6jQ9n8gQ:X9lQ:[9pQ:e:WQ:g:]R:k:fxlOwx!g!k%m&S&y'O*q,q2c6c6j8g9l9p:W:]:fU$h[&|-^X-`'b-]-a2zQ-['`R2o-TS-X'`-TQ2r-VQ2x-YU6p2p2q2sQ6w2vS8o6q6rR9s8p[rOwx!g&S*qS-q't-wT.h(Q.mR+S%y[sOwx!g&S*qS-s't-wT.i(Q.m[tOwx!g&S*qT.j(Q.mT.T'y.UX%af%k0h1QQ.w([R4_.xR.t(ZR(d#XQ(r#aS/R(j(kR4e/SR/V(lR4g/T",
  nodeNames: "âš  RawString > MacroName LineComment BlockComment PreprocDirective #include String EscapeSequence SystemLibString Identifier ArgumentList ( ConditionalExpression AssignmentExpression CallExpression PrimitiveType FieldExpression FieldIdentifier DestructorName TemplateMethod ScopedFieldIdentifier NamespaceIdentifier TemplateType TypeIdentifier ScopedTypeIdentifier ScopedNamespaceIdentifier :: NamespaceIdentifier TypeIdentifier TemplateArgumentList < TypeDescriptor const volatile restrict _Atomic mutable constexpr constinit consteval StructSpecifier struct MsDeclspecModifier __declspec ) Attribute AttributeName Identifier AttributeArgs { } [ ] UpdateOp ArithOp ArithOp ArithOp LogicOp BitOp BitOp BitOp CompareOp CompareOp CompareOp > CompareOp BitOp UpdateOp , Number CharLiteral AttributeArgs VirtualSpecifier BaseClassClause Access virtual FieldDeclarationList FieldDeclaration extern static register inline thread_local AttributeSpecifier __attribute__ PointerDeclarator MsBasedModifier __based MsPointerModifier FunctionDeclarator ParameterList ParameterDeclaration PointerDeclarator FunctionDeclarator Noexcept noexcept RequiresClause requires True False ParenthesizedExpression CommaExpression LambdaExpression LambdaCaptureSpecifier TemplateParameterList OptionalParameterDeclaration TypeParameterDeclaration typename class VariadicParameterDeclaration VariadicDeclarator ReferenceDeclarator OptionalTypeParameterDeclaration VariadicTypeParameterDeclaration TemplateTemplateParameterDeclaration template AbstractFunctionDeclarator AbstractPointerDeclarator AbstractArrayDeclarator AbstractParenthesizedDeclarator AbstractReferenceDeclarator ThrowSpecifier throw TrailingReturnType CompoundStatement FunctionDefinition MsCallModifier TryStatement try CatchClause catch LinkageSpecification Declaration InitDeclarator InitializerList InitializerPair SubscriptDesignator FieldDesignator ExportDeclaration export ImportDeclaration import ModuleName PartitionName HeaderName CaseStatement case default LabeledStatement StatementIdentifier ExpressionStatement IfStatement if ConditionClause Declaration else SwitchStatement switch DoStatement do while WhileStatement ForStatement for ReturnStatement return BreakStatement break ContinueStatement continue GotoStatement goto CoReturnStatement co_return CoYieldStatement co_yield AttributeStatement ForRangeLoop AliasDeclaration using TypeDefinition typedef PointerDeclarator FunctionDeclarator ArrayDeclarator ParenthesizedDeclarator ThrowStatement NamespaceDefinition namespace ScopedIdentifier Identifier OperatorName operator ArithOp BitOp CompareOp LogicOp new delete co_await ConceptDefinition concept UsingDeclaration enum StaticAssertDeclaration static_assert ConcatenatedString TemplateDeclaration FriendDeclaration friend union FunctionDefinition ExplicitFunctionSpecifier explicit FieldInitializerList FieldInitializer DefaultMethodClause DeleteMethodClause FunctionDefinition OperatorCast operator TemplateInstantiation FunctionDefinition FunctionDefinition Declaration ModuleDeclaration module RequiresExpression RequirementList SimpleRequirement TypeRequirement CompoundRequirement ReturnTypeRequirement ConstraintConjuction LogicOp ConstraintDisjunction LogicOp ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator TemplateFunction OperatorName StructuredBindingDeclarator ArrayDeclarator ParenthesizedDeclarator ReferenceDeclarator BitfieldClause FunctionDefinition FunctionDefinition Declaration FunctionDefinition Declaration AccessSpecifier UnionSpecifier ClassSpecifier EnumSpecifier SizedTypeSpecifier TypeSize EnumeratorList Enumerator DependentType Decltype decltype auto PlaceholderTypeSpecifier ParameterPackExpansion ParameterPackExpansion FieldIdentifier PointerExpression SubscriptExpression BinaryExpression ArithOp LogicOp LogicOp BitOp UnaryExpression LogicOp BitOp UpdateExpression CastExpression SizeofExpression sizeof CoAwaitExpression CompoundLiteralExpression NULL NewExpression new NewDeclarator DeleteExpression delete ParameterPackExpansion nullptr this UserDefinedLiteral ParamPack #define PreprocArg #if #ifdef #ifndef #else #endif #elif PreprocDirectiveName Macro Program",
  maxTerm: 425,
  nodeProps: [
    ["group", -35, 1, 8, 11, 14, 15, 16, 18, 71, 72, 100, 101, 102, 104, 191, 208, 229, 242, 243, 270, 271, 272, 277, 280, 281, 282, 284, 285, 286, 287, 290, 292, 293, 294, 295, 296, "Expression", -13, 17, 24, 25, 26, 42, 255, 256, 257, 258, 262, 263, 265, 266, "Type", -19, 126, 129, 147, 150, 152, 153, 158, 160, 163, 164, 166, 168, 170, 172, 174, 176, 178, 179, 188, "Statement"],
    ["isolate", -4, 4, 5, 8, 10, ""]
  ],
  propSources: [mw],
  skippedNodes: [0, 3, 4, 5, 6, 7, 10, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 347, 348],
  repeatNodeCount: 41,
  tokenData: "&*r7ZR!UOX$eXY({YZ.gZ]$e]^+P^p$epq({qr.}rs0}st2ktu$euv!7dvw!9bwx!;exy!<Yyz!=Tz{!>O{|!?R|}!AV}!O!BQ!O!P!DX!P!Q#+y!Q!R#Az!R![$(x![!]$Ag!]!^$Cc!^!_$D^!_!`%1W!`!a%2X!a!b%5_!b!c$e!c!n%6Y!n!o%7q!o!w%6Y!w!x%7q!x!}%6Y!}#O%:n#O#P%<g#P#Q%Kz#Q#R%Ms#R#S%6Y#S#T$e#T#i%6Y#i#j%Nv#j#o%6Y#o#p&!e#p#q&#`#q#r&%f#r#s&&a#s;'S$e;'S;=`(u<%lO$e&t$nY)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e&r%eW)ZW'f&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^&j&SU'f&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j&kX'f&jOY%}YZ%}Z]%}]^'W^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j']V'f&jOY%}YZ%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&j'uP;=`<%l%}&r'{P;=`<%l%^&l(VW(pQ'f&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O&l(rP;=`<%l(O&t(xP;=`<%l$e7Z)Y`)ZW(pQ(n.o'f&j*Z)`OX$eXY({YZ*[Z]$e]^+P^p$epq({qr$ers%^sw$ewx(Ox#O$e#O#P,^#P;'S$e;'S;=`(u<%lO$e.o*aT(n.oXY*[YZ*[]^*[pq*[#O#P*p.o*sQYZ*[]^*y.o*|PYZ*[4e+[`)ZW(pQ(n.o'f&jOX$eXY+PYZ*[Z]$e]^+P^p$epq+Pqr$ers%^sw$ewx(Ox#O$e#O#P,^#P;'S$e;'S;=`(u<%lO$e4Z,cX'f&jOY%}YZ-OZ]%}]^-{^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}4Z-V[(n.o'f&jOX%}XY-OYZ*[Z]%}]^-O^p%}pq-Oq#O%}#O#P,^#P;'S%};'S;=`'r<%lO%}4Z.QV'f&jOY%}YZ-OZ#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}7P.nT*W)`(n.oXY*[YZ*[]^*[pq*[#O#P*p3o/[[%^!b'QP)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`0Q!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o0_Y%]!b!a,g)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e6e1YY)ZW(qQ(o/]'f&jOY%^Zr%^rs1xsw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^(U2RW)x!b)ZW'f&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^4e2tf)ZW(pQ'f&jOX$eXY2kZp$epq2kqr$ers%^sw$ewx(Ox!c$e!c!}4Y!}#O$e#O#P&f#P#T$e#T#W4Y#W#X5m#X#Y>u#Y#]4Y#]#^NZ#^#o4Y#o;'S$e;'S;=`(u<%lO$e4e4eb)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e5xd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y7W#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e7cd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z8q#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e8|d)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^:[#^#o4Y#o;'S$e;'S;=`(u<%lO$e4e:gd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#b4Y#b#c;u#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e<Qd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y=`#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e=mb)ZW(pQ'e.o'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e?Qf)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#`4Y#`#a@f#a#b4Y#b#cHV#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e@qf)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^BV#^#g4Y#g#hEV#h#o4Y#o;'S$e;'S;=`(u<%lO$e4eBbd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#ZCp#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4eC}b)ZW(pQ'f&j'l.o'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eEbd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#YFp#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4eF}b)ZW(pQ'j.o'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eHbd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#XIp#X#o4Y#o;'S$e;'S;=`(u<%lO$e4eI{d)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#]4Y#]#^KZ#^#o4Y#o;'S$e;'S;=`(u<%lO$e4eKfd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#ZLt#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4eMRb)ZW(pQ'f&j'k.o'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4eNff)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z! z#Z#b4Y#b#c!.[#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e!!Xf)ZW(pQ'g.o'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!#m#X#b4Y#b#c!(W#c#o4Y#o;'S$e;'S;=`(u<%lO$e4e!#xd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!%W#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!%cd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z!&q#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e!'Ob)ZW(pQ'h.o'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e!(cd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!)q#X#o4Y#o;'S$e;'S;=`(u<%lO$e4e!)|d)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!+[#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!+gd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#Y4Y#Y#Z!,u#Z#o4Y#o;'S$e;'S;=`(u<%lO$e4e!-Sb)ZW(pQ'i.o'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e4e!.gd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#V4Y#V#W!/u#W#o4Y#o;'S$e;'S;=`(u<%lO$e4e!0Qd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#`4Y#`#a!1`#a#o4Y#o;'S$e;'S;=`(u<%lO$e4e!1kd)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#i4Y#i#j!2y#j#o4Y#o;'S$e;'S;=`(u<%lO$e4e!3Ud)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#W4Y#W#X!4d#X#o4Y#o;'S$e;'S;=`(u<%lO$e4e!4od)ZW(pQ'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#X4Y#X#Y!5}#Y#o4Y#o;'S$e;'S;=`(u<%lO$e4e!6[b)ZW(pQV.o'f&j'm.oOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![4Y![!c$e!c!}4Y!}#O$e#O#P&f#P#R$e#R#S4Y#S#T$e#T#o4Y#o;'S$e;'S;=`(u<%lO$e3o!7q[)ZW(pQ%Z!b![,g'f&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!8rY!g-y)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!9o])V,g)ZW(pQ%[!b'f&jOY$eZr$ers%^sv$evw!:hwx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!:uY)U,g%^!b)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2X!;pW)[S(pQ)Y,g'f&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O6i!<eY)ZW(pQ]6_'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e'V!=`Y!Oa)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!>][)S,g)ZW(pQ%Z!b'f&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!?`^)ZW(pQ%Z!b!Y,g'f&jOY$eZr$ers%^sw$ewx(Ox{$e{|!@[|!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!@gY)ZW!X-y(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!AbY!h,k)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!B__)ZW(pQ%Z!b!Y,g'f&jOY$eZr$ers%^sw$ewx(Ox}$e}!O!@[!O!_$e!_!`!8g!`!a!C^!a#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o!CiY(x-y)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!Dd^)ZW(pQ'f&j(w,gOY$eZr$ers%^sw$ewx(Ox!O$e!O!P!E`!P!Q$e!Q![!GY![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!Ei[)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P!F_!P#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2a!FjY)X,k)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]!Gen)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx!Icx!Q$e!Q![!GY![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2T!IjY(pQ'f&jOY(OZr(Ors%}s!Q(O!Q![!JY![#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O2T!Jcn(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx!Icx!Q(O!Q![!JY![!g(O!g!h!La!h!i##`!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#X(O#X#Y!La#Y#Z##`#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T!Ljl(pQ!i,g'f&jOY(OZr(Ors%}s{(O{|!Nb|}(O}!O!Nb!O!Q(O!Q![# e![!c(O!c!h# e!h!i# e!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#Y# e#Y#Z# e#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T!Ni^(pQ'f&jOY(OZr(Ors%}s!Q(O!Q![# e![!c(O!c!i# e!i#O(O#O#P&f#P#T(O#T#Z# e#Z;'S(O;'S;=`(o<%lO(O2T# nj(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx!Nbx!Q(O!Q![# e![!c(O!c!h# e!h!i# e!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#Y# e#Y#Z# e#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T##id(pQ!i,g'f&jOY(OZr(Ors%}s!h(O!h!i##`!i!n(O!n!o##`!o!w(O!w!x##`!x#O(O#O#P&f#P#Y(O#Y#Z##`#Z#`(O#`#a##`#a#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]#%Sn)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx(Ox{$e{|#'Q|}$e}!O#'Q!O!Q$e!Q![#(]![!c$e!c!h#(]!h!i#(]!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#Y#(]#Y#Z#(]#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]#'Z`)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![#(]![!c$e!c!i#(]!i#O$e#O#P&f#P#T$e#T#Z#(]#Z;'S$e;'S;=`(u<%lO$e2]#(hj)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx!Nbx!Q$e!Q![#(]![!c$e!c!h#(]!h!i#(]!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#Y#(]#Y#Z#(]#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]#*ef)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx(Ox!h$e!h!i#*Y!i!n$e!n!o#*Y!o!w$e!w!x#*Y!x#O$e#O#P&f#P#Y$e#Y#Z#*Y#Z#`$e#`#a#*Y#a#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e7Z#,W`)ZW(pQ%Z!b![,g'f&jOY$eZr$ers%^sw$ewx(Oxz$ez{#-Y{!P$e!P!Q#:s!Q!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z#-c])ZW(pQ'f&jOY#-YYZ#.[Zr#-Yrs#/csw#-Ywx#5wxz#-Yz{#8j{#O#-Y#O#P#2`#P;'S#-Y;'S;=`#:m<%lO#-Y1e#._TOz#.[z{#.n{;'S#.[;'S;=`#/]<%lO#.[1e#.qVOz#.[z{#.n{!P#.[!P!Q#/W!Q;'S#.[;'S;=`#/]<%lO#.[1e#/]OT1e1e#/`P;=`<%l#.[7X#/jZ)ZW'f&jOY#/cYZ#.[Zw#/cwx#0]xz#/cz{#4O{#O#/c#O#P#2`#P;'S#/c;'S;=`#5q<%lO#/c7P#0bX'f&jOY#0]YZ#.[Zz#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#1SZ'f&jOY#0]YZ#.[Zz#0]z{#0}{!P#0]!P!Q#1u!Q#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#1|UT1e'f&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}7P#2eZ'f&jOY#0]YZ#0]Z]#0]]^#3W^z#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#3]X'f&jOY#0]YZ#0]Zz#0]z{#0}{#O#0]#O#P#2`#P;'S#0];'S;=`#3x<%lO#0]7P#3{P;=`<%l#0]7X#4V])ZW'f&jOY#/cYZ#.[Zw#/cwx#0]xz#/cz{#4O{!P#/c!P!Q#5O!Q#O#/c#O#P#2`#P;'S#/c;'S;=`#5q<%lO#/c7X#5XW)ZWT1e'f&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^7X#5tP;=`<%l#/c7R#6OZ(pQ'f&jOY#5wYZ#.[Zr#5wrs#0]sz#5wz{#6q{#O#5w#O#P#2`#P;'S#5w;'S;=`#8d<%lO#5w7R#6x](pQ'f&jOY#5wYZ#.[Zr#5wrs#0]sz#5wz{#6q{!P#5w!P!Q#7q!Q#O#5w#O#P#2`#P;'S#5w;'S;=`#8d<%lO#5w7R#7zW(pQT1e'f&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O7R#8gP;=`<%l#5w7Z#8s_)ZW(pQ'f&jOY#-YYZ#.[Zr#-Yrs#/csw#-Ywx#5wxz#-Yz{#8j{!P#-Y!P!Q#9r!Q#O#-Y#O#P#2`#P;'S#-Y;'S;=`#:m<%lO#-Y7Z#9}Y)ZW(pQT1e'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z#:pP;=`<%l#-Y7Z#;OY)ZW(pQS1e'f&jOY#:sZr#:srs#;nsw#:swx#@{x#O#:s#O#P#<z#P;'S#:s;'S;=`#At<%lO#:s7X#;wW)ZWS1e'f&jOY#;nZw#;nwx#<ax#O#;n#O#P#<z#P;'S#;n;'S;=`#@u<%lO#;n7P#<hUS1e'f&jOY#<aZ#O#<a#O#P#<z#P;'S#<a;'S;=`#>[<%lO#<a7P#=RXS1e'f&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P;'S#<a;'S;=`#>[<%lO#<a7P#=uVS1e'f&jOY#<aYZ%}Z#O#<a#O#P#<z#P;'S#<a;'S;=`#>[<%lO#<a7P#>_P;=`<%l#<a7P#>i]S1e'f&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P#b#<a#b#c#<a#c#f#<a#f#g#?b#g;'S#<a;'S;=`#>[<%lO#<a7P#?iUS1e'f&jOY#<aZ#O#<a#O#P#?{#P;'S#<a;'S;=`#>[<%lO#<a7P#@SZS1e'f&jOY#<aYZ%}Z]#<a]^#=n^#O#<a#O#P#>b#P#b#<a#b#c#<a#c;'S#<a;'S;=`#>[<%lO#<a7X#@xP;=`<%l#;n7R#AUW(pQS1e'f&jOY#@{Zr#@{rs#<as#O#@{#O#P#<z#P;'S#@{;'S;=`#An<%lO#@{7R#AqP;=`<%l#@{7Z#AwP;=`<%l#:s2]#BVt)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#U$e#U#V$+X#V#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$=`#m;'S$e;'S;=`(u<%lO$e2T#DnY(pQ'f&jOY(OZr(Ors%}s!Q(O!Q![#E^![#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O2T#Egp(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx#Dgx!O(O!O!P#Gk!P!Q(O!Q![#E^![!g(O!g!h!La!h!i##`!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#X(O#X#Y!La#Y#Z##`#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#Gtn(pQ!i,g'f&jOY(OZr(Ors%}s!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#I{p(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx#LPx!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T#LW^(pQ'f&jOY(OZr(Ors%}s!Q(O!Q![#Ir![!c(O!c!i#Ir!i#O(O#O#P&f#P#T(O#T#Z#Ir#Z;'S(O;'S;=`(o<%lO(O2T#M]t(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx#LPx{(O{|!Nb|}(O}!O!Nb!O!Q(O!Q![#Ir![!c(O!c!g#Ir!g!h#MS!h!i#Ir!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X#Ir#X#Y#MS#Y#Z#Ir#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]$ xp)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$$Xp)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx#LPx!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$&ht)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx#LPx{$e{|#'Q|}$e}!O#'Q!O!Q$e!Q![$#|![!c$e!c!g$#|!g!h$&]!h!i$#|!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$#|#X#Y$&]#Y#Z$#|#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$)Tp)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$+b_)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P$,a!P!Q$e!Q!R$-`!R![$(x![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$,j[)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![!GY![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$-kt)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx#Dgx!O$e!O!P$ m!P!Q$e!Q![$(x![!g$e!g!h#$w!h!i#*Y!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#U$e#U#V$/{#V#X$e#X#Y#$w#Y#Z#*Y#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$0z#m;'S$e;'S;=`(u<%lO$e2]$0U[)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$(x![#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$1T`)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![$2V![!c$e!c!i$2V!i#O$e#O#P&f#P#T$e#T#Z$2V#Z;'S$e;'S;=`(u<%lO$e2]$2br)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx$4lx!O$e!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2T$4s^(pQ'f&jOY(OZr(Ors%}s!Q(O!Q![$5o![!c(O!c!i$5o!i#O(O#O#P&f#P#T(O#T#Z$5o#Z;'S(O;'S;=`(o<%lO(O2T$5xr(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx$4lx!O(O!O!P#Gk!P!Q(O!Q![$5o![!c(O!c!g$5o!g!h$8S!h!i$5o!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X$5o#X#Y$8S#Y#Z$5o#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2T$8]u(pQ!i,g'f&jOY(OZr(Ors%}sw(Owx$4lx{(O{|!Nb|}(O}!O!Nb!O!P#Gk!P!Q(O!Q![$5o![!c(O!c!g$5o!g!h$8S!h!i$5o!i!n(O!n!o##`!o!r(O!r!s!La!s!w(O!w!x##`!x#O(O#O#P&f#P#T(O#T#X$5o#X#Y$8S#Y#Z$5o#Z#`(O#`#a##`#a#d(O#d#e!La#e#i(O#i#j##`#j;'S(O;'S;=`(o<%lO(O2]$:{u)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx$4lx{$e{|#'Q|}$e}!O#'Q!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j;'S$e;'S;=`(u<%lO$e2]$=ic)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!O$e!O!P$,a!P!Q$e!Q!R$>t!R![$2V![!c$e!c!i$2V!i#O$e#O#P&f#P#T$e#T#Z$2V#Z;'S$e;'S;=`(u<%lO$e2]$?Pv)ZW(pQ!i,g'f&jOY$eZr$ers%^sw$ewx$4lx!O$e!O!P$ m!P!Q$e!Q![$2V![!c$e!c!g$2V!g!h$:p!h!i$2V!i!n$e!n!o#*Y!o!r$e!r!s#$w!s!w$e!w!x#*Y!x#O$e#O#P&f#P#T$e#T#U$2V#U#V$2V#V#X$2V#X#Y$:p#Y#Z$2V#Z#`$e#`#a#*Y#a#d$e#d#e#$w#e#i$e#i#j#*Y#j#l$e#l#m$0z#m;'S$e;'S;=`(u<%lO$e4e$Ar[(v-X)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox![$e![!]$Bh!]#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3s$BsYl-})ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e2]$CnY)W,g)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7V$Dk_p,g%]!b)ZW(pQ'f&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!^$Ej!^!_%+w!_!`%.U!`!a%0]!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej*[$Es])ZW(pQ'f&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ejp$FoTO!`$Fl!`!a$GO!a;'S$Fl;'S;=`$GT<%lO$Flp$GTO$Wpp$GWP;=`<%l$Fl*Y$GbZ)ZW'f&jOY$GZYZ$FlZw$GZwx$HTx!`$GZ!`!a%(U!a#O$GZ#O#P$Ib#P;'S$GZ;'S;=`%(y<%lO$GZ*Q$HYX'f&jOY$HTYZ$FlZ!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT*Q$IOU$WpY#t'f&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}*Q$Ig['f&jOY$HTYZ$HTZ]$HT]^$J]^!`$HT!`!a$NO!a#O$HT#O#P%&n#P;'S$HT;'S;=`%'f;=`<%l%$z<%lO$HT*Q$JbX'f&jOY$HTYZ$J}Z!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT'[$KSX'f&jOY$J}YZ$FlZ!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$KvU$Wp'f&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}'[$L_Z'f&jOY$J}YZ$J}Z]$J}]^$MQ^!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$MVX'f&jOY$J}YZ$J}Z!`$J}!`!a$Ko!a#O$J}#O#P$LY#P;'S$J};'S;=`$Mr<%lO$J}'[$MuP;=`<%l$J}*Q$M{P;=`<%l$HT*Q$NVW$Wp'f&jOY$NoZ!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`$NtW'f&jOY$NoZ!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`% eUY#t'f&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%})`% |Y'f&jOY$NoYZ$NoZ]$No]^%!l^#O$No#O#P%#d#P;'S$No;'S;=`%$[;=`<%l%$z<%lO$No)`%!qX'f&jOY$NoYZ%}Z!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`%#aP;=`<%l$No)`%#iZ'f&jOY$NoYZ%}Z]$No]^%!l^!`$No!`!a% ^!a#O$No#O#P% w#P;'S$No;'S;=`%#^<%lO$No)`%$_XOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l$No<%lO%$z#t%$}WOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h<%lO%$z#t%%lOY#t#t%%oRO;'S%$z;'S;=`%%x;=`O%$z#t%%{XOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l%$z<%lO%$z#t%&kP;=`<%l%$z*Q%&sZ'f&jOY$HTYZ$J}Z]$HT]^$J]^!`$HT!`!a$Hu!a#O$HT#O#P$Ib#P;'S$HT;'S;=`$Mx<%lO$HT*Q%'iXOY%$zZ!`%$z!`!a%%g!a#O%$z#O#P%%l#P;'S%$z;'S;=`%&h;=`<%l$HT<%lO%$z*Y%(aW$WpY#t)ZW'f&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^*Y%(|P;=`<%l$GZ*S%)WZ(pQ'f&jOY%)PYZ$FlZr%)Prs$HTs!`%)P!`!a%)y!a#O%)P#O#P$Ib#P;'S%)P;'S;=`%*n<%lO%)P*S%*UW$WpY#t(pQ'f&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O*S%*qP;=`<%l%)P*[%+RY$WpY#t)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e*[%+tP;=`<%l$Ej7V%,U^)ZW(pQ%[!b!f,g'f&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!_$Ej!_!`%-Q!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%-]]!g-y)ZW(pQ'f&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%*t!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%.c]%]!b!b,g)ZW(pQ'f&jOY$EjYZ$FlZr$Ejrs$GZsw$Ejwx%)Px!`$Ej!`!a%/[!a#O$Ej#O#P$Ib#P;'S$Ej;'S;=`%+q<%lO$Ej7V%/mY%]!b!b,g$WpY#t)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e)j%0hYY#t)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%1c[)j!c)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`0Q!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%2f]%]!b)ZW(pQ!d,g'f&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`%3_!`!a%4[!a#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%3lY%]!b!b,g)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%4i[)ZW(pQ%[!b!f,g'f&jOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e&u%5jY(uP)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z%6ib)ZW(yS(pQ!R,f(r%y'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e7Z%8Qb)ZW(yS(pQ!R,f(r%y'f&jOY$eZr$ers%9Ysw$ewx%9{x!Q$e!Q![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e5P%9cW)ZW(o/]'f&jOY%^Zw%^wx%}x#O%^#O#P&f#P;'S%^;'S;=`'x<%lO%^2T%:UW(pQ)Y,g'f&jOY(OZr(Ors%}s#O(O#O#P&f#P;'S(O;'S;=`(o<%lO(O3o%:yZ!V-y)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox!}$e!}#O%;l#O#P&f#P;'S$e;'S;=`(u<%lO$e&u%;wY)PP)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e4e%<la'f&jOY%=qYZ%>[Z]%=q]^%?Z^!Q%=q!Q![%?w![!w%=q!w!x%AX!x#O%=q#O#P%H_#P#i%=q#i#j%Ds#j#l%=q#l#m%IR#m;'S%=q;'S;=`%Kt<%lO%=q&t%=xUXY'f&jOY%}Z#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}4e%>e[XY(n.o'f&jOX%}XY-OYZ*[Z]%}]^-O^p%}pq-Oq#O%}#O#P,^#P;'S%};'S;=`'r<%lO%}4e%?bVXY'f&jOY%}YZ-OZ#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%@OWXY'f&jOY%}Z!Q%}!Q![%@h![#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%@oWXY'f&jOY%}Z!Q%}!Q![%=q![#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%A^['f&jOY%}Z!Q%}!Q![%BS![!c%}!c!i%BS!i#O%}#O#P&f#P#T%}#T#Z%BS#Z;'S%};'S;=`'r<%lO%}&t%BX['f&jOY%}Z!Q%}!Q![%B}![!c%}!c!i%B}!i#O%}#O#P&f#P#T%}#T#Z%B}#Z;'S%};'S;=`'r<%lO%}&t%CS['f&jOY%}Z!Q%}!Q![%Cx![!c%}!c!i%Cx!i#O%}#O#P&f#P#T%}#T#Z%Cx#Z;'S%};'S;=`'r<%lO%}&t%C}['f&jOY%}Z!Q%}!Q![%Ds![!c%}!c!i%Ds!i#O%}#O#P&f#P#T%}#T#Z%Ds#Z;'S%};'S;=`'r<%lO%}&t%Dx['f&jOY%}Z!Q%}!Q![%En![!c%}!c!i%En!i#O%}#O#P&f#P#T%}#T#Z%En#Z;'S%};'S;=`'r<%lO%}&t%Es['f&jOY%}Z!Q%}!Q![%Fi![!c%}!c!i%Fi!i#O%}#O#P&f#P#T%}#T#Z%Fi#Z;'S%};'S;=`'r<%lO%}&t%Fn['f&jOY%}Z!Q%}!Q![%Gd![!c%}!c!i%Gd!i#O%}#O#P&f#P#T%}#T#Z%Gd#Z;'S%};'S;=`'r<%lO%}&t%Gi['f&jOY%}Z!Q%}!Q![%=q![!c%}!c!i%=q!i#O%}#O#P&f#P#T%}#T#Z%=q#Z;'S%};'S;=`'r<%lO%}&t%HfXXY'f&jOY%}YZ%}Z]%}]^'W^#O%}#O#P&f#P;'S%};'S;=`'r<%lO%}&t%IW['f&jOY%}Z!Q%}!Q![%I|![!c%}!c!i%I|!i#O%}#O#P&f#P#T%}#T#Z%I|#Z;'S%};'S;=`'r<%lO%}&t%JR['f&jOY%}Z!Q%}!Q![%Jw![!c%}!c!i%Jw!i#O%}#O#P&f#P#T%}#T#Z%Jw#Z;'S%};'S;=`'r<%lO%}&t%KO[XY'f&jOY%}Z!Q%}!Q![%Jw![!c%}!c!i%Jw!i#O%}#O#P&f#P#T%}#T#Z%Jw#Z;'S%};'S;=`'r<%lO%}&t%KwP;=`<%l%=q2a%LVZ!W,V)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P#Q%Lx#Q;'S$e;'S;=`(u<%lO$e'Y%MTY)]d)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o%NQ[)ZW(pQ%[!b'f&j!_,gOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e7Z& Vd)ZW(yS(pQ!R,f(r%y'f&jOY$eZr$ers%9Ysw$ewx%9{x!Q$e!Q!Y%6Y!Y!Z%7q!Z![%6Y![!c$e!c!}%6Y!}#O$e#O#P&f#P#R$e#R#S%6Y#S#T$e#T#o%6Y#o;'S$e;'S;=`(u<%lO$e2]&!pY!T,g)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e3o&#m^)ZW(pQ%[!b'f&j!^,gOY$eZr$ers%^sw$ewx(Ox!_$e!_!`!8g!`#O$e#O#P&f#P#p$e#p#q&$i#q;'S$e;'S;=`(u<%lO$e3o&$vY)T,g%^!b)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e'V&%qY!Ua)ZW(pQ'f&jOY$eZr$ers%^sw$ewx(Ox#O$e#O#P&f#P;'S$e;'S;=`(u<%lO$e(]&&nc)ZW(pQ%[!b'RP'f&jOX$eXY&'yZp$epq&'yqr$ers%^sw$ewx(Ox!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e&y&(Sc)ZW(pQ'f&jOX$eXY&'yZp$epq&'yqr$ers%^sw$ewx(Ox!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e&y&)jb)ZW(pQdT'f&jOY$eZr$ers%^sw$ewx(Ox!Q$e!Q![&)_![!c$e!c!}&)_!}#O$e#O#P&f#P#R$e#R#S&)_#S#T$e#T#o&)_#o;'S$e;'S;=`(u<%lO$e",
  tokenizers: [dw, pw, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
  topRules: { Program: [0, 307] },
  dynamicPrecedences: { 87: 1, 94: 1, 119: 1, 184: 1, 187: -10, 240: -10, 241: 1, 244: -1, 246: -10, 247: 1, 262: -1, 267: 2, 268: 2, 306: -10, 365: 3, 417: 1, 418: 3, 419: 1, 420: 1 },
  specialized: [{ term: 356, get: (t) => Pw[t] || -1 }, { term: 32, get: (t) => gw[t] || -1 }, { term: 66, get: (t) => Sw[t] || -1 }, { term: 363, get: (t) => Xw[t] || -1 }],
  tokenPrec: 24891
}), bw = /* @__PURE__ */ re.define({
  name: "cpp",
  parser: /* @__PURE__ */ yw.configure({
    props: [
      /* @__PURE__ */ me.add({
        IfStatement: /* @__PURE__ */ ae({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ae({ except: /^\s*({|catch)\b/ }),
        LabeledStatement: qn,
        CaseStatement: (t) => t.baseIndent + t.unit,
        BlockComment: () => null,
        CompoundStatement: /* @__PURE__ */ YO({ closing: "}" }),
        Statement: /* @__PURE__ */ ae({ except: /^{/ })
      }),
      /* @__PURE__ */ fe.add({
        "DeclarationList CompoundStatement EnumeratorList FieldDeclarationList InitializerList": Ie,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/,
    closeBrackets: { stringPrefixes: ["L", "u", "U", "u8", "LR", "UR", "uR", "u8R", "R"] }
  }
});
function xw() {
  return new le(bw);
}
const Tw = se({
  null: l.null,
  instanceof: l.operatorKeyword,
  this: l.self,
  "new super assert open to with void": l.keyword,
  "class interface extends implements enum var": l.definitionKeyword,
  "module package import": l.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": l.controlKeyword,
  "requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws": l.modifier,
  IntegerLiteral: l.integer,
  FloatingPointLiteral: l.float,
  "StringLiteral TextBlock": l.string,
  CharacterLiteral: l.character,
  LineComment: l.lineComment,
  BlockComment: l.blockComment,
  BooleanLiteral: l.bool,
  PrimitiveType: l.standard(l.typeName),
  TypeName: l.typeName,
  Identifier: l.variableName,
  "MethodName/Identifier": l.function(l.variableName),
  Definition: l.definition(l.variableName),
  ArithOp: l.arithmeticOperator,
  LogicOp: l.logicOperator,
  BitOp: l.bitwiseOperator,
  CompareOp: l.compareOperator,
  AssignOp: l.definitionOperator,
  UpdateOp: l.updateOperator,
  Asterisk: l.punctuation,
  Label: l.labelName,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace,
  ".": l.derefOperator,
  ", ;": l.separator
}), ww = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 238, open: 267, module: 269, requires: 274, transitive: 276, exports: 278, to: 280, opens: 282, uses: 284, provides: 286, with: 288, package: 292, import: 296, if: 308, else: 310, while: 314, for: 318, var: 325, assert: 332, switch: 336, case: 342, do: 346, break: 350, continue: 354, return: 358, throw: 364, try: 368, catch: 372, finally: 380 }, kw = ne.deserialize({
  version: 14,
  states: "##jQ]QPOOQ$wQPOOO(bQQO'#H^O*iQQO'#CbOOQO'#Cb'#CbO*pQPO'#CaO*xOSO'#CpOOQO'#Hc'#HcOOQO'#Cu'#CuO,eQPO'#D_O-OQQO'#HmOOQO'#Hm'#HmO/gQQO'#HhO/nQQO'#HhOOQO'#Hh'#HhOOQO'#Hg'#HgO1rQPO'#DUO2PQPO'#GnO4wQPO'#D_O5OQPO'#DzO*pQPO'#E[O5qQPO'#E[OOQO'#DV'#DVO7SQQO'#HaO9^QQO'#EeO9eQPO'#EdO9jQPO'#EfOOQO'#Hb'#HbO7jQQO'#HbO:pQQO'#FhO:wQPO'#ExO:|QPO'#E}O:|QPO'#FPOOQO'#Ha'#HaOOQO'#HY'#HYOOQO'#Gh'#GhOOQO'#HX'#HXO<^QPO'#FiOOQO'#HW'#HWOOQO'#Gg'#GgQ]QPOOOOQO'#Hs'#HsO<cQPO'#HsO<hQPO'#D{O<hQPO'#EVO<hQPO'#EQO<pQPO'#HpO=RQQO'#EfO*pQPO'#C`O=ZQPO'#C`O*pQPO'#FcO=`QPO'#FeO=kQPO'#FkO=kQPO'#FnO<hQPO'#FsO=pQPO'#FpO:|QPO'#FwO=kQPO'#FyO]QPO'#GOO=uQPO'#GQO>QQPO'#GSO>]QPO'#GUO=kQPO'#GWO:|QPO'#GXO>dQPO'#GZO?QQQO'#HiO?mQQO'#CuO?tQPO'#HxO@SQPO'#D_O@rQPO'#DpO?wQPO'#DqO@|QPO'#HxOA_QPO'#DpOAgQPO'#IROAlQPO'#E`OOQO'#Hr'#HrOOQO'#Gm'#GmQ$wQPOOOAtQPO'#HsOOQO'#H^'#H^OCsQQO,58{OOQO'#H['#H[OOOO'#Gi'#GiOEfOSO,59[OOQO,59[,59[OOQO'#Hi'#HiOFVQPO,59eOGXQPO,59yOOQO-E:f-E:fO*pQPO,58zOG{QPO,58zO*pQPO,5;}OHQQPO'#DQOHVQPO'#DQOOQO'#Gk'#GkOIVQQO,59jOOQO'#Dm'#DmOJqQPO'#HuOJ{QPO'#DlOKZQPO'#HtOKcQPO,5<_OKhQPO,59^OLRQPO'#CxOOQO,59c,59cOLYQPO,59bOLeQQO'#H^ONgQQO'#CbO!!iQPO'#D_O!#nQQO'#HmO!$OQQO,59pO!$VQPO'#DvO!$eQPO'#H|O!$mQPO,5:`O!$rQPO,5:`O!%YQPO,5;nO!%eQPO'#ITO!%pQPO,5;eO!%uQPO,5=YOOQO-E:l-E:lOOQO,5:f,5:fO!']QPO,5:fO!'dQPO,5:vO?tQPO,5<_O*pQPO,5:vO<hQPO,5:gO<hQPO,5:qO<hQPO,5:lO<hQPO,5<_O!'zQPO,59qO:|QPO,5:}O!(RQPO,5;QO:|QPO,59TO!(aQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#Eo'#EoO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;UO:|QPO,5;fOOQO,5;i,5;iOOQO,5<S,5<SO!(hQPO,5;bO!(yQPO,5;dO!(hQPO'#CyO!)QQQO'#HmO!)`QQO,5;kO]QPO,5<TOOQO-E:e-E:eOOQO,5>_,5>_O!*sQPO,5:gO!+RQPO,5:qO!+ZQPO,5:lO!+fQPO,5>[O!$VQPO,5>[O!'iQPO,59UO!+qQQO,58zO!+yQQO,5;}O!,RQQO,5<PO*pQPO,5<PO:|QPO'#DUO]QPO,5<VO]QPO,5<YO!,ZQPO'#FrO]QPO,5<[O]QPO,5<aO!,kQQO,5<cO!,uQPO,5<eO!,zQPO,5<jOOQO'#Fj'#FjOOQO,5<l,5<lO!-PQPO,5<lOOQO,5<n,5<nO!-UQPO,5<nO!-ZQQO,5<pOOQO,5<p,5<pO>gQPO,5<rO!-bQQO,5<sO!-iQPO'#GdO!.oQPO,5<uO>gQPO,5<}O!2mQPO,59jO!2zQPO'#HuO!3RQPO,59xO!3WQPO,5>dO?tQPO,59xO!3cQPO,5:[OAlQPO,5:zO!3kQPO'#DrO?wQPO'#DrO!3vQPO'#HyO!4OQPO,5:]O?tQPO,5>dO!(hQPO,5>dOAgQPO,5>mOOQO,5:[,5:[O!$rQPO'#DtOOQO,5>m,5>mO!4TQPO'#EaOOQO,5:z,5:zO!7UQPO,5:zO!(hQPO'#DxOOQO-E:k-E:kOOQO,5:y,5:yO*pQPO,58}O!7ZQPO'#ChOOQO1G.k1G.kOOOO-E:g-E:gOOQO1G.v1G.vO!+qQQO1G.fO*pQPO1G.fO!7eQQO1G1iOOQO,59l,59lO!7mQPO,59lOOQO-E:i-E:iO!7rQPO,5>aO!8ZQPO,5:WO<hQPO'#GpO!8bQPO,5>`OOQO1G1y1G1yOOQO1G.x1G.xO!8{QPO'#CyO!9kQPO'#HmO!9uQPO'#CzO!:TQPO'#HlO!:]QPO,59dOOQO1G.|1G.|OLYQPO1G.|O!:sQPO,59eO!;QQQO'#H^O!;cQQO'#CbOOQO,5:b,5:bO<hQPO,5:cOOQO,5:a,5:aO!;tQQO,5:aOOQO1G/[1G/[O!;yQPO,5:bO!<[QPO'#GsO!<oQPO,5>hOOQO1G/z1G/zO!<wQPO'#DvO!=YQPO1G/zO!(hQPO'#GqO!=_QPO1G1YO:|QPO1G1YO<hQPO'#GyO!=gQPO,5>oOOQO1G1P1G1POOQO1G0Q1G0QO!=oQPO'#E]OOQO1G0b1G0bO!>`QPO1G1yO!'dQPO1G0bO!*sQPO1G0RO!+RQPO1G0]O!+ZQPO1G0WOOQO1G/]1G/]O!>eQQO1G.pO9eQPO1G0jO*pQPO1G0jO<pQPO'#HpO!@[QQO1G.pOOQO1G.p1G.pO!@aQQO1G0iOOQO1G0l1G0lO!@hQPO1G0lO!@sQQO1G.oO!AZQQO'#HqO!AhQPO,59sO!BzQQO1G0pO!DfQQO1G0pO!DmQQO1G0pO!FUQQO1G0pO!F]QQO1G0pO!GbQQO1G0pO!I]QQO1G0pO!IdQQO1G0pO!IkQQO1G0pO!IuQQO1G1QO!I|QQO'#HmOOQO1G0|1G0|O!KSQQO1G1OOOQO1G1O1G1OOOQO1G1o1G1oO!KjQPO'#D[O!(hQPO'#D|O!(hQPO'#D}OOQO1G0R1G0RO!KqQPO1G0RO!KvQPO1G0RO!LOQPO1G0RO!LZQPO'#EXOOQO1G0]1G0]O!LnQPO1G0]O!LsQPO'#ETO!(hQPO'#ESOOQO1G0W1G0WO!MmQPO1G0WO!MrQPO1G0WO!MzQPO'#EhO!NRQPO'#EhOOQO'#Gx'#GxO!NZQQO1G0mO# }QQO1G3vO9eQPO1G3vO#$PQPO'#FXOOQO1G.f1G.fOOQO1G1i1G1iO#$WQPO1G1kOOQO1G1k1G1kO#$cQQO1G1kO#$kQPO1G1qOOQO1G1t1G1tO+QQPO'#D_O-OQQO,5<bO#(cQPO,5<bO#(tQPO,5<^O#({QPO,5<^OOQO1G1v1G1vOOQO1G1{1G1{OOQO1G1}1G1}O:|QPO1G1}O#,oQPO'#F{OOQO1G2P1G2PO=kQPO1G2UOOQO1G2W1G2WOOQO1G2Y1G2YOOQO1G2[1G2[OOQO1G2^1G2^OOQO1G2_1G2_O#,vQQO'#H^O#-aQQO'#CbO-OQQO'#HmO#-zQQOOO#.hQQO'#EeO#.VQQO'#HbO!$VQPO'#GeO#.oQPO,5=OOOQO'#HQ'#HQO#.wQPO1G2aO#2uQPO'#G]O>gQPO'#GaOOQO1G2a1G2aO#2zQPO1G2iO#6xQPO,5>gOOQO1G/d1G/dOOQO1G4O1G4OO#7ZQPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO!7UQPO1G0fOOQO,5:^,5:^O!(hQPO'#DsO#7`QPO,5:^O?wQPO'#GrO#7kQPO,5>eOOQO1G/w1G/wOAgQPO'#H{O#7sQPO1G4OO?tQPO1G4OOOQO1G4X1G4XO!#YQPO'#DvO!!iQPO'#D_OOQO,5:{,5:{O#8OQPO,5:{O#8OQPO,5:{O#8VQQO'#HaO#9hQQO'#HbO#9rQQO'#EbO#9}QPO'#EbO#:VQPO'#IOOOQO,5:d,5:dOOQO1G.i1G.iO#:bQQO'#EeO#:rQQO'#H`O#;SQPO'#FTOOQO'#H`'#H`O#;^QPO'#H`O#;{QPO'#IWO#<TQPO,59SOOQO7+$Q7+$QO!+qQQO7+$QOOQO7+'T7+'TOOQO1G/W1G/WO#<YQPO'#DoO#<dQQO'#HvOOQO'#Hv'#HvOOQO1G/r1G/rOOQO,5=[,5=[OOQO-E:n-E:nO#<tQWO,58{O#<{QPO,59fOOQO,59f,59fO!(hQPO'#HoOKmQPO'#GjO#=ZQPO,5>WOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#=cQQO1G/{OOQO1G/}1G/}O#=hQPO1G/{OOQO1G/|1G/|O<hQPO1G/}OOQO,5=_,5=_OOQO-E:q-E:qOOQO7+%f7+%fOOQO,5=],5=]OOQO-E:o-E:oO:|QPO7+&tOOQO7+&t7+&tOOQO,5=e,5=eOOQO-E:w-E:wO#=mQPO'#EUO#={QPO'#EUOOQO'#Gw'#GwO#>dQPO,5:wOOQO,5:w,5:wOOQO7+'e7+'eOOQO7+%|7+%|OOQO7+%m7+%mO!KqQPO7+%mO!KvQPO7+%mO!LOQPO7+%mOOQO7+%w7+%wO!LnQPO7+%wOOQO7+%r7+%rO!MmQPO7+%rO!MrQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO9eQPO7+&UO9eQPO,5>[O#?TQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO:|QPO'#GlO#?cQPO,5>]OOQO1G/_1G/_O:|QPO7+&lO#?nQQO,59eO#@tQPO,59vOOQO,59v,59vOOQO,5:h,5:hOOQO'#EP'#EPOOQO,5:i,5:iO#@{QPO'#EYO<hQPO'#EYO#A^QPO'#IPO#AiQPO,5:sO?tQPO'#HxO!(hQPO'#HxO#AqQPO'#DpOOQO'#Gu'#GuO#AxQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#BrQQO,5;SO#ByQPO,5;SOOQO-E:v-E:vOOQO7+&X7+&XOOQO7+)b7+)bO#CQQQO7+)bOOQO'#G|'#G|O#DqQPO,5;sOOQO,5;s,5;sO#DxQPO'#FYO*pQPO'#FYO*pQPO'#FYO*pQPO'#FYO#EWQPO7+'VO#E]QPO7+'VOOQO7+'V7+'VO]QPO7+']O#EhQPO1G1|O?tQPO1G1|O#EvQQO1G1xO!(aQPO1G1xO#E}QPO1G1xO#FUQQO7+'iOOQO'#HP'#HPO#F]QPO,5<gOOQO,5<g,5<gO#FdQPO'#HsO:|QPO'#F|O#FlQPO7+'pO#FqQPO,5=PO?tQPO,5=PO#FvQPO1G2jO#HPQPO1G2jOOQO1G2j1G2jOOQO-E;O-E;OOOQO7+'{7+'{O!<[QPO'#G_O>gQPO,5<wOOQO,5<{,5<{O#HXQPO7+(TOOQO7+(T7+(TO#LVQPO1G4ROOQO7+%O7+%OOOQO7+&Q7+&QO#LhQPO,5:_OOQO1G/x1G/xOOQO,5=^,5=^OOQO-E:p-E:pOOQO7+)j7+)jO#LsQPO7+)jO!:bQPO,5:aOOQO1G0g1G0gO#MOQPO1G0gO#MVQPO,59qO#MkQPO,5:|O9eQPO,5:|O!(hQPO'#GtO#MpQPO,5>jO#M{QPO,59TO#NSQPO'#IVO#N[QPO,5;oO*pQPO'#G{O#NaQPO,5>rOOQO1G.n1G.nOOQO<<Gl<<GlO#NiQPO'#HwO#NqQPO,5:ZOOQO1G/Q1G/QOOQO,5>Z,5>ZOOQO,5=U,5=UOOQO-E:h-E:hO#NvQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J`<<J`O$ ^QPO'#H^O$ eQPO'#CbO$ lQPO,5:pO$ qQPO,5:xO#=mQPO,5:pOOQO-E:u-E:uOOQO1G0c1G0cOOQO<<IX<<IXO!KqQPO<<IXO!KvQPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!MmQPO<<I^OOQO<<Ip<<IpO$ vQQO<<GvO9eQPO<<IpO*pQPO<<IpOOQO<<Gv<<GvO$#mQQO,5=WOOQO-E:j-E:jO$#zQQO<<JWOOQO1G/b1G/bOOQO,5:t,5:tO$$bQPO,5:tO$$pQPO,5:tO$%RQPO'#GvO$%iQPO,5>kO$%tQPO'#EZOOQO1G0_1G0_O$%{QPO1G0_O?tQPO,5:pOOQO-E:s-E:sOOQO1G0Z1G0ZOOQO1G0n1G0nO$&QQQO1G0nOOQO<<L|<<L|OOQO-E:z-E:zOOQO1G1_1G1_O$&XQQO,5;tOOQO'#G}'#G}O#DxQPO,5;tOOQO'#IX'#IXO$&aQQO,5;tO$&rQQO,5;tOOQO<<Jq<<JqO$&zQPO<<JqOOQO<<Jw<<JwO:|QPO7+'hO$'PQPO7+'hO!(aQPO7+'dO$'_QPO7+'dO$'dQQO7+'dOOQO<<KT<<KTOOQO-E:}-E:}OOQO1G2R1G2ROOQO,5<h,5<hO$'kQQO,5<hOOQO<<K[<<K[O:|QPO1G2kO$'rQPO1G2kOOQO,5=n,5=nOOQO7+(U7+(UO$'wQPO7+(UOOQO-E;Q-E;QO$)fQWO'#HhO$)QQWO'#HhO$)mQPO'#G`O<hQPO,5<yO!$VQPO,5<yOOQO1G2c1G2cOOQO<<Ko<<KoO$*OQPO1G/yOOQO<<MU<<MUOOQO7+&R7+&RO$*ZQPO1G0jO$*fQQO1G0hOOQO1G0h1G0hO$*nQPO1G0hOOQO,5=`,5=`OOQO-E:r-E:rO$*sQQO1G.oOOQO1G1[1G1[O$*}QPO'#GzO$+[QPO,5>qOOQO1G1Z1G1ZO$+dQPO'#FUOOQO,5=g,5=gOOQO-E:y-E:yO$+iQPO'#GoO$+vQPO,5>cOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$,OQPO1G0dO$,TQPO1G0[O$,YQPO1G0dOOQOAN>sAN>sO!KqQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O9eQPOAN?[OOQO1G0`1G0`O$,_QPO1G0`OOQO,5=b,5=bOOQO-E:t-E:tO$,mQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1`1G1`O$,tQQO1G1`OOQO-E:{-E:{O$,|QQO'#IYO$,wQPO1G1`O$&gQPO1G1`O*pQPO1G1`OOQOAN@]AN@]O$-XQQO<<KSO:|QPO<<KSO$-`QPO<<KOOOQO<<KO<<KOO!(aQPO<<KOOOQO1G2S1G2SO$-eQQO7+(VO:|QPO7+(VOOQO<<Kp<<KpP!-iQPO'#HSO!$VQPO'#HRO$-oQPO,5<zO$-zQPO1G2eO<hQPO1G2eO9eQPO7+&SO$.PQPO7+&SOOQO7+&S7+&SOOQO,5=f,5=fOOQO-E:x-E:xO#M{QPO,5;pOOQO,5=Z,5=ZOOQO-E:m-E:mO$.UQPO7+&OOOQO7+%v7+%vO$.dQPO7+&OOOQOG24_G24_OOQOG24vG24vOOQO7+%z7+%zOOQO7+&z7+&zO*pQPO'#HOO$.iQPO,5>tO$.qQPO7+&zO$.vQQO'#IZOOQOAN@nAN@nO$/RQQOAN@nOOQOAN@jAN@jO$/YQPOAN@jO$/_QQO<<KqO$/iQPO,5=mOOQO-E;P-E;POOQO7+(P7+(PO$/zQPO7+(PO$0PQPO<<InOOQO<<In<<InO$0UQPO<<IjOOQO<<Ij<<IjO#M{QPO<<IjO$0UQPO<<IjO$0dQQO,5=jOOQO-E:|-E:|OOQO<<Jf<<JfO$0oQPO,5>uOOQOG26YG26YOOQOG26UG26UOOQO<<Kk<<KkOOQOAN?YAN?YOOQOAN?UAN?UO#M{QPOAN?UO$0wQPOAN?UO$0|QPOAN?UO$1[QPOG24pOOQOG24pG24pO#M{QPOG24pOOQOLD*[LD*[O$1aQPOLD*[OOQO!$'Mv!$'MvO*pQPO'#CaO$1fQQO'#H^O$1yQQO'#CbO!(hQPO'#Cy",
  stateData: "$2f~OPOSQOS%yOS~OZ`O_VO`VOaVObVOcVOeVOg^Oh^Op!POv{OwkOz!OO}cO!PvO!SyO!TyO!UyO!VyO!WyO!XyO!YyO!ZzO![!`O!]yO!^yO!_yO!u}O!z|O#fpO#roO#tpO#upO#y!RO#z!QO$W!SO$Y!TO$`!UO$c!VO$e!XO$h!WO$l!YO$n!ZO$s![O$u!]O$w!^O$y!_O$|!aO%O!bO%}TO&PRO&RQO&XUO&tdO~Og^Oh^Ov{O}cO!P!mO!SyO!TyO!UyO!VyO!W!pO!XyO!YyO!ZzO!]yO!^yO!_yO!u}O!z|O%}TO&P!cO&R!dO&_!hO&tdO~OWiXW&QXZ&QXuiXu&QX!P&QX!b&QX#]&QX#_&QX#a&QX#b&QX#d&QX#e&QX#f&QX#g&QX#h&QX#i&QX#k&QX#o&QX#r&QX%}iX&PiX&RiX&^&QX&_iX&_&QX&n&QX&viX&v&QX&x!aX~O#p$^X~P&bOWUXW&]XZUXuUXu&]X!PUX!bUX#]UX#_UX#aUX#bUX#dUX#eUX#fUX#gUX#hUX#iUX#kUX#oUX#rUX%}&]X&P&]X&R&]X&^UX&_UX&_&]X&nUX&vUX&v&]X&x!aX~O#p$^X~P(iO&PSO&R!qO~O&W!vO&Y!tO~Og^Oh^O!SyO!TyO!UyO!VyO!WyO!XyO!YyO!ZzO!]yO!^yO!_yO%}TO&P!wO&RWOg!RXh!RX$h!RX&P!RX&R!RX~O#y!|O#z!{O$W!}Ov!RX!u!RX!z!RX&t!RX~P+QOW#XOu#OO%}TO&P#SO&R#SO&v&aX~OW#[Ou&[X%}&[X&P&[X&R&[X&v&[XY&[Xw&[X&n&[X&q&[XZ&[Xq&[X&^&[X!P&[X#_&[X#a&[X#b&[X#d&[X#e&[X#f&[X#g&[X#h&[X#i&[X#k&[X#o&[X#r&[X}&[X!r&[X#p&[Xs&[X|&[X~O&_#YO~P-dO&_&[X~P-dOZ`O_VO`VOaVObVOcVOeVOg^Oh^Op!POwkOz!OO!SyO!TyO!UyO!VyO!WyO!XyO!YyO!ZzO!]yO!^yO!_yO#fpO#roO#tpO#upO%}TO&XUO~O&P#^O&R#]OY&pP~P/uO%}TOg%bXh%bXv%bX!S%bX!T%bX!U%bX!V%bX!W%bX!X%bX!Y%bX!Z%bX!]%bX!^%bX!_%bX!u%bX!z%bX$h%bX&P%bX&R%bX&t%bX&_%bX~O!SyO!TyO!UyO!VyO!WyO!XyO!YyO!ZzO!]yO!^yO!_yOg!RXh!RXv!RX!u!RX!z!RX&P!RX&R!RX&t!RX&_!RX~O$h!RX~P3gO|#kO~P]Og^Oh^Ov#pO!u#rO!z#qO&P!wO&RWO&t#oO~O$h#sO~P5VOu#uO&v#vO!P&TX#_&TX#a&TX#b&TX#d&TX#e&TX#f&TX#g&TX#h&TX#i&TX#k&TX#o&TX#r&TX&^&TX&_&TX&n&TX~OW#tOY&TX#p&TXs&TXq&TX|&TX~P5xO!b#wO#]#wOW&UXu&UX!P&UX#_&UX#a&UX#b&UX#d&UX#e&UX#f&UX#g&UX#h&UX#i&UX#k&UX#o&UX#r&UX&^&UX&_&UX&n&UX&v&UXY&UX#p&UXs&UXq&UX|&UX~OZ#XX~P7jOZ#xO~O&v#vO~O#_#|O#a#}O#b$OO#d$QO#e$RO#f$SO#g$TO#h$UO#i$UO#k$YO#o$VO#r$WO&^#zO&_#zO&n#{O~O!P$XO~P9oO&x$ZO~OZ`O_VO`VOaVObVOcVOeVOg^Oh^Op!POwkOz!OO#fpO#roO#tpO#upO%}TO&P0qO&R0pO&XUO~O#p$_O~O![$aO~O&P#SO&R#SO~Og^Oh^O&P!wO&RWO&_#YO~OW$gO&v#vO~O#z!{O~O!W$kO&PSO&R!qO~OZ$lO~OZ$oO~O!P$vO&P$uO&R$uO~O!P$xO&P$uO&R$uO~O!P${O~P:|OZ%OO}cO~OW&]Xu&]X%}&]X&P&]X&R&]X&_&]X~OZ!aX~P>lOWiXuiX%}iX&PiX&RiX&_iX~OZ!aX~P?XOu#OO%}TO&P#SO&R#SO~O%}TO~P3gOg^Oh^Ov#pO!u#rO!z#qO&_!hO&t#oO~O&P!cO&R!dO~P@ZOg^Oh^O%}TO&P!cO&R!dO~O}cO!P%aO~OZ%bO~O}%dO!m%gO~O}cOg&gXh&gXv&gX!S&gX!T&gX!U&gX!V&gX!W&gX!X&gX!Y&gX!Z&gX!]&gX!^&gX!_&gX!u&gX!z&gX%}&gX&P&gX&R&gX&_&gX&t&gX~OW%jOZ%kOgTahTa%}Ta&PTa&RTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#yTa#zTa$WTa$hTa&tTa&_TauTaYTaqTa|Ta!PTa~PC[O&W%nO&Y!tO~Ou#OO%}TOqma&^maYma&nma!Pma~O&vma}ma!rma~PEnO!SyO!TyO!UyO!VyO!WyO!XyO!YyO!ZzO!]yO!^yO!_yO~Og!Rah!Rav!Ra!u!Ra!z!Ra$h!Ra&P!Ra&R!Ra&t!Ra&_!Ra~PFdO#z%pO~Os%rO~Ou%sO%}TO~Ou#OO%}ra&Pra&Rra&vraYrawra&nra&qra!Pra&^raqra~OWra#_ra#ara#bra#dra#era#fra#gra#hra#ira#kra#ora#rra&_ra#prasra|ra~PH_Ou#OO%}TOq&iX!P&iX!b&iX~OY&iX#p&iX~PJ`O!b%vOq!`X!P!`XY!`X~Oq%wO!P&hX~O!P%yO~Ov%zO~Og^Oh^O%}0oO&P!wO&RWO&b%}O~O&^&`P~PKmO%}TO&P!wO&RWO~OW&QXYiXY!aXY&QXZ&QXq!aXu&QXwiX!b&QX#]&QX#_&QX#a&QX#b&QX#d&QX#e&QX#f&QX#g&QX#h&QX#i&QX#k&QX#o&QX#r&QX&^&QX&_&QX&niX&n&QX&qiX&viX&v&QX&x!aX~P?XOWUXYUXY!aXY&]XZUXq!aXuUXw&]X!bUX#]UX#_UX#aUX#bUX#dUX#eUX#fUX#gUX#hUX#iUX#kUX#oUX#rUX&^UX&_UX&nUX&n&]X&q&]X&vUX&v&]X&x!aX~P>lOg^Oh^O%}TO&P!wO&RWOg!RXh!RX&P!RX&R!RX~PFdOu#OOw&XO%}TO&P&UO&R&TO&q&WO~OW#XOY&aX&n&aX&v&aX~P!#YOY&ZO~P9oOg^Oh^O&P!wO&RWO~Oq&]OY&pX~OY&_O~Og^Oh^O%}TO&P!wO&RWOY&pP~PFdOY&dO&n&bO&v#vO~Oq&eO&x$ZOY&wX~OY&gO~O%}TOg%bah%bav%ba!S%ba!T%ba!U%ba!V%ba!W%ba!X%ba!Y%ba!Z%ba!]%ba!^%ba!_%ba!u%ba!z%ba$h%ba&P%ba&R%ba&t%ba&_%ba~O|&hO~P]O}&iO~Op&uOw&vO&PSO&R!qO&_#YO~Oz&tO~P!'iOz&xO&PSO&R!qO&_#YO~OY&eP~P:|Og^Oh^O%}TO&P!wO&RWO~O}cO~P:|OW#XOu#OO%}TO&v&aX~O#r$WO!P#sa#_#sa#a#sa#b#sa#d#sa#e#sa#f#sa#g#sa#h#sa#i#sa#k#sa#o#sa&^#sa&_#sa&n#saY#sa#p#sas#saq#sa|#sa~Oo'_O}'^O!r'`O&_!hO~O}'eO!r'`O~Oo'iO}'hO&_!hO~OZ#xOu'mO%}TO~OW%jO}'sO~OW%jO!P'uO~OW'vO!P'wO~O$h!WO&P0qO&R0pO!P&eP~P/uO!P(SO#p(TO~P9oO}(UO~O$c(WO~O!P(XO~O!P(YO~O!P(ZO~P9oO!P(]O~P9oOZ$lO_VO`VOaVObVOcVOeVOg^Oh^Op!POwkOz!OO%}TO&P(_O&R(^O&XUO~PFdO%Q(hO%U(iOZ$}a_$}a`$}aa$}ab$}ac$}ae$}ag$}ah$}ap$}av$}aw$}az$}a}$}a!P$}a!S$}a!T$}a!U$}a!V$}a!W$}a!X$}a!Y$}a!Z$}a![$}a!]$}a!^$}a!_$}a!u$}a!z$}a#f$}a#r$}a#t$}a#u$}a#y$}a#z$}a$W$}a$Y$}a$`$}a$c$}a$e$}a$h$}a$l$}a$n$}a$s$}a$u$}a$w$}a$y$}a$|$}a%O$}a%w$}a%}$}a&P$}a&R$}a&X$}a&t$}a|$}a$a$}a$q$}a~O}ra!rra'Ora~PH_OZ%bO~PJ`O!P(mO~O!m%gO}&la!P&la~O}cO!P(pO~Oo(tOq!fX&^!fX~Oq(vO&^&mX~O&^(xO~OZ`O_VO`VOaVObVOcVOeVOg^Oh^Op)UOv{Ow)TOz!OO|)PO}cO!PvO![!`O!u}O!z|O#fpO#roO#tpO#upO#y!RO#z!QO$W!SO$Y!TO$`!UO$c!VO$e!XO$h!WO$l!YO$n!ZO$s![O$u!]O$w!^O$y!_O$|!aO%O!bO%}TO&PRO&RQO&XUO&_#YO&tdO~PFdO}%dO~O})]OY&zP~P:|OW%jO!P)dO~Os)eO~Ou#OO%}TOq&ia!P&ia!b&iaY&ia#p&ia~O})fO~P:|Oq%wO!P&ha~Og^Oh^O%}0oO&P!wO&RWO~O&b)mO~P!8jOu#OO%}TOq&aX&^&aXY&aX&n&aX!P&aX~O}&aX!r&aX~P!9SOo)oOp)oOqnX&^nX~Oq)pO&^&`X~O&^)rO~Ou#OOw)tO%}TO&PSO&R!qO~OYma&nma&vma~P!:bOW&QXY!aXq!aXu!aX%}!aX~OWUXY!aXq!aXu!aX%}!aX~OW)wO~Ou#OO%}TO&P#SO&R#SO&q)yO~Og^Oh^O%}TO&P!wO&RWO~PFdOq&]OY&pa~Ou#OO%}TO&P#SO&R#SO&q&WO~OY)|O~OY*PO&n&bO~Oq&eOY&wa~Og^Oh^Ov{O|*XO!u}O%}TO&P!wO&RWO&tdO~PFdO!P*YO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#b^i#d^i#e^i#f^i#g^i#h^i#i^i#k^i#o^i#r^i&^^i&_^i&n^i&v^iY^i#p^is^iq^i|^i~OW*iO~Os*jO~P9oOz*kO&PSO&R!qO~O!P]iY]i#p]is]iq]i|]i~P9oOq*lOY&eX!P&eX~P9oOY*nO~O#f$SO#g$TO#k$YO#r$WO!P#^i#_#^i#a#^i#b#^i#d#^i#e#^i#o#^i&^#^i&_#^i&n#^iY#^i#p#^is#^iq#^i|#^i~O#h$UO#i$UO~P!AmO#_#|O#d$QO#e$RO#f$SO#g$TO#h$UO#i$UO#k$YO#r$WO&^#zO&_#zO&n#{O!P#^i#b#^i#o#^iY#^i#p#^is#^iq#^i|#^i~O#a#^i~P!CUO#a#}O~P!CUO#_#|O#f$SO#g$TO#h$UO#i$UO#k$YO#r$WO&^#zO&_#zO!P#^i#a#^i#b#^i#d#^i#e#^i#o#^iY#^i#p#^is#^iq#^i|#^i~O&n#^i~P!DtO&n#{O~P!DtO#f$SO#g$TO#k$YO#r$WO!P#^i#a#^i#b#^i#e#^i#o#^iY#^i#p#^is#^iq#^i|#^i~O#_#|O#d$QO#h$UO#i$UO&^#zO&_#zO&n#{O~P!FdO#k$YO#r$WO!P#^i#_#^i#a#^i#b#^i#d#^i#e#^i#f#^i#h#^i#i#^i#o#^i&^#^i&_#^i&n#^iY#^i#p#^is#^iq#^i|#^i~O#g$TO~P!G{O#g#^i~P!G{O#h#^i#i#^i~P!AmO#p*oO~P9oO#_&aX#a&aX#b&aX#d&aX#e&aX#f&aX#g&aX#h&aX#i&aX#k&aX#o&aX#r&aX&_&aX#p&aXs&aX|&aX~P!9SO!P#liY#li#p#lis#liq#li|#li~P9oO|*rO~P$wO}'^O~O}'^O!r'`O~Oo'_O}'^O!r'`O~O%}TO&P#SO&R#SO|&sP!P&sP~PFdO}'eO~Og^Oh^Ov{O|+PO!P*}O!u}O!z|O%}TO&P!wO&RWO&_!hO&tdO~PFdO}'hO~Oo'iO}'hO~Os+RO~P:|Ou+TO%}TO~Ou'mO})fO%}TOW#Zi!P#Zi#_#Zi#a#Zi#b#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#i#Zi#k#Zi#o#Zi#r#Zi&^#Zi&_#Zi&n#Zi&v#ZiY#Zi#p#Zis#Ziq#Zi|#Zi~O}'^OW&diu&di!P&di#_&di#a&di#b&di#d&di#e&di#f&di#g&di#h&di#i&di#k&di#o&di#r&di&^&di&_&di&n&di&v&diY&di#p&dis&diq&di|&di~O#}+]O$P+^O$R+^O$S+_O$T+`O~O|+[O~P##nO$Z+aO&PSO&R!qO~OW+bO!P+cO~O$a+dOZ$_i_$_i`$_ia$_ib$_ic$_ie$_ig$_ih$_ip$_iv$_iw$_iz$_i}$_i!P$_i!S$_i!T$_i!U$_i!V$_i!W$_i!X$_i!Y$_i!Z$_i![$_i!]$_i!^$_i!_$_i!u$_i!z$_i#f$_i#r$_i#t$_i#u$_i#y$_i#z$_i$W$_i$Y$_i$`$_i$c$_i$e$_i$h$_i$l$_i$n$_i$s$_i$u$_i$w$_i$y$_i$|$_i%O$_i%w$_i%}$_i&P$_i&R$_i&X$_i&t$_i|$_i$q$_i~Og^Oh^O$h#sO&P!wO&RWO~O!P+hO~P:|O!P+iO~OZ`O_VO`VOaVObVOcVOeVOg^Oh^Op!POv{OwkOz!OO}cO!PvO!SyO!TyO!UyO!VyO!WyO!XyO!YyO!Z+nO![!`O!]yO!^yO!_yO!u}O!z|O#fpO#roO#tpO#upO#y!RO#z!QO$W!SO$Y!TO$`!UO$c!VO$e!XO$h!WO$l!YO$n!ZO$q+oO$s![O$u!]O$w!^O$y!_O$|!aO%O!bO%}TO&PRO&RQO&XUO&tdO~O|+mO~P#)QOW&QXY&QXZ&QXu&QX!P&QX&viX&v&QX~P?XOWUXYUXZUXuUX!PUX&vUX&v&]X~P>lOW#tOu#uO&v#vO~OW&UXY%XXu&UX!P%XX&v&UX~OZ#XX~P#.VOY+uO!P+sO~O%Q(hO%U(iOZ$}i_$}i`$}ia$}ib$}ic$}ie$}ig$}ih$}ip$}iv$}iw$}iz$}i}$}i!P$}i!S$}i!T$}i!U$}i!V$}i!W$}i!X$}i!Y$}i!Z$}i![$}i!]$}i!^$}i!_$}i!u$}i!z$}i#f$}i#r$}i#t$}i#u$}i#y$}i#z$}i$W$}i$Y$}i$`$}i$c$}i$e$}i$h$}i$l$}i$n$}i$s$}i$u$}i$w$}i$y$}i$|$}i%O$}i%w$}i%}$}i&P$}i&R$}i&X$}i&t$}i|$}i$a$}i$q$}i~OZ+xO~O%Q(hO%U(iOZ%Vi_%Vi`%Via%Vib%Vic%Vie%Vig%Vih%Vip%Viv%Viw%Viz%Vi}%Vi!P%Vi!S%Vi!T%Vi!U%Vi!V%Vi!W%Vi!X%Vi!Y%Vi!Z%Vi![%Vi!]%Vi!^%Vi!_%Vi!u%Vi!z%Vi#f%Vi#r%Vi#t%Vi#u%Vi#y%Vi#z%Vi$W%Vi$Y%Vi$`%Vi$c%Vi$e%Vi$h%Vi$l%Vi$n%Vi$s%Vi$u%Vi$w%Vi$y%Vi$|%Vi%O%Vi%w%Vi%}%Vi&P%Vi&R%Vi&X%Vi&t%Vi|%Vi$a%Vi$q%Vi~Ou#OO%}TO}&oa!P&oa!m&oa~O!P,OO~Oo(tOq!fa&^!fa~Oq(vO&^&ma~O!m%gO}&li!P&li~O|,XO~P]OW,ZO~P5xOW&UXu&UX#_&UX#a&UX#b&UX#d&UX#e&UX#f&UX#g&UX#h&UX#i&UX#k&UX#o&UX#r&UX&^&UX&_&UX&n&UX&v&UX~OZ#xO!P&UX~P#8^OW$gOZ#xO&v#vO~Op,]Ow,]O~Oq,^O}&rX!P&rX~O!b,`O#]#wOY&UXZ#XX~P#8^OY&SXq&SX|&SX!P&SX~P9oO})]O|&yP~P:|OY&SXg%[Xh%[X%}%[X&P%[X&R%[Xq&SX|&SX!P&SX~Oq,cOY&zX~OY,eO~O})fO|&kP~P:|Oq&jX!P&jX|&jXY&jX~P9oO&bTa~PC[Oo)oOp)oOqna&^na~Oq)pO&^&`a~OW,mO~Ow,nO~Ou#OO%}TO&P,rO&R,qO~Og^Oh^Ov#pO!u#rO&P!wO&RWO&t#oO~Og^Oh^Ov{O|,wO!u}O%}TO&P!wO&RWO&tdO~PFdOw-SO&PSO&R!qO&_#YO~Oq*lOY&ea!P&ea~O#_ma#ama#bma#dma#ema#fma#gma#hma#ima#kma#oma#rma&_ma#pmasma|ma~PEnO|-WO~P$wOZ#xO}'^Oq!|X|!|X!P!|X~Oq-[O|&sX!P&sX~O|-_O!P-^O~O&_!hO~P5VOg^Oh^Ov{O|-cO!P*}O!u}O!z|O%}TO&P!wO&RWO&_!hO&tdO~PFdOs-dO~P9oOs-dO~P:|O}'^OW&dqu&dq!P&dq#_&dq#a&dq#b&dq#d&dq#e&dq#f&dq#g&dq#h&dq#i&dq#k&dq#o&dq#r&dq&^&dq&_&dq&n&dq&v&dqY&dq#p&dqs&dqq&dq|&dq~O|-hO~P##nO!W-lO$O-lO&PSO&R!qO~O!P-oO~O$Z-pO&PSO&R!qO~O!b%vO#p-rOq!`X!P!`X~O!P-tO~P9oO!P-tO~P:|O!P-wO~P9oO|-yO~P#)QO![$aO#p-zO~O!P-|O~O!b-}O~OY.QOZ$lO_VO`VOaVObVOcVOeVOg^Oh^Op!POwkOz!OO%}TO&P(_O&R(^O&XUO~PFdOY.QO!P.RO~O%Q(hO%U(iOZ%Vq_%Vq`%Vqa%Vqb%Vqc%Vqe%Vqg%Vqh%Vqp%Vqv%Vqw%Vqz%Vq}%Vq!P%Vq!S%Vq!T%Vq!U%Vq!V%Vq!W%Vq!X%Vq!Y%Vq!Z%Vq![%Vq!]%Vq!^%Vq!_%Vq!u%Vq!z%Vq#f%Vq#r%Vq#t%Vq#u%Vq#y%Vq#z%Vq$W%Vq$Y%Vq$`%Vq$c%Vq$e%Vq$h%Vq$l%Vq$n%Vq$s%Vq$u%Vq$w%Vq$y%Vq$|%Vq%O%Vq%w%Vq%}%Vq&P%Vq&R%Vq&X%Vq&t%Vq|%Vq$a%Vq$q%Vq~Ou#OO%}TO}&oi!P&oi!m&oi~O&n&bOq!ga&^!ga~O!m%gO}&lq!P&lq~O|.^O~P]Op.`Ow&vOz&tO&PSO&R!qO&_#YO~O!P.aO~Oq,^O}&ra!P&ra~O})]O~P:|Oq.gO|&yX~O|.iO~Oq,cOY&za~Oq.mO|&kX~O|.oO~Ow.pO~Oq!aXu!aX!P!aX!b!aX%}!aX~OZ&QX~P#N{OZUX~P#N{O!P.qO~OZ.rO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#b^y#d^y#e^y#f^y#g^y#h^y#i^y#k^y#o^y#r^y&^^y&_^y&n^y&v^yY^y#p^ys^yq^y|^y~OY%`aq%`a!P%`a~P9oO!P#nyY#ny#p#nys#nyq#ny|#ny~P9oO}'^Oq!|a|!|a!P!|a~OZ#xO}'^Oq!|a|!|a!P!|a~O%}TO&P#SO&R#SOq%jX|%jX!P%jX~PFdOq-[O|&sa!P&sa~O|!}X~P$wO|/PO~Os/QO~P9oOW%jO!P/RO~OW%jO$Q/WO&PSO&R!qO!P&|P~OW%jO$U/XO~O!P/YO~O!b%vO#p/[Oq!`X!P!`X~OY/^O~O!P/_O~P9oO#p/`O~P9oO!b/bO~OY/cOZ$lO_VO`VOaVObVOcVOeVOg^Oh^Op!POwkOz!OO%}TO&P(_O&R(^O&XUO~PFdOW#[Ou&[X%}&[X&P&[X&R&[X'O&[X~O&_#YO~P$)QOu#OO%}TO'O/eO&P%SX&R%SX~O&n&bOq!gi&^!gi~Op/iO&PSO&R!qO~OW*iOZ#xO~O!P/kO~OY&SXq&SX~P9oO})]Oq%nX|%nX~P:|Oq.gO|&ya~O!b/nO~O})fOq%cX|%cX~P:|Oq.mO|&ka~OY/qO~O!P/rO~OZ/sO~O}'^Oq!|i|!|i!P!|i~O|!}a~P$wOW%jO!P/wO~OW%jOq/xO!P&|X~OY/|O~P9oOY0OO~OY%Xq!P%Xq~P9oO'O/eO&P%Sa&R%Sa~OY0TO~O!P0WO~Ou#OO!P0YO!Z0ZO%}TO~OY0[O~Oq/xO!P&|a~O!P0_O~OW%jOq/xO!P&}X~OY0aO~P9oOY0bO~OY%Xy!P%Xy~P9oOu#OO%}TO&P%ua&R%ua'O%ua~OY0cO~O!P0dO~Ou#OO!P0eO!Z0fO%}TO~OW%jOq%ra!P%ra~Oq/xO!P&}a~O!P0jO~Ou#OO!P0jO!Z0kO%}TO~O!P0lO~O!P0nO~O#p&QXY&QXs&QXq&QX|&QX~P&bO#pUXYUXsUXqUX|UX~P(iO`Q_P#g&Xc~",
  goto: "#+S'OPPPP'P'd*x.OP'dPP.d.h0PPPPPP1nP3ZPP4v7l:[<z=d?[PPP?bPA{PPPBu3ZPDqPPElPFcFkPPPPPPPPPPPPGvH_PKjKrLOLjLpLvNiNmNmNuP! U!!^!#R!#]P!#r!!^P!#x!$S!!y!$cP!%S!%^!%d!!^!%g!%mFcFc!%q!%{!&O3Z!'m3Z3Z!)iP.hP!)mPP!*_PPPPPP.hP.h!+O.hPP.hP.hPP.h!,g!,qPP!,w!-QPPPPPPPP'PP'PPP!-U!-U!-i!-UPP!-UP!-UP!.S!.VP!-U!.m!-UP!-UP!.p!.sP!-UP!-UP!-UP!-UP!-U!-UP!-UP!.wP!.}!/Q!/WP!-U!/d!/gP!/o!0R!4T!4Z!4a!5g!5m!5{!7R!7X!7_!7i!7o!7u!7{!8R!8X!8_!8e!8k!8q!8w!8}!9T!9_!9e!9o!9uPPP!9{!-U!:pP!>WP!?[P!Ap!BW!E]3ZPPP!F|!Jm!MaPP#!P#!SP#$`#$f#&V#&f#&n#'p#(Y#)T#)^#)a#)oP#)r#*OP#*V#*^P#*aP#*lP#*o#*r#*u#*y#+PstOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Y'urOPXY`acopx!Y![!_!a!e!f!h!i!o!x#P#T#Y#[#_#`#e#i#l#n#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$]$_$e$l$m$n$o$p$q%O%S%V%Z%^%_%b%d%g%k%u%v%{%|&R&S&[&]&`&b&d&i'X'^'_'`'e'h'i'm'n'p'{'|(O(T(U(`(l(t(v({(})O)Q)R)])f)o)p*P*T*W*l*o*p*q*z*{+O+T+d+f+h+i+l+o+r+s+x+},W,Y,^,`,u-[-^-a-r-t-}.R.V.g.m/O/[/_/b/d/n/q0R0X0Z0[0f0h0k0r#xhO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0kt!sT!Q!S!T!{!}$k%p+]+^+_+`-k-m/W/X/x0oQ#mdS&Y#`(}Q&l#oU&q#t$g,ZQ&x#vW(b%O+s.R/dU)Y%j'v+bQ)Z%kS)u&S,WU*f&s-R._Q*k&yQ,t*TQ-P*iQ.j,cR.t,uu!sT!Q!S!T!{!}$k%p+]+^+_+`-k-m/W/X/x0oT%l!r)l#{qO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0k#zlO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0kX(c%O+s.R/d$TVO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%O%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o+s,Y,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0k$TkO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%O%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o+s,Y,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0k&O[OPX`ceopx!O!Y![!_!a!g!i!o#Y#_#b#e#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$_$f$l$m$n$o$p$q%O%_%b%d%g%k%v%{&]&b&d&i&t'^'_'`'h'i'm'{'}(O(T(U(d(t)O)Q)R)])f)o)p*P*U*W*l*o*q*{*|+O+T+d+h+i+l+o+s,Y,^,`-^-r-t-}.R.g.m/O/[/_/b/d/n0Z0f0k0rQ&Q#[Q)s&RV.T+x.X/e&O[OPX`ceopx!O!Y![!_!a!g!i!o#Y#_#b#e#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$_$f$l$m$n$o$p$q%O%_%b%d%g%k%v%{&]&b&d&i&t'^'_'`'h'i'm'{'}(O(T(U(d(t)O)Q)R)])f)o)p*P*U*W*l*o*q*{*|+O+T+d+h+i+l+o+s,Y,^,`-^-r-t-}.R.g.m/O/[/_/b/d/n0Z0f0k0rV.T+x.X/e&O]OPX`ceopx!O!Y![!_!a!g!i!o#Y#_#b#e#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$_$f$l$m$n$o$p$q%O%_%b%d%g%k%v%{&]&b&d&i&t'^'_'`'h'i'm'{'}(O(T(U(d(t)O)Q)R)])f)o)p*P*U*W*l*o*q*{*|+O+T+d+h+i+l+o+s,Y,^,`-^-r-t-}.R.g.m/O/[/_/b/d/n0Z0f0k0rV.U+x.X/eS#Z[.TS$f!O&tS&s#t$gQ&y#vQ)V%dQ-R*iR._,Z$kZO`copx!Y![!_!a#Y#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$_$l$m$n$o$p$q%O%d%g%k%v&b&d'_'`'i'm(O(T(U(t)Q)R)])f)o)p*P*l*o+T+d+h+i+l+o+s,Y,^,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0kQ&O#YR,k)p&P_OPX`ceopx!Y![!_!a!g!i!o#Y#_#b#e#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$_$l$m$n$o$p$q%O%_%b%d%g%k%v%{&]&b&d&i'^'_'`'h'i'm'{'}(O(T(U(d(t)O)Q)R)])f)o)p*P*U*W*l*o*q*{*|+O+T+d+h+i+l+o+s+x,Y,^,`-^-r-t-}.R.X.g.m/O/[/_/b/d/e/n0Z0f0k0r!o#QY!e!x#R#T#`#n$]%R%S%V%^%u%|&S&[&`'X'|(`(l({(}*T*p*z+f+r+},W,u-a.V/q0R0X0[0h$SkO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%O%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o+s,Y,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0kQ$m!UQ$n!VQ$s!ZQ$|!`R+p(WQ#yiS'q$e*hQ*e&rQ+X'rS,[)T)UQ-O*gQ-Y*vQ.b,]Q.x-QQ.{-ZQ/j.`Q/u.yR0V/iQ'a$bW*[&m'b'c'dQ+W'qU,x*]*^*_Q-X*vQ-f+XS.u,y,zS.z-Y-ZQ/t.vR/v.{]!mP!o'^*q-^/OreOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Y[!gP!o'^*q-^/OW#b`#e%b&]Q'}$oW(d%O+s.R/dS*U&i*WS*w'e-[S*|'h+OR.X+xh#VY!W!e#n#s%V'|*T*z+f,u-aQ)j%wQ)v&WR,o)y#xnOcopx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0k^!kP!g!o'^*q-^/Ov#TY!W#`#n#s%w&W&[&`'|(`(})y*T+f+r,u.W/hQ#g`Q$b{Q$c|Q$d}W%S!e%V*z-aS%Y!h(vQ%`!iQ&m#pQ&n#qQ&o#rQ(u%ZS(y%^({Q*R&eS*v'e-[R-Z*wU)h%v)f.mR+V'p[!mP!o'^*q-^/OT*}'h+O^!iP!g!o'^*q-^/OQ'd$bQ'l$dQ*_&mQ*d&oV*{'h*|+OQ%[!hR,S(vQ(s%YR,R(u#znO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0kQ%c!kS(l%S(yR(|%`T#e`%bU#c`#e%bR)z&]Q%f!lQ(n%UQ(r%XQ,U(zR.],VrvOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Y[!mP!o'^*q-^/OQ%P!bQ%a!jQ%i!pQ'[$ZQ([$|Q(k%QQ(p%WQ+z(iR.Y+yrtOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Y[!mP!o'^*q-^/OS*V&i*WT*}'h+OQ'c$bS*^&m'dR,z*_Q'b$bQ'g$cU*]&m'c'dQ*a&nS,y*^*_R.v,zQ*u'`R+Q'iQ'k$dS*c&o'lR,}*dQ'j$dU*b&o'k'lS,|*c*dR.w,}rtOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Y[!mP!o'^*q-^/OT*}'h+OQ'f$cS*`&n'gR,{*aQ*x'eR.|-[R-`*yQ&j#mR*Z&lT*V&i*WQ%e!lS(q%X%fR,P(rR)R%dWk%O+s.R/d#{lO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0k$SiO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%O%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o+s,Y,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0kU&r#t$g,ZS*g&s._Q-Q*iR.y-RT'o$e'p!_#|m#a$r$z$}&w&z&{'O'P'Q'R'S'W'Z)[)g+S+g+j-T-V-e-v-{.e/Z/a/}0Q!]$Pm#a$r$z$}&w&z&{'O'P'R'S'W'Z)[)g+S+g+j-T-V-e-v-{.e/Z/a/}0Q#{nO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0ka)^%k)],`.g/n0Z0f0kQ)`%kR.k,cQ't$hQ)b%oR,f)cT+Y's+ZsvOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,YruOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,YQ$w!]R$y!^R$p!XrvOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,YR(O$oR$q!XR(V$sT+k(U+lX(f%P(g(k+{R+y(hQ.W+xR/h.XQ(j%PQ+w(gQ+|(kR.Z+{R%Q!bQ(e%OV.P+s.R/dQxOQ#lcW$`x#l)Q,YQ)Q%dR,Y)RrXOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Yn!fP!o#e&]&i'^'e'h*W*q+O+x-[-^/Ol!zX!f#P#_#i$[%Z%_%{&R'n'{)O0r!j#PY!e!x#T#`#n$]%S%V%^%u%|&S&[&`'X'|(`(l({(}*T*p*z+f+r+},W,u-a.V/q0R0X0[0hQ#_`Q#ia#d$[op!Y!_!a#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$l%g%k%v&b&d'_'`'i'm(O(T(t)])f)o*P*l*o+T+h+i+o,^,`-r-t-}.g.m/[/_/b/n0Z0f0kS%Z!h(vS%_!i*{S%{#Y)pQ&R#[S'n$e'pY'{$o%O+s.R/dQ)O%bR0r$YQ!uUR%m!uQ)q&OR,l)q^#RY#`$]'X'|(`*px%R!e!x#n%V%^%|&S&[&`({(}*T*z+f+r,W,u-a.V0R[%t#R%R%u+}0X0hS%u#T%SQ+}(lQ0X/qR0h0[Q*m&{R-U*mQ!oPU%h!o*q/OQ*q'^R/O-^!pbOP`cx![!o#e#l$_$m$n$o$p$q%O%b%d&]&i'^'e'h(U)Q)R*W*q+O+d+l+s+x,Y-[-^.R/O/dY!yX!f#_'{)OT#jb!yQ.n,gR/p.nQ%x#VR)k%xQ&c#fS*O&c.[R.[,QQ(w%[R,T(wQ&^#cR){&^Q,_)WR.d,_Q+O'hR-b+OQ-]*xR.}-]Q*W&iR,v*WQ'p$eR+U'pQ&f#gR*S&fQ.h,aR/m.hQ,d)`R.l,dQ+Z'sR-g+ZQ-k+]R/T-kQ/y/US0^/y0`R0`/{Q+l(UR-x+lQ(g%PS+v(g+{R+{(kQ/f.VR0S/fQ+t(eR.S+t`wOcx#l%d)Q)R,YQ$t![Q']$_Q'y$mQ'z$nQ(Q$pQ(R$qS+k(U+lR-q+d'dsOPXY`acopx!Y![!_!a!e!f!h!i!o!x#P#T#Y#[#_#`#e#i#l#n#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$]$_$e$l$m$n$o$p$q%O%S%V%Z%^%_%b%d%g%u%v%{%|&R&S&[&]&`&b&d&i'X'^'_'`'e'h'i'm'n'p'{'|(O(T(U(`(l(t(v({(})O)Q)R)f)o)p*P*T*W*l*o*p*q*z*{+O+T+d+f+h+i+l+o+r+s+x+},W,Y,^,u-[-^-a-r-t-}.R.V.m/O/[/_/b/d/q0R0X0[0h0ra)_%k)],`.g/n0Z0f0kQ!rTQ$h!QQ$i!SQ$j!TQ%o!{Q%q!}Q'x$kQ)c%pQ)l0oS-i+]+_Q-m+^Q-n+`Q/S-kS/U-m/WQ/{/XR0]/x%uSOT`cdopx!Q!S!T!Y![!_!a!{!}#`#l#o#t#u#v#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$g$k$l$m$n$o$p$q%O%d%j%k%p%v&S&d&s&y'm'v(O(T(U(})Q)R)])f*P*T*i*l*o+T+]+^+_+`+b+d+h+i+l+o+s,W,Y,Z,`,c,u-R-k-m-r-t-}.R._.g.m/W/X/[/_/b/d/n/x0Z0f0k0oQ)a%kQ,a)]S.f,`/nQ/l.gQ0g0ZQ0i0fR0m0krmOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,YS#a`$lQ$WoQ$^pQ$r!YQ$z!_Q$}!aQ&w#uQ&z#wY&{#x$o+h-t/_Q&}#|Q'O#}Q'P$OQ'Q$PQ'R$QQ'S$RQ'T$SQ'U$TQ'V$UQ'W$VQ'Z$Z^)[%k)].g/n0Z0f0kU)g%v)f.mQ*Q&dQ+S'mQ+g(OQ+j(TQ,p*PQ-T*lQ-V*oQ-e+TQ-v+iQ-{+oQ.e,`Q/Z-rQ/a-}Q/}/[R0Q/b#xgO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o,Y,`-r-t-}.g.m/[/_/b/n0Z0f0kW(a%O+s.R/dR)S%drYOcx![#l$_$m$n$p$q%d(U)Q)R+d+l,Y[!eP!o'^*q-^/OW!xX$[%{'{Q#``Q#ne#S$]op!Y!_!a#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$l%k%v&d'm(O(T)])f*P*l*o+T+h+i+o,`-r-t-}.g.m/[/_/b/n0Z0f0kQ%V!gS%^!i*{d%|#Y%g&b'_'`'i(t)o)p,^Q&S#_Q&[#bS&`#e&]Q'X$YQ'|$oW(`%O+s.R/dQ({%_Q(}%bS*T&i*WQ*p0rS*z'h+OQ+f'}Q+r(dQ,W)OQ,u*UQ-a*|S.V+x.XR0R/e&O_OPX`ceopx!Y![!_!a!g!i!o#Y#_#b#e#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$_$l$m$n$o$p$q%O%_%b%d%g%k%v%{&]&b&d&i'^'_'`'h'i'm'{'}(O(T(U(d(t)O)Q)R)])f)o)p*P*U*W*l*o*q*{*|+O+T+d+h+i+l+o+s+x,Y,^,`-^-r-t-}.R.X.g.m/O/[/_/b/d/e/n0Z0f0k0rQ$e!OQ'r$fR*h&t&ZWOPX`ceopx!O!Y![!_!a!g!i!o#Y#[#_#b#e#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Y$Z$[$_$f$l$m$n$o$p$q%O%_%b%d%g%k%v%{&R&]&b&d&i&t'^'_'`'h'i'm'{'}(O(T(U(d(t)O)Q)R)])f)o)p*P*U*W*l*o*q*{*|+O+T+d+h+i+l+o+s+x,Y,^,`-^-r-t-}.R.X.g.m/O/[/_/b/d/e/n0Z0f0k0rR&P#Y$QjOcopx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%O%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o+s,Y,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0kQ#f`Q&O#YQ'Y$YU)W%g'`'iQ)}&bQ*s'_Q,Q(tQ,j)oQ,k)pR.c,^Q)n%}R,i)m$SfO`copx!Y![!_!a#l#u#w#x#|#}$O$P$Q$R$S$T$U$V$Z$_$l$m$n$o$p$q%O%d%k%v&d'm(O(T(U)Q)R)])f*P*l*o+T+d+h+i+l+o+s,Y,`-r-t-}.R.g.m/[/_/b/d/n0Z0f0kT&p#t,ZQ&|#xQ(P$oQ-u+hQ/]-tR0P/_]!nP!o'^*q-^/O#PaOPX`bcx![!f!o!y#_#e#l$_$m$n$o$p$q%O%b%d&]&i'^'e'h'{(U)O)Q)R*W*q+O+d+l+s+x,Y-[-^.R/O/dU#WY!W'|Q%T!eU&k#n#s+fQ(o%VS,s*T*zT.s,u-aj#UY!W!e#n#s%V%w&W)y*T*z,u-aU&V#`&`(}Q)x&[Q+e'|Q+q(`Q-s+fQ.O+rQ/g.WR0U/hQ)i%vQ,g)fR/o.mR,h)f`!jP!o'^'h*q+O-^/OT%W!g*|R%]!hW%U!e%V*z-aQ(z%^R,V({S#d`%bR&a#eQ)X%gT*t'`'iR*y'e[!lP!o'^*q-^/OR%X!gR#h`R,b)]R)a%kT-j+]-kQ/V-mR/z/WR/z/X",
  nodeNames: "âš  LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp LogicOp BitOp BitOp BitOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource ClassContent",
  maxTerm: 276,
  nodeProps: [
    ["isolate", -4, 1, 2, 18, 19, ""],
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 145, 147, 150, 151, 153, 156, 158, 161, 163, 165, 167, 172, 174, 176, 178, 180, 181, 183, 191, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 118, 120, 122, 125, 127, 130, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [Tw],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$f_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixyAQyzAnz{B[{|CQ|}Dh}!OEU!O!PFo!P!Q! i!Q!R!,_!R![!0V![!]!>g!]!^!?w!^!_!@e!_!`!BO!`!a!Br!a!b!D`!b!c!EO!c!}!Kz!}#O!MW#O#P%Q#P#Q!Mt#Q#R!Nb#R#S4e#S#T%Q#T#o4e#o#p# U#p#q# r#q#r##[#r#s##x#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&YSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&YS%yZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&YS%yZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%yZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#tP&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&YSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&YSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&YSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&WSXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&XP_4la&PZ&YSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#hQ&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&nR&YSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&YSOY9aYZ%lZr9ars:osw9awx%Qx#O9a#O#P;y#P;'S9a;'S;=`@z<%lO9aT9fX&YSOY%QYZ%lZr%Qrs%qsw%Qwx:Rx;'S%Q;'S;=`&s<%lO%QT:YVbP&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT:rXOY&ZYZ%lZr&Zrs&ysw&Zwx;_x;'S&Z;'S;=`'`<%lO&ZT;dVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<OZ&YSOY<qYZ%lZr<qrs=isw<qwx9ax#O<q#O#P9a#P;'S<q;'S;=`?T<%lO<qT<vZ&YSOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT=lZOY>_YZ%lZr>_rs?Zsw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_T>bZOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT?WP;=`<%l<qT?^ZOY>_YZ%lZr>_rs@Psw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_P@SVOY@PZw@Pwx@ix#O@P#P;'S@P;'S;=`@n<%lO@PP@nObPP@qP;=`<%l@PT@wP;=`<%l>_T@}P;=`<%l9a_AXVZZ&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAuVYR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVBeX$ZP&YS#gQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCXZ#fR&YSOY%QYZ%lZr%Qrs%qs{%Q{|Cz|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVDRV#rR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDoVqR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVE][#fR&YSOY%QYZ%lZr%Qrs%qs}%Q}!OCz!O!_%Q!_!`6e!`!aFR!a;'S%Q;'S;=`&s<%lO%QVFYV&xR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FvZWY&YSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGi!P!Q%Q!Q![Hw![;'S%Q;'S;=`&s<%lO%QVGnX&YSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHZ!P;'S%Q;'S;=`&s<%lO%QVHbV&qR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTIOc&YS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#R%Q#R#SNq#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTJbV&YS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJ|]&YSOY%QYZ%lZr%Qrs%qs{%Q{|Ku|}%Q}!OKu!O!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTKzX&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTLnc&YS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![!f%Q!f!gJZ!g!h%Q!h!iJZ!i#R%Q#R#SMy#S#W%Q#W#XJZ#X#Y%Q#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTNOZ&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![#R%Q#R#SMy#S;'S%Q;'S;=`&s<%lO%QTNvZ&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![#R%Q#R#SNq#S;'S%Q;'S;=`&s<%lO%Q_! p]&YS#gQOY%QYZ%lZr%Qrs%qsz%Qz{!!i{!P%Q!P!Q!)[!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!nX&YSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!#`T&YSOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!#rTOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!$UVOz!#oz{!$R{!P!#o!P!Q!$k!Q;'S!#o;'S;=`!$p<%lO!#oZ!$pOQZZ!$sP;=`<%l!#o_!$yXOY!%fYZ!#ZZr!%frs!'psz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!%iXOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!&ZZ&YSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!'TV&YSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'mP;=`<%l!!i_!'sXOY!%fYZ!#ZZr!%frs!#osz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!(cZOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!)XP;=`<%l!%f_!)cV&YSPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!)}VPZOY!*dYZ%lZr!*drs!+Us;'S!*d;'S;=`!,X<%lO!*d_!*iVPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!+RP;=`<%l!)[_!+ZVPZOY!*dYZ%lZr!*drs!+ps;'S!*d;'S;=`!,X<%lO!*dZ!+uSPZOY!+pZ;'S!+p;'S;=`!,R<%lO!+pZ!,UP;=`<%l!+p_!,[P;=`<%l!*dT!,fu&YS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!d%Q!d!e!3a!e!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o!q%Q!q!r!5_!r!z%Q!z!{!7V!{#R%Q#R#S!2i#S#U%Q#U#V!3a#V#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a#c%Q#c#d!5_#d#l%Q#l#m!7V#m;'S%Q;'S;=`&s<%lO%QT!/Qa&YS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QT!0^i&YS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o#R%Q#R#S!2i#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!2SV&YS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2nZ&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0V![#R%Q#R#S!2i#S;'S%Q;'S;=`&s<%lO%QT!3fY&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S;'S%Q;'S;=`&s<%lO%QT!4]`&YS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S!n%Q!n!o!1{!o#R%Q#R#S!3a#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!5dX&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y;'S%Q;'S;=`&s<%lO%QT!6W_&YS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y!n%Q!n!o!1{!o#R%Q#R#S!5_#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!7[_&YSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8Z!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QT!8`]&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i#T%Q#T#Z!9X#Z;'S%Q;'S;=`&s<%lO%QT!9^c&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#R%Q#R#S!8Z#S#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!:pi&YS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<_!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i!n%Q!n!o!1{!o!r%Q!r!sJw!s#R%Q#R#S!=i#S#T%Q#T#Z!:i#Z#`%Q#`#a!1{#a#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!<da&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!=n]&YSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QV!>nX#pR&YSOY%QYZ%lZr%Qrs%qs![%Q![!]!?Z!];'S%Q;'S;=`&s<%lO%QV!?bV&vR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!@OV!PR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@lY&_Z&YSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!A[!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!AcX#iQ&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BVX!bR&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!ByY&^R&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Ci!a;'S%Q;'S;=`&s<%lO%QU!CpY#iQ&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!A[!a;'S%Q;'S;=`&s<%lO%Q_!DiV&bX#oQ&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EVX%}Z&YSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!Er#^;'S%Q;'S;=`&s<%lO%QV!EwX&YSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!Fd#c;'S%Q;'S;=`&s<%lO%QV!FiX&YSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GU#i;'S%Q;'S;=`&s<%lO%QV!GZX&YSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gv#Y;'S%Q;'S;=`&s<%lO%QV!G{X&YSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hh#g;'S%Q;'S;=`&s<%lO%QV!HmX&YSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IY#Z;'S%Q;'S;=`&s<%lO%QV!I_X&YSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!Iz#U;'S%Q;'S;=`&s<%lO%QV!JPX&YSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jl#W;'S%Q;'S;=`&s<%lO%QV!JqX&YSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!K^#Y;'S%Q;'S;=`&s<%lO%QV!KeV&tR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!LRa&RZ&YSOY%QYZ%lZr%Qrs%qst%Qtu!Kzu!Q%Q!Q![!Kz![!c%Q!c!}!Kz!}#R%Q#R#S!Kz#S#T%Q#T#o!Kz#o;'S%Q;'S;=`&s<%lO%Q_!M_VuZ&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!M{VsR&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NiX#eQ&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# ]V}R&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# {Z'OX#dQ&YSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!n#q;'S%Q;'S;=`&s<%lO%QU#!uV#bQ&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##cV|R&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT#$PV#uP&YSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3], ClassContent: [1, 194] },
  dynamicPrecedences: { 27: 1, 232: -1, 243: -1 },
  specialized: [{ term: 231, get: (t) => ww[t] || -1 }],
  tokenPrec: 7144
}), Ww = /* @__PURE__ */ re.define({
  name: "java",
  parser: /* @__PURE__ */ kw.configure({
    props: [
      /* @__PURE__ */ me.add({
        IfStatement: /* @__PURE__ */ ae({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ ae({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: qn,
        SwitchBlock: (t) => {
          let e = t.textAfter, O = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (O ? 0 : i ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ YO({ closing: "}" }),
        BlockComment: () => null,
        Statement: /* @__PURE__ */ ae({ except: /^{/ })
      }),
      /* @__PURE__ */ fe.add({
        "Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer": Ie,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function Rw() {
  return new le(Ww);
}
const vw = 110, lQ = 1, Zw = 2, tp = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
function Rn(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function Yw(t) {
  return t >= 48 && t <= 57;
}
const zw = /* @__PURE__ */ new q((t, e) => {
  if (t.next == 40) {
    let O = t.peek(-1);
    (Rn(O) || Yw(O) || O == 95 || O == 45) && t.acceptToken(Zw, 1);
  }
}), qw = /* @__PURE__ */ new q((t) => {
  if (tp.indexOf(t.peek(-1)) > -1) {
    let { next: e } = t;
    (Rn(e) || e == 95 || e == 35 || e == 46 || e == 91 || e == 58 || e == 45) && t.acceptToken(vw);
  }
}), Uw = /* @__PURE__ */ new q((t) => {
  if (tp.indexOf(t.peek(-1)) < 0) {
    let { next: e } = t;
    if (e == 37 && (t.advance(), t.acceptToken(lQ)), Rn(e)) {
      do
        t.advance();
      while (Rn(t.next));
      t.acceptToken(lQ);
    }
  }
}), Vw = /* @__PURE__ */ se({
  "import charset namespace keyframes media supports when": l.definitionKeyword,
  "from to selector": l.keyword,
  NamespaceName: l.namespace,
  KeyframeName: l.labelName,
  TagName: l.tagName,
  ClassName: l.className,
  PseudoClassName: /* @__PURE__ */ l.constant(l.className),
  IdName: l.labelName,
  "FeatureName PropertyName PropertyVariable": l.propertyName,
  AttributeName: l.attributeName,
  NumberLiteral: l.number,
  KeywordQuery: l.keyword,
  UnaryQueryOp: l.operatorKeyword,
  "CallTag ValueName": l.atom,
  VariableName: l.variableName,
  "AtKeyword Interpolation": /* @__PURE__ */ l.special(l.variableName),
  Callee: l.operatorKeyword,
  Unit: l.unit,
  "UniversalSelector NestingSelector": l.definitionOperator,
  MatchOp: l.compareOperator,
  "ChildOp SiblingOp, LogicOp": l.logicOperator,
  BinOp: l.arithmeticOperator,
  Important: l.modifier,
  "Comment LineComment": l.blockComment,
  ColorLiteral: l.color,
  "ParenthesizedContent StringLiteral": l.string,
  Escape: /* @__PURE__ */ l.special(l.string),
  ": ...": l.punctuation,
  "PseudoOp #": l.derefOperator,
  "; ,": l.separator,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace
}), _w = { __proto__: null, lang: 40, "nth-child": 40, "nth-last-child": 40, "nth-of-type": 40, "nth-last-of-type": 40, dir: 40, "host-context": 40, and: 244, or: 244, not: 74, only: 74, url: 86, "url-prefix": 86, domain: 86, regexp: 86, when: 117, selector: 142, from: 172, to: 174 }, jw = { __proto__: null, "@import": 126, "@plugin": 126, "@media": 152, "@charset": 156, "@namespace": 160, "@keyframes": 166, "@supports": 178 }, Gw = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "@^O!gQWOOO!nQaO'#CeOOQP'#Cd'#CdO$RQWO'#CgO$xQaO'#EaO%cQWO'#CiO%kQWO'#DZO%pQWO'#D^O%uQaO'#DfOOQP'#Es'#EsO'YQWO'#DlO'yQWO'#DyO(QQWO'#D{O(xQWO'#D}O)TQWO'#EQO'bQWO'#EWO)YQ`O'#FTO)]Q`O'#FTO)hQ`O'#FTO)vQWO'#EYOOQO'#Er'#ErOOQO'#FV'#FVOOQO'#Ec'#EcO){QWO'#EqO*WQWO'#EqQOQWOOOOQP'#Ch'#ChOOQP,59R,59RO$RQWO,59RO*bQWO'#EdO+PQWO,58|O+_QWO,59TO%kQWO,59uO%pQWO,59xO*bQWO,59{O*bQWO,59}OOQO'#De'#DeO*bQWO,5:OO,bQpO'#E}O,iQWO'#DkOOQO,58|,58|O(QQWO,58|O,pQWO,5:{OOQO,5:{,5:{OOQT'#Cl'#ClO-UQeO,59TO.cQ[O,59TOOQP'#D]'#D]OOQP,59u,59uOOQO'#D_'#D_O.hQpO,59xOOQO'#EZ'#EZO.pQ`O,5;oOOQO,5;o,5;oO/OQWO,5:WO/VQWO,5:WOOQS'#Dn'#DnO/rQWO'#DsO/yQ!fO'#FRO0eQWO'#DtOOQS'#FS'#FSO+YQWO,5:eO'bQWO'#DrOOQS'#Cu'#CuO(QQWO'#CwO0jQ!hO'#CyO2^Q!fO,5:gO2oQWO'#DWOOQS'#Ex'#ExO(QQWO'#DQOOQO'#EP'#EPO2tQWO,5:iO2yQWO,5:iOOQO'#ES'#ESO3RQWO,5:lO3WQ!fO,5:rO3iQ`O'#EkO.pQ`O,5;oOOQO,5:|,5:|O3zQWO,5:tOOQO,5:},5:}O4XQWO,5;]OOQO-E8a-E8aOOQP1G.m1G.mOOQP'#Ce'#CeO5RQaO,5;OOOQP'#Df'#DfOOQO-E8b-E8bOOQO1G.h1G.hO(QQWO1G.hO5fQWO1G.hO5nQeO1G.oO.cQ[O1G.oOOQP1G/a1G/aO6{QpO1G/dO7fQaO1G/gO8cQaO1G/iO9`QaO1G/jO:]Q!fO'#FOO:yQ!fO'#ExOOQO'#FO'#FOOOQO,5;i,5;iO<^QWO,5;iO<iQWO,5:VO<nQ!fO1G.hOOQO1G0g1G0gO=PQWO'#CnOOQP1G.o1G.oO=WQWO'#CqOOQP1G/d1G/dO(QQWO1G/dO=_Q`O1G1ZOOQO1G1Z1G1ZO=mQWO1G/rO=rQ!fO'#FQO>WQWO1G/rO>]Q!fO'#DnO>qQWO,5:ZO>vQ!fO,5:_OOQO'#DP'#DPO'bQWO,5:]O?XQWO'#DwOOQS,5:b,5:bO?`QWO,5:dO'bQWO'#EiO?gQWO,5;mO*bQWO,5:`OOQO1G0P1G0PO?uQ!fO,5:^O@aQ!fO,59cOOQS,59e,59eO(QQWO,59iOOQS,59n,59nO@rQWO,59pOOQO1G0R1G0RO@yQ#tO,59rOARQ!fO,59lOOQO1G0T1G0TOBrQWO1G0TOBwQWO'#ETOOQO1G0W1G0WOOQO1G0^1G0^OOQO,5;V,5;VOOQO-E8i-E8iOCVQ!fO1G0bOCvQWO1G0`O%kQWO'#E_O$RQWO'#E`OEZQWO'#E^OOQO1G0b1G0bPEkQWO'#EcO<nQ!fO7+$SOOQO7+$S7+$SO(QQWO7+$SOOQP7+$Z7+$ZOOQP7+%O7+%OO(QQWO7+%OOEpQ!fO'#EeOF}QWO,5;jO(QQWO,5;jOOQO,5;j,5;jO+gQpO'#EgOG[QWO1G1TOOQO1G1T1G1TOOQO1G/q1G/qOGgQaO'#EvOGnQWO,59YOGsQWO'#EwOG}QWO,59]OHSQ!fO7+%OOOQO7+&u7+&uOOQO7+%^7+%^O(QQWO'#EhOHeQWO,5;lOHmQWO7+%^O(QQWO1G/uOOQS1G/y1G/yOOQS1G/w1G/wOHrQWO,5:cOHwQ!fO1G0OOOQS1G0O1G0OOIYQ!fO,5;TOOQO-E8g-E8gOItQaO1G/zOOQS1G.}1G.}OOQS1G/T1G/TOI{Q!fO1G/[OOQS1G/[1G/[OJ^QWO1G/^OOQO7+%o7+%oOJcQYO'#CyO+YQWO'#EjOJkQWO,5:oOOQO,5:o,5:oOJyQ!fO'#ElO(QQWO'#ElOL^QWO7+%|OOQO7+%|7+%|OOQO7+%z7+%zOOQO,5:y,5:yOOQO,5:z,5:zOLqQaO,5:xOOQO,5:x,5:xOOQO<<Gn<<GnO<nQ!fO<<GnOMRQ!fO<<HjOOQO-E8c-E8cOMdQWO1G1UOOQO,5;R,5;ROOQO-E8e-E8eOOQO7+&o7+&oOMqQWO,5;bOOQP1G.t1G.tO(QQWO'#EfOMyQWO,5;cOOQT1G.w1G.wOOQP<<Hj<<HjONRQ!fO,5;SOOQO-E8f-E8fO/OQWO<<HxONgQWO7+%aOOQS1G/}1G/}OOQS7+%j7+%jOOQS7+%f7+%fOOQS7+$v7+$vOOQS7+$x7+$xOOQO,5;U,5;UOOQO-E8h-E8hOOQO1G0Z1G0ZONnQ!fO,5;WOOQO-E8j-E8jOOQO<<Ih<<IhOOQO1G0d1G0dOOQOAN=YAN=YOOQPAN>UAN>UO!!RQWO,5;QOOQO-E8d-E8dO!!]QWOAN>dOOQS<<H{<<H{OOQOG24OG24O",
  stateData: "!!n~O#dOSROSSOS~OVXOYXO^TO_TOfaOgbOoaOpWOyVO!OUO!aYO!nZO!p[O!r]O!u^O!{_O#hPO#iRO~O#a#eP~P]O^XX^!}X_XXcXXjXXp!}XyXX!OXX!UXX!ZXX![XX!^XX#PXX#aXX#bXX#iXX#oXX#pXX#p!}X#x!}X!]XX~O#hjO~O^oO_oOcmOyqO!OpO!UrO#bsO#ilO#otO#ptO~OjvO![yO!^wO#P{O!Z#TX#a#TX!]#TX~P$WOd!OO#h|O~O#h!PO~O#h!RO~O#h!TO#p!VO#x!VO^!YX^#wX_!YXc!YXj!YXy!YX!O!YX!U!YX!Z!YX![!YX!^!YX#P!YX#a!YX#b!YX#i!YX#o!YX#p!YX!]!YX~Oj!XOn!WO~Og!^Oj!ZOo!^Op!^Ou!`O!i!]O#h!YO~O!^#uP~P'bOf!fOg!fOh!fOj!bOl!fOn!fOo!fOp!fOu!gO{!eO#h!aO#m!cO~On!iO{!eO#h!hO~O#h!kO~Op!nO#p!VO#x!VO^#wX~OjvO#p!VO#x!VO^#wX~O^!qO~O!Z!rO#a#eX!]#eX~O#a#eX!]#eX~P]OVXOYXO^TO_TOp!xOyVO!OUO#h!vO#iRO~OcmOjvO![!{O!^wO~Od#OO#h|O~Of!fOg#VOh!fOj!bOl!fOn!fOo!fOp!fOu!gO{!eO#h!aO#m!cO#s#WO~Oa#XO~P+gO!]#eP~P]O![!{O!^wO#P#]O!Z#Ta#a#Ta!]#Ta~OQ#^O^]a_]ac]aj]ay]a!O]a!U]a!Z]a![]a!^]a#P]a#a]a#b]a#i]a#o]a#p]a!]]aa]a~OQ#`O~Ow#aO!S#bO~Op!nO#p#dO#x#dO^#wa~O!Z#uP~P'bOa#tP~P(QOg!^Oj!ZOo!^Op!^Ou!`O!i!]O~O#h#hO~P/^OQ#mOc#pOr#lOy#oO#n#kO!^#uX!Z#uXa#uX~Oj#rO~OP#vOQmXrmXymX!ZmX#nmX^mXamXcmXfmXgmXhmXjmXlmXnmXomXpmXumX{mX#hmX#mmX!^mX#PmX#amXwmX!]mX~OQ#`Or#wOy#yO!Z#zO#n#kO~Oj#{O~O!Z#}O~On$OO{!eO~O!^$PO~OQ#mOr#lOy#oO!^wO#n#kO~O#h!TO^#_Xp#_X#p#_X#x#_X~O!O$WO!^wO#i$XO~P(QO!Z!rO#a#ea!]#ea~O^oO_oOyqO!OpO!UrO#bsO#ilO#otO#ptO~Oc#Waj#Wa![#Wa!^#Waa#Wa~P4dO![$_O!^wO~OQ#^O^]i_]ic]ij]iy]i!O]i!U]i!Z]i![]i!^]i#P]i#a]i#b]i#i]i#o]i#p]i!]]ia]i~Ow$aO!S$bO~O^oO_oOyqO!OpO#ilO~Oc!Tij!Ti!U!Ti!Z!Ti![!Ti!^!Ti#P!Ti#a!Ti#b!Ti#o!Ti#p!Ti!]!Tia!Ti~P7TOc!Vij!Vi!U!Vi!Z!Vi![!Vi!^!Vi#P!Vi#a!Vi#b!Vi#o!Vi#p!Vi!]!Via!Vi~P7TOc!Wij!Wi!U!Wi!Z!Wi![!Wi!^!Wi#P!Wi#a!Wi#b!Wi#o!Wi#p!Wi!]!Wia!Wi~P7TOQ#`O^$eOr#wOy#yO#n#kOa#rXc#rX!Z#rX~P(QO#s$fOQ#lX^#lXa#lXc#lXf#lXg#lXh#lXj#lXl#lXn#lXo#lXp#lXr#lXu#lXy#lX{#lX!Z#lX#h#lX#m#lX#n#lX~Oa$iOc$gO!Z$gO~O!]$jO~OQ#`Or#wOy#yO!^wO#n#kO~Oa#jP~P*bOa#kP~P(QOp!nO#p$pO#x$pO^#wi~O!Z$qO~OQ#`Oc$rOr#wOy#yO#n#kOa#tX~Oa$tO~OQ!bX^!dXa!bXr!bXy!bX#n!bX~O^$uO~OQ#mOa$vOr#lOy#oO#n#kO~Oa#uP~P'bOw$zO~P(QOc#pO!^#ua!Z#uaa#ua~OQ#mOr#lOy#oO#n#kOc!fa!^!fa!Z!faa!fa~OQ#`Oa%OOr#wOy#yO#n#kO~Ow%RO~P(QOn%SO|%SO~OQ#`Or#wOy#yO#n#kO!Zta^taatactaftagtahtajtaltantaotaptauta{ta#hta#mta!^ta#Pta#atawta!]ta~O!Z%TO~O!]%XO!x%VO!y%VO#m%UO~OQ#`Oc%ZOr#wOy#yO#P%]O#n#kO!Z#Oi#a#Oi!]#Oi~P(QO!Z%^OV!|iY!|i^!|i_!|if!|ig!|io!|ip!|iy!|i!O!|i!a!|i!n!|i!p!|i!r!|i!u!|i!{!|i#a!|i#h!|i#i!|i!]!|i~OjvO!Z#QX#a#QX!]#QX~P*bO!Z!rO~OQ#`Or#wOy#yO#n#kOa#XXc#XXf#XXg#XXh#XXj#XXl#XXn#XXo#XXp#XXu#XX{#XX!Z#XX#h#XX#m#XX~Oa#rac#ra!Z#ra~P(QOa%jOc$gO!Z$gO~Oa#jX~P$WOa%lO~Oc%mOa#kX~P(QOa%oO~OQ#`Or#wOw%pOy#yO#n#kO~Oc$rOa#ta~On%sO~Oa%uO~OQ#`Or#wOw%vOy#yO#n#kO~OQ#mOr#lOy#oO#n#kOc#]a!^#]a!Z#]aa#]a~Oa%wO~P4dOQ#`Or#wOw%xOy#yO#n#kO~Oa%yO~OP#vO!^mX~O!]%|O!x%VO!y%VO#m%UO~OQ#`Or#wOy#yO#n#kOc#`Xf#`Xg#`Xh#`Xj#`Xl#`Xn#`Xo#`Xp#`Xu#`X{#`X!Z#`X#P#`X#a#`X#h#`X#m#`X!]#`X~Oc%ZO#P&PO!Z#Oq#a#Oq!]#Oq~P(QOjvO!Z#Qa#a#Qa!]#Qa~P4dOQ#`Or#wOw&SOy#yO#n#kO~Oa#ric#ri!Z#ri~P(QOcmOa#ja~Oc%mOa#ka~OQ#`Or#wOy#yO#n#kOa#[ac#[a~Oa&WO~P(QOQ#`Or#wOy#yO#n#kOc#`af#`ag#`ah#`aj#`al#`an#`ao#`ap#`au#`a{#`a!Z#`a#P#`a#a#`a#h#`a#m#`a!]#`a~Oa#Yac#Ya~P(QO!Z&XO~Of#dpg#m|#iRSRr~",
  goto: "0^#zPPPPPP#{P$Q$^P$Q$j$QPP$sP$yPP%PPPP%jP%jP&ZPPP%jP'O%jP%jP%jP'jPP$QP(a$Q(jP$QP$Q$Q(p$QPPPP(w#{P)f)f)q)f)f)f)fP)f)t)f#{P#{P#{P){#{P*O*RPP#{P#{*U*aP*f*i*i*a*a*l*s*}+e+k+q+w+},T,_PPPP,e,k,pPP-[-_-bPPPP.u/UP/[/_/k0QP0VVdOhweXOhmrsuw#^#r$YeQOhmrsuw#^#r$YQkRQ!ulR%`$XQ}TR!}oQ#_}R$`!}Q#_!Or#x!d#U#[#f#u#|$U$]$c$o$y%Q%Y%d%e%q%}R$`#O!]!f[vy!X!b!g!q!{#U#`#b#o#w#y$U$_$b$d$e$g$m$r$u%Z%[%g%m%t&T![!f[vy!X!b!g!q!{#U#`#b#o#w#y$U$_$b$d$e$g$m$r$u%Z%[%g%m%t&TT%V$P%WY#l![!m#j#t${s#w!d#U#[#f#u#|$U$]$c$o$y%Q%Y%d%e%q%}![!f[vy!X!b!g!q!{#U#`#b#o#w#y$U$_$b$d$e$g$m$r$u%Z%[%g%m%t&TQ!i]R$O!jQ!QUQ#PpR%_$WQ!SVR#QqZuS!w$k$}%aQxSS!znzQ#s!_Q$R!mQ$V!qS$^!|#[Q%c$]Q%z%VR&R%dc!^Z_!W!Z!`#l#m#p%sR#i!ZZ#n![!m#j#t${R!j]R!l^R$Q!lU`OhwQ!UWR$S!nVeOhwR$Z!qR$Y!qShOwR!thQnSS!yn%kR%k$kQ$d#UQ$m#`Y%f$d$m%g%t&TQ%g$eQ%t$uR&T%mQ%n$mR&U%nQ$h#YR%i$hQ$s#fR%r$sQ#q![R$|#qQ%W$PR%{%WQ!o`Q#c!UT$T!o#cQ%[$UR&O%[QiOR#ZwVfOhwUSOhwQ!wmQ#RrQ#SsQ#TuQ$k#^Q$}#rR%a$YR$l#^R$n#`Q!d[S#Uv$gQ#[yQ#f!XQ#u!bQ#|!gQ$U!qQ$]!{d$c#U#`$d$e$m$u%g%m%t&TQ$o#bQ$y#oQ%P#wQ%Q#yS%Y$U%[Q%d$_Q%e$bQ%q$rR%}%ZQzSQ!pbQ!|nQ%b$YR&Q%aQ#YvR%h$gR#g!XQ!_ZQ#e!WQ$x#mR&V%sW![Z!W#m%sQ!m_Q#j!ZQ#t!`Q$w#lR${#pVcOhwSgOwR!sh",
  nodeNames: "âš  Unit ( Comment LineComment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName ) ArgList , PseudoClassName ArgList VariableName AtKeyword PropertyVariable ValueName ( ParenthesizedValue ColorLiteral NumberLiteral StringLiteral Escape Interpolation BinaryExpression BinOp LogicOp UnaryExpression UnaryQueryOp CallExpression ] SubscriptExpression [ CallLiteral CallTag ParenthesizedContent IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp InterpolatedSelector ; when } { Block ImportStatement import KeywordQuery FeatureQuery FeatureName BinaryQuery UnaryQuery ParenthesizedQuery SelectorQuery selector CallQuery ArgList SubscriptQuery MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports DetachedRuleSet PropertyName Declaration Important Inclusion IdSelector ClassSelector Inclusion CallExpression",
  maxTerm: 133,
  nodeProps: [
    ["isolate", -3, 3, 4, 30, ""],
    ["openedBy", 17, "(", 59, "{"],
    ["closedBy", 26, ")", 60, "}"]
  ],
  propSources: [Vw],
  skippedNodes: [0, 3, 4],
  repeatNodeCount: 10,
  tokenData: "!2q~R!ZOX$tX^%l^p$tpq%lqr)Ors-xst/ltu6Zuv$tvw8^wx:Uxy;syz<Uz{<Z{|<t|}BQ}!OBc!O!PDo!P!QFY!Q![Jw![!]Kr!]!^Ln!^!_MP!_!`M{!`!aNl!a!b$t!b!c! m!c!}!&R!}#O!'y#O#P$t#P#Q!([#Q#R!(m#R#T$t#T#o!&R#o#p!)S#p#q!(m#q#r!)e#r#s!)v#s#y$t#y#z%l#z$f$t$f$g%l$g#BY$t#BY#BZ%l#BZ$IS$t$IS$I_%l$I_$I|$t$I|$JO%l$JO$JT$t$JT$JU%l$JU$KV$t$KV$KW%l$KW&FU$t&FU&FV%l&FV;'S$t;'S;=`!2k<%lO$t`$wSOy%Tz;'S%T;'S;=`%f<%lO%T`%YS|`Oy%Tz;'S%T;'S;=`%f<%lO%T`%iP;=`<%l%T~%qh#d~OX%TX^']^p%Tpq']qy%Tz#y%T#y#z']#z$f%T$f$g']$g#BY%T#BY#BZ']#BZ$IS%T$IS$I_']$I_$I|%T$I|$JO']$JO$JT%T$JT$JU']$JU$KV%T$KV$KW']$KW&FU%T&FU&FV']&FV;'S%T;'S;=`%f<%lO%T~'dh#d~|`OX%TX^']^p%Tpq']qy%Tz#y%T#y#z']#z$f%T$f$g']$g#BY%T#BY#BZ']#BZ$IS%T$IS$I_']$I_$I|%T$I|$JO']$JO$JT%T$JT$JU']$JU$KV%T$KV$KW']$KW&FU%T&FU&FV']&FV;'S%T;'S;=`%f<%lO%Tk)RUOy%Tz#]%T#]#^)e#^;'S%T;'S;=`%f<%lO%Tk)jU|`Oy%Tz#a%T#a#b)|#b;'S%T;'S;=`%f<%lO%Tk*RU|`Oy%Tz#d%T#d#e*e#e;'S%T;'S;=`%f<%lO%Tk*jU|`Oy%Tz#c%T#c#d*|#d;'S%T;'S;=`%f<%lO%Tk+RU|`Oy%Tz#f%T#f#g+e#g;'S%T;'S;=`%f<%lO%Tk+jU|`Oy%Tz#h%T#h#i+|#i;'S%T;'S;=`%f<%lO%Tk,RU|`Oy%Tz#T%T#T#U,e#U;'S%T;'S;=`%f<%lO%Tk,jU|`Oy%Tz#b%T#b#c,|#c;'S%T;'S;=`%f<%lO%Tk-RU|`Oy%Tz#h%T#h#i-e#i;'S%T;'S;=`%f<%lO%Tk-lS#PZ|`Oy%Tz;'S%T;'S;=`%f<%lO%T~-{WOY-xZr-xrs.es#O-x#O#P.j#P;'S-x;'S;=`/f<%lO-x~.jOn~~.mRO;'S-x;'S;=`.v;=`O-x~.yXOY-xZr-xrs.es#O-x#O#P.j#P;'S-x;'S;=`/f;=`<%l-x<%lO-x~/iP;=`<%l-xo/qY!OROy%Tz!Q%T!Q![0a![!c%T!c!i0a!i#T%T#T#Z0a#Z;'S%T;'S;=`%f<%lO%Tm0fY|`Oy%Tz!Q%T!Q![1U![!c%T!c!i1U!i#T%T#T#Z1U#Z;'S%T;'S;=`%f<%lO%Tm1ZY|`Oy%Tz!Q%T!Q![1y![!c%T!c!i1y!i#T%T#T#Z1y#Z;'S%T;'S;=`%f<%lO%Tm2QYl]|`Oy%Tz!Q%T!Q![2p![!c%T!c!i2p!i#T%T#T#Z2p#Z;'S%T;'S;=`%f<%lO%Tm2wYl]|`Oy%Tz!Q%T!Q![3g![!c%T!c!i3g!i#T%T#T#Z3g#Z;'S%T;'S;=`%f<%lO%Tm3lY|`Oy%Tz!Q%T!Q![4[![!c%T!c!i4[!i#T%T#T#Z4[#Z;'S%T;'S;=`%f<%lO%Tm4cYl]|`Oy%Tz!Q%T!Q![5R![!c%T!c!i5R!i#T%T#T#Z5R#Z;'S%T;'S;=`%f<%lO%Tm5WY|`Oy%Tz!Q%T!Q![5v![!c%T!c!i5v!i#T%T#T#Z5v#Z;'S%T;'S;=`%f<%lO%Tm5}Sl]|`Oy%Tz;'S%T;'S;=`%f<%lO%Tm6^YOy%Tz!_%T!_!`6|!`!c%T!c!}7a!}#T%T#T#o7a#o;'S%T;'S;=`%f<%lO%Td7TS!SS|`Oy%Tz;'S%T;'S;=`%f<%lO%Tm7h[h]|`Oy%Tz}%T}!O7a!O!Q%T!Q![7a![!c%T!c!}7a!}#T%T#T#o7a#o;'S%T;'S;=`%f<%lO%Ta8c[YPOy%Tz}%T}!O9X!O!Q%T!Q![9X![!c%T!c!}9X!}#T%T#T#o9X#o;'S%T;'S;=`%f<%lO%Ta9`[YP|`Oy%Tz}%T}!O9X!O!Q%T!Q![9X![!c%T!c!}9X!}#T%T#T#o9X#o;'S%T;'S;=`%f<%lO%T~:XWOY:UZw:Uwx.ex#O:U#O#P:q#P;'S:U;'S;=`;m<%lO:U~:tRO;'S:U;'S;=`:};=`O:U~;QXOY:UZw:Uwx.ex#O:U#O#P:q#P;'S:U;'S;=`;m;=`<%l:U<%lO:U~;pP;=`<%l:Uo;xSj_Oy%Tz;'S%T;'S;=`%f<%lO%T~<ZOa~m<bUVPrWOy%Tz!_%T!_!`6|!`;'S%T;'S;=`%f<%lO%To<{Y#pQrWOy%Tz!O%T!O!P=k!P!Q%T!Q![@p![#R%T#R#SAm#S;'S%T;'S;=`%f<%lO%Tm=pU|`Oy%Tz!Q%T!Q![>S![;'S%T;'S;=`%f<%lO%Tm>ZY#m]|`Oy%Tz!Q%T!Q![>S![!g%T!g!h>y!h#X%T#X#Y>y#Y;'S%T;'S;=`%f<%lO%Tm?OY|`Oy%Tz{%T{|?n|}%T}!O?n!O!Q%T!Q![@V![;'S%T;'S;=`%f<%lO%Tm?sU|`Oy%Tz!Q%T!Q![@V![;'S%T;'S;=`%f<%lO%Tm@^U#m]|`Oy%Tz!Q%T!Q![@V![;'S%T;'S;=`%f<%lO%Tm@w[#m]|`Oy%Tz!O%T!O!P>S!P!Q%T!Q![@p![!g%T!g!h>y!h#X%T#X#Y>y#Y;'S%T;'S;=`%f<%lO%TbAtS#xQ|`Oy%Tz;'S%T;'S;=`%f<%lO%TkBVScZOy%Tz;'S%T;'S;=`%f<%lO%TmBhXrWOy%Tz}%T}!OCT!O!P=k!P!Q%T!Q![@p![;'S%T;'S;=`%f<%lO%TmCYW|`Oy%Tz!c%T!c!}Cr!}#T%T#T#oCr#o;'S%T;'S;=`%f<%lO%TmCy[f]|`Oy%Tz}%T}!OCr!O!Q%T!Q![Cr![!c%T!c!}Cr!}#T%T#T#oCr#o;'S%T;'S;=`%f<%lO%ToDtW#iROy%Tz!O%T!O!PE^!P!Q%T!Q![>S![;'S%T;'S;=`%f<%lO%TlEcU|`Oy%Tz!O%T!O!PEu!P;'S%T;'S;=`%f<%lO%TlE|S#s[|`Oy%Tz;'S%T;'S;=`%f<%lO%T~F_VrWOy%Tz{Ft{!P%T!P!QIl!Q;'S%T;'S;=`%f<%lO%T~FyU|`OyFtyzG]z{Hd{;'SFt;'S;=`If<%lOFt~G`TOzG]z{Go{;'SG];'S;=`H^<%lOG]~GrVOzG]z{Go{!PG]!P!QHX!Q;'SG];'S;=`H^<%lOG]~H^OR~~HaP;=`<%lG]~HiW|`OyFtyzG]z{Hd{!PFt!P!QIR!Q;'SFt;'S;=`If<%lOFt~IYS|`R~Oy%Tz;'S%T;'S;=`%f<%lO%T~IiP;=`<%lFt~IsV|`S~OYIlYZ%TZyIlyzJYz;'SIl;'S;=`Jq<%lOIl~J_SS~OYJYZ;'SJY;'S;=`Jk<%lOJY~JnP;=`<%lJY~JtP;=`<%lIlmJ|[#m]Oy%Tz!O%T!O!P>S!P!Q%T!Q![@p![!g%T!g!h>y!h#X%T#X#Y>y#Y;'S%T;'S;=`%f<%lO%TkKwU^ZOy%Tz![%T![!]LZ!];'S%T;'S;=`%f<%lO%TcLbS_R|`Oy%Tz;'S%T;'S;=`%f<%lO%TkLsS!ZZOy%Tz;'S%T;'S;=`%f<%lO%ThMUUrWOy%Tz!_%T!_!`Mh!`;'S%T;'S;=`%f<%lO%ThMoS|`rWOy%Tz;'S%T;'S;=`%f<%lO%TlNSW!SSrWOy%Tz!^%T!^!_Mh!_!`%T!`!aMh!a;'S%T;'S;=`%f<%lO%TjNsV!UQrWOy%Tz!_%T!_!`Mh!`!a! Y!a;'S%T;'S;=`%f<%lO%Tb! aS!UQ|`Oy%Tz;'S%T;'S;=`%f<%lO%To! rYg]Oy%Tz!b%T!b!c!!b!c!}!#R!}#T%T#T#o!#R#o#p!$O#p;'S%T;'S;=`%f<%lO%Tm!!iWg]|`Oy%Tz!c%T!c!}!#R!}#T%T#T#o!#R#o;'S%T;'S;=`%f<%lO%Tm!#Y[g]|`Oy%Tz}%T}!O!#R!O!Q%T!Q![!#R![!c%T!c!}!#R!}#T%T#T#o!#R#o;'S%T;'S;=`%f<%lO%To!$TW|`Oy%Tz!c%T!c!}!$m!}#T%T#T#o!$m#o;'S%T;'S;=`%f<%lO%To!$r^|`Oy%Tz}%T}!O!$m!O!Q%T!Q![!$m![!c%T!c!}!$m!}#T%T#T#o!$m#o#q%T#q#r!%n#r;'S%T;'S;=`%f<%lO%To!%uSp_|`Oy%Tz;'S%T;'S;=`%f<%lO%To!&W[#h_Oy%Tz}%T}!O!&|!O!Q%T!Q![!&|![!c%T!c!}!&|!}#T%T#T#o!&|#o;'S%T;'S;=`%f<%lO%To!'T[#h_|`Oy%Tz}%T}!O!&|!O!Q%T!Q![!&|![!c%T!c!}!&|!}#T%T#T#o!&|#o;'S%T;'S;=`%f<%lO%Tk!(OSyZOy%Tz;'S%T;'S;=`%f<%lO%Tm!(aSw]Oy%Tz;'S%T;'S;=`%f<%lO%Td!(pUOy%Tz!_%T!_!`6|!`;'S%T;'S;=`%f<%lO%Tk!)XS!^ZOy%Tz;'S%T;'S;=`%f<%lO%Tk!)jS!]ZOy%Tz;'S%T;'S;=`%f<%lO%To!){Y#oQOr%Trs!*ksw%Twx!.wxy%Tz!_%T!_!`6|!`;'S%T;'S;=`%f<%lO%Tm!*pZ|`OY!*kYZ%TZr!*krs!+csy!*kyz!+vz#O!*k#O#P!-j#P;'S!*k;'S;=`!.q<%lO!*km!+jSo]|`Oy%Tz;'S%T;'S;=`%f<%lO%T]!+yWOY!+vZr!+vrs!,cs#O!+v#O#P!,h#P;'S!+v;'S;=`!-d<%lO!+v]!,hOo]]!,kRO;'S!+v;'S;=`!,t;=`O!+v]!,wXOY!+vZr!+vrs!,cs#O!+v#O#P!,h#P;'S!+v;'S;=`!-d;=`<%l!+v<%lO!+v]!-gP;=`<%l!+vm!-oU|`Oy!*kyz!+vz;'S!*k;'S;=`!.R;=`<%l!+v<%lO!*km!.UXOY!+vZr!+vrs!,cs#O!+v#O#P!,h#P;'S!+v;'S;=`!-d;=`<%l!*k<%lO!+vm!.tP;=`<%l!*km!.|Z|`OY!.wYZ%TZw!.wwx!+cxy!.wyz!/oz#O!.w#O#P!1^#P;'S!.w;'S;=`!2e<%lO!.w]!/rWOY!/oZw!/owx!,cx#O!/o#O#P!0[#P;'S!/o;'S;=`!1W<%lO!/o]!0_RO;'S!/o;'S;=`!0h;=`O!/o]!0kXOY!/oZw!/owx!,cx#O!/o#O#P!0[#P;'S!/o;'S;=`!1W;=`<%l!/o<%lO!/o]!1ZP;=`<%l!/om!1cU|`Oy!.wyz!/oz;'S!.w;'S;=`!1u;=`<%l!/o<%lO!.wm!1xXOY!/oZw!/owx!,cx#O!/o#O#P!0[#P;'S!/o;'S;=`!1W;=`<%l!.w<%lO!/om!2hP;=`<%l!.w`!2nP;=`<%l$t",
  tokenizers: [qw, Uw, zw, 0, 1, 2, 3, 4],
  topRules: { StyleSheet: [0, 5] },
  specialized: [{ term: 116, get: (t) => _w[t] || -1 }, { term: 23, get: (t) => jw[t] || -1 }],
  tokenPrec: 2180
}), cQ = /* @__PURE__ */ re.define({
  name: "less",
  parser: /* @__PURE__ */ Gw.configure({
    props: [
      /* @__PURE__ */ me.add({
        Declaration: /* @__PURE__ */ ae()
      }),
      /* @__PURE__ */ fe.add({
        Block: Ie
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" }, line: "//" },
    indentOnInput: /^\s*\}$/,
    wordChars: "@-"
  }
}), Cw = /* @__PURE__ */ Ko((t) => t.name == "VariableName" || t.name == "AtKeyword");
function Ew() {
  return new le(cQ, cQ.data.of({ autocomplete: Cw }));
}
const Aw = se({
  LineComment: l.lineComment,
  BlockComment: l.blockComment,
  AnyChar: l.character,
  Literal: l.string,
  "tokens from grammar as empty prop extend specialize AtName": l.keyword,
  "@top @left @right @cut @external": l.modifier,
  "@precedence @tokens @context @dialects @skip @detectDelim @conflict": l.definitionKeyword,
  "@extend @specialize": l.operatorKeyword,
  "CharSet InvertedCharSet": l.regexp,
  CharClass: l.atom,
  RuleName: l.variableName,
  "RuleDeclaration/RuleName InlineRule/RuleName TokensBody/RuleName": l.definition(l.variableName),
  PrecedenceName: l.labelName,
  Name: l.name,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace,
  '"!" ~ "*" + ? |': l.operator
}), Dw = { __proto__: null, "@asciiLetter": 244, "@asciiUpperCase": 244, "@asciiLowerCase": 244, "@digit": 244, "@whitespace": 244, "@eof": 244, "@specialize": 76, "@extend": 78, "@top": 98, "@precedence": 102, "@left": 108, "@right": 110, "@cut": 112, "@tokens": 116, "@conflict": 126, "@local": 134, "@else": 142, "@external": 146, "@context": 172, "@dialects": 176, "@skip": 182, "@detectDelim": 190 }, Nw = { __proto__: null, tokens: 136, from: 148, prop: 156, as: 158, propSource: 162, extend: 166, specialize: 168 }, Iw = ne.deserialize({
  version: 14,
  states: "<zQ]QPOOOOQO'#Ca'#CaO}QPO'#C`OOQO'#Eq'#EqOOQO'#E`'#E`Q]QPOOOxQPO'#D^O!YQPO'#D`O!_QPO'#DgO!dQQO'#DpO!iQQO'#D{O!zQPO'#ETO#PQPO'#EVO#UQPO'#EYOOQO'#E^'#E^O#ZQPO'#CdO#fQPO'#CnO$iQPO'#CoOOQO,58z,58zO#UQPO,58zO!QQPO,58zOOQO-E8^-E8^O}QPO,59xO$pQPO'#DbOOQO,59z,59zO$xQPO'#DiOOQO,5:R,5:RO%ZQPO,5:[O!zQPO,5:bO!zQPO,5:gO!zQPO,5:jO#UQPO,5:lOOQO'#Cg'#CgO%`QQO,5:oO%eQPO'#EXOOQO,5:q,5:qO%mQPO,5:tO&eQPO'#CeO&pQPO,59OO#^QPO,59OOOQO,59O,59OOOQO,59Y,59YO&xQPO,59YO(bQPO'#EyO(oQPO'#EyOOQO'#Ey'#EyOOQO'#Cv'#CvO)nQPO'#EwO#UQPO'#C}O*[QPO'#DQOOQO'#Ex'#ExO$sQPO'#DVO!zQPO'#DYOOQO'#E{'#E{O*cQPO'#DUOOQO'#Ew'#EwO*vQPO'#EfO+ZQPO'#D[O+lQPO'#EvOOQO'#Ev'#EvOOQO,59Z,59ZO+}QPO,59ZO,SQPO'#DROOQO1G.f1G.fO#UQPO1G.fOOQO1G/d1G/dO#UQPO1G/dO!QQPO1G/dOOQO'#DX'#DXO,[QPO'#DcO,pQPO'#EgO,{QPO,59|OOQO,59|,59|O-TQPO'#DoOOQO'#E|'#E|OOQO'#Eh'#EhO-lQPO,5:TOOQO,5:T,5:TO-}QPO'#DjO.SQPO'#DlO.jQPO'#DsOOQO1G/v1G/vO.qQQO1G/|O.vQQO1G0RO/OQQO1G0UO!zQPO1G0WO/TQPO1G0ZO/YQPO'#ElO/eQPO,5:sOOQO,5:s,5:sO/mQPO'#E]OOQO1G0b1G0bO/xQPO,59POOQO,5:{,5:{OOQO1G.j1G.jO0^QPO1G.jOOQO-E8_-E8_O!zQPO'#EcO0fQPO1G.tOOQO1G.t1G.tOxQPO,59_O0nQPO'#CuOOQO,59`,59`OOQO,59i,59iO#UQPO,59iO0uQPO'#EeOOQO,59d,59dOOQO,59f,59fOOQO,59h,59hOOQO'#Ee'#EeO2VQPO,59pOOQO,59l,59lO2jQPO,59lOOQO,59q,59qOOQO,59t,59tOOQO,5;Q,5;QOOQO-E8d-E8dO2oQPO,59vOOQO1G.u1G.uOOQO,59m,59mO,VQPO,59mOOQO7+$Q7+$QOOQO7+%O7+%OO#UQPO7+%OOOQO,59},59}OOQO,5;R,5;ROOQO-E8e-E8eOOQO1G/h1G/hOOQO,5:Z,5:ZOOQO-E8f-E8fOOQO1G/o1G/oO3QQPO'#DkOOQO,5:U,5:UO3]QPO'#DnOOQO,5:W,5:WOOQO'#Ej'#EjO3eQPO,5:_OOQO,5:_,5:_OxQPO'#DtO3lQPO7+%hO3qQPO7+%mO!zQPO7+%mO3vQPO7+%pO3{QQO7+%rOOQO7+%u7+%uOOQO,5;W,5;WOOQO-E8j-E8jOOQO1G0_1G0_OOQO'#Em'#EmO4QQPO,5:wOOQO,5:w,5:wOxQPO'#CmOOQO'#Eb'#EbO4]QPO1G.kOOQO7+$U7+$UP&sQPO'#EaOOQO,5:},5:}OOQO-E8a-E8aOOQO7+$`7+$`OOQO1G.y1G.yOOQO,59a,59aO4qQPO,59aOOQO1G/T1G/TOOQO-E8c-E8cOOQO1G/W1G/WOOQO1G/X1G/XOOQO<<Hj<<HjO4yQPO'#EyO5_QPO'#EiO5mQPO,5:VOOQO,5:V,5:VO5xQPO,5:YOOQO-E8h-E8hOOQO1G/y1G/yO6TQPO,5:`O6lQPO<<ISOOQO<<IX<<IXO6qQQO<<IXOOQO<<I[<<I[O6vQPO<<I^OOQO-E8k-E8kOOQO1G0c1G0cO6{QPO,59XOOQO-E8`-E8`O#nQPO'#EdO7QQPO1G.{OOQO1G.{1G.{OOQO,5;T,5;TOOQO-E8g-E8gOOQO1G/q1G/qO7YQPO1G/tO7_QPO1G/tOOQO1G/z1G/zO7gQPO'#DyOOQOAN>nAN>nO7oQPOAN>sO6lQPOAN>xOOQO1G.s1G.sOOQO,5;O,5;OOOQO-E8b-E8bOOQO7+$g7+$gOOQO7+%`7+%`O7tQPO7+%`O7yQPO'#DzO8XQPO'#EkO8dQPO,5:eOOQO,5:e,5:eOOQOG24_G24_OOQOG24dG24dOOQO<<Hz<<HzOOQO,5:f,5:fOOQO,5;V,5;VOOQO-E8i-E8iOOQO1G0P1G0P",
  stateData: "8s~O#dOSPOSQOS~O!RUO!TVO![WO!eXO!kYO!xZO!z[O!}]O#R^O#fPO~OV_O`aO#i`O~O`gO~O`iO~O!fkO~O!flO!pmO!snO!uoO!voO~O#fpO~O`rO~O`aO~OUxOYuO#fpO~O#fpO#hyO~OV_O]!SOd!SOe!SOf!SOs!ROv!`Ow!`Oz!TO}!UO!P!YO#fPO#n!OO~O_!^O~P#nO_!jO#f!fO~O]!kO_!oO!T!pO!a!qO#fPO~O`!rO~O!l!xO~O_!{O#fpO~O`!|O!R!|a!T!|a![!|a!e!|a!k!|a!x!|a!z!|a!}!|a#R!|a#b!|a#f!|a~O[#OOUXX#gXX~OU#QO#g#PO~O#g#TO#h#VO~O#i#XO]#mX_#mXd#mXe#mXf#mXk#mXm#mXo#mXs#mXv#mXw#mXz#mX}#mX!P#mX#f#mX#n#mXr#mX#g#mX#h#mX~OV_O^#WO`aO~P'QOV#mX~P'QOV_O]!SOd!SOe!SOf!SOs!ROv!`Ow!`Oz!TO}!UO#fPO#n!OO~Ok#^Om#_Oo#`O_#kX!P#kXr#kX#g#kX#h#kX~P(vOr#cO~P#nO_xX!PxXrxX#gxX#hxX~P(vO_#YX!P#YXr#YX#g#YX#h#YX~P(vO!P!YO_!OXr!OX#g!OX#h!OX~O!P!YO_#jXr#jX#g#jX#h#jX~O_#jO~OV_O#i#XO~O!W#pO!X#pO!Y#pO_!VX#f!VX#g!VX~O#g#qO_#ZX#f#ZX~O_#sO#f!fO~OV_O]!cX_!cX!T!cX!a!cX#f!cX!i!cX~O]!kO_#vO!T!pO!a!qO#fPO~O`#wO~O`#yO~O]!kO!T!pO!a!qO!i$OO#fPO~O_#}O~P.XO!l$PO~O!l$QO!q$RO~O!l$SO~O]$UO~O#g$VO_#`X#f#`X~O_$XO#fpO~O_$[O!RUO#fPO~O]$^O^$^O`$]O#fpOUXa#gXa~OU$`O#g#PO~O#g#TO#h$dO~O#h$fO~P#nOk#^Om#_Oo#`OV#XX]#XX_#XXd#XXe#XXf#XXs#XXv#XXw#XXz#XX}#XX!P#XX#f#XX#n#XXr#XX#g#XX#h#XX~O_xa!Pxarxa#gxa#hxa~P(vOr$jO~O!P!YO_!Oar!Oa#g!Oa#h!Oa~O]$nO_$pO#fPO~O]$qO#fPO~O_$sO~P.XO]$uO~O]$vO~O]$xO~O!l$yO~O_${O!RUO#fPO~O]$^O^$^O`$]O#fpOUXi#gXi~O#g%OO#h%QO~O^#WO#i#XO]#mX_#mX#f#mX#g#mX~O#g%RO]#]X_#]X#f#]X~O]$nO_%TO#fPO~O]%UO#fPO#g%VO~OV_O]!ha_!ha!T!ha!a!ha!i!ha#f!ha~O`%XO~O!l%ZO~O]%[O~O_%]O~O#g%OO#h%`O~O_%aO~O]%bO#fPO~O_%fO#fPO~O]%gO~O_%iO~OV_O_!nX#f!nX#g!nX~O#g%kO_#_X#f#_X~O_%mO#fPO~Oe#dfz#f#q~",
  goto: ".d#qPPPP#r$QPP$}%nP%tPPPPP&m&q&}PPP'p(P(`(kP(kP(kP(k(kPP(k(kPP(u(|P)W(|P)_P)eP)mP)q)tPPP)mP)x){*R){P*U){)mPP*X*[P)mPP*`*f)mPP)mP)mPP)mP)mP*j)mP)m*m)mP*p*v*|+S+Y+`+g+t+z,Q,W,^,d,jPPP,pPPPP,t-Q-Z-gP.O.[SROTW!li!n!r#|T$Y!|$Z`QOTi!n!r!|#|$ZQfU`{a!P!R!W!Y#X#b%OQ$e#WY$m#w#y$o$q%VQ$t$OQ$|$]T%c%X%eQdQ`!Qa!P!R!W!Y#X#b%OQ!efQ#[{Q#l!`Q#t!kQ%W$tR%j%cQv_R#RwQqZSu_wQz`Q!tlQ!umQ!vnS!yr!zQ#f!UQ$T!wS$^#O$_Q$b#TR$w$RT$^#O$_QcQQ!bdQ!dfR#o!eQbQQt]S!acdQ!cfQ!woS#Z{!QQ#m!bS#n!d!eQ$h#[R$l#ok|a!P!R!W!Y#X#b#w#y$o$q%O%Vk}a!P!R!W!Y#X#b#w#y$o$q%O%VU#Y{|$mQ#k!`R$k#la!Sa!P!R!W!Y#X#b%OZ!Xa!R!Y#X%Oa!Va!P!R!W!Y#X#b%OS!gg!iR#e!TX!]a!R#X%OSROTT$Y!|$ZTROTRhVT!hg!iRjWX!li!n!r#|R#x!pR#z!qR!skT#{!r#|Q%Y$uR%h%[T%d%X%eRs[R!}tQTOReTQw_R#SwQ$_#OR$}$_Q#UzR$c#UQ%P$gR%_%PS#b!P!WR$i#bW!Za!R#X%OS#h!Z#iR#i![Q!igR#r!iQ!niR#u!nQ$o#wR%S$oQ#|!rR$r#|Q%e%XR%l%eQ!zrR$W!zQ$Z!|R$z$ZTSOTQ!_aQ#d!RQ$g#XR%^%OW![a!R#X%OR#g!YY!Pa!R!Y#X%OV#]!P!W#b`!Sa!P!R!W!Y#X#b%OS$n#w$oQ$q#yQ%U$qR%b%VY!Wa!R!Y#X%OV#a!P!W#bS!mi!nT#{!r#|",
  nodeNames: "âš  LineComment BlockComment Grammar RuleDeclaration RuleName ] [ Props Prop AtName Name = Literal . } { PropEsc ParamList Body CharSet AnyChar InvertedCharSet ScopedName Call ArgList CharClass ? Optional * Repeat + Repeat1 InlineRule ) ( ParenExpression Specialization @specialize @extend Sequence PrecedenceMarker ! PrecedenceName AmbiguityMarker ~ Choice | RuleDeclaration @top PrecedenceDeclaration @precedence PrecedenceBody Precedence @left @right @cut TokensDeclaration @tokens TokensBody TokenPrecedenceDeclaration PrecedenceBody TokenConflictDeclaration @conflict ConflictBody LiteralTokenDeclaration LocalTokensDeclaration @local tokens TokensBody ElseToken @else ExternalTokensDeclaration @external from TokensBody Token ExternalPropDeclaration prop as ExternalPropSourceDeclaration propSource ExternalSpecializeDeclaration extend specialize ContextDeclaration @context DialectsDeclaration @dialects DialectBody TopSkipDeclaration @skip SkipScope SkipBody DetectDelimDeclaration @detectDelim",
  maxTerm: 125,
  nodeProps: [
    ["group", 4, "Declaration Declaration", -16, 5, 13, 20, 21, 22, 23, 24, 26, 28, 30, 32, 33, 36, 37, 40, 46, "Expression", -16, 48, 50, 57, 60, 62, 65, 66, 72, 77, 80, 82, 85, 87, 90, 92, 94, "Declaration"],
    ["openedBy", 6, "[", 15, "{", 34, "("],
    ["closedBy", 7, "]", 16, "}", 35, ")"]
  ],
  propSources: [Aw],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 14,
  tokenData: "3w~R!OX^$Rpq$Rqr$vrs&ftu(^wx)zxy+myz+rz{+w{|+||},R}!O,W!O!P,}!P!Q-S!Q![,W!^!_.{!_!`/Q!`!a/V!a!b/[!b!c/a!c!},W!}#O0q#P#Q0v#R#S0{#T#o,W#o#p1n#p#q1s#q#r1x#r#s1}#y#z$R$f$g$R$g#BY,W#BY#BZ2S#BZ$IS,W$IS$I_2S$I_$I|,W$I|$JO2S$JO$JT,W$JT$JU2S$JU$KV,W$KV$KW2S$KW&FU,W&FU&FV2S&FV;'S,W;'S;=`,w<%lO,W~$WY#d~X^$Rpq$R#y#z$R$f$g$R#BY#BZ$R$IS$I_$R$I|$JO$R$JT$JU$R$KV$KW$R&FU&FV$R~${Pz~!}#O%O~%RUO#O%O#O#P%e#P#Q&Z#Q;'S%O;'S;=`&`<%lO%O~%hRO;'S%O;'S;=`%q;=`O%O~%tVO#O%O#O#P%e#P#Q&Z#Q;'S%O;'S;=`&`;=`<%l%O<%lO%O~&`Of~~&cP;=`<%l%O~&kW]~OY&fZr&frs'Ts#O&f#O#P'Y#P;'S&f;'S;=`(W<%lO&f~'YO]~~']RO;'S&f;'S;=`'f;=`O&f~'kX]~OY&fZr&frs'Ts#O&f#O#P'Y#P;'S&f;'S;=`(W;=`<%l&f<%lO&f~(ZP;=`<%l&f~(aP!}#O(d~(gUO#O(d#O#P(y#P#Q)o#Q;'S(d;'S;=`)t<%lO(d~(|RO;'S(d;'S;=`)V;=`O(d~)YVO#O(d#O#P(y#P#Q)o#Q;'S(d;'S;=`)t;=`<%l(d<%lO(d~)tOd~~)wP;=`<%l(d~*PW]~OY)zZw)zwx'Tx#O)z#O#P*i#P;'S)z;'S;=`+g<%lO)z~*lRO;'S)z;'S;=`*u;=`O)z~*zX]~OY)zZw)zwx'Tx#O)z#O#P*i#P;'S)z;'S;=`+g;=`<%l)z<%lO)z~+jP;=`<%l)z~+rOs~~+wOr~~+|Om~~,ROo~~,WO#g~R,_W#fP#qQ}!O,W!Q![,W!c!},W#R#S,W#T#o,W$g;'S,W;'S;=`,w<%lO,WR,zP;=`<%l,W~-SO^~~-VQz{-]!P!Q.d~-`TOz-]z{-o{;'S-];'S;=`.^<%lO-]~-rVOz-]z{-o{!P-]!P!Q.X!Q;'S-];'S;=`.^<%lO-]~.^OQ~~.aP;=`<%l-]~.iSP~OY.dZ;'S.d;'S;=`.u<%lO.d~.xP;=`<%l.d~/QO#i~~/VO[~~/[O#h~~/aOk~~/dW}!O/|!Q![/|!c!}/|#R#S/|#T#o/|$g;'S/|;'S;=`0k<%lO/|~0RWY~}!O/|!Q![/|!c!}/|#R#S/|#T#o/|$g;'S/|;'S;=`0k<%lO/|~0nP;=`<%l/|~0vOV~~0{OU~R1UWeP#fP#qQ}!O,W!Q![,W!c!},W#R#S,W#T#o,W$g;'S,W;'S;=`,w<%lO,W~1sO`~~1xO!P~~1}O_~~2SO}~~2]h#d~#fP#qQX^$Rpq$R}!O,W!Q![,W!c!},W#R#S,W#T#o,W#y#z$R$f$g$R$g#BY,W#BY#BZ2S#BZ$IS,W$IS$I_2S$I_$I|,W$I|$JO2S$JO$JT,W$JT$JU2S$JU$KV,W$KV$KW2S$KW&FU,W&FU&FV2S&FV;'S,W;'S;=`,w<%lO,W",
  tokenizers: [0, 1],
  topRules: { Grammar: [0, 3] },
  specialized: [{ term: 10, get: (t) => Dw[t] || -1 }, { term: 125, get: (t) => Nw[t] || -1 }],
  tokenPrec: 1086
}), Mw = /* @__PURE__ */ re.define({
  name: "lezer",
  parser: /* @__PURE__ */ Iw.configure({
    props: [
      /* @__PURE__ */ fe.add({
        "Body TokensBody SkipBody PrecedenceBody": Ie
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" }, line: "//" },
    indentOnInput: /^\s*\}$/
  }
});
function Lw() {
  return new le(Mw);
}
const Bw = 1, Fw = 2, Hw = 3, Kw = 180, Jw = 4, ek = 181, Ok = 5, tk = 182;
function ik(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122;
}
const rk = /* @__PURE__ */ new q((t) => {
  let e = t.pos;
  for (; ; ) {
    let { next: O } = t;
    if (O < 0)
      break;
    if (O == 123) {
      let i = t.peek(1);
      if (i == 123) {
        if (t.pos > e)
          break;
        t.acceptToken(Bw, 2);
        return;
      } else if (i == 37) {
        if (t.pos > e)
          break;
        let r = 2, n = 2;
        for (; ; ) {
          let s = t.peek(r);
          if (s == 32 || s == 10)
            ++r;
          else if (s == 35)
            for (++r; ; ) {
              let a = t.peek(r);
              if (a < 0 || a == 10)
                break;
              r++;
            }
          else if (s == 45 && n == 2)
            n = ++r;
          else {
            let a = s == 101 && t.peek(r + 1) == 110 && t.peek(r + 2) == 100;
            t.acceptToken(a ? Hw : Fw, n);
            return;
          }
        }
      }
    }
    if (t.advance(), O == 10)
      break;
  }
  t.pos > e && t.acceptToken(Kw);
});
function ip(t, e, O) {
  return new q((i) => {
    let r = i.pos;
    for (; ; ) {
      let { next: n } = i;
      if (n == 123 && i.peek(1) == 37) {
        let s = 2;
        for (; ; s++) {
          let o = i.peek(s);
          if (o != 32 && o != 10)
            break;
        }
        let a = "";
        for (; ; s++) {
          let o = i.peek(s);
          if (!ik(o))
            break;
          a += String.fromCharCode(o);
        }
        if (a == t) {
          if (i.pos > r)
            break;
          i.acceptToken(O, 2);
          break;
        }
      } else if (n < 0)
        break;
      if (i.advance(), n == 10)
        break;
    }
    i.pos > r && i.acceptToken(e);
  });
}
const nk = /* @__PURE__ */ ip("endcomment", tk, Ok), sk = /* @__PURE__ */ ip("endraw", ek, Jw), ak = { __proto__: null, contains: 32, or: 36, and: 36, true: 50, false: 50, empty: 52, forloop: 54, tablerowloop: 56, continue: 58, in: 128, with: 194, for: 196, as: 198, if: 234, endif: 238, unless: 244, endunless: 248, elsif: 252, else: 256, case: 262, endcase: 266, when: 270, endfor: 278, tablerow: 284, endtablerow: 288, break: 292, cycle: 298, echo: 302, render: 306, include: 312, assign: 316, capture: 322, endcapture: 326, increment: 330, decrement: 334 }, ok = { __proto__: null, if: 82, endif: 86, elsif: 90, else: 94, unless: 100, endunless: 104, case: 110, endcase: 114, when: 118, for: 126, endfor: 136, tablerow: 142, endtablerow: 146, break: 150, continue: 154, cycle: 158, comment: 164, endcomment: 170, raw: 176, endraw: 182, echo: 186, render: 190, include: 202, assign: 206, capture: 212, endcapture: 216, increment: 220, decrement: 224, liquid: 228 }, lk = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "GYQYOPOOOOOP'#F{'#F{OeOXO'#CdOsQWO'#CfO!bQ`O'#DQO#{OPO'#DTO$ZOPO'#D^O$iOPO'#DcO$wOPO'#DkO%VOPO'#DsO%eOSO'#EOO%jOQO'#EUO%oOPO'#EhOOOP'#G`'#G`OOOP'#G]'#G]OOOP'#Fz'#FzQYOPOOOOOP-E9y-E9yOOQO'#Cg'#CgO&`QpO,59QO&gQpO'#G^OsQWO'#CsOOQO'#G^'#G^OOOP,59l,59lO)PQWO,59lOsQWO,59pOsQWO,59tO)WQWO,59vOsQWO,59yOsQWO,5:OOsQWO,5:SO!]QWO,5:WO!]QWO,5:`O)]QWO,5:dO)bQWO,5:fO)gQWO,5:hO)lQWO,5:kO)qQWO,5:qOsQWO,5:vOsQWO,5:xOsQWO,5;OOsQWO,5;QOsQWO,5;TOsQWO,5;XOsQWO,5;ZO+QQWO,5;]O+XOPO'#CdOOOP,59o,59oO#{OPO,59oO+gQ`O'#DWOOOP,59x,59xO$ZOPO,59xO+lQ`O'#DaOOOP,59},59}O$iOPO,59}O+qQ`O'#DfOOOP,5:V,5:VO$wOPO,5:VO+vQ`O'#DqOOOP,5:_,5:_O%VOPO,5:_O+{Q`O'#DvOOOS'#GQ'#GQO,QOSO'#ERO,YOSO,5:jOOOQ'#GR'#GRO,_OQO'#EXO,gOQO,5:pOOOP,5;S,5;SO%oOPO,5;SO,lQ`O'#EkOOOP-E9x-E9xO,qQ!bO,59SOsQWO,59VOsQWO,59VO,vQWO'#C|OOQO'#F|'#F|O,{QWO1G.lOOOP1G.l1G.lOsQWO,59VOsQWO,59ZO-TQpO,59_O-fQpO1G/WOOOP1G/W1G/WO-wQpO1G/[O.YQpO1G/`OOOP1G/b1G/bO.kQpO1G/eO.|QpO1G/jO/pQpO1G/nO/wQWO1G/rO/|QWO1G/zOOOP1G0O1G0OOOOP1G0Q1G0QO0RQWO1G0SOOOS1G0V1G0VOOOQ1G0]1G0]O0^QpO1G0bO0eQpO1G0dO1PQpO1G0jO1bQpO1G0lO1sQpO1G0oO2UQpO1G0sO2gQpO1G0uO2xQWO'#EsO3PQWO'#ExO3WQWO'#FRO3_QWO'#FYO3fQWO'#F^O3mQWO'#FqOOQO'#Ga'#GaOOQO'#GT'#GTO3tQWO1G0wOsQWO'#EtOsQWO'#EyOsQWO'#E}OOQO'#FP'#FPOsQWO'#FSOsQWO'#FWO!]QWO'#FZO!]QWO'#F_OOQO'#Fc'#FcOOQO'#Fe'#FeO3{QWO'#FfOsQWO'#FhOsQWO'#FjOsQWO'#FmOsQWO'#FoOsQWO'#FrOsQWO'#FvOsQWO'#FxOOOP1G0w1G0wOOOP1G/Z1G/ZO4QQWO,59rOOOP1G/d1G/dO4VQWO,59{OOOP1G/i1G/iO4[QWO,5:QOOOP1G/q1G/qO4aQWO,5:]OOOP1G/y1G/yO4fQWO,5:bOOOS-E:O-E:OOOOP1G0U1G0UO4kQ`O'#ESOOOQ-E:P-E:POOOP1G0[1G0[O4pQ`O'#EYOOOP1G0n1G0nO4uQWO,5;VOOQO1G.n1G.nOOQO1G.q1G.qO7ZQpO1G.qOOQO'#DO'#DOO7eQWO,59hOOQO-E9z-E9zOOOP7+$W7+$WO9_QpO1G.qO9iQpO1G.uOsQWO1G.yOOOP7+$r7+$rOOOP7+$v7+$vOOOP7+$z7+$zOOOP7+%P7+%POOOP7+%U7+%UOsQWO'#F}O<OQWO7+%YOOOP7+%Y7+%YOsQWO7+%^OsQWO7+%fO<WQWO'#GPO<]QWO7+%nOOOP7+%n7+%nO<eQWO7+%nO<jQWO7+%|OOOP7+%|7+%|O!]QWO'#E`OOQO'#GS'#GSO<rQWO7+&OOsQWO'#E`OOOP7+&O7+&OOOOP7+&U7+&UOOOP7+&W7+&WOOOP7+&Z7+&ZOOOP7+&_7+&_OOOP7+&a7+&aOOQO,5;_,5;_O2xQWO,5;_OOQO'#Ev'#EvOOQO,5;d,5;dO3PQWO,5;dOOQO'#E{'#E{OOQO,5;m,5;mO3WQWO,5;mOOQO'#FU'#FUOOQO,5;t,5;tO3_QWO,5;tOOQO'#F['#F[OOQO,5;x,5;xO3fQWO,5;xOOQO'#Fa'#FaOOQO,5<],5<]O3mQWO,5<]OOQO'#Ft'#FtOOQO-E:R-E:ROOOP7+&c7+&cO=QQpO,5;`O>kQpO,5;eO@UQpO,5;iOBRQpO,5;nOClQpO,5;rOE_QWO,5;uOEdQWO,5;yOEiQWO,5<QOG`QpO,5<SOIRQpO,5<UOKRQpO,5<XOMOQpO,5<ZON{QpO,5<^O!!fQpO,5<bO!$cQpO,5<dOOOP1G/^1G/^OOOP1G/g1G/gOOOP1G/l1G/lOOOP1G/w1G/wOOOP1G/|1G/|O!&`QWO,5:nO!&eQWO,5:tOOOP1G0q1G0qOsQWO1G/SO!&jQpO7+$eO!&{QpO,5<iOOQO-E9{-E9{OOOP<<Ht<<HtO!)^QpO<<HxO!)eQpO<<IQOOQO,5<k,5<kOOQO-E9}-E9}OOOP<<IY<<IYO!)lQWO<<IYOOOP<<Ih<<IhO!)tQWO,5:zOOQO-E:Q-E:QOOOP<<Ij<<IjO!)yQpO,5:zOOQO1G0y1G0yOOQO1G1O1G1OOOQO1G1X1G1XOOQO1G1`1G1`OOQO1G1d1G1dOOQO1G1w1G1wO!*hQWO1G1^OsQWO1G1aOsQWO1G1eO!,[QWO1G1lO!.OQWO1G1lO!.TQWO1G1nO!]QWO'#FlOOQO'#GU'#GUO!/wQWO1G1pOOOP1G0Y1G0YOOOP1G0`1G0`O!1kQpO7+$nOOQO<<HP<<HPOOQO'#Dp'#DpO!3nQWO'#DoOOQO'#GO'#GOO!5XQWOAN>dOOOPAN>dAN>dO!5aQWOAN>lOOOPAN>lAN>lO!5iQWOAN>tOOOPAN>tAN>tOsQWO1G0fO!]QWO1G0fO!5qQpO7+&{O!7QQpO7+'PO!8aQWO7+'WO!:TQWO,5<WOOQO-E:S-E:SOsQWO,5:ZOOQO-E9|-E9|OOOPG24OG24OOOOPG24WG24WOOOPG24`G24`O!:YQpO7+&QOOQO7+&Q7+&QO!:tQWO<<JgO!<UQWO<<JkO!=fQWO<<JrOsQWO1G1rO!?YQpO1G/uO!@|QpO7+'^",
  stateData: "!B|~O%OOSUOS~OPROQSO$zPO~O$zPOPWXQWX$yWX~OfeOifOjfOkfOlfOmfOnfOofO%RbO~OuhOvgOyiO}jO!PkO!SlO!XmO!]nO!aoO!ipO!mqO!orO!qsO!ttO!zuO#PvO#RwO#XxO#ZyO#^zO#b{O#d|O#f}O~OPROQSOR!RO$zPO~OPROQSOR!UO$zPO~OPROQSOR!XO$zPO~OPROQSOR![O$zPO~OPROQSOR!_O$zPO~O$|!`O~O${!cO~OPROQSOR!hO$zPO~O]!jO`!qOa!kOb!lOq!mO~OX!pO~P%}Od!rOX%QX]%QX`%QXa%QXb%QXq%QXh%QXv%QX!^%QX#T%QX#U%QXm%QX#i%QX#k%QX#n%QX#r%QX#t%QX#w%QX#{%QX$S%QX$W%QX$Z%QX$]%QX$_%QX$b%QX$d%QX$g%QX$k%QX$m%QX#p%QX#y%QX$i%QXe%QX%R%QX#V%QX$P%QX$U%QX~Ov!uO~PsOv!xO~Ov#OO~Ov#PO~On#QO~Ov#RO~Ov#SO~Om#nO#U#kO#i#eO#n#fO#r#gO#t#hO#w#iO#{#jO$S#lO$W#mO$Z#oO$]#pO$_#qO$b#rO$d#sO$g#tO$k#uO$m#vO~Ov#wO~P)vO$zPOPWXQWXRWX~O{#yO~O!U#{O~O!Z#}O~O!f$PO~O!k$RO~O$|!`OT!uX~OT$UO~O${!cOS!{X~OS$XO~O#`$ZO~O^$[O~O%R$_O~OX$bOq!mO~O]!jO`!qOa!kOb!lOh$eO~O]!jO`!qOa!kOb!lOv$fO~O]!jO`!qOa!kOb!lOv$gO~O]!jO`!qOa!kOb!lOv$hO~O]!jO`!qOa!kOb!lOv$iO~O]!jO`!qOa!kOb!lOv$jO~O]!jO`!qOa!kOb!lO!^$kO~Ov$mO~P/_O!b$nO~O!b$oO~Os$sOv$rO!^$pO~Ov$uO~P%}O]!jO`!qOa!kOb!lOv$zO!^$vO#T$yO#U$yO~O]!jO`!qOa!kOb!lOv${O~O]!jO`!qOa!kOb!lOv$|O~O]!jO`!qOa!kOb!lOv$}O~O]!jO`!qOa!kOb!lOv%OO~O]!jO`!qOa!kOb!lOv%PO~O#k%SO~P)vO#p%VO~P)vO#y%YO~P)vO$P%]O~P)vO$U%`O~P)vO$i%cO~P)vOv%eO~P)vOn%mO~Ov%uO~Ov%vO~Ov%wO~Ov%xO~Ov%yO~O!w%zO~O!}%{O~Ov%|O~Oa!kOX_i]_iq_ih_iv_i!^_i#T_i#U_im_i#i_i#k_i#n_i#r_i#t_i#w_i#{_i$S_i$W_i$Z_i$]_i$__i$b_i$d_i$g_i$k_i$m_i#p_i#y_i$i_ie_i%R_i#V_i$P_i$U_i~O`!qOb!lO~P4zOs%}OXpaqpavpampa#Upa#ipa#npa#rpa#tpa#wpa#{pa$Spa$Wpa$Zpa$]pa$_pa$bpa$dpa$gpa$kpa$mpa#kpa#ppa#ypa$Ppa$Upa$ipa~O`_ib_i~P4zO`!qOa!kOb!lOXci]ciqcihcivci!^ci#Tci#Ucimci#ici#kci#nci#rci#tci#wci#{ci$Sci$Wci$Zci$]ci$_ci$bci$dci$gci$kci$mci#pci#yci$icieci%Rci#Vci$Pci$Uci~Ov&RO!^$kO~On&UO~Ov&WO!^$pO~On&XO~Oq!mOv&YO~Ov&]O!^$vO#T$yO#U$yO~O]!jO`!qOa!kOb!lOm#ha#U#ha#i#ha#k#ha#n#ha#r#ha#t#ha#w#ha#{#ha$S#ha$W#ha$Z#ha$]#ha$_#ha$b#ha$d#ha$g#ha$k#ha$m#ha~O]!jO`!qOa!kOb!lOm#ma#U#ma#i#ma#n#ma#p#ma#r#ma#t#ma#w#ma#{#ma$S#ma$W#ma$Z#ma$]#ma$_#ma$b#ma$d#ma$g#ma$k#ma$m#ma~O]!jO`!qOa!kOb!lOm#qav#qa#U#qa#i#qa#n#qa#r#qa#t#qa#w#qa#{#qa$S#qa$W#qa$Z#qa$]#qa$_#qa$b#qa$d#qa$g#qa$k#qa$m#qa#k#qa#p#qa#y#qa$P#qa$U#qa$i#qa~O]!jO`!qOa!kOb!lOm#va#U#va#i#va#n#va#r#va#t#va#w#va#y#va#{#va$S#va$W#va$Z#va$]#va$_#va$b#va$d#va$g#va$k#va$m#va~Om#zav#za#U#za#i#za#n#za#r#za#t#za#w#za#{#za$S#za$W#za$Z#za$]#za$_#za$b#za$d#za$g#za$k#za$m#za#k#za#p#za#y#za$P#za$U#za$i#za~P/_O!b&fO~O!b&gO~Os&iO!^$pOm$Yav$Ya#U$Ya#i$Ya#n$Ya#r$Ya#t$Ya#w$Ya#{$Ya$S$Ya$W$Ya$Z$Ya$]$Ya$_$Ya$b$Ya$d$Ya$g$Ya$k$Ya$m$Ya#k$Ya#p$Ya#y$Ya$P$Ya$U$Ya$i$Ya~Om$[av$[a#U$[a#i$[a#n$[a#r$[a#t$[a#w$[a#{$[a$S$[a$W$[a$Z$[a$]$[a$_$[a$b$[a$d$[a$g$[a$k$[a$m$[a#k$[a#p$[a#y$[a$P$[a$U$[a$i$[a~P%}O]!jO`!qOa!kOb!lO!^&kOm$^av$^a#U$^a#i$^a#n$^a#r$^a#t$^a#w$^a#{$^a$S$^a$W$^a$Z$^a$]$^a$_$^a$b$^a$d$^a$g$^a$k$^a$m$^a#k$^a#p$^a#y$^a$P$^a$U$^a$i$^a~O]!jO`!qOa!kOb!lOm$aav$aa#U$aa#i$aa#n$aa#r$aa#t$aa#w$aa#{$aa$S$aa$W$aa$Z$aa$]$aa$_$aa$b$aa$d$aa$g$aa$k$aa$m$aa#k$aa#p$aa#y$aa$P$aa$U$aa$i$aa~O]!jO`!qOa!kOb!lOm$cav$ca#U$ca#i$ca#n$ca#r$ca#t$ca#w$ca#{$ca$S$ca$W$ca$Z$ca$]$ca$_$ca$b$ca$d$ca$g$ca$k$ca$m$ca#k$ca#p$ca#y$ca$P$ca$U$ca$i$ca~O]!jO`!qOa!kOb!lOm$fa#U$fa#i$fa#n$fa#r$fa#t$fa#w$fa#{$fa$S$fa$W$fa$Z$fa$]$fa$_$fa$b$fa$d$fa$g$fa$i$fa$k$fa$m$fa~O]!jO`!qOa!kOb!lOm$jav$ja#U$ja#i$ja#n$ja#r$ja#t$ja#w$ja#{$ja$S$ja$W$ja$Z$ja$]$ja$_$ja$b$ja$d$ja$g$ja$k$ja$m$ja#k$ja#p$ja#y$ja$P$ja$U$ja$i$ja~O]!jO`!qOa!kOb!lOm$lav$la#U$la#i$la#n$la#r$la#t$la#w$la#{$la$S$la$W$la$Z$la$]$la$_$la$b$la$d$la$g$la$k$la$m$la#k$la#p$la#y$la$P$la$U$la$i$la~Ov&nO~Ov&oO~O]!jO`!qOa!kOb!lOe&qO~O]!jO`!qOa!kOb!lOv$qa!^$qam$qa#U$qa#i$qa#n$qa#r$qa#t$qa#w$qa#{$qa$S$qa$W$qa$Z$qa$]$qa$_$qa$b$qa$d$qa$g$qa$k$qa$m$qa#k$qa#p$qa#y$qa$P$qa$U$qa$i$qa~O]!jO`!qOa!kOb!lO%R&rO~Ov&vO~P!({Ov&xO~P!({Ov&zO!^$pO~Os&{O~O]!jO`!qOa!kOb!lO#V&|Ov#Sa!^#Sa#T#Sa#U#Sa~O!^$kOm#ziv#zi#U#zi#i#zi#n#zi#r#zi#t#zi#w#zi#{#zi$S#zi$W#zi$Z#zi$]#zi$_#zi$b#zi$d#zi$g#zi$k#zi$m#zi#k#zi#p#zi#y#zi$P#zi$U#zi$i#zi~O!^$pOm$Yiv$Yi#U$Yi#i$Yi#n$Yi#r$Yi#t$Yi#w$Yi#{$Yi$S$Yi$W$Yi$Z$Yi$]$Yi$_$Yi$b$Yi$d$Yi$g$Yi$k$Yi$m$Yi#k$Yi#p$Yi#y$Yi$P$Yi$U$Yi$i$Yi~On'PO~Oq!mOm$[iv$[i#U$[i#i$[i#n$[i#r$[i#t$[i#w$[i#{$[i$S$[i$W$[i$Z$[i$]$[i$_$[i$b$[i$d$[i$g$[i$k$[i$m$[i#k$[i#p$[i#y$[i$P$[i$U$[i$i$[i~O!^&kOm$^iv$^i#U$^i#i$^i#n$^i#r$^i#t$^i#w$^i#{$^i$S$^i$W$^i$Z$^i$]$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i#k$^i#p$^i#y$^i$P$^i$U$^i$i$^i~O]!jO`!qOa!kOb!lOXpqqpqvpqmpq#Upq#ipq#npq#rpq#tpq#wpq#{pq$Spq$Wpq$Zpq$]pq$_pq$bpq$dpq$gpq$kpq$mpq#kpq#ppq#ypq$Ppq$Upq$ipq~Os'SOv!cX%R!cXm!cX#U!cX#i!cX#n!cX#r!cX#t!cX#w!cX#{!cX$P!cX$S!cX$W!cX$Z!cX$]!cX$_!cX$b!cX$d!cX$g!cX$k!cX$m!cX$U!cX~Ov'UO%R&rO~Ov'VO%R&rO~Ov'WO!^$pO~Om#}q#U#}q#i#}q#n#}q#r#}q#t#}q#w#}q#{#}q$P#}q$S#}q$W#}q$Z#}q$]#}q$_#}q$b#}q$d#}q$g#}q$k#}q$m#}q~P!({Om$Rq#U$Rq#i$Rq#n$Rq#r$Rq#t$Rq#w$Rq#{$Rq$S$Rq$U$Rq$W$Rq$Z$Rq$]$Rq$_$Rq$b$Rq$d$Rq$g$Rq$k$Rq$m$Rq~P!({O!^$pOm$Yqv$Yq#U$Yq#i$Yq#n$Yq#r$Yq#t$Yq#w$Yq#{$Yq$S$Yq$W$Yq$Z$Yq$]$Yq$_$Yq$b$Yq$d$Yq$g$Yq$k$Yq$m$Yq#k$Yq#p$Yq#y$Yq$P$Yq$U$Yq$i$Yq~Os'^O~O]!jO`!qOa!kOb!lOv#Sq!^#Sq#T#Sq#U#Sq~O%R&rOm#}y#U#}y#i#}y#n#}y#r#}y#t#}y#w#}y#{#}y$P#}y$S#}y$W#}y$Z#}y$]#}y$_#}y$b#}y$d#}y$g#}y$k#}y$m#}y~O%R&rOm$Ry#U$Ry#i$Ry#n$Ry#r$Ry#t$Ry#w$Ry#{$Ry$S$Ry$U$Ry$W$Ry$Z$Ry$]$Ry$_$Ry$b$Ry$d$Ry$g$Ry$k$Ry$m$Ry~O!^$pOm$Yyv$Yy#U$Yy#i$Yy#n$Yy#r$Yy#t$Yy#w$Yy#{$Yy$S$Yy$W$Yy$Z$Yy$]$Yy$_$Yy$b$Yy$d$Yy$g$Yy$k$Yy$m$Yy#k$Yy#p$Yy#y$Yy$P$Yy$U$Yy$i$Yy~O]!jO`!qOa!kOb!lOv!ci%R!cim!ci#U!ci#i!ci#n!ci#r!ci#t!ci#w!ci#{!ci$P!ci$S!ci$W!ci$Z!ci$]!ci$_!ci$b!ci$d!ci$g!ci$k!ci$m!ci$U!ci~O]!jO`!qOa!kOb!lOm$`qv$`q!^$`q#U$`q#i$`q#n$`q#r$`q#t$`q#w$`q#{$`q$S$`q$W$`q$Z$`q$]$`q$_$`q$b$`q$d$`q$g$`q$k$`q$m$`q#k$`q#p$`q#y$`q$P$`q$U$`q$i$`q~O",
  goto: "7V%UPPPPPPPP%VP%V%g&zPP&zPPP&zPPP&zPPPPPPPP'xP(QP(TPP(T(eP(uP(TP(TP(T({P)]P(T)cP)sP(TPP(T)yPP*Z*e*oP(T*uP+VP(TP(TP(TP(T+]P+m+pP(T+sP,T,WP(TP(TP,ZPPP(TP(TP(T,_P,oP(TP(TP(TP,u-VP-gP,u-mP-}P,uP,uP,u.TP.eP,uP,u.k.{P,u/RP/cP,uP,u,uP,uP,uP/i,uP,uP,u/mP/}P,uP,uP0T0s1Z1i1s2V2i2o2u2{3kPPPPPP3q4RP%V6um^OTUVWX[`!Q!T!W!Z!^!g!vdRehijlmnvwxyz{|!k!l!q!r#e#f#g#i#j#p#q#r#s#t#u#v$e$k$n$o$y%}&f&g&{'S'^Q!|oQ!}pQ%k#kQ%l#lQ&Z$vQ'Q&kR'Y&|!wfRehijlmnvwxyz{|!k!l!q!r#e#f#g#i#j#p#q#r#s#t#u#v$e$k$n$o$y%}&f&g&{'S'^]!nc!o#T$t%n&jR$`!mm]OTUVWX[`!Q!T!W!Z!^!gmTOTUVWX[`!Q!T!W!Z!^!gQ!PTR#x!QmUOTUVWX[`!Q!T!W!Z!^!gQ!SUR#z!TmVOTUVWX[`!Q!T!W!Z!^!gQ!VVR#|!WmWOTUVWX[`!Q!T!W!Z!^!ga&t&S&T&u&w&}'O'Z'[a&s&S&T&u&w&}'O'Z'[Q!YWR$O!ZmXOTUVWX[`!Q!T!W!Z!^!gQ!]XR$Q!^mYOTUVWX[`!Q!T!W!Z!^!gR!bYR$T!bmZOTUVWX[`!Q!T!W!Z!^!gR!eZR$W!eT$w#U$xm[OTUVWX[`!Q!T!W!Z!^!gQ!f[R$Y!gm#b}#[#]#^#_#`#a#d%R%U%X%[%_%bm#[}#[#]#^#_#`#a#d%R%U%X%[%_%bQ%Q#[R&_%Rm#]}#[#]#^#_#`#a#d%R%U%X%[%_%bQ%T#]R&`%Um#^}#[#]#^#_#`#a#d%R%U%X%[%_%bQ%W#^R&a%Xm#_}#[#]#^#_#`#a#d%R%U%X%[%_%bQ%Z#_R&b%[m#`}#[#]#^#_#`#a#d%R%U%X%[%_%bQ%^#`R&c%_T&l%o&mm#a}#[#]#^#_#`#a#d%R%U%X%[%_%bQ%a#aR&d%bQ`OQ!QTQ!TUQ!WVQ!ZWQ!^XQ!g[_!i`!Q!T!W!Z!^!gSQO`SaQ!Oi!OTUVWX[!Q!T!W!Z!^!gQ!ocU$a!o$t&jQ$t#TR&j%nQ$l!{S&Q$l&eR&e%jQ&u&SQ&w&TW'T&u&w'Z'[Q'Z&}R'['OQ$q#QW&V$q&h&y']Q&h%mQ&y&XR']'PQ!aYR$S!aQ!dZR$V!dQ$x#UR&[$xQ#d}Q%R#[Q%U#]Q%X#^Q%[#_Q%_#`Q%b#a_%d#d%R%U%X%[%_%bQ&m%oR'R&mm_OTUVWX[`!Q!T!W!Z!^!gQcRQ!seQ!thQ!viQ!wjQ!ylQ!zmQ!{nQ#TvQ#UwQ#VxQ#WyQ#XzQ#Y{Q#Z|Q$]!kQ$^!lQ$c!qQ$d!rQ%f#eQ%g#fQ%h#gQ%i#iQ%j#jQ%n#pQ%o#qQ%p#rQ%q#sQ%r#tQ%s#uQ%t#vQ&O$eQ&P$kQ&S$nQ&T$oQ&^$yQ&p%}Q&}&fQ'O&gQ'X&{Q'_'SR'`'^m#c}#[#]#^#_#`#a#d%R%U%X%[%_%b",
  nodeNames: "âš  {{ {% {% {% {% InlineComment Template Text }} Interpolation VariableName MemberExpression . PropertyName BinaryExpression contains CompareOp LogicOp AssignmentExpression AssignOp ) ( RangeExpression .. BooleanLiteral empty forloop tablerowloop continue StringLiteral NumberLiteral Filter | FilterName : Tag TagName %} IfDirective Tag if EndTag endif Tag elsif Tag else UnlessDirective Tag unless EndTag endunless CaseDirective Tag case EndTag endcase Tag when , ForDirective Tag for in Parameter ParameterName EndTag endfor TableDirective Tag tablerow EndTag endtablerow Tag break Tag continue Tag cycle Comment Tag comment CommentText EndTag endcomment RawDirective Tag raw RawText EndTag endraw Tag echo Tag render RenderParameter with for as Tag include Tag assign CaptureDirective Tag capture EndTag endcapture Tag increment Tag decrement Tag liquid IfDirective Tag if EndTag endif UnlessDirective Tag unless EndTag endunless Tag elsif Tag else CaseDirective Tag case EndTag endcase Tag when ForDirective Tag EndTag endfor TableDirective Tag tablerow EndTag endtablerow Tag break Tag Tag cycle Tag echo Tag render RenderParameter Tag include Tag assign CaptureDirective Tag capture EndTag endcapture Tag increment Tag decrement",
  maxTerm: 189,
  nodeProps: [
    ["closedBy", 1, "}}", -4, 2, 3, 4, 5, "%}", 22, ")"],
    ["openedBy", 9, "{{", 21, "(", 38, "{%"],
    ["group", -12, 11, 12, 15, 19, 23, 25, 26, 27, 28, 29, 30, 31, "Expression"]
  ],
  skippedNodes: [0, 6],
  repeatNodeCount: 11,
  tokenData: ")l~RlXY!yYZ!y]^!ypq!yqr#[rs#gst$Xuv$pwx${xy%hyz%m{|%r|}'^}!O'c!O!P'o!Q![&{![!](P!^!_(U!_!`(^!`!a(U!c!}(f#R#S(f#T#o(f#p#q)[#q#r)a%W;'S(f;'S;:j)U<%lO(f~#OS%O~XY!yYZ!y]^!ypq!y~#_P!_!`#b~#gOa~~#jUOY#gZr#grs#|s;'S#g;'S;=`$R<%lO#g~$ROn~~$UP;=`<%l#g~$^SU~OY$XZ;'S$X;'S;=`$j<%lO$X~$mP;=`<%l$X~$sP#q#r$v~${Ov~~%OUOY${Zw${wx#|x;'S${;'S;=`%b<%lO${~%eP;=`<%l${~%mOf~~%rOe~P%uQ!O!P%{!Q![&{P&OP!Q![&RP&WRoP!Q![&R!g!h&a#X#Y&aP&dR{|&m}!O&m!Q![&sP&pP!Q![&sP&xPoP!Q![&sP'QSoP!O!P%{!Q![&{!g!h&a#X#Y&a~'cO!^~~'fRuv$p!O!P%{!Q![&{~'tQ]S!O!P'z!Q![&R~(POh~~(UOs~~(ZPa~!_!`#b~(cPd~!_!`#b_(oV^WuQ%RT!Q![(f!c!}(f#R#S(f#T#o(f%W;'S(f;'S;:j)U<%lO(f_)XP;=`<%l(f~)aOq~~)dP#q#r)g~)lOX~",
  tokenizers: [rk, sk, nk, 0, 1, 2, 3],
  topRules: { Template: [0, 7] },
  specialized: [{ term: 187, get: (t) => ak[t] || -1 }, { term: 37, get: (t) => ok[t] || -1 }],
  tokenPrec: 0
});
function lr(t, e) {
  return t.split(" ").map((O) => ({ label: O, type: e }));
}
const hQ = /* @__PURE__ */ lr("abs append at_least at_most capitalize ceil compact concat date default divided_by downcase escape escape_once first floor join last lstrip map minus modulo newline_to_br plus prepend remove remove_first replace replace_first reverse round rstrip size slice sort sort_natural split strip strip_html strip_newlines sum times truncate truncatewords uniq upcase url_decode url_encode where", "function"), QQ = /* @__PURE__ */ lr("cycle comment endcomment raw endraw echo increment decrement liquid if elsif else endif unless endunless case endcase for endfor tablerow endtablerow break continue assign capture endcapture render include", "keyword"), fQ = /* @__PURE__ */ lr("empty forloop tablerowloop in with as contains", "keyword"), ck = /* @__PURE__ */ lr("first index index0 last length rindex", "property"), hk = /* @__PURE__ */ lr("col col0 col_first col_last first index index0 last length rindex rindex0 row", "property");
function Qk(t) {
  var e;
  let { state: O, pos: i } = t, r = I(O).resolveInner(i, -1).enterUnfinishedNodesBefore(i), n = ((e = r.childBefore(i)) === null || e === void 0 ? void 0 : e.name) || r.name;
  if (r.name == "FilterName")
    return { type: "filter", node: r };
  if (t.explicit && n == "|")
    return { type: "filter" };
  if (r.name == "TagName")
    return { type: "tag", node: r };
  if (t.explicit && n == "{%")
    return { type: "tag" };
  if (r.name == "PropertyName" && r.parent.name == "MemberExpression")
    return { type: "property", node: r, target: r.parent };
  if (r.name == "." && r.parent.name == "MemberExpression")
    return { type: "property", target: r.parent };
  if (r.name == "MemberExpression" && n == ".")
    return { type: "property", target: r };
  if (r.name == "VariableName")
    return { type: "expression", from: r.from };
  let s = t.matchBefore(/[\w\u00c0-\uffff]+$/);
  return s ? { type: "expression", from: s.from } : t.explicit && r.name != "CommentText" && r.name != "StringLiteral" && r.name != "NumberLiteral" && r.name != "InlineComment" ? { type: "expression" } : null;
}
function fk(t, e, O, i) {
  let r = [];
  for (; ; ) {
    let n = e.getChild("Expression");
    if (!n)
      return [];
    if (n.name == "forloop")
      return r.length ? [] : ck;
    if (n.name == "tablerowloop")
      return r.length ? [] : hk;
    if (n.name == "VariableName") {
      r.unshift(t.sliceDoc(n.from, n.to));
      break;
    } else if (n.name == "MemberExpression") {
      let s = n.getChild("PropertyName");
      s && r.unshift(t.sliceDoc(s.from, s.to)), e = n;
    } else
      return [];
  }
  return i ? i(r, t, O) : [];
}
function $k(t = {}) {
  let e = t.filters ? t.filters.concat(hQ) : hQ, O = t.tags ? t.tags.concat(QQ) : QQ, i = t.variables ? t.variables.concat(fQ) : fQ, { properties: r } = t;
  return (n) => {
    var s;
    let a = Qk(n);
    if (!a)
      return null;
    let o = (s = a.from) !== null && s !== void 0 ? s : a.node ? a.node.from : n.pos, c;
    return a.type == "filter" ? c = e : a.type == "tag" ? c = O : a.type == "expression" ? c = i : c = fk(n.state, a.target, n, r), c.length ? { options: c, from: o, validFor: /^[\w\u00c0-\uffff]*$/ } : null;
  };
}
const uk = /* @__PURE__ */ k.inputHandler.of((t, e, O, i) => i != "%" || e != O || t.state.doc.sliceString(e - 1, O + 1) != "{}" ? !1 : (t.dispatch(t.state.changeByRange((r) => ({
  changes: { from: r.from, to: r.to, insert: "%%" },
  range: g.cursor(r.from + 1)
})), {
  scrollIntoView: !0,
  userEvent: "input.type"
}), !0));
function Zs(t) {
  return (e) => {
    let O = t.test(e.textAfter);
    return e.lineIndent(e.node.from) + (O ? 0 : e.unit);
  };
}
const dk = /* @__PURE__ */ re.define({
  name: "liquid",
  parser: /* @__PURE__ */ lk.configure({
    props: [
      /* @__PURE__ */ se({
        "cycle comment endcomment raw endraw echo increment decrement liquid in with as": l.keyword,
        "empty forloop tablerowloop": l.atom,
        "if elsif else endif unless endunless case endcase for endfor tablerow endtablerow break continue": l.controlKeyword,
        "assign capture endcapture": l.definitionKeyword,
        contains: l.operatorKeyword,
        "render include": l.moduleKeyword,
        VariableName: l.variableName,
        TagName: l.tagName,
        FilterName: /* @__PURE__ */ l.function(l.variableName),
        PropertyName: l.propertyName,
        CompareOp: l.compareOperator,
        AssignOp: l.definitionOperator,
        LogicOp: l.logicOperator,
        NumberLiteral: l.number,
        StringLiteral: l.string,
        BooleanLiteral: l.bool,
        InlineComment: l.lineComment,
        CommentText: l.blockComment,
        "{% %} {{ }}": l.brace,
        "( )": l.paren,
        ".": l.derefOperator,
        ", .. : |": l.punctuation
      }),
      /* @__PURE__ */ me.add({
        Tag: /* @__PURE__ */ YO({ closing: "%}" }),
        "UnlessDirective ForDirective TablerowDirective CaptureDirective": /* @__PURE__ */ Zs(/^\s*(\{%-?\s*)?end\w/),
        IfDirective: /* @__PURE__ */ Zs(/^\s*(\{%-?\s*)?(endif|else|elsif)\b/),
        CaseDirective: /* @__PURE__ */ Zs(/^\s*(\{%-?\s*)?(endcase|when)\b/)
      }),
      /* @__PURE__ */ fe.add({
        "UnlessDirective ForDirective TablerowDirective CaptureDirective IfDirective CaseDirective RawDirective Comment"(t) {
          let e = t.firstChild, O = t.lastChild;
          return !e || e.name != "Tag" ? null : { from: e.to, to: O.name == "EndTag" ? O.from : t.to };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*{%-?\s*(?:end|elsif|else|when|)$/
  }
}), Ha = /* @__PURE__ */ Ht();
function rp(t) {
  return dk.configure({
    wrap: SO((e) => e.type.isTop ? {
      parser: t.parser,
      overlay: (O) => O.name == "Text" || O.name == "RawText"
    } : null)
  }, "liquid");
}
const pk = /* @__PURE__ */ rp(Ha.language);
function mk(t = {}) {
  let e = t.base || Ha, O = e.language == Ha.language ? pk : rp(e.language);
  return new le(O, [
    e.support,
    O.data.of({ autocomplete: $k(t) }),
    e.language.data.of({ closeBrackets: { brackets: ["{"] } }),
    uk
  ]);
}
const Pk = 1, gk = 2, Sk = 263, Xk = 3, yk = 264, $Q = 265, bk = 266, xk = 4, Tk = 5, wk = 6, kk = 7, uQ = 8, Wk = 9, Rk = 10, vk = 11, Zk = 12, Yk = 13, zk = 14, qk = 15, Uk = 16, Vk = 17, _k = 18, jk = 19, Gk = 20, Ck = 21, Ek = 22, Ak = 23, Dk = 24, Nk = 25, Ik = 26, Mk = 27, Lk = 28, Bk = 29, Fk = 30, Hk = 31, Kk = 32, Jk = 33, eW = 34, OW = 35, tW = 36, iW = 37, rW = 38, nW = 39, sW = 40, aW = 41, oW = 42, lW = 43, cW = 44, hW = 45, QW = 46, fW = 47, $W = 48, uW = 49, dW = 50, pW = 51, mW = 52, PW = 53, gW = 54, SW = 55, XW = 56, yW = 57, bW = 58, xW = 59, TW = 60, wW = 61, Ys = 62, kW = 63, WW = 64, RW = 65, vW = {
  abstract: xk,
  and: Tk,
  array: wk,
  as: kk,
  true: uQ,
  false: uQ,
  break: Wk,
  case: Rk,
  catch: vk,
  clone: Zk,
  const: Yk,
  continue: zk,
  declare: Uk,
  default: qk,
  do: Vk,
  echo: _k,
  else: jk,
  elseif: Gk,
  enddeclare: Ck,
  endfor: Ek,
  endforeach: Ak,
  endif: Dk,
  endswitch: Nk,
  endwhile: Ik,
  enum: Mk,
  extends: Lk,
  final: Bk,
  finally: Fk,
  fn: Hk,
  for: Kk,
  foreach: Jk,
  from: eW,
  function: OW,
  global: tW,
  goto: iW,
  if: rW,
  implements: nW,
  include: sW,
  include_once: aW,
  instanceof: oW,
  insteadof: lW,
  interface: cW,
  list: hW,
  match: QW,
  namespace: fW,
  new: $W,
  null: uW,
  or: dW,
  print: pW,
  require: mW,
  require_once: PW,
  return: gW,
  switch: SW,
  throw: XW,
  trait: yW,
  try: bW,
  unset: xW,
  use: TW,
  var: wW,
  public: Ys,
  private: Ys,
  protected: Ys,
  while: kW,
  xor: WW,
  yield: RW,
  __proto__: null
};
function dQ(t) {
  let e = vW[t.toLowerCase()];
  return e ?? -1;
}
function pQ(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
function np(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function gi(t) {
  return t == 95 || t >= 128 || np(t);
}
function zs(t) {
  return t >= 48 && t <= 55 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
const ZW = {
  int: !0,
  integer: !0,
  bool: !0,
  boolean: !0,
  float: !0,
  double: !0,
  real: !0,
  string: !0,
  array: !0,
  object: !0,
  unset: !0,
  __proto__: null
}, YW = new q((t) => {
  if (t.next == 40) {
    t.advance();
    let e = 0;
    for (; pQ(t.peek(e)); ) e++;
    let O = "", i;
    for (; np(i = t.peek(e)); )
      O += String.fromCharCode(i), e++;
    for (; pQ(t.peek(e)); ) e++;
    t.peek(e) == 41 && ZW[O.toLowerCase()] && t.acceptToken(Pk);
  } else if (t.next == 60 && t.peek(1) == 60 && t.peek(2) == 60) {
    for (let i = 0; i < 3; i++) t.advance();
    for (; t.next == 32 || t.next == 9; ) t.advance();
    let e = t.next == 39;
    if (e && t.advance(), !gi(t.next)) return;
    let O = String.fromCharCode(t.next);
    for (; t.advance(), !(!gi(t.next) && !(t.next >= 48 && t.next <= 55)); )
      O += String.fromCharCode(t.next);
    if (e) {
      if (t.next != 39) return;
      t.advance();
    }
    if (t.next != 10 && t.next != 13) return;
    for (; ; ) {
      let i = t.next == 10 || t.next == 13;
      if (t.advance(), t.next < 0) return;
      if (i) {
        for (; t.next == 32 || t.next == 9; ) t.advance();
        let r = !0;
        for (let n = 0; n < O.length; n++) {
          if (t.next != O.charCodeAt(n)) {
            r = !1;
            break;
          }
          t.advance();
        }
        if (r) return t.acceptToken(gk);
      }
    }
  }
}), zW = new q((t) => {
  t.next < 0 && t.acceptToken(bk);
}), qW = new q((t, e) => {
  t.next == 63 && e.canShift($Q) && t.peek(1) == 62 && t.acceptToken($Q);
});
function UW(t) {
  let e = t.peek(1);
  if (e == 110 || e == 114 || e == 116 || e == 118 || e == 101 || e == 102 || e == 92 || e == 36 || e == 34 || e == 123)
    return 2;
  if (e >= 48 && e <= 55) {
    let O = 2, i;
    for (; O < 5 && (i = t.peek(O)) >= 48 && i <= 55; ) O++;
    return O;
  }
  if (e == 120 && zs(t.peek(2)))
    return zs(t.peek(3)) ? 4 : 3;
  if (e == 117 && t.peek(2) == 123)
    for (let O = 3; ; O++) {
      let i = t.peek(O);
      if (i == 125) return O == 2 ? 0 : O + 1;
      if (!zs(i)) break;
    }
  return 0;
}
const VW = new q((t, e) => {
  let O = !1;
  for (; !(t.next == 34 || t.next < 0 || t.next == 36 && (gi(t.peek(1)) || t.peek(1) == 123) || t.next == 123 && t.peek(1) == 36); O = !0) {
    if (t.next == 92) {
      let i = UW(t);
      if (i) {
        if (O) break;
        return t.acceptToken(Xk, i);
      }
    } else if (!O && (t.next == 91 || t.next == 45 && t.peek(1) == 62 && gi(t.peek(2)) || t.next == 63 && t.peek(1) == 45 && t.peek(2) == 62 && gi(t.peek(3))) && e.canShift(yk))
      break;
    t.advance();
  }
  O && t.acceptToken(Sk);
}), _W = se({
  "Visibility abstract final static": l.modifier,
  "for foreach while do if else elseif switch try catch finally return throw break continue default case": l.controlKeyword,
  "endif endfor endforeach endswitch endwhile declare enddeclare goto match": l.controlKeyword,
  "and or xor yield unset clone instanceof insteadof": l.operatorKeyword,
  "function fn class trait implements extends const enum global interface use var": l.definitionKeyword,
  "include include_once require require_once namespace": l.moduleKeyword,
  "new from echo print array list as": l.keyword,
  null: l.null,
  Boolean: l.bool,
  VariableName: l.variableName,
  "NamespaceName/...": l.namespace,
  "NamedType/...": l.typeName,
  Name: l.name,
  "CallExpression/Name": l.function(l.variableName),
  "LabelStatement/Name": l.labelName,
  "MemberExpression/Name": l.propertyName,
  "MemberExpression/VariableName": l.special(l.propertyName),
  "ScopedExpression/ClassMemberName/Name": l.propertyName,
  "ScopedExpression/ClassMemberName/VariableName": l.special(l.propertyName),
  "CallExpression/MemberExpression/Name": l.function(l.propertyName),
  "CallExpression/ScopedExpression/ClassMemberName/Name": l.function(l.propertyName),
  "MethodDeclaration/Name": l.function(l.definition(l.variableName)),
  "FunctionDefinition/Name": l.function(l.definition(l.variableName)),
  "ClassDeclaration/Name": l.definition(l.className),
  UpdateOp: l.updateOperator,
  ArithOp: l.arithmeticOperator,
  LogicOp: l.logicOperator,
  BitOp: l.bitwiseOperator,
  CompareOp: l.compareOperator,
  ControlOp: l.controlOperator,
  AssignOp: l.definitionOperator,
  "$ ConcatOp": l.operator,
  LineComment: l.lineComment,
  BlockComment: l.blockComment,
  Integer: l.integer,
  Float: l.float,
  String: l.string,
  ShellExpression: l.special(l.string),
  "=> ->": l.punctuation,
  "( )": l.paren,
  "#[ [ ]": l.squareBracket,
  "${ { }": l.brace,
  "-> ?->": l.derefOperator,
  ", ; :: : \\": l.separator,
  "PhpOpen PhpClose": l.processingInstruction
}), jW = { __proto__: null, static: 311, STATIC: 311, class: 333, CLASS: 333 }, GW = ne.deserialize({
  version: 14,
  states: "$GSQ`OWOOQhQaOOP%oO`OOOOO#t'#H_'#H_O%tO#|O'#DtOOO#u'#Dw'#DwQ&SOWO'#DwO&XO$VOOOOQ#u'#Dx'#DxO&lQaO'#D|O(mQdO'#E}O(tQdO'#EQO*kQaO'#EWO,zQ`O'#ETO-PQ`O'#E^O/nQaO'#E^O/uQ`O'#EfO/zQ`O'#EoO*kQaO'#EoO0VQ`O'#HhO0[Q`O'#E{O0[Q`O'#E{OOQS'#Ic'#IcO0aQ`O'#EvOOQS'#IZ'#IZO2oQdO'#IWO6tQeO'#FUO*kQaO'#FeO*kQaO'#FfO*kQaO'#FgO*kQaO'#FhO*kQaO'#FhO*kQaO'#FkOOQO'#Id'#IdO7RQ`O'#FqOOQO'#Hi'#HiO7ZQ`O'#HOO7uQ`O'#FlO8QQ`O'#H]O8]Q`O'#FvO8eQaO'#FwO*kQaO'#GVO*kQaO'#GYO8}OrO'#G]OOQS'#Iq'#IqOOQS'#Ip'#IpOOQS'#IW'#IWO,zQ`O'#GdO,zQ`O'#GfO,zQ`O'#GkOhQaO'#GmO9UQ`O'#GnO9ZQ`O'#GqO9`Q`O'#GtO9eQeO'#GuO9eQeO'#GvO9eQeO'#GwO9oQ`O'#GxO9tQ`O'#GzO9yQaO'#G{O<YQ`O'#G|O<_Q`O'#G}O<dQ`O'#G}O9oQ`O'#HOO<iQ`O'#HQO<nQ`O'#HRO<sQ`O'#HSO<xQ`O'#HVO=TQ`O'#HWO9yQaO'#H[OOQ#u'#IV'#IVOOQ#u'#Ha'#HaQhQaOOO=fQ`O'#HPO7pQ`O'#HPO=kO#|O'#DrPOOO)CCw)CCwOOO#t-E;]-E;]OOO#u,5:c,5:cOOO#u'#H`'#H`O&XO$VOOO=vQ$VO'#IUOOOO'#IU'#IUQOOOOOOOQ#y,5:h,5:hO=}QaO,5:hOOQ#u,5:j,5:jO@eQaO,5:mO@lQaO,5;UO*kQaO,5;UO@sQ`O,5;VOCbQaO'#EsOOQS,5;^,5;^OCiQ`O,5;jOOQP'#F]'#F]O*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qO*kQaO,5;qOOQ#u'#Im'#ImOOQS,5<q,5<qOOQ#u,5:l,5:lOEbQ`O,5:rOEiQdO'#E}OF]Q`O'#FlOFeQ`O'#FlOFmQ`O,5:oOFrQaO'#E_OOQS,5:x,5:xOHyQ`O'#I]O9yQaO'#EaO9yQaO'#I]OOQS'#I]'#I]OIQQ`O'#I[OIYQ`O,5:xO-UQaO,5:xOI_QaO'#EgOOQS,5;Q,5;QOOQS,5;Z,5;ZOIiQ`O,5;ZOOQO,5>S,5>SOJ[QdO,5;gOOQO-E;f-E;fOL^Q`O,5;gOLcQpO,5;bO0aQ`O'#EyOLkQtO'#E}OOQS'#Ez'#EzOOQS'#Ib'#IbOM`QaO,5:wO*kQaO,5;nOOQS,5;p,5;pO*kQaO,5;pOMgQdO,5<POMwQdO,5<QONXQdO,5<RONiQdO,5<SO!!sQdO,5<SO!!zQdO,5<VO!#[Q`O'#FrO!#gQ`O'#IgO!#oQ`O,5<]OOQO-E;g-E;gO!#tQ`O'#IoO<_Q`O,5=iO!#|Q`O,5=iO9oQ`O,5=jO!$RQ`O,5=nO!$WQ`O,5=kO!$]Q`O,5=kO!$bQ`O'#FnO!$xQ`O,5<WO!%TQ`O,5<WO!%WQ`O,5?ZO!%]Q`O,5<WO!%eQ`O,5<bO!%mQdO'#GPO!%{QdO'#InO!&WQdO,5=wO!&`Q`O,5<bO!%WQ`O,5<bO!&hQdO,5<cO!&xQ`O,5<cO!'lQdO,5<qO!)nQdO,5<tO!*OOrO'#HsOOOQ'#It'#ItO*kQaO'#GbOOOQ'#Hs'#HsO!*pOrO,5<wOOQS,5<w,5<wO!*wQaO,5=OO!+OQ`O,5=QO!+WQeO,5=VO!+bQ`O,5=XO!+gQaO'#GoO!+WQeO,5=YO9yQaO'#GrO!+WQeO,5=]O!&WQdO,5=`O(tQdO,5=aOOQ#u,5=a,5=aO(tQdO,5=bOOQ#u,5=b,5=bO(tQdO,5=cOOQ#u,5=c,5=cO!+nQ`O,5=dO!+vQ`O,5=fO!+{QdO'#IvOOQS'#Iv'#IvO!&WQdO,5=gO>UQaO,5=hO!-eQ`O'#F}O!-jQdO'#IlO!&WQdO,5=iOOQ#u,5=j,5=jO!-uQ`O,5=lO!-xQ`O,5=mO!-}Q`O,5=nO!.YQdO,5=qOOQ#u,5=q,5=qO!.eQ`O,5=rO!.eQ`O,5=rO!.mQdO'#IwO!.{Q`O'#HXO!&WQdO,5=rO!/ZQ`O,5=rO!/fQdO'#IYO!&WQdO,5=vOOQ#u-E;_-E;_O!1RQ`O,5=kOOO#u,5:^,5:^O!1^O#|O,5:^OOO#u-E;^-E;^OOOO,5>p,5>pOOQ#y1G0S1G0SO!1fQ`O1G0XO*kQaO1G0XO!2xQ`O1G0pOOQS1G0p1G0pO!4[Q`O1G0pOOQS'#I_'#I_O*kQaO'#I_OOQS1G0q1G0qO!4cQ`O'#IaO!7lQ`O'#E}O!7yQaO'#EuOOQO'#Ia'#IaO!8TQ`O'#I`O!8]Q`O,5;_OOQS'#FQ'#FQOOQS1G1U1G1UO!8bQdO1G1]O!:dQdO1G1]O!<PQdO1G1]O!=lQdO1G1]O!?XQdO1G1]O!@tQdO1G1]O!BaQdO1G1]O!C|QdO1G1]O!EiQdO1G1]O!GUQdO1G1]O!HqQdO1G1]O!J^QdO1G1]O!KyQdO1G1]O!MfQdO1G1]O# RQdO1G1]O#!nQdO1G1]OOQT1G0^1G0^O!%WQ`O,5<WO#$ZQaO'#EXOOQS1G0Z1G0ZO#$bQ`O,5:yOFuQaO,5:yO#$gQaO,5:}O#$nQdO,5:{O#&jQdO,5>wO#(fQaO'#HdO#(vQ`O,5>vOOQS1G0d1G0dO#)OQ`O1G0dO#)TQ`O'#I^O#*mQ`O'#I^O#*uQ`O,5;ROIbQaO,5;ROOQS1G0u1G0uPOQO'#E}'#E}O#+fQdO1G1RO0aQ`O'#HgO#-hQtO,5;cO#.YQaO1G0|OOQS,5;e,5;eO#0iQtO,5;gO#0vQdO1G0cO*kQaO1G0cO#2cQdO1G1YO#4OQdO1G1[OOQO,5<^,5<^O#4`Q`O'#HjO#4nQ`O,5?ROOQO1G1w1G1wO#4vQ`O,5?ZO!&WQdO1G3TO<_Q`O1G3TOOQ#u1G3U1G3UO#4{Q`O1G3YO!1RQ`O1G3VO#5WQ`O1G3VO#5]QpO'#FoO#5kQ`O'#FoO#5{Q`O'#FoO#6WQ`O'#FoO#6`Q`O'#FsO#6eQ`O'#FtOOQO'#If'#IfO#6lQ`O'#IeO#6tQ`O,5<YOOQS1G1r1G1rO0aQ`O1G1rO#6yQ`O1G1rO#7OQ`O1G1rO!%WQ`O1G4uO#7ZQdO1G4uO!%WQ`O1G1rO#7iQ`O1G1|O!%WQ`O1G1|O9yQaO,5<kO#7qQdO'#HqO#8PQdO,5?YOOQ#u1G3c1G3cO*kQaO1G1|O0aQ`O1G1|O#8[QdO1G1}O7RQ`O'#FyO7RQ`O'#FzO#:nQ`O'#F{OOQS1G1}1G1}O!-xQ`O1G1}O!1UQ`O1G1}O!1RQ`O1G1}O#;eO`O,5<xO#;jO`O,5<xO#;uO!bO,5<yO#<TQ`O,5<|OOOQ-E;q-E;qOOQS1G2c1G2cO#<[QaO'#GeO#<uQ$VO1G2jO#AuQ`O1G2jO#BQQ`O'#GgO#B]Q`O'#GjOOQ#u1G2l1G2lO#BhQ`O1G2lOOQ#u'#Gl'#GlOOQ#u'#Iu'#IuOOQ#u1G2q1G2qO#BmQ`O1G2qO,zQ`O1G2sO#BrQaO,5=ZO#ByQ`O,5=ZOOQ#u1G2t1G2tO#COQ`O1G2tO#CTQ`O,5=^OOQ#u1G2w1G2wO#DgQ`O1G2wOOQ#u1G2z1G2zOOQ#u1G2{1G2{OOQ#u1G2|1G2|OOQ#u1G2}1G2}O#DlQ`O'#HxO9oQ`O'#HxO#DqQ$VO1G3OO#IwQ`O1G3QO9yQaO'#HwO#I|QdO,5=[OOQ#u1G3R1G3RO#JXQ`O1G3SO9yQaO,5<iO#J^QdO'#HpO#JlQdO,5?WOOQ#u1G3T1G3TOOQ#u1G3W1G3WO!-xQ`O1G3WOOQ#u1G3X1G3XO#KfQ`O'#HTOOQ#u1G3Y1G3YO#KmQ`O1G3YO0aQ`O1G3YOOQ#u1G3]1G3]O!&WQdO1G3^O#KrQ`O1G3^O#KzQdO'#HzO#L]QdO,5?cO#LhQ`O,5?cO#LmQ`O'#HYO7RQ`O'#HYO#LxQ`O'#IxO#MQQ`O,5=sOOQ#u1G3^1G3^O!.eQ`O1G3^O!.eQ`O1G3^O#MVQeO'#HbO#MgQdO,5>tOOQ#u1G3b1G3bOOQ#u1G3V1G3VO!-xQ`O1G3VO!1UQ`O1G3VOOO#u1G/x1G/xO*kQaO7+%sO#MuQdO7+%sOOQS7+&[7+&[O$ bQ`O,5>yO>UQaO,5;`O$ iQ`O,5;aO$#OQaO'#HfO$#YQ`O,5>zOOQS1G0y1G0yO$#bQ`O'#EYO$#gQ`O'#IXO$#oQ`O,5:sOOQS1G0e1G0eO$#tQ`O1G0eO$#yQ`O1G0iO9yQaO1G0iOOQO,5>O,5>OOOQO-E;b-E;bOOQS7+&O7+&OO>UQaO,5;SO$%`QaO'#HeO$%jQ`O,5>xOOQS1G0m1G0mO$%rQ`O1G0mOOQS,5>R,5>ROOQS-E;e-E;eO$%wQdO7+&hO$'yQtO1G1RO$(WQdO7+%}OOQS1G0i1G0iOOQO,5>U,5>UOOQO-E;h-E;hOOQ#u7+(o7+(oO!&WQdO7+(oOOQ#u7+(t7+(tO#KmQ`O7+(tO0aQ`O7+(tOOQ#u7+(q7+(qO!-xQ`O7+(qO!1UQ`O7+(qO!1RQ`O7+(qO$)sQ`O,5<ZO$*OQ`O,5<ZO$*WQ`O,5<_O$*]QpO,5<ZO>UQaO,5<ZOOQO,5<_,5<_O$*kQpO,5<`O$*sQ`O,5<`O$+OQ`O'#HkO$+iQ`O,5?POOQS1G1t1G1tO$+qQpO7+'^O$+yQ`O'#FuO$,UQ`O7+'^OOQS7+'^7+'^O0aQ`O7+'^O#6yQ`O7+'^O$,^QdO7+*aO0aQ`O7+*aO$,lQ`O7+'^O*kQaO7+'hO0aQ`O7+'hO$,wQ`O7+'hO$-PQdO1G2VOOQS,5>],5>]OOQS-E;o-E;oO$.iQdO7+'hO$.yQpO7+'hO$/RQdO'#IiOOQO,5<e,5<eOOQO,5<f,5<fO$/dQpO'#GOO$/lQ`O'#GOOOQO'#Ik'#IkOOQO'#Ho'#HoO$0]Q`O'#GOO<_Q`O'#F|O!&WQdO'#GOO!.YQdO'#GQO7RQ`O'#GROOQO'#Ij'#IjOOQO'#Hn'#HnO$0yQ`O,5<gOOQ#y,5<g,5<gOOQS7+'i7+'iO!-xQ`O7+'iO!1UQ`O7+'iOOOQ1G2d1G2dO$1pO`O1G2dO$1uO!bO1G2eO$2TO`O'#G`O$2YO`O1G2eOOOQ1G2h1G2hO$2_QaO,5=PO,zQ`O'#HtO$2xQ$VO7+(UOhQaO7+(UO,zQ`O'#HuO$7xQ`O7+(UO!&WQdO7+(UO$8TQ`O7+(UO$8YQaO'#GhO$:iQ`O'#GiOOQO'#Hv'#HvO$:qQ`O,5=ROOQ#u,5=R,5=RO$:|Q`O,5=UO!&WQdO7+(WO!&WQdO7+(]O!&WQdO7+(_O$;XQaO1G2uO$;`Q`O1G2uO$;eQaO1G2uO!&WQdO7+(`O9yQaO1G2xO!&WQdO7+(cO0aQ`O'#GyO9oQ`O,5>dOOQ#u,5>d,5>dOOQ#u-E;v-E;vO$;lQaO7+(lO$<TQdO,5>cOOQS-E;u-E;uO!&WQdO7+(nO$=mQdO1G2TOOQS,5>[,5>[OOQS-E;n-E;nOOQ#u7+(r7+(rO$?nQ`O'#GQO$?uQ`O'#GQO$@ZQ`O'#HUOOQO'#Hy'#HyO$@`Q`O,5=oOOQ#u,5=o,5=oO$@gQpO7+(tOOQ#u7+(x7+(xO!&WQdO7+(xO$@rQdO,5>fOOQS-E;x-E;xO$AQQdO1G4}O$A]Q`O,5=tO$AbQ`O,5=tO$AmQ`O'#H{O$BRQ`O,5?dOOQS1G3_1G3_O#KrQ`O7+(xO$BZQdO,5=|OOQS-E;`-E;`O$CvQdO<<I_OOQS1G4e1G4eO$EcQ`O1G0zOOQO,5>Q,5>QOOQO-E;d-E;dO$8YQaO,5:tO$FxQaO'#HcO$GVQ`O,5>sOOQS1G0_1G0_OOQS7+&P7+&PO$G_Q`O7+&TO$HtQ`O1G0nO$JZQ`O,5>POOQO,5>P,5>POOQO-E;c-E;cOOQS7+&X7+&XOOQS7+&T7+&TOOQ#u<<LZ<<LZOOQ#u<<L`<<L`O$@gQpO<<L`OOQ#u<<L]<<L]O!-xQ`O<<L]O!1UQ`O<<L]O>UQaO1G1uO$KsQ`O1G1uO$LOQ`O1G1yOOQO1G1y1G1yO$LTQ`O1G1uO$L]Q`O1G1uO$MrQ`O1G1zO>UQaO1G1zOOQO,5>V,5>VOOQO-E;i-E;iOOQS<<Jx<<JxO$M}Q`O'#IhO$NVQ`O'#IhO$N[Q`O,5<aO0aQ`O<<JxO$+qQpO<<JxO$NaQ`O<<JxO0aQ`O<<M{O$NiQtO<<M{O#6yQ`O<<JxO$NwQdO<<KSO% XQpO<<KSO*kQaO<<KSO0aQ`O<<KSO% aQdO'#HmO% xQdO,5?TO!&WQdO,5<jO$/dQpO,5<jO%!ZQ`O,5<jO<_Q`O,5<hO!.YQdO,5<lOOQO-E;m-E;mO!&WQdO,5<hOOQO,5<j,5<jOOQO,5<l,5<lO%!tQdO,5<mOOQO-E;l-E;lOOQ#y1G2R1G2ROOQS<<KT<<KTO!-xQ`O<<KTOOOQ7+(O7+(OO%#PO`O7+(POOOO,5<z,5<zOOOQ7+(P7+(POhQaO,5>`OOQ#u-E;r-E;rOhQaO<<KpOOQ#u<<Kp<<KpO$8TQ`O,5>aOOQO-E;s-E;sO!&WQdO<<KpO$8TQ`O<<KpO%#UQ`O<<KpO%#ZQ`O,5=SO%$pQaO,5=TOOQO-E;t-E;tOOQ#u1G2m1G2mOOQ#u<<Kr<<KrOOQ#u<<Kw<<KwOOQ#u<<Ky<<KyOOQT7+(a7+(aO%%QQ`O7+(aO%%VQaO7+(aO%%^Q`O7+(aOOQ#u<<Kz<<KzO%%cQ`O7+(dO%&xQ`O7+(dOOQ#u<<K}<<K}O%&}QpO,5=eOOQ#u1G4O1G4OO%'YQ`O<<LWOOQ#u<<LY<<LYO$?uQ`O,5<lO%'_Q`O,5=pO%'dQdO,5=pOOQO-E;w-E;wOOQ#u1G3Z1G3ZO#KmQ`O<<L`OOQ#u<<Ld<<LdO%'oQ`O1G4QO%'tQdO7+*iOOQO1G3`1G3`O%(PQ`O1G3`O%(UQ`O'#HZO7RQ`O'#HZOOQO,5>g,5>gOOQO-E;y-E;yO!&WQdO<<LdO%(aQ`O1G0`OOQO,5=},5=}OOQO-E;a-E;aO>UQaO,5;TOOQ#uANAzANAzO#KmQ`OANAzOOQ#uANAwANAwO!-xQ`OANAwO%)vQ`O7+'aO>UQaO7+'aOOQO7+'e7+'eO%+]Q`O7+'aO%+hQ`O7+'eO>UQaO7+'fO%+mQ`O7+'fO%-SQ`O'#HlO%-bQ`O,5?SO%-bQ`O,5?SOOQO1G1{1G1{O$+qQpOAN@dOOQSAN@dAN@dO0aQ`OAN@dO%-jQtOANCgO%-xQ`OAN@dO*kQaOAN@nO%.QQdOAN@nO%.bQpOAN@nOOQS,5>X,5>XOOQS-E;k-E;kOOQO1G2U1G2UO!&WQdO1G2UO$/dQpO1G2UO<_Q`O1G2SO!.YQdO1G2WO!&WQdO1G2SOOQO1G2W1G2WOOQO1G2S1G2SO%.jQaO'#GSOOQO1G2X1G2XOOQSAN@oAN@oOOOQ<<Kk<<KkOOQ#u1G3z1G3zOOQ#uANA[ANA[OOQO1G3{1G3{O%0iQ`OANA[O!&WQdOANA[O%0nQaO1G2nO%1OQaO1G2oOOQT<<K{<<K{O%1`Q`O<<K{O%1eQaO<<K{O*kQaO,5=_OOQT<<LO<<LOOOQO1G3P1G3PO%1lQ`O1G3PO!+WQeOANArO%1qQdO1G3[OOQO1G3[1G3[O%1|Q`O1G3[OOQS7+)l7+)lOOQO7+(z7+(zO%2UQ`O,5=uO%2ZQ`O,5=uOOQ#uANBOANBOO%2fQ`O1G0oOOQ#uG27fG27fOOQ#uG27cG27cO%3{Q`O<<J{O>UQaO<<J{OOQO<<KP<<KPO%5bQ`O<<KQOOQO,5>W,5>WO%6wQ`O,5>WOOQO-E;j-E;jO%6|Q`O1G4nOOQSG26OG26OO$+qQpOG26OO0aQ`OG26OO%7UQdOG26YO*kQaOG26YOOQO7+'p7+'pO!&WQdO7+'pO!&WQdO7+'nOOQO7+'r7+'rOOQO7+'n7+'nO%7fQ`OLD+tO%8uQ`O'#E}O%9PQ`O'#IZO!&WQdO'#HrO%:|QaO,5<nOOQO,5<n,5<nO!&WQdOG26vOOQ#uG26vG26vO%<{QaO7+(YOOQTANAgANAgO%=]Q`OANAgO%=bQ`O1G2yOOQO7+(k7+(kOOQ#uG27^G27^O%=iQ`OG27^OOQO7+(v7+(vO%=nQ`O7+(vO!&WQdO7+(vOOQO1G3a1G3aO%=vQ`O1G3aO%={Q`OAN@gOOQO1G3r1G3rOOQSLD+jLD+jO$+qQpOLD+jO%?bQdOLD+tOOQO<<K[<<K[OOQO<<KY<<KYO%?rQ`O,5<oO%?wQ`O,5<pOOQP,5>^,5>^OOQP-E;p-E;pOOQO1G2Y1G2YOOQ#uLD,bLD,bOOQTG27RG27RO!&WQdOLD,xO!&WQdO<<LbOOQO<<Lb<<LbOOQO7+({7+({OOQS!$( U!$( UOOQS1G2Z1G2ZOOQS1G2[1G2[O%@PQdO1G2[OOQ#u!$(!d!$(!dOOQOANA|ANA|OOQS7+'v7+'vO%@[Q`O'#E{O%@[Q`O'#E{O%@aQ`O,5;gO%@fQdO,5<cO%BbQaO,5:}O*kQaO1G0iO%BiQaO'#FwO#.YQaO'#GVO#.YQaO'#GYO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO#.YQaO,5;qO%BpQdO'#I]O%D`QdO'#I]O#.YQaO'#EaO#.YQaO'#I]O%FbQaO,5:wO#.YQaO,5;nO#.YQaO,5;pO%FiQdO,5<PO%HeQdO,5<QO%JaQdO,5<RO%L]QdO,5<SO%NXQdO,5<SO%NoQdO,5<VO&!kQdO,5<tO#.YQaO1G0XO&$gQdO1G1]O&&cQdO1G1]O&(_QdO1G1]O&*ZQdO1G1]O&,VQdO1G1]O&.RQdO1G1]O&/}QdO1G1]O&1yQdO1G1]O&3uQdO1G1]O&5qQdO1G1]O&7mQdO1G1]O&9iQdO1G1]O&;eQdO1G1]O&=aQdO1G1]O&?]QdO1G1]O&AXQdO,5:{O&CTQdO,5>wO&EPQdO1G0cO#.YQaO1G0cO&F{QdO1G1YO&HwQdO1G1[O#.YQaO1G1|O#.YQaO7+%sO&JsQdO7+%sO&LoQdO7+%}O#.YQaO7+'hO&NkQdO7+'hO'!gQdO<<I_O'$cQdO<<KSO#.YQaO<<KSO#.YQaOAN@nO'&_QdOAN@nO'(ZQdOG26YO#.YQaOG26YO'*VQdOLD+tO',RQaO,5:}O'.QQaO1G0iO'/|QdO'#IWO'0aQeO'#FUO'4aQeO'#FUO#.YQaO'#FeO'.QQaO'#FeO#.YQaO'#FfO'.QQaO'#FfO#.YQaO'#FgO'.QQaO'#FgO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FhO'.QQaO'#FhO#.YQaO'#FkO'.QQaO'#FkO'8gQaO,5:mO'8nQ`O,5<bO'8vQ`O1G0XO'.QQaO1G0|O':YQ`O1G1|O':bQ`O7+'hO':jQpO7+'hO':rQpO<<KSO':zQpOAN@nO';SQaO'#FwO'.QQaO'#GVO'.QQaO'#GYO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO,5;qO'.QQaO'#EaO'.QQaO'#I]O'=RQaO,5:wO'.QQaO,5;nO'.QQaO,5;pO'?QQdO,5<PO'ASQdO,5<QO'CUQdO,5<RO'EWQdO,5<SO'GYQdO,5<SO'GvQdO,5<VO'IxQdO,5<tO'.QQaO1G0XO'KzQdO1G1]O'M|QdO1G1]O(!OQdO1G1]O($QQdO1G1]O(&SQdO1G1]O((UQdO1G1]O(*WQdO1G1]O(,YQdO1G1]O(.[QdO1G1]O(0^QdO1G1]O(2`QdO1G1]O(4bQdO1G1]O(6dQdO1G1]O(8fQdO1G1]O(:hQdO1G1]O(<jQdO,5:{O(>lQdO,5>wO(@nQdO1G0cO'.QQaO1G0cO(BpQdO1G1YO(DrQdO1G1[O'.QQaO1G1|O'.QQaO7+%sO(FtQdO7+%sO(HvQdO7+%}O'.QQaO7+'hO(JxQdO7+'hO(LzQdO<<I_O(N|QdO<<KSO'.QQaO<<KSO'.QQaOAN@nO)#OQdOAN@nO)%QQdOG26YO'.QQaOG26YO)'SQdOLD+tO))UQaO,5:}O#.YQaO1G0iO))]Q`O'#FvO))eQpO,5;bO))mQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO))uQdO,5<cO)+wQdO'#I]O)-vQdO'#IWO).aQaO,5:mO).hQ`O,5<bO).pQ`O1G0XO)0SQ`O1G1|O)0[Q`O7+'hO)0dQpO7+'hO)0lQpO<<KSO)0tQpOAN@nO0aQ`O'#EvO9yQaO'#FeO9yQaO'#FfO9yQaO'#FgO9yQaO'#FhO9yQaO'#FhO9yQaO'#FkO)0|QaO'#FwO9yQaO'#GVO9yQaO'#GYO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO9yQaO,5;qO)1TQ`O'#FlO*kQaO'#EaO*kQaO'#I]O)1]QaO,5:wO9yQaO,5;nO9yQaO,5;pO)1dQdO,5<PO)3`QdO,5<QO)5[QdO,5<RO)7WQdO,5<SO)9SQdO,5<SO)9jQdO,5<VO);fQdO,5<cO)=bQdO,5<tO)?^Q`O'#IvO)@sQ`O'#IYO9yQaO1G0XO)BYQdO1G1]O)DUQdO1G1]O)FQQdO1G1]O)G|QdO1G1]O)IxQdO1G1]O)KtQdO1G1]O)MpQdO1G1]O* lQdO1G1]O*#hQdO1G1]O*%dQdO1G1]O*'`QdO1G1]O*)[QdO1G1]O*+WQdO1G1]O*-SQdO1G1]O*/OQdO1G1]O*0zQaO,5:}O*1RQdO,5:{O*1cQdO,5>wO*1sQaO'#HdO*2TQ`O,5>vO*2]QdO1G0cO9yQaO1G0cO*4XQdO1G1YO*6TQdO1G1[O9yQaO1G1|O>UQaO'#HwO*8PQ`O,5=[O*8XQaO'#HbO*8cQ`O,5>tO9yQaO7+%sO*8kQdO7+%sO*:gQ`O1G0iO>UQaO1G0iO*;|QdO7+%}O9yQaO7+'hO*=xQdO7+'hO*?tQ`O,5>cO*AZQ`O,5=|O*BpQdO<<I_O*DlQ`O7+&TO*FRQdO<<KSO9yQaO<<KSO9yQaOAN@nO*G}QdOAN@nO*IyQdOG26YO9yQaOG26YO*KuQdOLD+tO*MqQaO,5:}O9yQaO1G0iO*MxQdO'#I]O*NcQ`O'#FvO*NkQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO*NsQdO'#IWO+ ^QeO'#FUO+ zQaO'#FUO+#sQaO'#FUO+%`QaO'#FUO>UQaO'#FeO>UQaO'#FfO>UQaO'#FgO>UQaO'#FhO>UQaO'#FhO>UQaO'#FkO+'XQaO'#FwO>UQaO'#GVO>UQaO'#GYO+'`QaO,5:mO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO>UQaO,5;qO+'gQ`O'#I]O$8YQaO'#EaO+)PQaOG26YO$8YQaO'#I]O+*{Q`O'#I[O++TQaO,5:wO>UQaO,5;nO>UQaO,5;pO++[Q`O,5<PO+,wQ`O,5<QO+.dQ`O,5<RO+0PQ`O,5<SO+1lQ`O,5<SO+3XQ`O,5<VO+4tQ`O,5<bO+4|Q`O,5<cO+6iQ`O,5<tO+8UQ`O1G0XO>UQaO1G0XO+9hQ`O1G1]O+;TQ`O1G1]O+<pQ`O1G1]O+>]Q`O1G1]O+?xQ`O1G1]O+AeQ`O1G1]O+CQQ`O1G1]O+DmQ`O1G1]O+FYQ`O1G1]O+GuQ`O1G1]O+IbQ`O1G1]O+J}Q`O1G1]O+LjQ`O1G1]O+NVQ`O1G1]O, rQ`O1G1]O,#_Q`O1G0cO>UQaO1G0cO,$zQ`O1G1YO,&gQ`O1G1[O,(SQ`O1G1|O>UQaO1G1|O>UQaO7+%sO,([Q`O7+%sO,)wQ`O7+%}O>UQaO7+'hO,+dQ`O7+'hO,+lQ`O7+'hO,-XQpO7+'hO,-aQ`O<<I_O,.|Q`O<<KSO,0iQpO<<KSO>UQaO<<KSO>UQaOAN@nO,0qQ`OAN@nO,2^QpOAN@nO,2fQ`OG26YO>UQaOG26YO,4RQ`OLD+tO,5nQaO,5:}O>UQaO1G0iO,5uQ`O'#I]O$8YQaO'#FeO$8YQaO'#FfO$8YQaO'#FgO$8YQaO'#FhO$8YQaO'#FhO+)PQaO'#FhO$8YQaO'#FkO,6SQaO'#FwO,6ZQaO'#FwO$8YQaO'#GVO+)PQaO'#GVO$8YQaO'#GYO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO$8YQaO,5;qO+)PQaO,5;qO,8YQ`O'#FlO>UQaO'#EaO>UQaO'#I]O,8bQaO,5:wO,8iQaO,5:wO$8YQaO,5;nO+)PQaO,5;nO$8YQaO,5;pO,:hQ`O,5<PO,<TQ`O,5<QO,=pQ`O,5<RO,?]Q`O,5<SO,@xQ`O,5<SO,BeQ`O,5<SO,CtQ`O,5<VO,EaQ`O,5<cO%7fQ`O,5<cO,F|Q`O,5<tO$8YQaO1G0XO+)PQaO1G0XO,HiQ`O1G1]O,JUQ`O1G1]O,KeQ`O1G1]O,MQQ`O1G1]O,NaQ`O1G1]O- |Q`O1G1]O-#]Q`O1G1]O-$xQ`O1G1]O-&XQ`O1G1]O-'tQ`O1G1]O-)TQ`O1G1]O-*pQ`O1G1]O-,PQ`O1G1]O--lQ`O1G1]O-.{Q`O1G1]O-0hQ`O1G1]O-1wQ`O1G1]O-3dQ`O1G1]O-4sQ`O1G1]O-6`Q`O1G1]O-7oQ`O1G1]O-9[Q`O1G1]O-:kQ`O1G1]O-<WQ`O1G1]O-=gQ`O1G1]O-?SQ`O1G1]O-@cQ`O1G1]O-BOQ`O1G1]O-C_Q`O1G1]O-DzQ`O1G1]O-FZQ`O,5:{O-GvQ`O,5>wO-IcQ`O1G0cO-KOQ`O1G0cO$8YQaO1G0cO+)PQaO1G0cO-L_Q`O1G1YO-MzQ`O1G1YO. ZQ`O1G1[O$8YQaO1G1|O$8YQaO7+%sO+)PQaO7+%sO.!vQ`O7+%sO.$cQ`O7+%sO.%rQ`O7+%}O.'_Q`O7+%}O$8YQaO7+'hO.(nQ`O7+'hO.*ZQ`O<<I_O.+vQ`O<<I_O.-VQ`O<<KSO$8YQaO<<KSO$8YQaOAN@nO..rQ`OAN@nO.0_Q`OG26YO$8YQaOG26YO.1zQ`OLD+tO.3gQaO,5:}O.3nQaO,5:}O$8YQaO1G0iO+)PQaO1G0iO.5mQ`O'#I]O.7PQ`O'#I]O.:fQ`O'#IWO.:vQ`O'#FvO.;OQaO,5:mO.;VQ`O,5<bO.;_Q`O,5<bO!%WQ`O,5<bO.;gQ`O1G0XO.<yQ`O,5:{O.>fQ`O,5>wO.@RQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO.@ZQ`O7+'hO.@cQpO7+'hO.@kQpO<<KSO0aQ`O<<KSO.@sQpOAN@nO.@{Q`O'#IWO.A]Q`O'#IWO.CSQaO,5:mO.CZQaO,5:mO.CbQ`O,5<bO.CjQ`O7+'hO.CrQ`O1G0XO.EUQ`O1G0XO.FhQ`O1G1|O.FpQ`O7+'hO.FxQpO7+'hO.GQQpOAN@nO.GYQpO<<KSO.GbQpOAN@nO.GjQ`O'#FvO.GrQ`O'#FlO.GzQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O0aQ`O1G1|O0aQ`O7+'hO0aQ`O<<KSO.HSQ`O'#FvO.H[Q`O,5<bO.HdQ`O,5<bO!%WQ`O,5<bO!%WQ`O1G1|O!%WQ`O1G1|O0aQ`O1G1|O0aQ`O<<KSO0aQ`O7+'hO0aQ`O<<KSO.HlQ`O'#FlO.HtQ`O'#FlO.H|Q`O'#Fl",
  stateData: ".Ic~O!dOS!eOS&vOS!gQQ~O!iTO&wRO~OPgOQ|OS!lOU^OW}OX!XO[mO]!_O^!WO`![Oa!SOb!]Ok!dOm!lOowOp!TOq!UOsuOt!gOu!VOv!POxkOykO|!bO}`O!O]O!P!eO!QxO!R}O!TpO!UlO!VlO!W!YO!X!QO!YzO!Z!cO![!ZO!]!^O!^!fO!`!`O!a!RO!cjO!mWO!oXO!sYO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$drO$l!kO$zyO${!OO$}}O%O}O%V|O'g{O~O!g!mO~O&wRO!i!hX&p!hX&t!hX~O!i!pO~O!d!qO!e!qO!g!mO&t!tO&v!qO~PhO!n!vO~PhOT'VXz'VX!S'VX!b'VX!m'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX&s'VX~O!q!xO~P&sOT#TOz#RO!S#UO!b#VO!m#cO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO&s#cO~OPgOQ|OU^OW}O[mOowOs#hOxkOykO}`O!O]O!QxO!R}O!TpO!UlO!VlO!YzO!cjO!s#gO!y[O#W_O#bhO#daO#ebO#peO$ToO$]nO$^oO$aqO$zyO${!OO$}}O%O}O%V|O'g{O~O!y[O~O!y#kO~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#S#oO#U#nO#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O#X'OP~O!}#sO~P-UO!y#tO~O#b#vO#daO#ebO~O#p#xO~O!s#yO~OU$PO!R$PO!s$OO!v#}O#p2XO~OT&zXz&zX!S&zX!b&zX!m&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX&s&zX!x&zX!n&zX~O#u$RO#w$SO~P0rOP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{OT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX~Or$UO#S6yO#U6xO~P2yO!s#gO#peO~OS$gO]$bOk$eOm$gOs$aO!`$cO$drO$l$fO~O!s$kO!y$hO#S$jO~Oo$mOs$lO#b$nO~O!y$hO#S$rO~O$l$tO~P*kOR$zO!o$yO#b$xO#e$yO&q$zO~O'f$|O~P8lO!y%RO~O!y%TO~O!s%VO~O!m#cO&s#cO~P*kO!oXO~O!y%_O~OP6]OQ|OU^OW}O[6`Oo=YOs#hOx6^Oy6^O}`O!O]O!Q6dO!R}O!T6cO!U6_O!V6_O!Y6fO!c8fO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T6bO$]6aO$^6bO$aqO$z6eO${!OO$}}O%O}O%V|O'g{O~O!y%cO~O!s%dO~O]$bO~O!s%hO~O!s%iO~O!s%jO~O!oXO!s#gO#peO~O]%rOs%rO!o%pO!s#gO#p%nO~O!s%vO~O!i%wO&t%wO&wRO~O&t%zO~PhO!n%{O~PhOPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!q%}O~P>UO#X&PO~P>UO!o&SO!s&RO#b&RO~OPgOQ|OU^OW}O[8lOo=yOs#hOx8jOy8jO}`O!O]O!Q8pO!R}O!T8oO!U8kO!V8kO!Y8rO!c8iO!s&VO!y[O#U&WO#W_O#bhO#daO#ebO#peO$T8nO$]8mO$^8nO$aqO$z8qO${!OO$}}O%O}O%V|O'g{O~O!x'SP~PAOO!s&[O#b&[O~OT#TOz#RO!S#UO!b#VO!o!{O!v!yO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO~O!x&nO~PCqO!x'VX!}'VX#O'VX#X'VX!n'VXV'VX!q'VX#u'VX#w'VXw'VX~P&sO!y$hO#S&oO~Oo$mOs$lO~O!o&pO~O!}&sO#S;dO#U;cO!x'OP~P9yOT6iOz6gO!S6jO!b6kO!o!{O!v8sO!y!}O#S#QO#W!zO#`!|O#a!|O#s#PO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'PX#X'PX~O#O&tO~PGSO!}&wO#X'OX~O#X&yO~O!}'OO!x'QP~P9yO!n'PO~PCqO!m#oa!o#oa#S#oa#p#qX&s#oa!x#oa#O#oaw#oa~OT#oaz#oa!S#oa!b#oa!v#oa!y#oa#W#oa#`#oa#a#oa#s#oa#z#oa#{#oa#|#oa#}#oa$O#oa$Q#oa$R#oa$S#oa$T#oa$U#oa$V#oa$W#oa$z#oa!}#oa#X#oa!n#oaV#oa!q#oa#u#oa#w#oa~PIpO!s'RO~O!x'UO#l'SO~O!x'VX#l'VX#p#qX#S'VX#U'VX#b'VX!o'VX#O'VXw'VX!m'VX&s'VX~O#S'YO~P*kO!m$Xa&s$Xa!x$Xa!n$Xa~PCqO!m$Ya&s$Ya!x$Ya!n$Ya~PCqO!m$Za&s$Za!x$Za!n$Za~PCqO!m$[a&s$[a!x$[a!n$[a~PCqO!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO$z#dOT$[a!S$[a!b$[a!m$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a&s$[a!x$[a!n$[a~Oz#RO~PNyO!m$_a&s$_a!x$_a!n$_a~PCqO!y!}O!}$fX#X$fX~O!}'^O#X'ZX~O#X'`O~O!s$kO#S'aO~O]'cO~O!s'eO~O!s'fO~O$l'gO~O!`'mO#S'kO#U'lO#b'jO$drO!x'XP~P0aO!^'sO!oXO!q'rO~O!s'uO!y$hO~O!y$hO#S'wO~O!y$hO#S'yO~O#u'zO!m$sX!}$sX&s$sX~O!}'{O!m'bX&s'bX~O!m#cO&s#cO~O!q(PO#O(OO~O!m$ka&s$ka!x$ka!n$ka~PCqOl(ROw(SO!o(TO!y!}O~O!o!{O!y!}O#W!zO#`!|O#a!|O#s#PO~OT$yaz$ya!S$ya!b$ya!m$ya!v$ya#S$ya#z$ya#{$ya#|$ya#}$ya$O$ya$Q$ya$R$ya$S$ya$T$ya$U$ya$V$ya$W$ya$z$ya&s$ya!x$ya!}$ya#O$ya#X$ya!n$ya!q$yaV$ya#u$ya#w$ya~P!'WO!m$|a&s$|a!x$|a!n$|a~PCqO#W([O#`(YO#a(YO&r(ZOR&gX!o&gX#b&gX#e&gX&q&gX'f&gX~O'f(_O~P8lO!q(`O~PhO!o(cO!q(dO~O!q(`O&s(gO~PhO!a(kO~O!m(lO~P9yOZ(wOn(xO~O!s(zO~OT6iOz6gO!S6jO!b6kO!v8sO!}({O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'jX&s'jX~P!'WO#u)PO~O!})QO!m'`X&s'`X~Ol(RO!o(TO~Ow(SO!o)WO!q)ZO~O!m#cO!oXO&s#cO~O!o%pO!s#yO~OV)aO!})_O!m'kX&s'kX~O])cOs)cO!s#gO#peO~O!o%pO!s#gO#p)hO~OT6iOz6gO!S6jO!b6kO!v8sO!})iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&|X&s&|X#O&|X~P!'WOl(ROw(SO!o(TO~O!i)oO&t)oO~OT8vOz8tO!S8wO!b8xO!q)pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#X)rO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!n)rO~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'TX!}'TX~P!'WOT'VXz'VX!S'VX!b'VX!o'VX!v'VX!y'VX#S'VX#W'VX#`'VX#a'VX#p#qX#s'VX#z'VX#{'VX#|'VX#}'VX$O'VX$Q'VX$R'VX$S'VX$T'VX$U'VX$V'VX$W'VX$z'VX~O!q)tO!x'VX!}'VX~P!5xO!x#iX!}#iX~P>UO!})vO!x'SX~O!x)xO~O$z#dOT#yiz#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi$W#yi&s#yi!x#yi!}#yi#O#yi#X#yi!n#yi!q#yiV#yi#u#yi#w#yi~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi&s#yi!x#yi!n#yi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!b#VO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!m#yi&s#yi!x#yi!n#yi~P!'WOT#TOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dO!S#yi!b#yi!m#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi~P!'WOz#RO#S#QO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi~P!'WOz#RO$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi~P!'WOz#RO$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$S#_O$T#`O$V#bO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi~P!'WOz#RO$W#bO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi~P!'WO_)yO~P9yO!x)|O~O#S*PO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Ta#X#Ta#O#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}'Pa#X'Pa#O'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WO#S#oO#U#nO!}&WX#X&WX~P9yO!}&wO#X'Oa~O#X*SO~OT6iOz6gO!S6jO!b6kO!v8sO!}*UO#O*TO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'QX~P!'WO!}*UO!x'QX~O!x*WO~O!m#oi!o#oi#S#oi#p#qX&s#oi!x#oi#O#oiw#oi~OT#oiz#oi!S#oi!b#oi!v#oi!y#oi#W#oi#`#oi#a#oi#s#oi#z#oi#{#oi#|#oi#}#oi$O#oi$Q#oi$R#oi$S#oi$T#oi$U#oi$V#oi$W#oi$z#oi!}#oi#X#oi!n#oiV#oi!q#oi#u#oi#w#oi~P#*zO#l'SO!x#ka#S#ka#U#ka#b#ka!o#ka#O#kaw#ka!m#ka&s#ka~OPgOQ|OU^OW}O[4OOo5xOs#hOx3zOy3zO}`O!O]O!Q2^O!R}O!T4UO!U3|O!V3|O!Y2`O!c3xO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4SO$]4QO$^4SO$aqO$z2_O${!OO$}}O%O}O%V|O'g{O~O#l#oa#U#oa#b#oa~PIpOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pi!S#Pi!b#Pi!m#Pi&s#Pi!x#Pi!n#Pi~P!'WOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#vi!S#vi!b#vi!m#vi&s#vi!x#vi!n#vi~P!'WO!m#xi&s#xi!x#xi!n#xi~PCqO!s#gO#peO!}&^X#X&^X~O!}'^O#X'Za~O!s'uO~Ow(SO!o)WO!q*fO~O!s*jO~O#S*lO#U*mO#b*kO#l'SO~O#S*lO#U*mO#b*kO$drO~P0aO#u*oO!x$cX!}$cX~O#U*mO#b*kO~O#b*pO~O#b*rO~P0aO!}*sO!x'XX~O!x*uO~O!y*wO~O!^*{O!oXO!q*zO~O!q*}O!o'ci!m'ci&s'ci~O!q+QO#O+PO~O#b$nO!m&eX!}&eX&s&eX~O!}'{O!m'ba&s'ba~OT$kiz$ki!S$ki!b$ki!m$ki!o$ki!v$ki!y$ki#S$ki#W$ki#`$ki#a$ki#s$ki#u#fa#w#fa#z$ki#{$ki#|$ki#}$ki$O$ki$Q$ki$R$ki$S$ki$T$ki$U$ki$V$ki$W$ki$z$ki&s$ki!x$ki!}$ki#O$ki#X$ki!n$ki!q$kiV$ki~OS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n+hO#b$nO$aqO$drO~P0aO!s+lO~O#W+nO#`+mO#a+mO~O!s+pO#b+pO$}+pO%T+oO~O!n+qO~PCqOc%XXd%XXh%XXj%XXf%XXg%XXe%XX~PhOc+uOd+sOP%WiQ%WiS%WiU%WiW%WiX%Wi[%Wi]%Wi^%Wi`%Wia%Wib%Wik%Wim%Wio%Wip%Wiq%Wis%Wit%Wiu%Wiv%Wix%Wiy%Wi|%Wi}%Wi!O%Wi!P%Wi!Q%Wi!R%Wi!T%Wi!U%Wi!V%Wi!W%Wi!X%Wi!Y%Wi!Z%Wi![%Wi!]%Wi!^%Wi!`%Wi!a%Wi!c%Wi!m%Wi!o%Wi!s%Wi!y%Wi#W%Wi#b%Wi#d%Wi#e%Wi#p%Wi$T%Wi$]%Wi$^%Wi$a%Wi$d%Wi$l%Wi$z%Wi${%Wi$}%Wi%O%Wi%V%Wi&p%Wi'g%Wi&t%Wi!n%Wih%Wij%Wif%Wig%WiY%Wi_%Wii%Wie%Wi~Oc+yOd+vOh+xO~OY+zO_+{O!n,OO~OY+zO_+{Oi%^X~Oi,QO~Oj,RO~O!m,TO~P9yO!m,VO~Of,WO~OT6iOV,XOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOg,YO~O!y,ZO~OZ(wOn(xOP%liQ%liS%liU%liW%liX%li[%li]%li^%li`%lia%lib%lik%lim%lio%lip%liq%lis%lit%liu%liv%lix%liy%li|%li}%li!O%li!P%li!Q%li!R%li!T%li!U%li!V%li!W%li!X%li!Y%li!Z%li![%li!]%li!^%li!`%li!a%li!c%li!m%li!o%li!s%li!y%li#W%li#b%li#d%li#e%li#p%li$T%li$]%li$^%li$a%li$d%li$l%li$z%li${%li$}%li%O%li%V%li&p%li'g%li&t%li!n%lic%lid%lih%lij%lif%lig%liY%li_%lii%lie%li~O#u,_O~O!}({O!m%da&s%da~O!x,bO~O!s%dO!m&dX!}&dX&s&dX~O!})QO!m'`a&s'`a~OS+^OY,iOm+^Os$aO!^+dO!_+^O!`+^O$aqO$drO~O!n,lO~P#JwO!o)WO~O!o%pO!s'RO~O!s#gO#peO!m&nX!}&nX&s&nX~O!})_O!m'ka&s'ka~O!s,rO~OV,sO!n%|X!}%|X~O!},uO!n'lX~O!n,wO~O!m&UX!}&UX&s&UX#O&UX~P9yO!})iO!m&|a&s&|a#O&|a~Oz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq&s!uq!x!uq!n!uq~P!'WO!n,|O~PCqOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#ia!}#ia~P!'WO!x&YX!}&YX~PAOO!})vO!x'Sa~O#O-QO~O!}-RO!n&{X~O!n-TO~O!x-UO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vi#X#Vi~P!'WO!x&XX!}&XX~P9yO!}*UO!x'Qa~O!x-[O~OT#jqz#jq!S#jq!b#jq!m#jq!v#jq#S#jq#u#jq#w#jq#z#jq#{#jq#|#jq#}#jq$O#jq$Q#jq$R#jq$S#jq$T#jq$U#jq$V#jq$W#jq$z#jq&s#jq!x#jq!}#jq#O#jq#X#jq!n#jq!q#jqV#jq~P!'WO#l#oi#U#oi#b#oi~P#*zOz#RO!v!yO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT#Pq!S#Pq!b#Pq!m#Pq&s#Pq!x#Pq!n#Pq~P!'WO#u-dO!x$ca!}$ca~O#U-fO#b-eO~O#b-gO~O#S-hO#U-fO#b-eO#l'SO~O#b-jO#l'SO~O#u-kO!x$ha!}$ha~O!`'mO#S'kO#U'lO#b'jO$drO!x&_X!}&_X~P0aO!}*sO!x'Xa~O!oXO#l'SO~O#S-pO#b-oO!x'[P~O!oXO!q-rO~O!q-uO!o'cq!m'cq&s'cq~O!^-wO!oXO!q-rO~O!q-{O#O-zO~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$si!}$si&s$si~P!'WO!m$jq&s$jq!x$jq!n$jq~PCqO#O-zO#l'SO~O!}-|Ow']X!o']X!m']X&s']X~O#b$nO#l'SO~OS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO$drO~P0aOS+^O].ROm+^Os$aO!_+^O!`+^O#b$nO$aqO~P0aOS+^O]+aOm+^Os$aO!^+dO!_+^O!`+^O!n.ZO#b$nO$aqO$drO~P0aO!s.^O~O!s._O#b._O$}._O%T+oO~O$}.`O~O#X.aO~Oc%Xad%Xah%Xaj%Xaf%Xag%Xae%Xa~PhOc.dOd+sOP%WqQ%WqS%WqU%WqW%WqX%Wq[%Wq]%Wq^%Wq`%Wqa%Wqb%Wqk%Wqm%Wqo%Wqp%Wqq%Wqs%Wqt%Wqu%Wqv%Wqx%Wqy%Wq|%Wq}%Wq!O%Wq!P%Wq!Q%Wq!R%Wq!T%Wq!U%Wq!V%Wq!W%Wq!X%Wq!Y%Wq!Z%Wq![%Wq!]%Wq!^%Wq!`%Wq!a%Wq!c%Wq!m%Wq!o%Wq!s%Wq!y%Wq#W%Wq#b%Wq#d%Wq#e%Wq#p%Wq$T%Wq$]%Wq$^%Wq$a%Wq$d%Wq$l%Wq$z%Wq${%Wq$}%Wq%O%Wq%V%Wq&p%Wq'g%Wq&t%Wq!n%Wqh%Wqj%Wqf%Wqg%WqY%Wq_%Wqi%Wqe%Wq~Oc.iOd+vOh.hO~O!q(`O~OP6]OQ|OU^OW}O[:fOo>ROs#hOx:dOy:dO}`O!O]O!Q:kO!R}O!T:jO!U:eO!V:eO!Y:oO!c8gO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:hO$]:gO$^:hO$aqO$z:mO${!OO$}}O%O}O%V|O'g{O~O!m.lO!q.lO~OY+zO_+{O!n.nO~OY+zO_+{Oi%^a~O!x.rO~P>UO!m.tO~O!m.tO~P9yOQ|OW}O!R}O$}}O%O}O%V|O'g{O~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&ka!}&ka&s&ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m$qi!}$qi&s$qi~P!'WOS+^Om+^Os$aO!_+^O!`+^O$aqO$drO~OY/PO~P$?VOS+^Om+^Os$aO!_+^O!`+^O$aqO~O!s/QO~O!n/SO~P#JwOw(SO!o)WO#l'SO~OV/VO!m&na!}&na&s&na~O!})_O!m'ki&s'ki~O!s/XO~OV/YO!n%|a!}%|a~O]/[Os/[O!s#gO#peO!n&oX!}&oX~O!},uO!n'la~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m&Ua!}&Ua&s&Ua#O&Ua~P!'WOz#RO#S#QO#z#SO#{#WO#|#XO#}#YO$O#ZO$Q#]O$R#^O$S#_O$T#`O$U#aO$V#bO$W#bO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy&s!uy!x!uy!n!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#hi!}#hi~P!'WO_)yO!n&VX!}&VX~P9yO!}-RO!n&{a~OT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#Vq#X#Vq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#[i!}#[i~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O/cO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x&Xa!}&Xa~P!'WO#u/iO!x$ci!}$ci~O#b/jO~O#U/lO#b/kO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$ci!}$ci~P!'WO#u/mO!x$hi!}$hi~O!}/oO!x'[X~O#b/qO~O!x/rO~O!oXO!q/uO~O#l'SO!o'cy!m'cy&s'cy~O!m$jy&s$jy!x$jy!n$jy~PCqO#O/xO#l'SO~O!s#gO#peOw&aX!o&aX!}&aX!m&aX&s&aX~O!}-|Ow']a!o']a!m']a&s']a~OU$PO]0QO!R$PO!s$OO!v#}O#b$nO#p2XO~P$?uO!m#cO!o0VO&s#cO~O#X0YO~Oh0_O~OT:tOz:pO!S:vO!b:xO!m0`O!q0`O!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO~P!'WOY%]a_%]a!n%]ai%]a~PhO!x0bO~O!x0bO~P>UO!m0dO~OT6iOz6gO!S6jO!b6kO!v8sO!x0fO#O0eO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WO!x0fO~O!x0gO#b0hO#l'SO~O!x0iO~O!s0jO~O!m#cO#u0lO&s#cO~O!s0mO~O!})_O!m'kq&s'kq~O!s0nO~OV0oO!n%}X!}%}X~OT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!n!|i!}!|i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cq!}$cq~P!'WO#u0vO!x$cq!}$cq~O#b0wO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hq!}$hq~P!'WO#S0zO#b0yO!x&`X!}&`X~O!}/oO!x'[a~O#l'SO!o'c!R!m'c!R&s'c!R~O!oXO!q1PO~O!m$j!R&s$j!R!x$j!R!n$j!R~PCqO#O1RO#l'SO~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1^O!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOh1_O~OY%[i_%[i!n%[ii%[i~PhOY%]i_%]i!n%]ii%]i~PhO!x1bO~O!x1bO~P>UO!x1eO~O!m#cO#u1iO&s#cO~O$}1jO%V1jO~O!s1kO~OV1lO!n%}a!}%}a~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#]i!}#]i~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$cy!}$cy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$hy!}$hy~P!'WO#b1nO~O!}/oO!x'[i~O!m$j!Z&s$j!Z!x$j!Z!n$j!Z~PCqOT:uOz:qO!S:wO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO~P!'WOV1uO{1tO~P!5xOV1uO{1tOT&}Xz&}X!S&}X!b&}X!o&}X!v&}X!y&}X#S&}X#W&}X#`&}X#a&}X#s&}X#u&}X#w&}X#z&}X#{&}X#|&}X#}&}X$O&}X$Q&}X$R&}X$S&}X$T&}X$U&}X$V&}X$W&}X$z&}X~OP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!n1xO!s1YO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOY%[q_%[q!n%[qi%[q~PhO!x1zO~O!x%gi~PCqOe1{O~O$}1|O%V1|O~O!s2OO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x$c!R!}$c!R~P!'WO!m$j!c&s$j!c!x$j!c!n$j!c~PCqO!s2QO~O!`2SO!s2RO~O!s2VO!m$xi&s$xi~O!s'WO~O!s*]O~OT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$ka#u$ka#w$ka&s$ka!x$ka!n$ka!q$ka#X$ka!}$ka~P!'WO#S2]O~P*kO$l$tO~P#.YOT6iOz6gO!S6jO!b6kO!v8sO#O2[O#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX&s'PX!x'PX!n'PX~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O3uO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'PX#X'PX#u'PX#w'PX!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~P!'WO#S3dO~P#.YOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Xa#u$Xa#w$Xa&s$Xa!x$Xa!n$Xa!q$Xa#X$Xa!}$Xa~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Ya#u$Ya#w$Ya&s$Ya!x$Ya!n$Ya!q$Ya#X$Ya!}$Ya~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$Za#u$Za#w$Za&s$Za!x$Za!n$Za!q$Za#X$Za!}$Za~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$[a#u$[a#w$[a&s$[a!x$[a!n$[a!q$[a#X$[a!}$[a~P!'WOz2aO#u$[a#w$[a!q$[a#X$[a!}$[a~PNyOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$_a#u$_a#w$_a&s$_a!x$_a!n$_a!q$_a#X$_a!}$_a~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$|a#u$|a#w$|a&s$|a!x$|a!n$|a!q$|a#X$|a!}$|a~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!S#yi!b#yi!m#yi#u#yi#w#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO#S#QO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$S2mO$T2nO$V2pO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOz2aO$W2pO$z#dOT#yi!S#yi!b#yi!m#yi!v#yi#S#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi&s#yi!x#yi!n#yi!q#yi#X#yi!}#yi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#Ta#u#Ta#w#Ta&s#Ta!x#Ta!n#Ta!q#Ta#X#Ta!}#Ta~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m'Pa#u'Pa#w'Pa&s'Pa!x'Pa!n'Pa!q'Pa#X'Pa!}'Pa~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pi!S#Pi!b#Pi!m#Pi#u#Pi#w#Pi&s#Pi!x#Pi!n#Pi!q#Pi#X#Pi!}#Pi~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#vi!S#vi!b#vi!m#vi#u#vi#w#vi&s#vi!x#vi!n#vi!q#vi#X#vi!}#vi~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m#xi#u#xi#w#xi&s#xi!x#xi!n#xi!q#xi#X#xi!}#xi~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uq!S!uq!b!uq!m!uq!v!uq#u!uq#w!uq&s!uq!x!uq!n!uq!q!uq#X!uq!}!uq~P!'WOz2aO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT#Pq!S#Pq!b#Pq!m#Pq#u#Pq#w#Pq&s#Pq!x#Pq!n#Pq!q#Pq#X#Pq!}#Pq~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jq#u$jq#w$jq&s$jq!x$jq!n$jq!q$jq#X$jq!}$jq~P!'WOz2aO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dOT!uy!S!uy!b!uy!m!uy!v!uy#u!uy#w!uy&s!uy!x!uy!n!uy!q!uy#X!uy!}!uy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$jy#u$jy#w$jy&s$jy!x$jy!n$jy!q$jy#X$jy!}$jy~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!R#u$j!R#w$j!R&s$j!R!x$j!R!n$j!R!q$j!R#X$j!R!}$j!R~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!Z#u$j!Z#w$j!Z&s$j!Z!x$j!Z!n$j!Z!q$j!Z#X$j!Z!}$j!Z~P!'WOT2cOz2aO!S2dO!b2eO!v4WO#S#QO#z2bO#{2fO#|2gO#}2hO$O2iO$Q2kO$R2lO$S2mO$T2nO$U2oO$V2pO$W2pO$z#dO!m$j!c#u$j!c#w$j!c&s$j!c!x$j!c!n$j!c!q$j!c#X$j!c!}$j!c~P!'WOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S3vO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lO#u2uO#w2vO!q&zX#X&zX!}&zX~P0rOP6]OU^O[4POo8^Or2wOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S2tO#U2sO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!v#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX&s#xX!x#xX!n#xX!q#xX#X#xX!}#xX~P$;lOP6]OU^O[4POo8^Or4xOs#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S4uO#U4tO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OOT#xXz#xX!S#xX!b#xX!o#xX!v#xX!}#xX#O#xX#X#xX#`#xX#a#xX#s#xX#u#xX#w#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!m#xX&s#xX!x#xX!n#xXV#xX!q#xX~P$;lO!q3PO~P>UO!q5}O#O3gO~OT8vOz8tO!S8wO!b8xO!q3hO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q6OO#O3kO~O!q6PO#O3oO~O#O3oO#l'SO~O#O3pO#l'SO~O#O3sO#l'SO~OP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$l$tO$z4bO${!OO~P$;lOP6]OU^O[4POo8^Os#hOx3{Oy3{O}`O!O]O!Q4aO!T4VO!U3}O!V3}O!Y4cO!c3yO!s#gO!y[O#S5eO#W_O#bhO#daO#ebO#peO$T4TO$]4RO$^4TO$aqO$z4bO${!OO~P$;lOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Xa#O$Xa#X$Xa#u$Xa#w$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Ya#O$Ya#X$Ya#u$Ya#w$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$Za#O$Za#X$Za#u$Za#w$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$[a#O$[a#X$[a#u$[a#w$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz4dO!}$[a#O$[a#X$[a#u$[a#w$[aV$[a!q$[a~PNyOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$_a#O$_a#X$_a#u$_a#w$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$|a#O$|a#X$|a#u$|a#w$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi#u#yi#w#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO#S#QO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$S4pO$T4qO$V4sO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz4dO$W4sO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#u#yi#w#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#Ta#O#Ta#X#Ta#u#Ta#w#Ta!m#Ta&s#Ta!x#Ta!n#TaV#Ta!q#Ta~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}'Pa#O'Pa#X'Pa#u'Pa#w'Pa!m'Pa&s'Pa!x'Pa!n'PaV'Pa!q'Pa~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi#u#Pi#w#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi#u#vi#w#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}#xi#O#xi#X#xi#u#xi#w#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq#u!uq#w!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOz4dO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq#u#Pq#w#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jq#O$jq#X$jq#u$jq#w$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOz4dO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy#u!uy#w!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$jy#O$jy#X$jy#u$jy#w$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!R#O$j!R#X$j!R#u$j!R#w$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!Z#O$j!Z#X$j!Z#u$j!Z#w$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$j!c#O$j!c#X$j!c#u$j!c#w$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S5wO~P#.YO!y$hO#S5{O~O!x4ZO#l'SO~O!y$hO#S5|O~OT4fOz4dO!S4gO!b4hO!v6TO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!}$ka#O$ka#X$ka#u$ka#w$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT4fOz4dO!S4gO!b4hO!v6TO#O5vO#S#QO#z4eO#{4iO#|4jO#}4kO$O4lO$Q4nO$R4oO$S4pO$T4qO$U4rO$V4sO$W4sO$z#dO!m'PX#u'PX#w'PX&s'PX!x'PX!n'PX!q'PX#X'PX!}'PX~P!'WO#u4vO#w4wO!}&zX#O&zX#X&zXV&zX!q&zX~P0rO!q5QO~P>UO!q8bO#O5hO~OT8vOz8tO!S8wO!b8xO!q5iO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q8cO#O5lO~O!q8dO#O5pO~O#O5pO#l'SO~O#O5qO#l'SO~O#O5tO#l'SO~O$l$tO~P9yOo5zOs$lO~O#S7oO~P9yOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Xa#O$Xa#X$Xa!m$Xa&s$Xa!x$Xa!n$XaV$Xa!q$Xa~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Ya#O$Ya#X$Ya!m$Ya&s$Ya!x$Ya!n$YaV$Ya!q$Ya~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$Za#O$Za#X$Za!m$Za&s$Za!x$Za!n$ZaV$Za!q$Za~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$[a#O$[a#X$[a!m$[a&s$[a!x$[a!n$[aV$[a!q$[a~P!'WOz6gO!}$[a#O$[a#X$[aV$[a!q$[a~PNyOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$_a#O$_a#X$_a!m$_a&s$_a!x$_a!n$_aV$_a!q$_a~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$ka#O$ka#X$ka!m$ka&s$ka!x$ka!n$kaV$ka!q$ka~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$|a#O$|a#X$|a!m$|a&s$|a!x$|a!n$|aV$|a!q$|a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7sO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'jX~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO!}7uO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&|X~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOT6iOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!S#yi!b#yi!}#yi#O#yi#X#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO#S#QO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$S6sO$T6tO$V6vO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WOz6gO$W6vO$z#dOT#yi!S#yi!b#yi!v#yi!}#yi#O#yi#S#yi#X#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!m#yi&s#yi!x#yi!n#yiV#yi!q#yi~P!'WO#S7zO~P>UO!m#Ta&s#Ta!x#Ta!n#Ta~PCqO!m'Pa&s'Pa!x'Pa!n'Pa~PCqO#S;dO#U;cO!x&WX!}&WX~P9yO!}7lO!x'Oa~Oz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pi!S#Pi!b#Pi!}#Pi#O#Pi#X#Pi!m#Pi&s#Pi!x#Pi!n#PiV#Pi!q#Pi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#vi!S#vi!b#vi!}#vi#O#vi#X#vi!m#vi&s#vi!x#vi!n#viV#vi!q#vi~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}#xi#O#xi#X#xi!m#xi&s#xi!x#xi!n#xiV#xi!q#xi~P!'WO!}7sO!x%da~O!x&UX!}&UX~P>UO!}7uO!x&|a~Oz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uq!S!uq!b!uq!v!uq!}!uq#O!uq#X!uq!m!uq&s!uq!x!uq!n!uqV!uq!q!uq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vi!}#Vi~P!'WOz6gO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT#Pq!S#Pq!b#Pq!}#Pq#O#Pq#X#Pq!m#Pq&s#Pq!x#Pq!n#PqV#Pq!q#Pq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jq#O$jq#X$jq!m$jq&s$jq!x$jq!n$jqV$jq!q$jq~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&ka!}&ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x&Ua!}&Ua~P!'WOz6gO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dOT!uy!S!uy!b!uy!v!uy!}!uy#O!uy#X!uy!m!uy&s!uy!x!uy!n!uyV!uy!q!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Vq!}#Vq~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$jy#O$jy#X$jy!m$jy&s$jy!x$jy!n$jyV$jy!q$jy~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!R#O$j!R#X$j!R!m$j!R&s$j!R!x$j!R!n$j!RV$j!R!q$j!R~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!Z#O$j!Z#X$j!Z!m$j!Z&s$j!Z!x$j!Z!n$j!ZV$j!Z!q$j!Z~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!}$j!c#O$j!c#X$j!c!m$j!c&s$j!c!x$j!c!n$j!cV$j!c!q$j!c~P!'WO#S8[O~P9yO#O8ZO!m'PX&s'PX!x'PX!n'PXV'PX!q'PX~PGSO!y$hO#S8`O~O!y$hO#S8aO~O#u6zO#w6{O!}&zX#O&zX#X&zXV&zX!q&zX~P0rOr6|O#S#oO#U#nO!}#xX#O#xX#X#xXV#xX!q#xX~P2yOr;iO#S9XO#U9VOT#xXz#xX!S#xX!b#xX!m#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX!n#xX!}#xX~P9yOr9WO#S9WO#U9WOT#xXz#xX!S#xX!b#xX!o#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX~P9yOr9]O#S;dO#U;cOT#xXz#xX!S#xX!b#xX!o#xX!q#xX!v#xX#`#xX#a#xX#s#xX#z#xX#{#xX#|#xX#}#xX$O#xX$Q#xX$R#xX$S#xX$U#xX$V#xX$W#xX#X#xX!x#xX!}#xX~P9yO$l$tO~P>UO!q7XO~P>UOT6iOz6gO!S6jO!b6kO!v8sO#O7iO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!x'PX!}'PX~P!'WOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lO!}7lO!x'OX~O#S9yO~P>UOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Xa#X$Xa!x$Xa!}$Xa~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Ya#X$Ya!x$Ya!}$Ya~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$Za#X$Za!x$Za!}$Za~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$[a#X$[a!x$[a!}$[a~P!'WOz8tO$z#dOT$[a!S$[a!b$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a#X$[a!x$[a!}$[a~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$_a#X$_a!x$_a!}$_a~P!'WO!q=dO#O7rO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$ka#X$ka!x$ka!}$ka~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$|a#X$|a!x$|a!}$|a~P!'WOT8vOz8tO!S8wO!b8xO!q7wO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!q#yi#X#yi!x#yi!}#yi~P!'WOT8vOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!S#yi!b#yi!q#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi#X#yi!x#yi!}#yi~P!'WOz8tO#S#QO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi#X#yi!x#yi!}#yi~P!'WOz8tO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi#X#yi!x#yi!}#yi~P!'WOz8tO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$S9QO$T9RO$V9TO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi#X#yi!x#yi!}#yi~P!'WOz8tO$W9TO$z#dOT#yi!S#yi!b#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi#X#yi!x#yi!}#yi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pi!S#Pi!b#Pi!q#Pi#X#Pi!x#Pi!}#Pi~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#vi!S#vi!b#vi!q#vi#X#vi!x#vi!}#vi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q#xi#X#xi!x#xi!}#xi~P!'WO!q=eO#O7|O~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uq!S!uq!b!uq!q!uq!v!uq#X!uq!x!uq!}!uq~P!'WOz8tO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT#Pq!S#Pq!b#Pq!q#Pq#X#Pq!x#Pq!}#Pq~P!'WO!q=iO#O8TO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jq#X$jq!x$jq!}$jq~P!'WO#O8TO#l'SO~Oz8tO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dOT!uy!S!uy!b!uy!q!uy!v!uy#X!uy!x!uy!}!uy~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$jy#X$jy!x$jy!}$jy~P!'WO#O8UO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!R#X$j!R!x$j!R!}$j!R~P!'WO#O8XO#l'SO~OT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!Z#X$j!Z!x$j!Z!}$j!Z~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!q$j!c#X$j!c!x$j!c!}$j!c~P!'WO#S:bO~P>UO#O:aO!q'PX!x'PX~PGSO$l$tO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$l$tO$z:nO${!OO~P$;lOo8_Os$lO~O#S<jO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S<kO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Xa!q$Xa!n$Xa!}$Xa~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Ya!q$Ya!n$Ya!}$Ya~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$Za!q$Za!n$Za!}$Za~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$[a!q$[a!n$[a!}$[a~P!'WOz:pO$z#dOT$[a!S$[a!b$[a!m$[a!q$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a!n$[a!}$[a~P!'WOz:qO$z#dOT$[a!S$[a!b$[a!v$[a#S$[a#z$[a#{$[a#|$[a#}$[a$O$[a$Q$[a$R$[a$S$[a$T$[a$U$[a$V$[a$W$[a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$_a!q$_a!n$_a!}$_a~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$ka!q$ka!n$ka!}$ka~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$|a!q$|a!n$|a!}$|a~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi!n#yi!}#yi~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi~P!'WOT:tOz:pO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!b:yO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi~P!'WOT:tOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!S#yi!b#yi!m#yi!q#yi!n#yi!}#yi~P!'WOT:uOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dO!S#yi!b#yi~P!'WOz:pO#S#QO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi!n#yi!}#yi~P!'WOz:qO#S#QO#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi~P!'WOz:pO#S#QO#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi!n#yi!}#yi~P!'WOz:qO#S#QO#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi~P!'WOz:pO#S#QO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi!n#yi!}#yi~P!'WOz:qO#S#QO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi~P!'WOz:pO#S#QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO#S#QO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi!n#yi!}#yi~P!'WOz:qO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi~P!'WOz:pO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi!n#yi!}#yi~P!'WOz:qO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi~P!'WOz:pO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi~P!'WOz:pO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi!n#yi!}#yi~P!'WOz:qO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$U#yi~P!'WOz:pO$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi!n#yi!}#yi~P!'WOz:qO$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi~P!'WOz:pO$S;YO$T;[O$V;`O$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi!n#yi!}#yi~P!'WOz:qO$S;ZO$T;]O$V;aO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$U#yi~P!'WOz:pO$W;`O$z#dOT#yi!S#yi!b#yi!m#yi!q#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi!n#yi!}#yi~P!'WOz:qO$W;aO$z#dOT#yi!S#yi!b#yi!v#yi#S#yi#z#yi#{#yi#|#yi#}#yi$O#yi$Q#yi$R#yi$S#yi$T#yi$U#yi$V#yi~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x#Ta!}#Ta!q#Ta#X#Ta~P!'WOT8vOz8tO!S8wO!b8xO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO!x'Pa!}'Pa!q'Pa#X'Pa~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pi!S#Pi!b#Pi!m#Pi!q#Pi!n#Pi!}#Pi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pi!S#Pi!b#Pi~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#vi!S#vi!b#vi!m#vi!q#vi!n#vi!}#vi~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#vi!S#vi!b#vi~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#xi!q#xi!n#xi!}#xi~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uq!S!uq!b!uq!m!uq!q!uq!v!uq!n!uq!}!uq~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uq!S!uq!b!uq!v!uq~P!'WOz:pO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT#Pq!S#Pq!b#Pq!m#Pq!q#Pq!n#Pq!}#Pq~P!'WOz:qO!v=nO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT#Pq!S#Pq!b#Pq~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jq!q$jq!n$jq!}$jq~P!'WOz:pO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dOT!uy!S!uy!b!uy!m!uy!q!uy!v!uy!n!uy!}!uy~P!'WOz:qO#S#QO#z:sO#{:{O#|:}O#};PO$O;RO$Q;VO$R;XO$S;ZO$T;]O$U;_O$V;aO$W;aO$z#dOT!uy!S!uy!b!uy!v!uy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$jy!q$jy!n$jy!}$jy~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!R!q$j!R!n$j!R!}$j!R~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!Z!q$j!Z!n$j!Z!}$j!Z~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m$j!c!q$j!c!n$j!c!}$j!c~P!'WO#S=TO~P$8YOP6]OU^O[9WOo>SOs#hOx9WOy9WO}`O!O]O!Q:lO!T9WO!U9WO!V9WO!Y9WO!c8hO!s#gO!y[O#S=UO#W_O#bhO#daO#ebO#peO$T:iO$]9WO$^:iO$aqO$z:nO${!OO~P$;lOT6iOz6gO!S6jO!b6kO!v8sO#O=SO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO~P!'WOT6iOz6gO!S6jO!b6kO!v8sO#O=RO#S#QO#z6hO#{6lO#|6mO#}6nO$O6oO$Q6qO$R6rO$S6sO$T6tO$U6uO$V6vO$W6vO$z#dO!m'PX!q'PX!n'PX!}'PX~P!'WOT&zXz&zX!S&zX!b&zX!o&zX!q&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX!}&zX~O#u9ZO#w9[O#X&zX!x&zX~P.8oO!y$hO#S=^O~O!q9hO~P>UO!y$hO#S=cO~O!q>OO#O9}O~OT8vOz8tO!S8wO!b8xO!q:OO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m#Ta!q#Ta!n#Ta!}#Ta~P!'WOT:tOz:pO!S:vO!b:xO!v=mO#S#QO#z:rO#{:zO#|:|O#};OO$O;QO$Q;UO$R;WO$S;YO$T;[O$U;^O$V;`O$W;`O$z#dO!m'Pa!q'Pa!n'Pa!}'Pa~P!'WO!q>PO#O:RO~O!q>QO#O:YO~O#O:YO#l'SO~O#O:ZO#l'SO~O#O:_O#l'SO~O#u;eO#w;gO!m&zX!n&zX~P.8oO#u;fO#w;hOT&zXz&zX!S&zX!b&zX!o&zX!v&zX!y&zX#S&zX#W&zX#`&zX#a&zX#s&zX#z&zX#{&zX#|&zX#}&zX$O&zX$Q&zX$R&zX$S&zX$T&zX$U&zX$V&zX$W&zX$z&zX~O!q;tO~P>UO!q;uO~P>UO!q>XO#O<oO~O!q>YO#O9WO~OT8vOz8tO!S8wO!b8xO!q<pO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WOT8vOz8tO!S8wO!b8xO!q<qO!v=ZO#S#QO#z8uO#{8yO#|8zO#}8{O$O8|O$Q9OO$R9PO$S9QO$T9RO$U9SO$V9TO$W9TO$z#dO~P!'WO!q>ZO#O<vO~O!q>[O#O<{O~O#O<{O#l'SO~O#O9WO#l'SO~O#O<|O#l'SO~O#O=PO#l'SO~O!y$hO#S=|O~Oo=[Os$lO~O!y$hO#S=}O~O!y$hO#S>UO~O!y$hO#S>VO~O!y$hO#S>WO~Oo={Os$lO~Oo>TOs$lO~Oo>SOs$lO~O%O$U$}$d!d$V#b%V#e'g!s#d~",
  goto: "%&y'mPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP'nP'uPP'{(OPPP(hP(OP(O*ZP*ZPP2W:j:mPP*Z:sBpPBsPBsPP:sCSCVCZ:s:sPPPC^PP:sK^!$S!$S:s!$WP!$W!$W!%UP!.]!7pP!?oP*ZP*Z*ZPPPPP!?rPPPPPPP*Z*Z*Z*ZPP*Z*ZP!E]!GRP!GV!Gy!GR!GR!HP*Z*ZP!HY!Hl!Ib!J`!Jd!J`!Jo!J}!J}!KV!KY!KY*ZPP*ZPP!K^#%[#%[#%`P#%fP(O#%j(O#&S#&V#&V#&](O#&`(O(O#&f#&i(O#&r#&u(O(O(O(O(O#&x(O(O(O(O(O(O(O(O(O#&{!KR(O(O#'_#'o#'r(O(OP#'u#'|#(S#(o#(y#)P#)Z#)b#)h#*d#4X#5T#5Z#5a#5k#5q#5w#6]#6c#6i#6o#6u#6{#7R#7]#7g#7m#7s#7}PPPPPPPP#8T#8X#8}#NO#NR#N]$(f$(r$)X$)_$)b$)e$)k$,X$5v$>_$>b$>h$>k$>n$>w$>{$?X$?k$Bk$CO$C{$K{PP%%y%%}%&Z%&p%&vQ!nQT!qV!rQUOR%x!mRVO}!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a|!hPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ%^!ZQ%g!aQ%l!eQ'd$dQ'q$iQ)[%kQ*y'tQ,](xU-n*v*x+OQ.W+cQ.{,[S/t-s-tQ0T.SS0}/s/wQ1V0RQ1o1OR2P1p0u!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nQ#j]Q$}!PQ%O!QQ%P!RQ,S(kQ.b+sR.f+vR&q#jQ)z&pR/a-R0uhPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#l^k#p_j#k#s&s&w3x3y7l8f8g8h8iR#u`T&|#t'OR-Y*U0thPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR#va-r#OZ#f#m#w$V$W$X$Y$Z$[$u$v%W%Y%[%`%s%|&O&Q&U&^&_&`&a&b&c&d&e&f&g&h&i&j&k&l&m&u&v&{'X'Z'[(](p)q)s)u*O*[*^+S+V,`,c,y,{,}-V-W-X-i-x.k.w/`/h/n/y0r0u0x1Q1X1d1m1q2q2r2x2y2z2{2|2}3O3Q3R3S3T3U3V3W3X3Y3Z3[3]3^3_3`3a3b3c3e3f3i3j3l3m3n3q3r3t4Y4y4z4{4|4}5O5P5R5S5T5U5V5W5X5Y5Z5[5]5^5_5`5a5b5c5d5f5g5j5k5m5n5o5r5s5u6R6V6}7O7P7Q7R7S7U7V7W7Y7Z7[7]7^7_7`7a7b7c7d7e7f7g7h7j7k7n7p7q7x7y7{7}8O8P8Q8R8S8V8W8Y8]9U9^9_9`9a9b9c9f9g9i9j9k9l9m9n9o9p9q9r9s9t9u9v9w9x9z9{:P:Q:T:V:W:[:^:`:c;j;k;l;m;n;o;p;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<T<U<V<W<X<Y<Z<[<]<^<_<`<a<b<c<d<e<f<g<h<i<l<m<n<r<s<t<u<w<x<y<z<}=O=Q=V=W=_=`=a=q=rQ']$]Y(Q$s7T9e;q;rS(U2Z6QR(X$tT&X!})v!w$Qg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[3ZfPVX[_bgjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#}$R$S$U$h$y$}%P%R%S%T%U%c%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)_)c)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[3scPVX[_bdegjklmnoprxyz!S!W!X!Y!]!e!f!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t#{#}$R$S$U$h$y$}%P%R%S%T%U%c%m%n%p%r%}&S&W&p&s&t&w'O'S'U'Y'^'i'm'r'z(O(P(R(S(T(`(l({)P)Z)^)_)c)g)h)i)p)t)v*P*T*U*f*o*s*z*}+P+Q+]+`+d+g+r+u+z,T,V,X,Z,u,x-Q-R-d-k-r-u-z-{-|.Q.b.d.l.t/[/c/i/m/u/x0V0`0a0d0e0i0v1P1R1]1a2W2X2Y2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w5}6O6P6T6]6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8b8c8d8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=d=e=i=m=n>O>P>Q>X>Y>Z>[0phPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0`0a0d0e0i0v1R1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT1Z0V1]R&]#P!n#[Z#f#w$V$W$X$Y$[$s$v%W%Y%[&Q&_&`&a&b&c&d&e&f'X'Z'[(])q)s*^+V,{-x/y1Q1d1q7j7k!Y2j2Z2x2y2z2{2}3O3Q3R3S3T3U3V3W3X3a3b3c3e3f3i3j3l3m3n3q3r3t!^4m2r4y4z4{4|5O5P5R5S5T5U5V5W5X5Y5b5c5d5f5g5j5k5m5n5o5r5s5u6Q6R#Q6p#m%`%s&u&v&{(p*O+S,`,c,y-V-X.w2q6}7O7P7Q7S7T7U7Y7Z7[7]7^7_7`7a7n7p7q7x7{7}8Q8S8V8W8Y8]9U:c=V=W#^8}%|&O&U)u,}-W-i/h/n0r0u0x1m4Y6V7V7W7y8O8P8R9^9_9`9a9c9e9f9g9i9j9k9l9m9n9o9p9x9z9{:P:Q:T:V:W:[:^:`<f<g=_=q=r!^;S.k/`;j;k;l;m;p;q;s;v;x;z;|<O<Q<S<U<h<l<n<r<t<w<x<z<}=O=Q=`=ao;T1X;r;w;y;{;}<P<R<T<V<i<m<s<u<yS$iu#hQ$qwU't$j$l&oQ'v$kS'x$m$rQ*|'uQ+O'wQ+R'yQ4X5xS4[5z5{Q4]5|Q6U8^S6W8_8`Q6X8aQ9d=YS9|=[=^Q:S=cQ=]=yS=b={=|Q=f=}Q=o>RS=p>S>VS=s>T>UR=t>WT'n$h*s!csPVXt!S!j!r!s!w$h$}%P%S%U'i(T(`)W*s+]+g+r+u,g,k.b.d.l0`0a0i1aQ$^rR*`'^Q*x'sQ-t*{R/w-wQ(W$tQ)U%hQ)n%vQ*i'fQ+k(XR-c*jQ(V$tQ)Y%jQ)m%vQ*e'eS*h'f)nS+j(W(XS-b*i*jQ.]+kQ/T,mQ/e-`R/g-cQ(U$tQ)T%hQ)V%iQ)l%vU*g'f)m)nU+i(V(W(XQ,f)UU-a*h*i*jS.[+j+kS/f-b-cQ0X.]R0t/gT+e(T+g[%e!_$b'c+a.R0QR,d)Qb$ov(T+[+]+`+g.P.Q0PR+T'{S+e(T+gT,j)W,kR0W.XT1[0V1]0w|PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$x{${Q+p([R._+nT$z{${Q(b$}Q(j%PQ(o%SQ(r%UQ.j+yQ0].fQ0^.iR1g0iR(e%OX+|(c(d+},PR(f%OX(h%P%S%U0iR%S!T_%a!]%R(l,T,V.t0dR%U!UR.x,XR,[(wQ)X%jS*d'e)YS-_*e,mS/d-`/TR0s/eQ%q!fU)]%m%n%rU,o)^)g)hR/_,xR)d%pR/],uSSO!mR!oSQ!rVR%y!rQ!jPS!sV!rQ!wX[%u!j!s!w+r0a1aQ+r(`Q0a.lR1a0`Q)j%sS,z)j7vR7v7WQ-S)zR/b-SQ&x#qS*R&x7mR7m9YS*V&{&|R-Z*VQ)w&YR-P)w!l'T#|'h*n*q*v+W+[,m-`-s-v-y.P.z/s/v/z0P1O1p4^4_4`5y6Y6Z6[:U:X:]=g=h=j=u=v=w=xR*Z'T1^dPVX[_bjklmnoprxyz!S!W!X!Y!]!e!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%p%}&S&W&p&s&t&w'O'U'Y'^'z(O(R(S(`(l({)P)_)c)i)p)t)v*P*T*U*o+P+d+r+u+z,T,V,X,u-Q-R-d-k-z-|.b.d.l.t/[/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n`#zd#{%m)^)g,x2W2YQ#{eQ%m!fQ)^%nQ)g%rQ,x)h!v2Wg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[R2Y2X|tPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aW$`t'i+],gS'i$h*sS+](T+gT,g)W,kQ'_$^R*a'_Q*t'oR-m*tQ/p-oS0{/p0|R0|/qQ-}+XR/|-}Q+g(TR.Y+gS+`(T+gS,h)W,kQ.Q+]W.T+`,h.Q/OR/O,gQ)R%eR,e)RQ'|$oR+U'|Q1]0VR1w1]Q${{R(^${Q+t(aR.c+tQ+w(bR.g+wQ+}(cQ,P(dT.m+},PQ(|%`S,a(|7tR7t7VQ(y%^R,^(yQ,k)WR/R,kQ)`%oS,q)`/WR/W,rQ,v)dR/^,vT!uV!rj!iPVX!j!r!s!w(`+r.l0`0a1aQ%Q!SQ(a$}W(h%P%S%U0iQ.e+uQ0Z.bR0[.d|ZPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ#f[U#m_#s&wQ#wbQ$VkQ$WlQ$XmQ$YnQ$ZoQ$[pQ$sx^$uy2_4b6e8q:m:nQ$vzQ%W!WQ%Y!XQ%[!YW%`!]%R(l,VU%s!g&p-RQ%|!yQ&O!zQ&Q!{S&U!})v^&^#R2a4d6g8t:p:qQ&_#SQ&`#TQ&a#UQ&b#VQ&c#WQ&d#XQ&e#YQ&f#ZQ&g#[Q&h#]Q&i#^Q&j#_Q&k#`Q&l#aQ&m#bQ&u#nQ&v#oS&{#t'OQ'X$RQ'Z$SQ'[$UQ(]$yQ(p%TQ)q%}Q)s&SQ)u&WQ*O&tS*['U4ZQ*^'Y^*_2[3u5v8Z:a=R=SQ+S'zQ+V(OQ,`({Q,c)PQ,y)iQ,{)pQ,})tQ-V*PQ-W*TQ-X*U^-]2]3v5w8[:b=T=UQ-i*oQ-x+PQ.k+zQ.w,XQ/`-QQ/h-dQ/n-kQ/y-zQ0r/cQ0u/iQ0x/mQ1Q/xU1X0V1]9WQ1d0eQ1m0vQ1q1RQ2Z2^Q2qjQ2r3yQ2x3zQ2y3|Q2z4OQ2{4QQ2|4SQ2}4UQ3O2`Q3Q2bQ3R2cQ3S2dQ3T2eQ3U2fQ3V2gQ3W2hQ3X2iQ3Y2jQ3Z2kQ3[2lQ3]2mQ3^2nQ3_2oQ3`2pQ3a2sQ3b2tQ3c2uQ3e2vQ3f2wQ3i3PQ3j3dQ3l3gQ3m3hQ3n3kQ3q3oQ3r3pQ3t3sQ4Y4WQ4y3{Q4z3}Q4{4PQ4|4RQ4}4TQ5O4VQ5P4cQ5R4eQ5S4fQ5T4gQ5U4hQ5V4iQ5W4jQ5X4kQ5Y4lQ5Z4mQ5[4nQ5]4oQ5^4pQ5_4qQ5`4rQ5a4sQ5b4tQ5c4uQ5d4vQ5f4wQ5g4xQ5j5QQ5k5eQ5m5hQ5n5iQ5o5lQ5r5pQ5s5qQ5u5tQ6Q4aQ6R3xQ6V6TQ6}6^Q7O6_Q7P6`Q7Q6aQ7R6bQ7S6cQ7T6dQ7U6fU7V,T.t0dQ7W%cQ7Y6hQ7Z6iQ7[6jQ7]6kQ7^6lQ7_6mQ7`6nQ7a6oQ7b6pQ7c6qQ7d6rQ7e6sQ7f6tQ7g6uQ7h6vQ7j6xQ7k6yQ7n6zQ7p6{Q7q6|Q7x7XQ7y7iQ7{7oQ7}7rQ8O7sQ8P7uQ8Q7wQ8R7zQ8S7|Q8V8TQ8W8UQ8Y8XQ8]8fU9U#k&s7lQ9^8jQ9_8kQ9`8lQ9a8mQ9b8nQ9c8oQ9e8pQ9f8rQ9g8sQ9i8uQ9j8vQ9k8wQ9l8xQ9m8yQ9n8zQ9o8{Q9p8|Q9q8}Q9r9OQ9s9PQ9t9QQ9u9RQ9v9SQ9w9TQ9x9ZQ9z9[Q9{9]Q:P9hQ:Q9yQ:T9}Q:V:OQ:W:RQ:[:YQ:^:ZQ:`:_Q:c8iQ;j:dQ;k:eQ;l:fQ;m:gQ;n:hQ;o:iQ;p:jQ;q:kQ;r:lQ;s:oQ;v:rQ;w:sQ;x:tQ;y:uQ;z:vQ;{:wQ;|:xQ;}:yQ<O:zQ<P:{Q<Q:|Q<R:}Q<S;OQ<T;PQ<U;QQ<V;RQ<W;SQ<X;TQ<Y;UQ<Z;VQ<[;WQ<];XQ<^;YQ<_;ZQ<`;[Q<a;]Q<b;^Q<c;_Q<d;`Q<e;aQ<f;cQ<g;dQ<h;eQ<i;fQ<l;gQ<m;hQ<n;iQ<r;tQ<s;uQ<t<jQ<u<kQ<w<oQ<x<pQ<y<qQ<z<vQ<}<{Q=O<|Q=Q=PQ=V8hQ=W8gQ=_=ZQ=`9VQ=a9XQ=q=mR=r=nR){&pQ%t!gQ)O%cT)y&p-R$SiPVX[bklmnopxyz!S!W!X!Y!j!r!s!w!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y$}%P%S%U%}&S'Y(O(`)p+P+r+u-z.b.d.l/x0`0a0e0i1R1a2[2]6x6y!t3w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x6S3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O8e_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|=X!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v=k+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]=l0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UQ#r_Q&r#kQ&z#sR)}&sS#q_#s^$Tj3x3y8f8g8h8iS*Q&w7lT9Y#k&sQ&}#tR*X'OR&T!|R&Z!}Q&Y!}R-O)vQ#|gQ'V#}S'h$h*sQ*Y'SQ*n'iQ*q'mQ*v'rQ+W(PS+[(T+gQ,m)ZQ-`*fQ-s*zQ-v*}Q-y+QS.P+]+`Q.z,ZQ/s-rQ/v-uQ/z-{Q0P.QQ1O/uQ1p1PQ4^5}Q4_6OQ4`6PQ5y6]Q6Y8bQ6Z8cQ6[8dQ:U=dQ:X=eQ:]=iQ=g>OQ=h>PQ=j>QQ=u>XQ=v>YQ=w>ZR=x>[0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=n!v$Pg#}$h'S'i'm'r(P(T)Z*f*s*z*}+Q+]+`+g,Z-r-u-{.Q/u1P5}6O6P6]8b8c8d=d=e=i>O>P>Q>X>Y>Z>[S$]r'^Q%k!eS%o!f%rQ)b%pU+X(R(S+dQ,p)_Q,t)cQ/Z,uQ/{-|R0p/[|vPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1a#U#i[bklmnopxyz!W!X!Y!{#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b$R$S$U$y%}&S'Y(O)p+P-z/x0e1R2[2]6x6yd+^(T)W+]+`+g,g,h,k.Q/O!t6w'U2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3z3|4O4Q4S4U5v5w!x;b3u3v3x3y3{3}4P4R4T4V4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t$O=z_j!]!g#k#n#o#s#t%R%T&p&s&t&w'O'z(l({)P)i*P*U,V,X-R6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6z6{6|7X7l7o7r7w7|8T8U8X8Z8[8f8g8h8i#|>]!y!z!}%c&W)t)v*T*o,T-d-k.t/c/i/m0d0v4W6T7i7s7u7z8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9Z9[9]9h9y9}:O:R:Y:Z:_:a:b;c;d=Z=m=n!v>^+z-Q9V9X:d:e:f:g:h:j:k:m:o:p:r:t:v:x:z:|;O;Q;S;U;W;Y;[;^;`;e;g;i;t<j<o<p<v<{<|=P=R=T!]>_0V1]9W:i:l:n:q:s:u:w:y:{:};P;R;T;V;X;Z;];_;a;f;h;u<k<q=S=UR'p$hQ'o$hR-l*sR$_rR-q*wQ+Y(RQ+Z(SR.X+dT+f(T+ge+_(T)W+]+`+g,g,h,k.Q/OQ%f!_Q'b$bQ*c'cQ.U+aQ0S.RR1U0QQ#eZQ%X!WQ%Z!XQ%]!YQ'}$pQ(s%VQ(t%WQ(u%YQ(v%[Q(}%bQ)S%fQ)[%kQ)f%qQ)k%tQ*b'bQ,n)]Q-^*cQ.V+bQ.W+cQ.e+xQ.o,QQ.p,RQ.q,SQ.v,WQ.y,YQ.},bQ/U,oQ/}.OQ0T.SQ0U.UQ0W.XQ0[.hQ0k/QQ0q/_Q1S0OQ1V0RQ1W0SQ1`0_Q1h0jQ1r1TQ1s1UQ1v1[Q1y1_Q1}1jQ2T1{R2U1|Q$pvS+b(T+gU.O+[+]+`S0O.P.QR1T0P|!aPVX!S!j!r!s!w$}%P%S%U(`+r+u.b.d.l0`0a0i1aQ$dtW+c(T)W+g,kW.S+]+`,g,hT0R.Q/O0t!OPVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nR.|,_0w}PVX[_bjklmnopxyz!S!W!X!Y!]!g!j!r!s!w!y!z!{!}#R#S#T#U#V#W#X#Y#Z#[#]#^#_#`#a#b#k#n#o#s#t$R$S$U$y$}%P%R%S%T%U%c%}&S&W&p&s&t&w'O'U'Y'z(O(`(l({)P)i)p)t)v*P*T*U*o+P+r+u+z,T,V,X,_-Q-R-d-k-z.b.d.l.t/c/i/m/x0V0`0a0d0e0i0v1R1]1a2[2]2^2_2`2a2b2c2d2e2f2g2h2i2j2k2l2m2n2o2p2s2t2u2v2w3P3d3g3h3k3o3p3s3u3v3x3y3z3{3|3}4O4P4Q4R4S4T4U4V4W4Z4a4b4c4d4e4f4g4h4i4j4k4l4m4n4o4p4q4r4s4t4u4v4w4x5Q5e5h5i5l5p5q5t5v5w6T6^6_6`6a6b6c6d6e6f6g6h6i6j6k6l6m6n6o6p6q6r6s6t6u6v6x6y6z6{6|7X7i7l7o7r7s7u7w7z7|8T8U8X8Z8[8f8g8h8i8j8k8l8m8n8o8p8q8r8s8t8u8v8w8x8y8z8{8|8}9O9P9Q9R9S9T9V9W9X9Z9[9]9h9y9}:O:R:Y:Z:_:a:b:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:{:|:};O;P;Q;R;S;T;U;V;W;X;Y;Z;[;];^;_;`;a;c;d;e;f;g;h;i;t;u<j<k<o<p<q<v<{<|=P=R=S=T=U=Z=m=nT$w{${Q(i%PQ(n%SQ(q%UR1f0iQ%b!]Q(m%RQ,U(lQ.s,TQ.u,VQ0c.tR1c0dQ%q!fR)]%rR)e%p",
  nodeNames: "âš  ( HeredocString EscapeSequence abstract LogicOp array as Boolean break case catch clone const continue default declare do echo else elseif enddeclare endfor endforeach endif endswitch endwhile enum extends final finally fn for foreach from function global goto if implements include include_once LogicOp insteadof interface list match namespace new null LogicOp print require require_once return switch throw trait try unset use var Visibility while LogicOp yield LineComment BlockComment TextInterpolation PhpClose Text PhpOpen Template TextInterpolation EmptyStatement ; } { Block : LabelStatement Name ExpressionStatement ConditionalExpression LogicOp MatchExpression ) ( ParenthesizedExpression MatchBlock MatchArm , => AssignmentExpression ArrayExpression ValueList & VariadicUnpacking ... Pair [ ] ListExpression ValueList Pair Pair SubscriptExpression MemberExpression -> ?-> VariableName DynamicVariable $ ${ CallExpression ArgList NamedArgument SpreadArgument CastExpression UnionType LogicOp OptionalType NamedType QualifiedName \\ NamespaceName ScopedExpression :: ClassMemberName AssignOp UpdateExpression UpdateOp YieldExpression BinaryExpression LogicOp LogicOp LogicOp BitOp BitOp BitOp CompareOp CompareOp BitOp ArithOp ConcatOp ArithOp ArithOp IncludeExpression RequireExpression CloneExpression UnaryExpression ControlOp LogicOp PrintIntrinsic FunctionExpression static ParamList Parameter #[ Attributes Attribute VariadicParameter PropertyParameter UseList ArrowFunction NewExpression class BaseClause ClassInterfaceClause DeclarationList ConstDeclaration VariableDeclarator PropertyDeclaration VariableDeclarator MethodDeclaration UseDeclaration UseList UseInsteadOfClause UseAsClause UpdateExpression ArithOp ShellExpression ThrowExpression Integer Float String MemberExpression SubscriptExpression UnaryExpression ArithOp Interpolation String IfStatement ColonBlock SwitchStatement Block CaseStatement DefaultStatement ColonBlock WhileStatement EmptyStatement DoStatement ForStatement ForSpec SequenceExpression ForeachStatement ForSpec Pair GotoStatement ContinueStatement BreakStatement ReturnStatement TryStatement CatchDeclarator DeclareStatement EchoStatement UnsetStatement ConstDeclaration FunctionDefinition ClassDeclaration InterfaceDeclaration TraitDeclaration EnumDeclaration EnumBody EnumCase NamespaceDefinition NamespaceUseDeclaration UseGroup UseClause UseClause GlobalDeclaration FunctionStaticDeclaration Program",
  maxTerm: 304,
  nodeProps: [
    ["group", -36, 2, 8, 49, 81, 83, 85, 88, 93, 94, 102, 106, 107, 110, 111, 114, 118, 123, 126, 130, 132, 133, 147, 148, 149, 150, 153, 154, 164, 165, 179, 181, 182, 183, 184, 185, 191, "Expression", -28, 74, 78, 80, 82, 192, 194, 199, 201, 202, 205, 208, 209, 210, 211, 212, 214, 215, 216, 217, 218, 219, 220, 221, 222, 225, 226, 230, 231, "Statement", -3, 119, 121, 122, "Type"],
    ["isolate", -4, 66, 67, 70, 191, ""],
    ["openedBy", 69, "phpOpen", 76, "{", 86, "(", 101, "#["],
    ["closedBy", 71, "phpClose", 77, "}", 87, ")", 158, "]"]
  ],
  propSources: [_W],
  skippedNodes: [0],
  repeatNodeCount: 29,
  tokenData: "!F|_R!]OX$zXY&^YZ'sZ]$z]^&^^p$zpq&^qr)Rrs+Pst+otu2buv5evw6rwx8Vxy>]yz>yz{?g{|@}|}Bb}!OCO!O!PDh!P!QKT!Q!R!!o!R![!$q![!]!,P!]!^!-a!^!_!-}!_!`!1S!`!a!2d!a!b!3t!b!c!7^!c!d!7z!d!e!9W!e!}!7z!}#O!;^#O#P!;z#P#Q!<h#Q#R!=U#R#S!7z#S#T!=u#T#U!7z#U#V!9W#V#o!7z#o#p!Co#p#q!D]#q#r!Er#r#s!F`#s$f$z$f$g&^$g&j!7z&j$I_$z$I_$I`&^$I`$KW$z$KW$KX&^$KX;'S$z;'S;=`&W<%l?HT$z?HT?HU&^?HUO$zP%PV&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zP%kO&wPP%nWOY$zYZ%fZ!a$z!b;'S$z;'S;=`&W<%l~$z~O$z~~%fP&ZP;=`<%l$zV&ed&wP&vUOX$zXY&^YZ'sZ]$z]^&^^p$zpq&^q!^$z!^!_%k!_$f$z$f$g&^$g$I_$z$I_$I`&^$I`$KW$z$KW$KX&^$KX;'S$z;'S;=`&W<%l?HT$z?HT?HU&^?HUO$zV'zW&wP&vUXY(dYZ(d]^(dpq(d$f$g(d$I_$I`(d$KW$KX(d?HT?HU(dU(iW&vUXY(dYZ(d]^(dpq(d$f$g(d$I_$I`(d$KW$KX(d?HT?HU(dR)YW$^Q&wPOY$zYZ%fZ!^$z!^!_%k!_!`)r!`;'S$z;'S;=`&W<%lO$zR)yW$QQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`*c!`;'S$z;'S;=`&W<%lO$zR*jV$QQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV+YV'fS&wP'gQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV+v]&wP!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b!},o!}#O1f#O;'S,o;'S;=`/s<%lO,oV,vZ&wP!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b;'S,o;'S;=`/s<%lO,oV-nZ!dUOY,oYZ%fZ],o]^$z^!a,o!a!b.a!b;'S,o;'S;=`/s<%l~,o~O,o~~%fU.dWOY.|YZ/nZ].|]^/n^!`.|!a;'S.|;'S;=`/h<%lO.|U/RV!dUOY.|Z].|^!a.|!a!b.a!b;'S.|;'S;=`/h<%lO.|U/kP;=`<%l.|U/sO!dUV/vP;=`<%l,oV0OZ&wPOY,oYZ0qZ],o]^0x^!^,o!^!_-i!_!`,o!`!a$z!a;'S,o;'S;=`/s<%lO,oV0xO&wP!dUV1PV&wP!dUOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV1oZ&wP$dQ!dUOY,oYZ%fZ],o]^$z^!^,o!^!_-i!_!a,o!a!b/y!b;'S,o;'S;=`/s<%lO,o_2i`&wP#dQOY$zYZ%fZ!^$z!^!_%k!_!c$z!c!}3k!}#R$z#R#S3k#S#T$z#T#o3k#o#p4w#p$g$z$g&j3k&j;'S$z;'S;=`&W<%lO$z_3ra&wP#b^OY$zYZ%fZ!Q$z!Q![3k![!^$z!^!_%k!_!c$z!c!}3k!}#R$z#R#S3k#S#T$z#T#o3k#o$g$z$g&j3k&j;'S$z;'S;=`&W<%lO$zV5OV&wP#eUOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR5lW&wP$VQOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR6]V#wQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV6yY#SU&wPOY$zYZ%fZv$zvw7iw!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR7pV#|Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR8^Z&wP%VQOY8VYZ9PZw8Vwx;_x!^8V!^!_;{!_#O8V#O#P<y#P;'S8V;'S;=`>V<%lO8VR9WV&wP%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X<%lO9mQ9rV%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X<%lO9mQ:^O%VQQ:aRO;'S9m;'S;=`:j;=`O9mQ:oW%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X;=`<%l9m<%lO9mQ;[P;=`<%l9mR;fV&wP%VQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR<Q]%VQOY8VYZ9PZw8Vwx;_x!a8V!a!b9m!b#O8V#O#P<y#P;'S8V;'S;=`>V<%l~8V~O8V~~%fR=OW&wPOY8VYZ9PZ!^8V!^!_;{!_;'S8V;'S;=`=h;=`<%l9m<%lO8VR=mW%VQOw9mwx:Xx#O9m#O#P:^#P;'S9m;'S;=`;X;=`<%l8V<%lO9mR>YP;=`<%l8VR>dV!yQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV?QV!xU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR?nY&wP$VQOY$zYZ%fZz$zz{@^{!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR@eW$WQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zRAUY$TQ&wPOY$zYZ%fZ{$z{|At|!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zRA{V$zQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRBiV!}Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z_CXZ$TQ%TW&wPOY$zYZ%fZ}$z}!OAt!O!^$z!^!_%k!_!`6U!`!aCz!a;'S$z;'S;=`&W<%lO$zVDRV#`U&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVDo[&wP$UQOY$zYZ%fZ!O$z!O!PEe!P!Q$z!Q![Fs![!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zVEjX&wPOY$zYZ%fZ!O$z!O!PFV!P!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVF^V#UU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRFz_&wP%OQOY$zYZ%fZ!Q$z!Q![Fs![!^$z!^!_%k!_!g$z!g!hGy!h#R$z#R#SJc#S#X$z#X#YGy#Y;'S$z;'S;=`&W<%lO$zRHO]&wPOY$zYZ%fZ{$z{|Hw|}$z}!OHw!O!Q$z!Q![Ii![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRH|X&wPOY$zYZ%fZ!Q$z!Q![Ii![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zRIpZ&wP%OQOY$zYZ%fZ!Q$z!Q![Ii![!^$z!^!_%k!_#R$z#R#SHw#S;'S$z;'S;=`&W<%lO$zRJhX&wPOY$zYZ%fZ!Q$z!Q![Fs![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zVK[[&wP$VQOY$zYZ%fZz$zz{LQ{!P$z!P!Q,o!Q!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zVLVX&wPOYLQYZLrZzLQz{N_{!^LQ!^!_! s!_;'SLQ;'S;=`!!i<%lOLQVLwT&wPOzMWz{Mj{;'SMW;'S;=`NX<%lOMWUMZTOzMWz{Mj{;'SMW;'S;=`NX<%lOMWUMmVOzMWz{Mj{!PMW!P!QNS!Q;'SMW;'S;=`NX<%lOMWUNXO!eUUN[P;=`<%lMWVNdZ&wPOYLQYZLrZzLQz{N_{!PLQ!P!Q! V!Q!^LQ!^!_! s!_;'SLQ;'S;=`!!i<%lOLQV! ^V!eU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV! vZOYLQYZLrZzLQz{N_{!aLQ!a!bMW!b;'SLQ;'S;=`!!i<%l~LQ~OLQ~~%fV!!lP;=`<%lLQZ!!vm&wP$}YOY$zYZ%fZ!O$z!O!PFs!P!Q$z!Q![!$q![!^$z!^!_%k!_!d$z!d!e!&o!e!g$z!g!hGy!h!q$z!q!r!(a!r!z$z!z!{!){!{#R$z#R#S!%}#S#U$z#U#V!&o#V#X$z#X#YGy#Y#c$z#c#d!(a#d#l$z#l#m!){#m;'S$z;'S;=`&W<%lO$zZ!$xa&wP$}YOY$zYZ%fZ!O$z!O!PFs!P!Q$z!Q![!$q![!^$z!^!_%k!_!g$z!g!hGy!h#R$z#R#S!%}#S#X$z#X#YGy#Y;'S$z;'S;=`&W<%lO$zZ!&SX&wPOY$zYZ%fZ!Q$z!Q![!$q![!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!&tY&wPOY$zYZ%fZ!Q$z!Q!R!'d!R!S!'d!S!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!'k[&wP$}YOY$zYZ%fZ!Q$z!Q!R!'d!R!S!'d!S!^$z!^!_%k!_#R$z#R#S!&o#S;'S$z;'S;=`&W<%lO$zZ!(fX&wPOY$zYZ%fZ!Q$z!Q!Y!)R!Y!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zZ!)YZ&wP$}YOY$zYZ%fZ!Q$z!Q!Y!)R!Y!^$z!^!_%k!_#R$z#R#S!(a#S;'S$z;'S;=`&W<%lO$zZ!*Q]&wPOY$zYZ%fZ!Q$z!Q![!*y![!^$z!^!_%k!_!c$z!c!i!*y!i#T$z#T#Z!*y#Z;'S$z;'S;=`&W<%lO$zZ!+Q_&wP$}YOY$zYZ%fZ!Q$z!Q![!*y![!^$z!^!_%k!_!c$z!c!i!*y!i#R$z#R#S!){#S#T$z#T#Z!*y#Z;'S$z;'S;=`&W<%lO$zR!,WX!qQ&wPOY$zYZ%fZ![$z![!]!,s!]!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!,zV#sQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!-hV!mU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!.S[$RQOY$zYZ%fZ!^$z!^!_!.x!_!`!/i!`!a*c!a!b!0]!b;'S$z;'S;=`&W<%l~$z~O$z~~%fR!/PW$SQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!/pX$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`$z!`!a*c!a;'S$z;'S;=`&W<%lO$zP!0bR!iP!_!`!0k!r!s!0p#d#e!0pP!0pO!iPP!0sQ!j!k!0y#[#]!0yP!0|Q!r!s!0k#d#e!0kV!1ZX#uQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`)r!`!a!1v!a;'S$z;'S;=`&W<%lO$zV!1}V#OU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!2kX$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`!3W!`!a!.x!a;'S$z;'S;=`&W<%lO$zR!3_V$RQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!3{[!vQ&wPOY$zYZ%fZ}$z}!O!4q!O!^$z!^!_%k!_!`$z!`!a!6P!a!b!6m!b;'S$z;'S;=`&W<%lO$zV!4vX&wPOY$zYZ%fZ!^$z!^!_%k!_!`$z!`!a!5c!a;'S$z;'S;=`&W<%lO$zV!5jV#aU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!6WV!gU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!6tW#zQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!7eV$]Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z_!8Ra&wP!s^OY$zYZ%fZ!Q$z!Q![!7z![!^$z!^!_%k!_!c$z!c!}!7z!}#R$z#R#S!7z#S#T$z#T#o!7z#o$g$z$g&j!7z&j;'S$z;'S;=`&W<%lO$z_!9_e&wP!s^OY$zYZ%fZr$zrs!:psw$zwx8Vx!Q$z!Q![!7z![!^$z!^!_%k!_!c$z!c!}!7z!}#R$z#R#S!7z#S#T$z#T#o!7z#o$g$z$g&j!7z&j;'S$z;'S;=`&W<%lO$zR!:wV&wP'gQOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!;eV#WU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!<RV#pU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!<oV#XQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!=]W$OQ&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`;'S$z;'S;=`&W<%lO$zR!=zZ&wPOY!=uYZ!>mZ!^!=u!^!_!@u!_#O!=u#O#P!Aq#P#S!=u#S#T!B{#T;'S!=u;'S;=`!Ci<%lO!=uR!>rV&wPO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o<%lO!?XQ!?[VO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o<%lO!?XQ!?tRO;'S!?X;'S;=`!?};=`O!?XQ!@QWO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o;=`<%l!?X<%lO!?XQ!@oO${QQ!@rP;=`<%l!?XR!@x]OY!=uYZ!>mZ!a!=u!a!b!?X!b#O!=u#O#P!Aq#P#S!=u#S#T!B{#T;'S!=u;'S;=`!Ci<%l~!=u~O!=u~~%fR!AvW&wPOY!=uYZ!>mZ!^!=u!^!_!@u!_;'S!=u;'S;=`!B`;=`<%l!?X<%lO!=uR!BcWO#O!?X#O#P!?q#P#S!?X#S#T!@j#T;'S!?X;'S;=`!@o;=`<%l!=u<%lO!?XR!CSV${Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!ClP;=`<%l!=uV!CvV!oU&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zV!DfY#}Q#lS&wPOY$zYZ%fZ!^$z!^!_%k!_!`6U!`#p$z#p#q!EU#q;'S$z;'S;=`&W<%lO$zR!E]V#{Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!EyV!nQ&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$zR!FgV$^Q&wPOY$zYZ%fZ!^$z!^!_%k!_;'S$z;'S;=`&W<%lO$z",
  tokenizers: [YW, VW, qW, 0, 1, 2, 3, zW],
  topRules: { Template: [0, 72], Program: [1, 232] },
  dynamicPrecedences: { 284: 1 },
  specialized: [{ term: 81, get: (t, e) => dQ(t) << 1, external: dQ }, { term: 81, get: (t) => jW[t] || -1 }],
  tokenPrec: 29354
}), CW = /* @__PURE__ */ re.define({
  name: "php",
  parser: /* @__PURE__ */ GW.configure({
    props: [
      /* @__PURE__ */ me.add({
        IfStatement: /* @__PURE__ */ ae({ except: /^\s*({|else\b|elseif\b|endif\b)/ }),
        TryStatement: /* @__PURE__ */ ae({ except: /^\s*({|catch\b|finally\b)/ }),
        SwitchBody: (t) => {
          let e = t.textAfter, O = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (O ? 0 : i ? 1 : 2) * t.unit;
        },
        ColonBlock: (t) => t.baseIndent + t.unit,
        "Block EnumBody DeclarationList": /* @__PURE__ */ YO({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "String BlockComment": () => null,
        Statement: /* @__PURE__ */ ae({ except: /^({|end(for|foreach|switch|while)\b)/ })
      }),
      /* @__PURE__ */ fe.add({
        "Block EnumBody DeclarationList SwitchBody ArrayExpression ValueList": Ie,
        ColonBlock(t) {
          return { from: t.from + 1, to: t.to };
        },
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" }, line: "//" },
    indentOnInput: /^\s*(?:case |default:|end(?:if|for(?:each)?|switch|while)|else(?:if)?|\{|\})$/,
    wordChars: "$",
    closeBrackets: { stringPrefixes: ["b", "B"] }
  }
});
function EW(t = {}) {
  let e = [], O;
  if (t.baseLanguage !== null) if (t.baseLanguage)
    O = t.baseLanguage;
  else {
    let i = Ht({ matchClosingTags: !1 });
    e.push(i.support), O = i.language;
  }
  return new le(CW.configure({
    wrap: O && SO((i) => i.type.isTop ? {
      parser: O.parser,
      overlay: (r) => r.name == "Text"
    } : null),
    top: t.plain ? "Program" : "Template"
  }), e);
}
const AW = 1, DW = 2, NW = 3, IW = 4, MW = 5, mQ = 98, LW = 101, BW = 102, PQ = 114, FW = 69, Ur = 48, gQ = 46, HW = 43, KW = 45, SQ = 35, XQ = 34, JW = 124, eR = 60, OR = 62;
function Ka(t) {
  return t >= 48 && t <= 57;
}
function Vr(t) {
  return Ka(t) || t == 95;
}
const tR = new q((t, e) => {
  if (Ka(t.next)) {
    let O = !1;
    do
      t.advance();
    while (Vr(t.next));
    if (t.next == gQ) {
      if (O = !0, t.advance(), Ka(t.next))
        do
          t.advance();
        while (Vr(t.next));
      else if (t.next == gQ || t.next > 127 || /\w/.test(String.fromCharCode(t.next)))
        return;
    }
    if (t.next == LW || t.next == FW) {
      if (O = !0, t.advance(), (t.next == HW || t.next == KW) && t.advance(), !Vr(t.next)) return;
      do
        t.advance();
      while (Vr(t.next));
    }
    if (t.next == BW) {
      let i = t.peek(1);
      if (i == Ur + 3 && t.peek(2) == Ur + 2 || i == Ur + 6 && t.peek(2) == Ur + 4)
        t.advance(3), O = !0;
      else
        return;
    }
    O && t.acceptToken(MW);
  } else if (t.next == mQ || t.next == PQ) {
    if (t.next == mQ && t.advance(), t.next != PQ) return;
    t.advance();
    let O = 0;
    for (; t.next == SQ; )
      O++, t.advance();
    if (t.next != XQ) return;
    t.advance();
    e: for (; ; ) {
      if (t.next < 0) return;
      let i = t.next == XQ;
      if (t.advance(), i) {
        for (let r = 0; r < O; r++) {
          if (t.next != SQ) continue e;
          t.advance();
        }
        t.acceptToken(IW);
        return;
      }
    }
  }
}), iR = new q((t) => {
  t.next == JW && t.acceptToken(AW, 1);
}), rR = new q((t) => {
  t.next == eR ? t.acceptToken(DW, 1) : t.next == OR && t.acceptToken(NW, 1);
}), nR = se({
  "const macro_rules struct union enum type fn impl trait let static": l.definitionKeyword,
  "mod use crate": l.moduleKeyword,
  "pub unsafe async mut extern default move": l.modifier,
  "for if else loop while match continue break return await": l.controlKeyword,
  "as in ref": l.operatorKeyword,
  "where _ crate super dyn": l.keyword,
  self: l.self,
  String: l.string,
  Char: l.character,
  RawString: l.special(l.string),
  Boolean: l.bool,
  Identifier: l.variableName,
  "CallExpression/Identifier": l.function(l.variableName),
  BoundIdentifier: l.definition(l.variableName),
  "FunctionItem/BoundIdentifier": l.function(l.definition(l.variableName)),
  LoopLabel: l.labelName,
  FieldIdentifier: l.propertyName,
  "CallExpression/FieldExpression/FieldIdentifier": l.function(l.propertyName),
  Lifetime: l.special(l.variableName),
  ScopeIdentifier: l.namespace,
  TypeIdentifier: l.typeName,
  "MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier": l.macroName,
  "MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier": l.macroName,
  '"!"': l.macroName,
  UpdateOp: l.updateOperator,
  LineComment: l.lineComment,
  BlockComment: l.blockComment,
  Integer: l.integer,
  Float: l.float,
  ArithOp: l.arithmeticOperator,
  LogicOp: l.logicOperator,
  BitOp: l.bitwiseOperator,
  CompareOp: l.compareOperator,
  "=": l.definitionOperator,
  ".. ... => ->": l.punctuation,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace,
  ". DerefOp": l.derefOperator,
  "&": l.operator,
  ", ; ::": l.separator,
  "Attribute/...": l.meta
}), sR = { __proto__: null, self: 28, super: 32, crate: 34, impl: 46, true: 72, false: 72, pub: 88, in: 92, const: 96, unsafe: 104, async: 108, move: 110, if: 114, let: 118, ref: 142, mut: 144, _: 198, else: 200, match: 204, as: 248, return: 252, await: 262, break: 270, continue: 276, while: 312, loop: 316, for: 320, macro_rules: 327, mod: 334, extern: 342, struct: 346, where: 364, union: 379, enum: 382, type: 390, default: 395, fn: 396, trait: 412, use: 420, static: 438, dyn: 476 }, aR = ne.deserialize({
  version: 14,
  states: "$2xQ]Q_OOP$wOWOOO&sQWO'#CnO)WQWO'#I`OOQP'#I`'#I`OOQQ'#Ie'#IeO)hO`O'#C}OOQR'#Ih'#IhO)sQWO'#IuOOQO'#Hk'#HkO)xQWO'#DpOOQR'#Iw'#IwO)xQWO'#DpO*ZQWO'#DpOOQO'#Iv'#IvO,SQWO'#J`O,ZQWO'#EiOOQV'#Hp'#HpO,cQYO'#F{OOQV'#El'#ElOOQV'#Em'#EmOOQV'#En'#EnO.YQ_O'#EkO0_Q_O'#EoO2gQWOOO4QQ_O'#FPO7hQWO'#J`OOQV'#FY'#FYO7{Q_O'#F^O:WQ_O'#FaOOQO'#F`'#F`O=sQ_O'#FcO=}Q_O'#FbO@VQWO'#FgOOQO'#J`'#J`OOQV'#Io'#IoOA]Q_O'#InOEPQWO'#InOOQV'#Fw'#FwOF[QWO'#JuOFcQWO'#F|OOQO'#IO'#IOOGrQWO'#GhOOQV'#Im'#ImOOQV'#Il'#IlOOQV'#Hj'#HjQGyQ_OOOKeQ_O'#DUOKlQYO'#CqOOQP'#I_'#I_OOQV'#Hg'#HgQ]Q_OOOLuQWO'#I`ONsQYO'#DXO!!eQWO'#JuO!!lQWO'#JuO!!vQ_O'#DfO!%]Q_O'#E}O!(sQ_O'#FWO!,ZQWO'#FZO!.^QXO'#FbO!.cQ_O'#EeO!!vQ_O'#FmO!0uQWO'#FoO!0zQWO'#FoO!1PQ^O'#FqO!1WQWO'#JuO!1_QWO'#FtO!1dQWO'#FxO!2WQWO'#JjO!2_QWO'#GOO!2_QWO'#G`O!2_QWO'#GbO!2_QWO'#GsOOQO'#Ju'#JuO!2dQWO'#GhO!2lQYO'#GpO!2_QWO'#GqO!3uQ^O'#GtO!3|QWO'#GuO!4hQWO'#HOP!4sOpO'#CcPOOO)CC})CC}OOOO'#Hi'#HiO!5OO`O,59iOOQV,59i,59iO!5ZQYO,5?aOOQO-E;i-E;iOOQO,5:[,5:[OOQP,59Z,59ZO)xQWO,5:[O)xQWO,5:[O!5oQWO,5?kO!5zQYO,5;qO!6PQYO,5;TO!6hQWO,59QO!7kQXO'#CnO!7xQXO'#I`O!9SQWO'#CoO,^QWO'#EiOOQV-E;n-E;nO!9eQWO'#FsOOQV,5<g,5<gO!9SQWO'#CoO!9jQWO'#CoO!9oQWO'#I`O! yQWO'#JuO!9yQWO'#J`O!:aQWO,5;VOOQO'#In'#InO!0zQWO'#DaO!<aQWO'#DcO!<iQWO,5;ZO.YQ_O,5;ZOOQO,5;[,5;[OOQV'#Er'#ErOOQV'#Es'#EsOOQV'#Et'#EtOOQV'#Eu'#EuOOQV'#Ev'#EvOOQV'#Ew'#EwOOQV'#Ex'#ExOOQV'#Ey'#EyO.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;fO!=PQ_O,5;kO!@gQ_O'#FROOQO,5;l,5;lO!BrQWO,5;pO.YQ_O,5;wOKlQYO,5;gO!D_QWO,5;kO!EOQWO,5;xOOQO,5;x,5;xO!E]QWO,5;xO!EbQ_O,5;xO!GmQWO'#CfO!GrQWO,5<QO!G|Q_O,5<QOOQO,5;{,5;{O!JjQXO'#CnO!K{QXO'#I`OOQS'#Dk'#DkOOQP'#Ir'#IrO!LuQ[O'#IrO!L}QXO'#DjO!M{QWO'#DnO!M{QWO'#DnO!N^QWO'#DnOOQP'#It'#ItO!NcQXO'#ItO# ^Q^O'#DoO# hQWO'#DrO# pQ^O'#DzO# zQ^O'#D|O#!RQWO'#EPO#!^QXO'#FdOOQP'#ES'#ESOOQP'#Iq'#IqO#!lQXO'#JfOOQP'#Je'#JeO#!tQXO,5;}O#!yQXO'#I`O!1PQ^O'#DyO!1PQ^O'#FdO##sQWO,5;|OOQO,5;|,5;|OKlQYO,5;|O#$ZQWO'#FhOOQO,5<R,5<ROOQV,5=l,5=lO#&`QYO'#FzOOQV,5<h,5<hO#&gQWO,5<hO#&nQWO,5=SO!1WQWO,59rO!1dQWO,5<dO#&uQWO,5=iO!2_QWO,5<jO!2_QWO,5<zO!2_QWO,5<|O!2_QWO,5=QO#&|QWO,5=]O#'TQWO,5=SO!2_QWO,5=]O!3|QWO,5=aO#']QWO,5=jOOQO-E;|-E;|O#'hQWO'#JjOOQV-E;h-E;hO#(PQWO'#HRO#(WQ_O,59pOOQV,59p,59pO#(_QWO,59pO#(dQ_O,59pO#)SQZO'#CuO#+[QZO'#CvOOQV'#C|'#C|O#-wQWO'#HTO#.OQYO'#IdOOQO'#Hh'#HhO#.WQWO'#CwO#.WQWO'#CwO#.iQWO'#CwOOQR'#Ic'#IcO#.nQZO'#IbO#1TQYO'#HTO#1qQYO'#H[O#2}QYO'#H_OKlQYO'#H`OOQR'#Hb'#HbO#4ZQWO'#HeO#4`QYO,59]OOQR'#Ib'#IbO#5PQZO'#CtO#7[QYO'#HUO#7aQWO'#HTO#7fQYO'#CrO#8VQWO'#H]O#7fQYO'#HcOOQV-E;e-E;eO#8_QWO,59sOOQV,59{,59{O#8mQYO,5=[OOQV,59},59}O!0zQWO,59}O#;aQWO'#IpOOQO'#Ip'#IpO!1PQ^O'#DhO!0zQWO,5:QO#;hQWO,5;iO#<OQWO,5;rO#<fQ_O,5;rOOQO,5;u,5;uO#@PQ_O,5;|O#BXQWO,5;PO!0zQWO,5<XO#B`QWO,5<ZOOQV,5<Z,5<ZO#BkQWO,5<]O!1PQ^O'#EOOOQQ'#D_'#D_O#BsQWO,59rO#BxQWO,5<`O#B}QWO,5<dOOQO,5@U,5@UO#CVQWO,5=iOOQQ'#Cv'#CvO#C[QYO,5<jO#CmQYO,5<zO#CxQYO,5<|O#DTQYO,5=_O#DcQYO,5=SO#E{QYO'#GQO#FYQYO,5=[O#FmQWO,5=[O#F{QYO,5=[O#HUQYO,5=]O#HdQWO,5=`O!1PQ^O,5=`O#HrQWO'#CnO#ITQWO'#I`OOQO'#Jy'#JyO#IfQWO'#IQO#IkQWO'#GwOOQO'#Jz'#JzO#JSQWO'#GzOOQO'#G|'#G|OOQO'#Jx'#JxO#IkQWO'#GwO#JZQWO'#GxO#J`QWO,5=aO#JeQWO,5=jO!1dQWO,5=jO#'`QWO,5=jPOOO'#Hf'#HfP#JjOpO,58}POOO,58},58}OOOO-E;g-E;gOOQV1G/T1G/TO#JuQWO1G4{O#JzQ^O'#CyPOQQ'#Cx'#CxOOQO1G/v1G/vOOQP1G.u1G.uO)xQWO1G/vO#NTQ!fO'#ETO#N[Q!fO'#EaO#NcQ!fO'#EbO$ kQWO1G1yO$!_Q_O1G1yOOQP1G5V1G5VOOQO1G1]1G1]O$&RQWO1G0oO$&WQWO'#CiO!7xQXO'#I`O!6PQYO1G.lO!5oQWO,5<_O!9SQWO,59ZO!9SQWO,59ZO!5oQWO,5?kO$&iQWO1G0uO$(vQWO1G0wO$*nQWO1G0wO$+UQWO1G0wO$-YQWO1G0wO$-aQWO1G0wO$/bQWO1G0wO$/iQWO1G0wO$1jQWO1G0wO$1qQWO1G0wO$3YQWO1G1QO$5ZQWO1G1VO$5zQ_O'#JcO$8SQWO'#JcOOQO'#Jb'#JbO$8^QWO,5;mOOQO'#Dw'#DwOOQO1G1[1G1[OOQO1G1Y1G1YO$8cQWO1G1cOOQO1G1R1G1RO$8jQ_O'#HrO$:xQWO,5@OO.YQ_O1G1dOOQO1G1d1G1dO$;QQWO1G1dO$;_QWO1G1dO$;dQWO1G1eOOQO1G1l1G1lO$;lQWO1G1lOOQP,5?^,5?^O$;vQ^O,5:kO$<aQXO,5:YO!M{QWO,5:YO!M{QWO,5:YO!1PQ^O,5:gO$=bQWO'#IyOOQO'#Ix'#IxO$=pQWO,5:ZO# ^Q^O,5:ZO$=uQWO'#DsOOQP,5:^,5:^O$>WQWO,5:fOOQP,5:h,5:hO!1PQ^O,5:hO!1PQ^O,5:mO$>]QYO,5<OO$>gQ_O'#HsO$>tQXO,5@QOOQV1G1i1G1iOOQP,5:e,5:eO$>|QXO,5<OO$?[QWO1G1hO$?dQWO'#CnO$?oQWO'#FiOOQO'#Fi'#FiO$?wQWO'#FjO.YQ_O'#FkOOQO'#Ji'#JiO$?|QWO'#JhOOQO'#Jg'#JgO$@UQWO,5<SOOQQ'#Hv'#HvO$@ZQYO,5<fOOQV,5<f,5<fO$@bQYO,5<fOOQV1G2S1G2SO$@iQWO1G2nO$@qQWO1G/^O$@vQWO1G2OO#CVQWO1G3TO$AOQYO1G2UO#CmQYO1G2fO#CxQYO1G2hO$AaQYO1G2lO!2_QWO1G2wO#DcQYO1G2nO#HUQYO1G2wO$AiQWO1G2{O$AnQWO1G3UO!1dQWO1G3UO$AsQWO1G3UOOQV1G/[1G/[O$A{QWO1G/[O$BQQ_O1G/[O#7aQWO,5=oO$BXQYO,5?OO$BmQWO,5?OO$BrQZO'#IeOOQO-E;f-E;fOOQR,59c,59cO#.WQWO,59cO#.WQWO,59cOOQR,5=n,5=nO$E_QYO'#HVO$FwQZO,5=oO!5oQWO,5={O$IZQWO,5=oO$IbQZO,5=vO$KqQYO,5=vO$>]QYO,5=vO$LRQWO'#KRO$L^QWO,5=xOOQR,5=y,5=yO$LcQWO,5=zO$>]QYO,5>PO$>]QYO,5>POOQO1G.w1G.wO$>]QYO1G.wO$LnQYO,5=pO$LvQZO,59^OOQR,59^,59^O$>]QYO,5=wO% YQZO,5=}OOQR,5=},5=}O%#lQWO1G/_O!6PQYO1G/_O#FYQYO1G2vO%#qQWO1G2vO%$PQYO1G2vOOQV1G/i1G/iO%%YQWO,5:SO%%bQ_O1G/lO%*kQWO1G1^O%+RQWO1G1hOOQO1G1h1G1hO$>]QYO1G1hO%+iQ^O'#EgOOQV1G0k1G0kOOQV1G1s1G1sO!!vQ_O1G1sO!0zQWO1G1uO!1PQ^O1G1wO!.cQ_O1G1wOOQP,5:j,5:jO$>]QYO1G/^OOQO'#Cn'#CnO%+vQWO1G1zOOQV1G2O1G2OO%,OQWO'#CnO%,WQWO1G3TO%,]QWO1G3TO%,bQYO'#GQO%,sQWO'#G]O%-UQYO'#G_O%.hQYO'#GXOOQV1G2U1G2UO%/wQWO1G2UO%/|QWO1G2UO$ARQWO1G2UOOQV1G2f1G2fO%/wQWO1G2fO#CpQWO1G2fO%0UQWO'#GdOOQV1G2h1G2hO%0gQWO1G2hO#C{QWO1G2hO%0lQYO'#GSO$>]QYO1G2lO$AdQWO1G2lOOQV1G2y1G2yO%1xQWO1G2yO%3hQ^O'#GkO%3rQWO1G2nO#DfQWO1G2nO%4QQYO,5<lO%4[QYO,5<lO%4jQYO,5<lO%5XQYO,5<lOOQQ,5<l,5<lO!1WQWO'#JuO%5dQYO,5<lO%5lQWO1G2vOOQV1G2v1G2vO%5tQWO1G2vO$>]QYO1G2vOOQV1G2w1G2wO%5tQWO1G2wO%5yQWO1G2wO#HXQWO1G2wOOQV1G2z1G2zO.YQ_O1G2zO$>]QYO1G2zO%6RQWO1G2zOOQO,5>l,5>lOOQO-E<O-E<OOOQO,5=c,5=cOOQO,5=e,5=eOOQO,5=g,5=gOOQO,5=h,5=hO%6aQWO'#J|OOQO'#J{'#J{O%6iQWO,5=fO%6nQWO,5=cO!1dQWO,5=dOOQV1G2{1G2{O$>]QYO1G3UPOOO-E;d-E;dPOOO1G.i1G.iOOQO7+*g7+*gO%7VQYO'#IcO%7nQYO'#IfO%7yQYO'#IfO%8RQYO'#IfO%8^QYO,59eOOQO7+%b7+%bOOQP7+$a7+$aO%8cQ!fO'#JTOOQS'#EX'#EXOOQS'#EY'#EYOOQS'#EZ'#EZOOQS'#JT'#JTO%;UQWO'#EWOOQS'#E`'#E`OOQS'#JR'#JROOQS'#Hn'#HnO%;ZQ!fO,5:oOOQV,5:o,5:oOOQV'#JQ'#JQO%;bQ!fO,5:{OOQV,5:{,5:{O%;iQ!fO,5:|OOQV,5:|,5:|OOQV7+'e7+'eOOQV7+&Z7+&ZO%;pQ!fO,59TOOQO,59T,59TO%>YQWO7+$WO%>_QWO1G1yOOQV1G1y1G1yO!9SQWO1G.uO%>dQWO,5?}O%>nQ_O'#HqO%@|QWO,5?}OOQO1G1X1G1XOOQO7+&}7+&}O%AUQWO,5>^OOQO-E;p-E;pO%AcQWO7+'OO.YQ_O7+'OOOQO7+'O7+'OOOQO7+'P7+'PO%AjQWO7+'POOQO7+'W7+'WOOQP1G0V1G0VO%ArQXO1G/tO!M{QWO1G/tO%BsQXO1G0RO%CkQ^O'#HlO%C{QWO,5?eOOQP1G/u1G/uO%DWQWO1G/uO%D]QWO'#D_OOQO'#Dt'#DtO%DhQWO'#DtO%DmQWO'#I{OOQO'#Iz'#IzO%DuQWO,5:_O%DzQWO'#DtO%EPQWO'#DtOOQP1G0Q1G0QOOQP1G0S1G0SOOQP1G0X1G0XO%EXQXO1G1jO%EdQXO'#FeOOQP,5>_,5>_O!1PQ^O'#FeOOQP-E;q-E;qO$>]QYO1G1jOOQO7+'S7+'SOOQO,5<T,5<TO%ErQWO,5<UO.YQ_O,5<UO%EwQWO,5<VO%FRQWO'#HtO%FdQWO,5@SOOQO1G1n1G1nOOQQ-E;t-E;tOOQV1G2Q1G2QO%FlQYO1G2QO#DcQYO7+(YO$>]QYO7+$xOOQV7+'j7+'jO%FsQWO7+(oO%FxQWO7+(oOOQV7+'p7+'pO%/wQWO7+'pO%F}QWO7+'pO%GVQWO7+'pOOQV7+(Q7+(QO%/wQWO7+(QO#CpQWO7+(QOOQV7+(S7+(SO%0gQWO7+(SO#C{QWO7+(SO$>]QYO7+(WO%GeQWO7+(WO#HUQYO7+(cO%GjQWO7+(YO#DfQWO7+(YOOQV7+(c7+(cO%5tQWO7+(cO%5yQWO7+(cO#HXQWO7+(cOOQV7+(g7+(gO$>]QYO7+(pO%GxQWO7+(pO!1dQWO7+(pOOQV7+$v7+$vO%G}QWO7+$vO%HSQZO1G3ZO%JfQWO1G4jOOQO1G4j1G4jOOQR1G.}1G.}O#.WQWO1G.}O%JkQWO'#KQOOQO'#HW'#HWO%J|QWO'#HXO%KXQWO'#KQOOQO'#KP'#KPO%KaQWO,5=qO%KfQYO'#H[O%LrQWO'#GmO%L}QYO'#CtO%MXQWO'#GmO$>]QYO1G3ZOOQR1G3g1G3gO#7aQWO1G3ZO%M^QZO1G3bO$>]QYO1G3bO& mQYO'#IVO& }QWO,5@mOOQR1G3d1G3dOOQR1G3f1G3fO.YQ_O1G3fOOQR1G3k1G3kO&!VQYO7+$cO&!_QYO'#KOOOQQ'#J}'#J}O&!gQYO1G3[O&!lQZO1G3cOOQQ7+$y7+$yO&${QWO7+$yO&%QQWO7+(bOOQV7+(b7+(bO%5tQWO7+(bO$>]QYO7+(bO#FYQYO7+(bO&%YQWO7+(bO!.cQ_O1G/nO&%hQWO7+%WO$?[QWO7+'SO&%pQWO'#EhO&%{Q^O'#EhOOQU'#Ho'#HoO&%{Q^O,5;ROOQV,5;R,5;RO&&VQWO,5;RO&&[Q^O,5;RO!0zQWO7+'_OOQV7+'a7+'aO&&iQWO7+'cO&&qQWO7+'cO&&xQWO7+$xO&'TQ!fO7+'fO&'[Q!fO7+'fOOQV7+(o7+(oO!1dQWO7+(oO&'cQYO,5<lO&'nQYO,5<lO!1dQWO'#GWO&'|QWO'#JpO&([QWO'#G^O!BxQWO'#G^O&(aQWO'#JpOOQO'#Jo'#JoO&(iQWO,5<wOOQO'#DX'#DXO&(nQYO'#JrO&)}QWO'#JrO$>]QYO'#JrOOQO'#Jq'#JqO&*YQWO,5<yO&*_QWO'#GZO#D^QWO'#G[O&*gQWO'#G[O&*oQWO'#JmOOQO'#Jl'#JlO&*zQYO'#GTOOQO,5<s,5<sO&+PQWO7+'pO&+UQWO'#JtO&+dQWO'#GeO#BxQWO'#GeO&+uQWO'#JtOOQO'#Js'#JsO&+}QWO,5=OO$>]QYO'#GUO&,SQYO'#JkOOQQ,5<n,5<nO&,kQWO7+(WOOQV7+(e7+(eO&.TQ^O'#D|O&._QWO'#GlO&.gQ^O'#JwOOQO'#Gn'#GnO&.nQWO'#JwOOQO'#Jv'#JvO&.vQWO,5=VO&.{QWO'#I`O&/]Q^O'#GmO&/dQWO'#IqO&/rQWO'#GmOOQV7+(Y7+(YO&/zQWO7+(YO$>]QYO7+(YO&0SQYO'#HxO&0hQYO1G2WOOQQ1G2W1G2WOOQQ,5<m,5<mO$>]QYO,5<qO&0pQWO,5<rO&0uQWO7+(bO&1QQWO7+(fO&1XQWO7+(fOOQV7+(f7+(fO.YQ_O7+(fO$>]QYO7+(fO&1dQWO'#IRO&1nQWO,5@hOOQO1G3Q1G3QOOQO1G2}1G2}OOQO1G3P1G3POOQO1G3R1G3ROOQO1G3S1G3SOOQO1G3O1G3OO&1vQWO7+(pO$>]QYO,59fO&2RQ^O'#ISO&2xQYO,5?QOOQR1G/P1G/PO&3QQ!bO,5:pO&3VQ!fO,5:rOOQS-E;l-E;lOOQV1G0Z1G0ZOOQV1G0g1G0gOOQV1G0h1G0hO&3^QWO'#JTOOQO1G.o1G.oOOQV<<Gr<<GrO&3iQWO1G5iO$5zQ_O,5>]O&3qQWO,5>]OOQO-E;o-E;oOOQO<<Jj<<JjO&3{QWO<<JjOOQO<<Jk<<JkO&4SQXO7+%`O&5TQWO,5>WOOQO-E;j-E;jOOQP7+%a7+%aO!1PQ^O,5:`O&5cQWO'#HmO&5wQWO,5?gOOQP1G/y1G/yOOQO,5:`,5:`O&6PQWO,5:`O%DzQWO,5:`O$>]QYO,5<PO&6UQXO,5<PO&6dQXO7+'UO.YQ_O1G1pO&6oQWO1G1pOOQO,5>`,5>`OOQO-E;r-E;rOOQV7+'l7+'lO&6yQWO<<KtO#DfQWO<<KtO&7XQWO<<HdOOQV<<LZ<<LZO!1dQWO<<LZOOQV<<K[<<K[O&7dQWO<<K[O%/wQWO<<K[O&7iQWO<<K[OOQV<<Kl<<KlO%/wQWO<<KlOOQV<<Kn<<KnO%0gQWO<<KnO&7qQWO<<KrO$>]QYO<<KrOOQV<<K}<<K}O%5tQWO<<K}O%5yQWO<<K}O#HXQWO<<K}OOQV<<Kt<<KtO&7yQWO<<KtO$>]QYO<<KtO&8RQWO<<L[O$>]QYO<<L[O&8^QWO<<L[OOQV<<Hb<<HbO$>]QYO7+(uOOQO7+*U7+*UOOQR7+$i7+$iO&8cQWO,5@lOOQO'#Gm'#GmO&8kQWO'#GmO&8vQYO'#IUO&8cQWO,5@lOOQR1G3]1G3]O&:cQYO,5=vO&;rQYO,5=XO&;|QWO,5=XOOQO,5=X,5=XOOQR7+(u7+(uO&<RQZO7+(uO&>eQZO7+(|O&@tQWO,5>qOOQO-E<T-E<TO&APQWO7+)QOOQO<<G}<<G}O&AWQYO'#ITO&AcQYO,5@jOOQQ7+(v7+(vOOQQ<<He<<HeO$>]QYO<<K|OOQV<<K|<<K|O&0uQWO<<K|O&AkQWO<<K|O%5tQWO<<K|O&AsQWO7+%YOOQV<<Hr<<HrOOQO<<Jn<<JnO.YQ_O,5;SO&AzQWO,5;SO.YQ_O'#EjO&BPQWO,5;SOOQU-E;m-E;mO&B[QWO1G0mOOQV1G0m1G0mO&%{Q^O1G0mOOQV<<Jy<<JyO!.cQ_O<<J}OOQV<<J}<<J}OOQV<<Hd<<HdO.YQ_O<<HdO&BaQWO'#FvO&BfQWO<<KQO&BnQ!fO<<KQO&BuQWO<<KQO&BzQWO<<KQO&CSQ!fO<<KQOOQV<<KQ<<KQO&CZQWO<<LZO&C`QWO,5@[O$>]QYO,5<xO&ChQWO,5<xO&CmQWO'#H{O&C`QWO,5@[OOQV1G2c1G2cO&DRQWO,5@^O$>]QYO,5@^O&D^QYO'#H|O&EsQWO,5@^OOQO1G2e1G2eO%,nQWO,5<uOOQO,5<v,5<vO&E{QYO'#HzO&G_QWO,5@XO%,bQYO,5=pO$>]QYO,5<oO&GjQWO,5@`O.YQ_O,5=PO&GrQWO,5=PO&G}QWO,5=PO&H`QWO'#H}O&GjQWO,5@`OOQV1G2j1G2jO&HtQYO,5<pO%0lQYO,5>PO&I]QYO,5@VOOQV<<Kr<<KrO&ItQWO,5=XO&KfQ^O,5:hO&KmQWO,5=XO$>]QYO,5=WO&KuQWO,5@cO&K}QWO,5@cO&MvQ^O'#IPO&KuQWO,5@cOOQO1G2q1G2qO&NTQWO,5=WO&N]QWO<<KtO&NkQYO,5>oO&NvQYO,5>dO' UQYO,5>dOOQQ,5>d,5>dOOQQ-E;v-E;vOOQQ7+'r7+'rO' aQYO1G2]O$>]QYO1G2^OOQV<<LQ<<LQO.YQ_O<<LQO' lQWO<<LQO' sQWO<<LQOOQO,5>m,5>mOOQO-E<P-E<POOQV<<L[<<L[O.YQ_O<<L[O'!OQYO1G/QO'!ZQYO,5>nOOQQ,5>n,5>nO'!fQYO,5>nOOQQ-E<Q-E<QOOQS1G0[1G0[O'$tQ!fO1G0^O'%RQ!fO1G0^O'%YQWO1G3wOOQOAN@UAN@UO'%dQWO1G/zOOQO,5>X,5>XOOQO-E;k-E;kO!1PQ^O1G/zOOQO1G/z1G/zO'%oQWO1G/zO'%tQXO1G1kO$>]QYO1G1kO'&PQWO7+'[OOQVANA`ANA`O'&ZQWOANA`O$>]QYOANA`O'&cQWOANA`OOQVAN>OAN>OO.YQ_OAN>OO'&qQWOANAuOOQVAN@vAN@vO'&vQWOAN@vOOQVANAWANAWOOQVANAYANAYOOQVANA^ANA^O'&{QWOANA^OOQVANAiANAiO%5tQWOANAiO%5yQWOANAiO''TQWOANA`OOQVANAvANAvO.YQ_OANAvO''cQWOANAvO$>]QYOANAvOOQR<<La<<LaO''nQWO1G6WO%JkQWO,5>pOOQO'#HY'#HYO''vQWO'#HZOOQO,5>p,5>pOOQO-E<S-E<SO'(RQYO1G2sO'(]QWO1G2sOOQO1G2s1G2sO$>]QYO<<LaOOQR<<Ll<<LlOOQQ,5>o,5>oOOQQ-E<R-E<RO&0uQWOANAhOOQVANAhANAhO%5tQWOANAhO$>]QYOANAhO'(bQWO1G1rO')UQ^O1G0nO.YQ_O1G0nO'*zQWO,5;UO'+RQWO1G0nP'+WQWO'#ERP&%{Q^O'#HpOOQV7+&X7+&XO'+cQWO7+&XO&&qQWOAN@iO'+hQWOAN>OO!5oQWO,5<bOOQS,5>a,5>aO'+oQWOAN@lO'+tQWOAN@lOOQS-E;s-E;sOOQVAN@lAN@lO'+|QWOAN@lOOQVANAuANAuO',UQWO1G5vO',^QWO1G2dO$>]QYO1G2dO&'|QWO,5>gOOQO,5>g,5>gOOQO-E;y-E;yO',iQWO1G5xO',qQWO1G5xO&(nQYO,5>hO',|QWO,5>hO$>]QYO,5>hOOQO-E;z-E;zO'-XQWO'#JnOOQO1G2a1G2aOOQO,5>f,5>fOOQO-E;x-E;xO&'cQYO,5<lO'-gQYO1G2ZO'.RQWO1G5zO'.ZQWO1G2kO.YQ_O1G2kO'.eQWO1G2kO&+UQWO,5>iOOQO,5>i,5>iOOQO-E;{-E;{OOQQ,5>c,5>cOOQQ-E;u-E;uO'.pQWO1G2sO'/QQWO1G2rO'/]QWO1G5}O'/eQ^O,5>kOOQO'#Go'#GoOOQO,5>k,5>kO'/lQWO,5>kOOQO-E;}-E;}O$>]QYO1G2rO'/zQYO7+'xO'0VQWOANAlOOQVANAlANAlO.YQ_OANAlO'0^QWOANAvOOQS7+%x7+%xO'0eQWO7+%xO'0pQ!fO7+%xO'0}QWO7+%fO!1PQ^O7+%fO'1YQXO7+'VOOQVG26zG26zO'1eQWOG26zO'1sQWOG26zO$>]QYOG26zO'1{QWOG23jOOQVG27aG27aOOQVG26bG26bOOQVG26xG26xOOQVG27TG27TO%5tQWOG27TO'2SQWOG27bOOQVG27bG27bO.YQ_OG27bO'2ZQWOG27bOOQO1G4[1G4[OOQO7+(_7+(_OOQRANA{ANA{OOQVG27SG27SO%5tQWOG27SO&0uQWOG27SO'2fQ^O7+&YO'4PQWO7+'^O'4sQ^O7+&YO.YQ_O7+&YP.YQ_O,5;SP'6PQWO,5;SP'6UQWO,5;SOOQV<<Is<<IsOOQVG26TG26TOOQVG23jG23jOOQO1G1|1G1|OOQVG26WG26WO'6aQWOG26WP&B}QWO'#HuO'6fQWO7+(OOOQO1G4R1G4RO'6qQWO7++dO'6yQWO1G4SO$>]QYO1G4SO%,nQWO'#HyO'7UQWO,5@YO'7dQWO7+(VO.YQ_O7+(VOOQO1G4T1G4TOOQO1G4V1G4VO'7nQWO1G4VO'7|QWO7+(^OOQVG27WG27WO'8XQWOG27WOOQS<<Id<<IdO'8`QWO<<IdO'8kQWO<<IQOOQVLD,fLD,fO'8vQWOLD,fO'9OQWOLD,fOOQVLD)ULD)UOOQVLD,oLD,oOOQVLD,|LD,|O'9^QWOLD,|O.YQ_OLD,|OOQVLD,nLD,nO%5tQWOLD,nO'9eQ^O<<ItO';OQWO<<JxO';rQ^O<<ItP'=OQWO1G0nP'=oQ^O1G0nP.YQ_O1G0nP'?bQWO1G0nOOQVLD+rLD+rO'?gQWO7+)nOOQO,5>e,5>eOOQO-E;w-E;wO'?rQWO<<KqOOQVLD,rLD,rOOQSAN?OAN?OOOQV!$(!Q!$(!QO'?|QWO!$(!QOOQV!$(!h!$(!hO'@UQWO!$(!hOOQV!$(!Y!$(!YO'@]Q^OAN?`POQU7+&Y7+&YP'AvQWO7+&YP'BgQ^O7+&YP.YQ_O7+&YOOQV!)9El!)9ElOOQV!)9FS!)9FSPOQU<<It<<ItP'DYQWO<<ItP'DyQ^O<<ItPOQUAN?`AN?`O'FlQWO'#CnO'FsQXO'#CnO'GlQWO'#I`O'IRQXO'#I`O'IxQWO'#DpO'IxQWO'#DpO!.cQ_O'#EkO'JZQ_O'#EoO'JbQ_O'#FPO'MfQ_O'#FbO'MmQXO'#I`O'NdQ_O'#E}O( gQ_O'#FWO'IxQWO,5:[O'IxQWO,5:[O!.cQ_O,5;ZO!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;fO(!jQ_O,5;kO(%nQWO,5;kO(&OQWO,5;|O(&VQYO'#CuO(&bQYO'#CvO(&mQWO'#CwO(&mQWO'#CwO('OQYO'#CtO('ZQWO,5;iO('bQWO,5;rO('iQ_O,5;rO((oQ_O,5;|O'IxQWO1G/vO((vQWO1G0uO(*eQWO1G0wO(*oQWO1G0wO(,dQWO1G0wO(,kQWO1G0wO(.]QWO1G0wO(.dQWO1G0wO(0UQWO1G0wO(0]QWO1G0wO(0dQWO1G1QO(0tQWO1G1VO(1UQYO'#IeO(&mQWO,59cO(&mQWO,59cO(1aQWO1G1^O(1hQWO1G1hO(&mQWO1G.}O(1oQWO'#DpO!.^QXO'#FbO(1tQWO,5;ZO(1{QWO'#Cw",
  stateData: "(2_~O&|OSUOS&}PQ~OPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'TQO'ZkO'^UO'gcO'qiO(QdO~O&}!sO~OZbX[bXdbXdlXobXwjX}bX!lbX!qbX!tbX#ObX#PbX#pbX'gbX'qbX'rbX'xbX'ybX'zbX'{bX'|bX'}bX(ObX(PbX(QbX(RbX(TbX~OybXXbX!ebX!PbXvbX#RbX~P$|OZ'SX['SXd'SXd'XXo'SXw'kXy'SX}'SX!l'SX!q'SX!t'SX#O'SX#P'SX#p'SX'g'SX'q'SX'r'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SXv'SX~OX'SX!e'SX!P'SX#R'SX~P'ZOr!uO']!wO'_!uO~Od!xO~O^RO_RO`ROaRO'TQO~Od!}O~Od#PO[(SXo(SXy(SX}(SX!l(SX!q(SX!t(SX#O(SX#P(SX#p(SX'g(SX'q(SX'r(SX'x(SX'y(SX'z(SX'{(SX'|(SX'}(SX(O(SX(P(SX(Q(SX(R(SX(T(SXv(SX~OZ#OO~P*`OZ#RO[#QO~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'T#SO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!j#eO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xO[#}Oo#xO}#zO!l#yO!q#jO!t#yO#O#xO#P#uO#p$OO'g#gO'q#yO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~OPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXy#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sXX#sX!e#sX!P#sXv#sX#R#sX~P)xOX(SX!e(SX!P(SXw(SX#R(SX~P*`OPoOQ!QOSVOTVOX$ROZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!P$XO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOQ!QOSVOTVO[$gO^$pO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j$rOP(XP~P<cOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q$uO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw$vO~Oo'bX#O'bX#P'bX#p'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(R'bX(T'bX~OP%tXQ%tXS%tXT%tXZ%tX[%tX^%tX_%tX`%tXa%tXd%tXg%tXs%tXt%tXu%tXw%tXy%tX|%tX}%tX!Q%tX!U%tX!W%tX!X%tX!Z%tX!]%tX!l%tX!q%tX!t%tX#Y%tX#r%tX#{%tX$O%tX$b%tX$d%tX$f%tX$i%tX$m%tX$q%tX$s%tX%T%tX%V%tX%Z%tX%]%tX%^%tX%f%tX%j%tX%s%tX&z%tX'Q%tX'T%tX'Z%tX'^%tX'g%tX'q%tX(Q%tXv%tX~P@[Oy$xO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bXv'bX~P@[Ow$yO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Oy$zO~PEsO!Q$}O!U%UO!W!lO$m%OO$q%PO$s%QO%T%RO%V%SO%Z%TO%]!lO%^%VO%f%WO%j%XO%s%YO~O!Q!lO!U!lO!W!lO$q%[O%]!lO~O%^%VO~PGaOPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q#VO'TQO'ZkO'^UO'gcO'qiO(QdO~Ov%`O~P]OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~P'ZO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~O}%}O'T{XQ{XZ{X[{X^{X_{X`{Xa{Xd{Xg{X!q{X$f{X&W{X'Z{X(Q{X~PMuOg&PO%f%WO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Ow!PO~P! yOw!PO!X&RO~PEvOPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!]&UO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#qXy#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qXX#qX!e#qX!P#qXv#qX#R#qX~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zXy#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zXX#zX!e#zX!P#zXv#zX#R#zX~P)xO'ZkO[#}Xo#}Xy#}X}#}X!l#}X!q#}X!t#}X#O#}X#P#}X#p#}X'g#}X'q#}X'r#}X'x#}X'y#}X'z#}X'{#}X'|#}X'}#}X(O#}X(P#}X(Q#}X(R#}X(T#}XX#}X!e#}X!P#}Xv#}Xw#}X#R#}X~OPoO~OPoOQ!QOSVOTVOZeO[lO^9qO_9qO`9qOa9qOd9tOsVOtVOuVOw!PO}mO!U#bO!W#cO!X:zO!Z!YO!l9wO!q9vO!t9wO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'T9oO'ZkO'^UO'gcO'q9wO(QdO~O!S&_O~Ow!PO~O!j&bO~P<cO'T&cO~PEvOZ&eO~O'T&cO~O'^UOw(^Xy(^X!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Oa&hO~P!1iO'T&iO~O_&nO'T&cO~OQ&oOZ&pO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO!j&uO~P<cO^&wO_&wO`&wOa&wOd'POw&|O'T&vO(Q&}O~O!i'UO!j'TO'T&cO~O&}!sO'O'VO'P'XO~Or!uO']'ZO'_!uO~OQ']O^'ia_'ia`'iaa'ia'T'ia~O['cOw'dO}'bO~OQ']O~OQ!QO^#TO_#TO`#TOa'kOd#ZO'T#SO~O['lO~OZbXdlXXbXobXPbX!SbX!ebX'rbX!PbX!ObXybX!ZbX#RbXvbX~O[bXwbX}bX~P!6mOZ'SXd'XXX'SX['SXo'SXw'SX}'SX#p'SXP'SX!S'SX!e'SX'r'SX!P'SX!O'SXy'SX!Z'SX#R'SXv'SX~O^#TO_#TO`#TOa'kO'T#SO~OZ'mO~Od'oO~OZ'SXd'XX~PMuOZ'pOX(SX!e(SX!P(SXw(SX#R(SX~P*`O[#}O}#zO(O#|O(R#fOo#_ay#_a!l#_a!q#_a!t#_a#O#_a#P#_a#p#_a'g#_a'q#_a'r#_a'x#_a'y#_a'z#_a'{#_a'|#_a'}#_a(P#_a(Q#_a(T#_aX#_a!e#_a!P#_av#_aw#_a#R#_a~Ow!PO!X&RO~Oy#caX#ca!e#ca!P#cav#ca#R#ca~P2gOPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#say#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#saX#sa!e#sa!P#sav#sa#R#sa~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P(UP~P)xOu(SO#w(TO'T(RO~O[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#sa!t#sa#p#sa'q#sa~Oo#xO#O#xO#P#uOy#saX#sa!e#sa!P#sav#sa#R#sa~P!B}Oy(YO!e(WOX(WX~P2gOX(ZO~OPoOQ!QOSVOTVOX(ZOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZ#RO~O!P(_O!e(WO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q$UO'ZkO'^UO'gcO'qiO(QdO~P)xOZbXdlXwjX}jX!tbX'qbX~OP!RX!S!RX!e!RX'p!RX'r!RX!O!RXo!RXy!RX!P!RXX!RX!Z!RX#R!RXv!RX~P!JUOZ'SXd'XXw'kX}'kX!t'SX'q'SX~OP!`X!S!`X!e!`X'r!`X!O!`Xo!`Xy!`X!P!`XX!`X!Z!`X#R!`Xv!`X~P!KgOT(aOu(aO~O!t(bO'q(bOP!^X!S!^X!e!^X'r!^X!O!^Xo!^Xy!^X!P!^XX!^X!Z!^X#R!^Xv!^X~O^9rO_9rO`9yOa9yO'T9pO~Od(eO~O'p(fOP'hX!S'hX!e'hX'r'hX!O'hXo'hXy'hX!P'hXX'hX!Z'hX#R'hXv'hX~O!j&bO!P'lP~P<cOw(kO}(jO~O!j&bOX'lP~P<cO!j(oO~P<cOZ'pO!t(bO'q(bO~O!S(qO'r(pOP$WX!e$WX~O!e(rOP(YX~OP(tO~OP!aX!S!aX!e!aX'r!aX!O!aXo!aXy!aX!P!aXX!aX!Z!aX#R!aXv!aX~P!KgOy$UaX$Ua!e$Ua!P$Uav$Ua#R$Ua~P2gO!l(|O'Q#VO'T(xOv(ZP~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'Q`O'T#SO~Ov)TO~P#$iOy)VO~PEsO%^)WO~PGaOa)ZO~P!1iO%f)`O~PEvO_)aO'T&cO~O!i)fO!j)eO'T&cO~O'^UO!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Ov%uX~P2gOv)gO~PGyOv)gO~Ov)gO~P]OQiXQ'XXZiXd'XX}iX#piX(PiX~ORiXwiX$fiX$|iX[iXoiXyiX!liX!qiX!tiX#OiX#PiX'giX'qiX'riX'xiX'yiX'ziX'{iX'|iX'}iX(OiX(QiX(RiX(TiX!PiX!eiXXiXPiXviX!SiX#RiX~P#(kOQjXQlXRjXZjXdlX}jX#pjX(PjXwjX$fjX$|jX[jXojXyjX!ljX!qjX!tjX#OjX#PjX'gjX'qjX'rjX'xjX'yjX'zjX'{jX'|jX'}jX(OjX(QjX(RjX(TjX!PjX!ejXXjX!SjXPjXvjX#RjX~O%^)jO~PGaOQ']Od)kO~O^)mO_)mO`)mOa)mO'T%dO~Od)qO~OQ']OZ)uO})sOR'UX#p'UX(P'UXw'UX$f'UX$|'UX['UXo'UXy'UX!l'UX!q'UX!t'UX#O'UX#P'UX'g'UX'q'UX'r'UX'x'UX'y'UX'z'UX'{'UX'|'UX'}'UX(O'UX(Q'UX(R'UX(T'UX!P'UX!e'UXX'UXP'UXv'UX!S'UX#R'UX~OQ!QO^:bO_:^O`TOaTOd:aO%^)jO'T:_O~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!j)yO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!P)|O!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO(P*OO~OR*QO#p*RO(P*PO~OQhXQ'XXZhXd'XX}hX(PhX~ORhX#phXwhX$fhX$|hX[hXohXyhX!lhX!qhX!thX#OhX#PhX'ghX'qhX'rhX'xhX'yhX'zhX'{hX'|hX'}hX(OhX(QhX(RhX(ThX!PhX!ehXXhXPhXvhX!ShX#RhX~P#4kOQ*SO~O})sO~OQ!QO^%vO_%cO`TOaTOd%jO$f%wO%^%xO'T%dO~PGaO!Q*VO!j*VO~O^*YO`*YOa*YO!O*ZO~OQ&oOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO[#}Oo:YO}#zO!l:ZO!q#jO!t:ZO#O:YO#P:VO#p$OO'g#gO'q:ZO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~Ow'dX~P#9vOy#qaX#qa!e#qa!P#qav#qa#R#qa~P2gOy#zaX#za!e#za!P#zav#za#R#za~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!S&_O!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOo#zay#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#zaX#za!e#za!P#zav#za#R#za~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Q*eO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdO~P)xOw*fO~P#9vO$b*iO$d*jO$f*kO~O!O*lO'r(pO~O!S*nO~O'T*oO~Ow$yOy*qO~O'T*rO~OQ*uOw*vOy*yO}*wO$|*xO~OQ*uOw*vO$|*xO~OQ*uOw+QO$|*xO~OQ*uOo+VOy+XO!S+UO~OQ*uO}+ZO~OQ!QOZ%rO[%qO^%vO`TOaTOd%jOg%yO}%pO!U!lO!W!lO!q%oO$f%wO$q%[O%]!lO%^%xO&W%{O'T%dO'Z%eO(Q%zO~OR+bO_+^O!Q+cO~P#DkO_%cO!Q!lOw&UX$|&UX(P&UX~P#DkOw$yO$f+hO$|*xO(P*PO~OQ!QOZ*[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOQ*uOw$yO!S+UO$|*xO~Oo+nOy+mO!S+oO'r(pO~OdlXy!RX#pbXv!RX!e!RX~Od'XXy(mX#p'SXv(mX!e(mX~Od+qO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q+vO~Ov(oP~P!3|O#p+{O~Oy+|O~O!S+}O~O&}!sO'O'VO'P,PO~Od,QO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UO~P#DkOS,^OT,^OZ,^O['cO_,YOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~O!P,dO~P#KkOX,gO~P#KkOv,iO~P#KkOo'tX#O'tX#P'tX#p'tX'r'tX'x'tX'y'tX'z'tX'{'tX'|'tX'}'tX(O'tX(P'tX(R'tX(T'tX~Oy,jO['tX}'tX!l'tX!q'tX!t'tX'g'tX'q'tX(Q'tXv'tX~P#NjOP$giQ$giS$giT$giZ$gi[$gi^$gi_$gi`$gia$gid$gig$gis$git$giu$giw$giy$gi|$gi}$gi!Q$gi!U$gi!W$gi!X$gi!Z$gi!]$gi!l$gi!q$gi!t$gi#Y$gi#r$gi#{$gi$O$gi$b$gi$d$gi$f$gi$i$gi$m$gi$q$gi$s$gi%T$gi%V$gi%Z$gi%]$gi%^$gi%f$gi%j$gi%s$gi&z$gi'Q$gi'T$gi'Z$gi'^$gi'g$gi'q$gi(Q$giv$gi~P#NjOX,kO~O['cOo,lOw'dO}'bOX]X~Oy#ciX#ci!e#ci!P#civ#ci#R#ci~P2gO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei(P#ei~P$'PO[#}O}#zO(O#|O(R#fOo#eiy#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'g#ei'x#ei(P#ei(Q#ei(T#eiw#ei~P$)QO'g#gO(P#gO~P$'PO[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O!q#ei~P$+`O!q#jO~P$+`O[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#R#ei~O'r#ei~P$-hO'r#lO~P$-hO[#}O}#zO!q#jO#P#uO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#eiX#ei!e#ei!P#eiv#ei#R#ei~O'}#ei~P$/pO'}#mO~P$/pO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#ni!t#ni#p#ni'q#ni~Oo#xO#O#xO#P#uOy#niX#ni!e#ni!P#niv#ni#R#ni~P$1xO[#}O}#zO!q#jO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#si!t#si#p#si'q#si~Oo#xO#O#xO#P#uOy#siX#si!e#si!P#siv#si#R#si~P$3yOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO~P)xO!e,sO!P(VX~P2gO!P,uO~OX,vO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO'gcO'qiO(QdOX&fX!e&fX!P&fX~P)xO!e(WOX(Wa~Oy,zO!e(WOX(WX~P2gOX,{O~O!P,|O!e(WO~O!P-OO!e(WO~P2gOSVOTVOsVOtVOuVO'^UO'g$[O~P!6POP!baZca!S!ba!e!ba!tca'qca'r!ba!O!bao!bay!ba!P!baX!ba!Z!ba#R!bav!ba~O!e-TO'r(pO!P'mXX'mX~O!P-VO~O!i-`O!j-_O!l-[O'T-XOv'nP~OX-aO~O_%cO!Q!lO~P#DkO!j-gOP&gX!e&gX~P<cO!e(rOP(Ya~O!S-iO'r(pOP$Wa!e$Wa~Ow!PO(P*PO~OvbX!S!kX!ebX~O'Q#VO'T(xO~O!S-mO~O!e-oOv([X~Ov-qO~Ov-sO~P,cOv-sO~P#$iO_-uO'T&cO~O!S-vO~Ow$yOy-wO~OQ*uOw*vOy-zO}*wO$|*xO~OQ*uOo.UO~Oy._O~O!S.`O~O!j.bO'T&cO~Ov.cO~Ov.cO~PGyOQ']O^'Wa_'Wa`'Waa'Wa'T'Wa~Od.gO~OQ'XXQ'kXR'kXZ'kXd'XX}'kX#p'kX(P'kXw'kX$f'kX$|'kX['kXo'kXy'kX!l'kX!q'kX!t'kX#O'kX#P'kX'g'kX'q'kX'r'kX'x'kX'y'kX'z'kX'{'kX'|'kX'}'kX(O'kX(Q'kX(R'kX(T'kX!P'kX!e'kXX'kXP'kXv'kX!S'kX#R'kX~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t.kO#V.mO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(sP~PGaO#Q.tOR%wa#p%wa(P%waw%wa$f%wa$|%wa[%wao%way%wa}%wa!l%wa!q%wa!t%wa#O%wa#P%wa'g%wa'q%wa'r%wa'x%wa'y%wa'z%wa'{%wa'|%wa'}%wa(O%wa(Q%wa(R%wa(T%wa!P%wa!e%waX%waP%wav%wa!S%wa#R%wa~O%^.vO~PGaO(P*POR&Oa#p&Oaw&Oa$f&Oa$|&Oa[&Oao&Oay&Oa}&Oa!l&Oa!q&Oa!t&Oa#O&Oa#P&Oa'g&Oa'q&Oa'r&Oa'x&Oa'y&Oa'z&Oa'{&Oa'|&Oa'}&Oa(O&Oa(Q&Oa(R&Oa(T&Oa!P&Oa!e&OaX&OaP&Oav&Oa!S&Oa#R&Oa~O_%cO!Q!lO!j.xO(P*OO~P#DkO!e.yO(P*PO!P(uX~O!P.{O~OX.|Oy.}O(P*PO~O'Z%eOR(qP~OQ']O})sORfa#pfa(Pfawfa$ffa$|fa[faofayfa!lfa!qfa!tfa#Ofa#Pfa'gfa'qfa'rfa'xfa'yfa'zfa'{fa'|fa'}fa(Ofa(Qfa(Rfa(Tfa!Pfa!efaXfaPfavfa!Sfa#Rfa~OQ']O})sOR&Va#p&Va(P&Vaw&Va$f&Va$|&Va[&Vao&Vay&Va!l&Va!q&Va!t&Va#O&Va#P&Va'g&Va'q&Va'r&Va'x&Va'y&Va'z&Va'{&Va'|&Va'}&Va(O&Va(Q&Va(R&Va(T&Va!P&Va!e&VaX&VaP&Vav&Va!S&Va#R&Va~O!P/UO~Ow$yO$f/ZO$|*xO(P*PO~OQ!QOZ/[O[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaOo/^O'r(pO~O#W/_OP!YiQ!YiS!YiT!YiZ!Yi[!Yi^!Yi_!Yi`!Yia!Yid!Yig!Yio!Yis!Yit!Yiu!Yiw!Yiy!Yi|!Yi}!Yi!Q!Yi!U!Yi!W!Yi!X!Yi!Z!Yi!]!Yi!l!Yi!q!Yi!t!Yi#O!Yi#P!Yi#Y!Yi#p!Yi#r!Yi#{!Yi$O!Yi$b!Yi$d!Yi$f!Yi$i!Yi$m!Yi$q!Yi$s!Yi%T!Yi%V!Yi%Z!Yi%]!Yi%^!Yi%f!Yi%j!Yi%s!Yi&z!Yi'Q!Yi'T!Yi'Z!Yi'^!Yi'g!Yi'q!Yi'r!Yi'x!Yi'y!Yi'z!Yi'{!Yi'|!Yi'}!Yi(O!Yi(P!Yi(Q!Yi(R!Yi(T!YiX!Yi!e!Yi!P!Yiv!Yi!i!Yi!j!Yi#V!Yi#R!Yi~Oy#ziX#zi!e#zi!P#ziv#zi#R#zi~P2gOy$UiX$Ui!e$Ui!P$Uiv$Ui#R$Ui~P2gOv/eO!j&bO'Q`O~P<cOw/nO}/mO~Oy!RX#pbX~Oy/oO~O#p/pO~OR+bO_+dO!Q/sO'T&iO'Z%eO~Oa/zO|!VO'Q#VO'T(ROv(cP~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P(eP~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw(`Py(`P~PGaOw*vO~Oy-zO$|*xO~Oa/zO|!VO'Q#VO'T*oOv(gP~Ow+QO~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zO(R0`O~PGaOy0dO~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t0hO'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V0nO!P(jP~P%1}Ow!POy0pO#Q0rO$|*xO~OR0uO!e0sO~P#(kOR0uO!S+UO!e0sO(P*OO~OR0uOo0wO!S+UO!e0sOQ'VXZ'VX}'VX#p'VX(P'VX~OR0uOo0wO!e0sO~OR0uO!e0sO~O$f/ZO(P*PO~Ow$yO~Ow$yO$|*xO~Oo0}Oy0|O!S1OO'r(pO~O!e1POv(pX~Ov1RO~O^#TO_#TO`#TOa'kOw&|O'T&vO(Q1VO~Oo1YOQ'VXR'VXZ'VX}'VX!e'VX(P'VX~O!e1ZO(P*POR'YX~O!e1ZOR'YX~O!e1ZO(P*OOR'YX~OR1]O~O!S1^OS'wXT'wXZ'wX['wX_'wXd'wXo'wXs'wXu'wXw'wXy'wX}'wX!P'wX!e'wX!l'wX!q'wX!t'wX!y'wX#O'wX#P'wX#Q'wX#R'wX'Q'wX'Z'wX'^'wX'g'wX'r'wX'v'wX'x'wX'y'wX'z'wX'{'wX'|'wX'}'wX(O'wX(P'wX(Q'wX(R'wXX'wXv'wX~O}1_O~O!P1aO~P#KkOX1bO~P#KkOv1cO~P#KkOS,^OT,^OZ,^O['cO_1dOd,^Oo,^Os,^Ou,^Ow'dOy,^O}'bO!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'v,_O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O(P,`O(Q,`O(R,aO~OX1fO~Oy,jO~O!e,sO!P(Va~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'Q#VO'ZkO'^UO'gcO'qiO(QdO!P&eX!e&eX~P)xO!e,sO!P(Va~OX&fa!e&fa!P&fa~P2gOX1kO~P2gO!P1mO!e(WO~OP!biZci!S!bi!e!bi!tci'qci'r!bi!O!bio!biy!bi!P!biX!bi!Z!bi#R!biv!bi~O'r(pOP!oi!S!oi!e!oi!O!oio!oiy!oi!P!oiX!oi!Z!oi#R!oiv!oi~O!j&bO!P&`X!e&`XX&`X~P<cO!e-TO!P'maX'ma~O!P1qO~Ov!RX!S!kX!e!RX~O!S1rO~O!e1sOv'oX~Ov1uO~O'T-XO~O!j1xO'T-XO~O(P*POP$Wi!e$Wi~O!S1yO'r(pOP$XX!e$XX~O!S1|O~Ov$_a!e$_a~P2gO!l(|O'Q#VO'T(xOv&hX!e&hX~O!e-oOv([a~Ov2QO~P,cOy2UO~O#p2VO~Oy2WO$|*xO~Ow*vOy2WO}*wO$|*xO~Oo2aO~Ow!POy2fO#Q2hO$|*xO~O!S2jO~Ov2lO~O#Q2mOR%wi#p%wi(P%wiw%wi$f%wi$|%wi[%wio%wiy%wi}%wi!l%wi!q%wi!t%wi#O%wi#P%wi'g%wi'q%wi'r%wi'x%wi'y%wi'z%wi'{%wi'|%wi'}%wi(O%wi(Q%wi(R%wi(T%wi!P%wi!e%wiX%wiP%wiv%wi!S%wi#R%wi~Od2nO~O^2qO!j.sO!q2rO'Q#VO'Z%eO~O(P*PO!P%{X!e%{X~O!e2sO!P(tX~O!P2uO~OQ!QOZ%rO[%qO^2wO_%cO`TOaTOd%jOg%yO}%pO!j2xO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(Q%zO~PGaO^2yO!j2xO(P*OO~O!P%aX!e%aX~P#4kO^2yO~O(P*POR&Oi#p&Oiw&Oi$f&Oi$|&Oi[&Oio&Oiy&Oi}&Oi!l&Oi!q&Oi!t&Oi#O&Oi#P&Oi'g&Oi'q&Oi'r&Oi'x&Oi'y&Oi'z&Oi'{&Oi'|&Oi'}&Oi(O&Oi(Q&Oi(R&Oi(T&Oi!P&Oi!e&OiX&OiP&Oiv&Oi!S&Oi#R&Oi~O_%cO!Q!lO!P&yX!e&yX~P#DkO!e.yO!P(ua~OR3QO(P*PO~O!e3ROR(rX~OR3TO~O(P*POR&Pi#p&Piw&Pi$f&Pi$|&Pi[&Pio&Piy&Pi}&Pi!l&Pi!q&Pi!t&Pi#O&Pi#P&Pi'g&Pi'q&Pi'r&Pi'x&Pi'y&Pi'z&Pi'{&Pi'|&Pi'}&Pi(O&Pi(Q&Pi(R&Pi(T&Pi!P&Pi!e&PiX&PiP&Piv&Pi!S&Pi#R&Pi~O!P3UO~O$f3VO(P*PO~Ow$yO$f3VO$|*xO(P*PO~Ow!PO!Z!YO~O!Z3aO#R3_O'r(pO~O!j&bO'Q#VO~P<cOv3eO~Ov3eO!j&bO'Q`O~P<cO!O3hO'r(pO~Ow!PO~P#9vOo3kOy3jO(P*PO~O!P3oO~P%;pOv3rO~P%;pOR0uO!S+UO!e0sO~OR0uOo0wO!S+UO!e0sO~Oa/zO|!VO'Q#VO'T(RO~O!S3uO~O!e3wOv(dX~Ov3yO~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO~PGaO!e3|O(P*PO!P(fX~O!P4OO~O!S4PO(P*OO~O!S+UO(P*PO~O!e4ROw(aXy(aX~OQ4TO~Oy2WO~Oa/zO|!VO'Q#VO'T*oO~Oo4WOw*vO}*wOv%XX!e%XX~O!e4ZOv(hX~Ov4]O~O(P4_Oy(_Xw(_X$|(_XR(_Xo(_X!e(_X~Oy4aO(P*PO~OQ!QOSVOTVO[$gO^4bO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O!j4cO'Z%eO~P&,sO!S4eO'r(pO~O#V4gO~P%1}O!e4hO!P(kX~O!P4jO~O!P%aX!S!aX!e%aX'r!aX~P!KgO!j&bO~P&,sO!e4hO!P(kX!S'eX'r'eX~O^2yO!j2xO~Ow!POy2fO~O_4pO!Q/sO'T&iO'Z%eOR&lX!e&lX~OR4rO!e0sO~O!S4tO~Ow$yO$|*xO(P*PO~Oy4uO~P2gOo4vOy4uO(P*PO~Ov&uX!e&uX~P!3|O!e1POv(pa~Oo4|Oy4{O(P*PO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'^UOR&vX!e&vX~P#DkO!e1ZOR'Ya~O!y5SO~O!P5TO~P#KkO!S1^OX'wX#R'wX~O!e,sO!P(Vi~O!P&ea!e&ea~P2gOX5WO~P2gOP!bqZcq!S!bq!e!bq!tcq'qcq'r!bq!O!bqo!bqy!bq!P!bqX!bq!Z!bq#R!bqv!bq~O'r(pO!P&`a!e&`aX&`a~O!i-`O!j-_O!l5YO'T-XOv&aX!e&aX~O!e1sOv'oa~O!S5[O~O!S5`O'r(pOP$Xa!e$Xa~O(P*POP$Wq!e$Wq~Ov$^i!e$^i~P2gOw!POy5bO#Q5dO$|*xO~Oo5gOy5fO(P*PO~Oy5iO~Oy5iO$|*xO~Oy5mO(P*PO~Ow!POy5bO~Oo5tOy5sO(P*PO~O!S5vO~O!e2sO!P(ta~O^2yO!j2xO'Z%eO~OQ!QOZ%rO[%qO^.rO_%cO`TOaTOd%jOg%yO}%pO!j.sO!q.pO!t5zO#V5|O$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&xX!e&xX~PGaOQ!QOZ%rO[%qO^6OO_%cO`TOaTOd%jOg%yO}%pO!j6PO!q%oO$f%wO%^%xO&W%{O'T%dO'Z%eO(P*OO(Q%zO~PGaO!P%aa!e%aa~P#4kO^6QO~O#Q6ROR%wq#p%wq(P%wqw%wq$f%wq$|%wq[%wqo%wqy%wq}%wq!l%wq!q%wq!t%wq#O%wq#P%wq'g%wq'q%wq'r%wq'x%wq'y%wq'z%wq'{%wq'|%wq'}%wq(O%wq(Q%wq(R%wq(T%wq!P%wq!e%wqX%wqP%wqv%wq!S%wq#R%wq~O(P*POR&Oq#p&Oqw&Oq$f&Oq$|&Oq[&Oqo&Oqy&Oq}&Oq!l&Oq!q&Oq!t&Oq#O&Oq#P&Oq'g&Oq'q&Oq'r&Oq'x&Oq'y&Oq'z&Oq'{&Oq'|&Oq'}&Oq(O&Oq(Q&Oq(R&Oq(T&Oq!P&Oq!e&OqX&OqP&Oqv&Oq!S&Oq#R&Oq~O(P*PO!P&ya!e&ya~OX6SO~P2gO'Z%eOR&wX!e&wX~O!e3ROR(ra~O$f6YO(P*PO~Ow![q~P#9vO#R6]O~O!Z3aO#R6]O'r(pO~Ov6bO~O#R6fO~Oy6gO!P6hO~O!P6hO~P%;pOy6kO~Ov6kOy6gO~Ov6kO~P%;pOy6mO~O!e3wOv(da~O!S6pO~Oa/zO|!VO'Q#VO'T(ROv&oX!e&oX~O!e3|O(P*PO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOa/zOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'Q#VO'T%dO'Z%eO(Q%zO!P&pX!e&pX~PGaO!e3|O!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0VO%^%xO&W%{O'T%dO'Z%eO(Q%zOw&nX!e&nXy&nX~PGaO!e4ROw(aay(aa~O!e4ZOv(ha~Oo7SOv%Xa!e%Xa~Oo7SOw*vO}*wOv%Xa!e%Xa~Oa/zO|!VO'Q#VO'T*oOv&qX!e&qX~O(P*POy$xaw$xa$|$xaR$xao$xa!e$xa~O(P4_Oy(_aw(_a$|(_aR(_ao(_a!e(_a~O!P%aa!S!aX!e%aa'r!aX~P!KgOQ!QOSVOTVO[$gO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'T$YO'^UO'g$[O~O^7ZO~P&JUO^6QO!j6PO~O!e4hO!P(ka~O!e4hO!P(ka!S'eX'r'eX~OQ!QOSVOTVO[$gO^0lO_$ZO`9yOa9yOd$aOsVOtVOuVO}$eO!i$qO!j0mO!l$lO!q0eO!t7_O'Q#VO'T$YO'Z%eO'^UO'g$[O~O#V7aO!P&sX!e&sX~P&L]O!S7cO'r(pO~Ow!POy5bO$|*xO(P*PO~O!S+UOR&la!e&la~Oo0wO!S+UOR&la!e&la~Oo0wOR&la!e&la~O(P*POR$yi!e$yi~Oy7fO~P2gOo7gOy7fO(P*PO~O(P*PORni!eni~O(P*POR&va!e&va~O(P*OOR&va!e&va~OS,^OT,^OZ,^O_,^Od,^Oo,^Os,^Ou,^Oy,^O!S,^O!e,^O!l,^O!q,[O!t,^O!y,^O#O,^O#P,^O#Q,^O#R,^O'Q,^O'Z%eO'^UO'g,ZO'r,[O'x,ZO'y,[O'z,[O'{,[O'|,]O'},]O(O,^O~O(P7iO(Q7iO(R7iO~P'!qO!P7kO~P#KkO!P&ei!e&ei~P2gO'r(pOv!hi!e!hi~O!S7mO~O(P*POP$Xi!e$Xi~Ov$^q!e$^q~P2gOw!POy7oO~Ow!POy7oO#Q7rO$|*xO~Oy7tO~Oy7uO~Oy7vO(P*PO~Ow!POy7oO$|*xO(P*PO~Oo7{Oy7zO(P*PO~O!e2sO!P(ti~O(P*PO!P%}X!e%}X~O!P%ai!e%ai~P#4kO^8OO~O!e8TO['bXv$`i}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[iv$`i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R#^a~P2gO#R8WO~O!Z3aO#R8XO'r(pO~Ov8[O~Oy8^O~P2gOy8`O~Oy6gO!P8aO~Ov8`Oy6gO~O!e3wOv(di~O(P*POv%Qi!e%Qi~O!e3|O!P(fi~O!e3|O(P*PO!P(fi~O(P*PO!P&pa!e&pa~O(P8hOw(bX!e(bXy(bX~O(P*PO!S$wiy$wiw$wi$|$wiR$wio$wi!e$wi~O!e4ZOv(hi~Ov%Xi!e%Xi~P2gOo8kOv%Xi!e%Xi~O!P%ai!S!aX!e%ai'r!aX~P!KgO(P*PO!P%`i!e%`i~O!e4hO!P(ki~O#V8nO~P&L]O!P&sa!S'eX!e&sa'r'eX~O(P*POR$zq!e$zq~Oy8pO~P2gOy7zO~P2gO(P8rO(Q8rO(R8rO~O(P8rO(Q8rO(R8rO~P'!qO'r(pOv!hq!e!hq~O(P*POP$Xq!e$Xq~Ow!POy8uO$|*xO(P*PO~Ow!POy8uO~Oy8xO~P2gOy8zO~P2gOo8|Oy8zO(P*PO~OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[qv$`q}#[q!i#[q!j#[q!l#[q!q#[q#V#[q'Q#[q'T#[q'^#[q'g#[q~O!e9PO['bXv$`q}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'2fO#R9UO~O!Z3aO#R9UO'r(pO~Oy9WO~O(P*POv%Qq!e%Qq~O!e3|O!P(fq~O(P*PO!P&pi!e&pi~O(P8hOw(ba!e(bay(ba~Ov%Xq!e%Xq~P2gO!P&si!S'eX!e&si'r'eX~O(P*PO!P%`q!e%`q~Oy9]O~P2gO(P9^O(Q9^O(R9^O~O'r(pOv!hy!e!hy~Ow!POy9_O~Ow!POy9_O$|*xO(P*PO~Oy9aO~P2gOQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[yv$`y}#[y!i#[y!j#[y!l#[y!q#[y#V#[y'Q#[y'T#[y'^#[y'g#[y~O!e9dO['bXv$`y}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[Oo'bX!t'bX#O'bX#P'bX#p'bX'q'bX'r'bX'x'bX'y'bX'z'bX'{'bX'|'bX'}'bX(O'bX(P'bX(Q'bX(R'bX(T'bX~P'9eO!e9eO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[i}#[i!i#[i!j#[i!l#[i!q#[i!t'bX#V#[i'Q#[i'T#[i'^#[i'g#[i'q'bX(Q'bX~P@[O#R9hO~O(P*PO!P&pq!e&pq~Ov%Xy!e%Xy~P2gOw!POy9iO~Oy9jO~P2gOQ#[!RS#[!RT#[!R[#[!R^#[!R_#[!R`#[!Ra#[!Rd#[!Rs#[!Rt#[!Ru#[!Rv$`!R}#[!R!i#[!R!j#[!R!l#[!R!q#[!R#V#[!R'Q#[!R'T#[!R'^#[!R'g#[!R~O!e9kO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[q}#[q!i#[q!j#[q!l#[q!q#[q!t'bX#V#[q'Q#[q'T#[q'^#[q'g#[q'q'bX(Q'bX~P@[O!e9nO['bX}'bX!l'bX!q'bX!t'bX'g'bX'q'bX(Q'bX~P@[OQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[y}#[y!i#[y!j#[y!l#[y!q#[y!t'bX#V#[y'Q#[y'T#[y'^#[y'g#[y'q'bX(Q'bX~P@[OwbX~P$|OwjX}jX!tbX'qbX~P!6mOZ'SXd'XXo'SXw'kX!t'SX'q'SX'r'SX~O['SXd'SXw'SX}'SX!l'SX!q'SX#O'SX#P'SX#p'SX'g'SX'x'SX'y'SX'z'SX'{'SX'|'SX'}'SX(O'SX(P'SX(Q'SX(R'SX(T'SX~P'GTOP'SX}'kX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTO^9qO_9qO`9qOa9qO'T9oO~O!j:OO~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sXo#sXw#sX}#sX!l#sX!q#sX!t#sX#O#sX#P#sX#p#sX'g#sX'q#sX'r#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sX~P'IxO#Q$uO~P!.cO}'kXP'SX!S'SX!e'SX!O'SXy'SX!P'SXX'SX!Z'SX#R'SXv'SX~P'GTOo#qX#O#qX#P#qX#p#qX'r#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qX~P!.cOo#zX#O#zX#P#zX#p#zX'r#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zX~P!.cOPoOQ!QOSVOTVOZeOd9tOsVOtVOuVO!U#bO!W#cO!X:zO!Z!YO#Y!_O#r9zO#{9{O$O!]O$b!`O$d!bO$f!cO'ZkO'^UO[#sao#saw#sa}#sa!l#sa!q#sa!t#sa#O#sa#P#sa#p#sa'g#sa'q#sa'r#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#sa~P'IxOo:YO#O:YO#P:VOw#sa~P!B}Ow$Ua~P#9vOQ'XXd'XX}iX~OQlXdlX}jX~O^:sO_:sO`:sOa:sO'T:_O~OQ'XXd'XX}hX~Ow#qa~P#9vOw#za~P#9vO!S&_Oo#za#O#za#P#za#p#za'r#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#za~P!.cO#Q*eO~P!.cOw#ci~P#9vO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!q#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'y#ei'z#ei'{#ei'|#ei'}#ei~O'g#ei(P#ei~P((}O'g#gO(P#gO~P((}O[#}O}#zO'g#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'r#ei'{#ei'|#ei'}#ei~O!q#ei~P(*yO!q#jO~P(*yO[#}O}#zO!q#jO'g#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#P#ei#p#ei'q#ei'|#ei'}#ei~O'r#ei~P(,rO'r#lO~P(,rO[#}O}#zO!q#jO#P:VO'g#gO'r#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#O#ei#p#ei'q#ei'|#ei~O'}#ei~P(.kO'}#mO~P(.kOo:YO#O:YO#P:VOw#ni~P$1xOo:YO#O:YO#P:VOw#si~P$3yOQ'XXd'XX}'kX~Ow#zi~P#9vOw$Ui~P#9vOd9}O~Ow#ca~P#9vOd:uO~OU'x_'v'P'O'^s!y'^'T'Z~",
  goto: "$Ku(vPPPPPPP(wPP)OPP)^PPPP)d-hP0f5aP7R7R8v7R>wD_DpPDvHQPPPPPPK`P! P! _PPPPP!!VP!$oP!$oPP!&oP!(rP!(w!)n!*f!*f!*f!(w!+]P!(w!.Q!.TPP!.ZP!(w!(w!(w!(wP!(w!(wP!(w!(w!.y!/dP!/dJ}J}J}PPPP!/d!.y!/sPP!$oP!0^!0a!0g!1h!1t!3t!3t!5r!7t!1t!1t!9p!;_!=O!>k!@U!Am!CS!De!1t!1tP!1tP!1t!1t!Et!1tP!Ge!1t!1tP!Ie!1tP!1t!7t!7t!1t!7t!1t!Kl!Mt!Mw!7t!1t!Mz!M}!M}!M}!NR!$oP!$oP!$oP! P! PP!N]! P! PP!Ni# }! PP! PP#!^##c##k#$Z#$_#$e#$e#$mP#&s#&s#&y#'o#'{! PP! PP#(]#(l! PP! PPP#(x#)W#)d#)|#)^! P! PP! P! P! PP#*S#*S#*Y#*`#*S#*S! P! PP#*m#*v#+Q#+Q#,x#.l#.x#.x#.{#.{5a5a5a5a5a5a5a5aP5a#/O#/U#/p#1{#2R#2b#6^#6d#6j#6|#7W#8w#9R#9b#9h#9n#9x#:S#:Y#:g#:m#:s#:}#;]#;g#=u#>R#>`#>f#>n#>u#?PPPPPPPP#?V#BaP#F^#Jx#Ls#Nr$&^P$&aPPP$)_$)h$)z$/U$1d$1m$3fP!(w$4`$7r$:i$>T$>^$>c$>fPPP$>i$A`$A|P$BaPPPPPPPPPP$BvP$EU$EX$E[$Eb$Ee$Eh$Ek$En$Et$HO$HR$HU$HX$H[$H_$Hb$He$Hh$Hk$Hn$Jt$Jw$Jz#*S$KW$K^$Ka$Kd$Kh$Kl$Ko$KrQ!tPT'V!s'Wi!SOlm!P!T$T$W$y%b)U*f/gQ'i#QR,n'l(OSOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%X%_%b&U&Y&[&b&u&z&|'P'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n+z,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1P1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:gS(z$v-oQ*p&eQ*t&hQ-k(yQ-y)ZW0Z+Q0Y4Z7UR4Y0[&w!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#r]Ofgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hb#[b#Q$y'l(b)S)U*Z-t!h$bo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m$b%k!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g!W:y!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:|%n$_%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g$e%l!Q!n$O$u%n%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g'hZOY[fgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r%_%b%i%j&U&Y&[&b&u'a'}(W(Y(d(e(f(j(o(p(r(|)i)p)q*f*i*k*l+Z+n,s,z-R-T-g-m.i.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:x$^%l!Q!n$O$u%n%o%p%q%y%{&P&p&r(q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ&j!hQ&k!iQ&l!jQ&m!kQ&s!oQ)[%QQ)]%RQ)^%SQ)_%TQ)b%WQ+`&oS,R']1ZQ.W)`S/r*u4TR4n0s+yTOY[bfgilmop!O!P!Q!T!Y!Z![!_!`!c!n!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$O$T$W$`$a$e$g$h$q$r$u$y%X%_%b%i%j%n%o%p%q%y%{&P&U&Y&[&b&o&p&r&u&z&|'P']'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(q(r(|)S)U)i)p)q)s)x)y*O*P*R*V*Z*[*^*e*f*i*k*l*n*w*x+U+V+Z+h+n+o+z+},q,s,z-R-T-g-i-m-t-v.U.`.i.p.t.x.y.}/Z/[/^/b/d/g/{/}0`0e0g0m0r0w0}1O1P1Y1Z1h1r1y1|2a2h2j2m2s2v3V3_3a3f3h3k3u3{3|4R4U4W4_4c4e4h4t4v4|5[5`5d5g5t5v6R6Y6]6a6p6v6x7S7^7c7g7m7r7{8W8X8g8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:`:a:e:f:g:t:u:xQ'[!xQ'h#PQ)l%gU)r%m*T*WR.f)kQ,T']R5P1Z#t%s!Q!n$O$u%p%q&P&p&r(q)x)y*O*R*V*[*^*e*n*w+V+h+o+}-i-v.U.`.t.x.y/Z/[/{/}0`0r0w1O1Y1y2a2h2j2m2v3V3u3{3|4U4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)x%oQ+_&oQ,U']n,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7kS.q)s2sQ/O*PQ/Q*SQ/q*uS0Q*x4RQ0a+U[0o+Z.j0g4h5y7^Q2v.pS4d0e2rQ4m0sQ5Q1ZQ6T3RQ6z4PQ7O4TQ7X4_R9Y8h&jVOfgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u']'}(W(Y(b(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1Z1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fU&g!g%P%[o,^'b'c'd,c,f,h,l/m/n1_3n3q5T5U7k$nsOfgilm!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y'}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9z9{:O:P:Q:R:S:T:U:V:W:X:Y:eS$tp9xS&O!W#bS&Q!X#cQ&`!bQ*_&RQ*a&VS*d&[:fQ*h&^Q,T']Q-j(wQ/i*jQ0p+[S2f.X0qQ3]/_Q3^/`Q3g/hQ3i/kQ5P1ZU5b2R2g4lU7o5c5e5rQ8]6dS8u7p7qS9_8v8wR9i9`i{Ob!O!P!T$y%_%b)S)U)i-thxOb!O!P!T$y%_%b)S)U)i-tW/v*v/t3w6qQ/}*wW0[+Q0Y4Z7UQ3{/{Q6x3|R8g6v!h$do!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ&d!dQ&f!fQ&n!mW&x!q%X&|1PQ'S!rQ)X$}Q)Y%OQ)a%VU)d%Y'T'UQ*s&hS+s&z'PS-Y(k1sQ-u)WQ-x)ZS.a)e)fS0x+c/sQ1S+zQ1W+{S1v-_-`Q2k.bQ3s/pQ5]1xR5h2V${sOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$zsOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR3]/_V&T!Y!`*i!i$lo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!k$^o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m!i$co!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&e^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR(l$fQ-[(kR5Y1sQ(S#|S({$v-oS-Z(k1sQ-l(yW/u*v/t3w6qS1w-_-`Q3v/vR5^1xQ'e#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,o'mk,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ'f#Or,e'b'c'd'j'p)u,c,f,h,l/m/n1_3n3q5U6fR,p'mR*g&]X/c*f/d/g3f!}aOb!O!P!T#z$v$y%_%b'}(y)S)U)i)s*f*v*w+Q+Z,s-o-t.j/b/d/g/t/{0Y0g1h2s3f3w3|4Z4h5y6a6q6v7U7^Q3`/aQ6_3bQ8Y6`R9V8Z${rOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f#nfOfglmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!T9u!Y!_!`*i*l/^3h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#rfOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h!X9u!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$srOfglmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:e:f#U#oh#d$P$Q$V$s%^&W&X'q't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b}:P&S&]/k3[6d:[:]:c:d:h:j:k:l:m:n:o:p:q:r:v:w:{#W#ph#d$P$Q$V$s%^&W&X'q'r't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b!P:Q&S&]/k3[6d:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{#S#qh#d$P$Q$V$s%^&W&X'q'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9b{:R&S&]/k3[6d:[:]:c:d:h:k:l:m:n:o:p:q:r:v:w:{#Q#rh#d$P$Q$V$s%^&W&X'q'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9by:S&S&]/k3[6d:[:]:c:d:h:l:m:n:o:p:q:r:v:w:{#O#sh#d$P$Q$V$s%^&W&X'q'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bw:T&S&]/k3[6d:[:]:c:d:h:m:n:o:p:q:r:v:w:{!|#th#d$P$Q$V$s%^&W&X'q'x'y'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bu:U&S&]/k3[6d:[:]:c:d:h:n:o:p:q:r:v:w:{!x#vh#d$P$Q$V$s%^&W&X'q'z'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bq:W&S&]/k3[6d:[:]:c:d:h:p:q:r:v:w:{!v#wh#d$P$Q$V$s%^&W&X'q'{'|(O(U([(`*b*c,r,w,y-n0z1i1l1}3P4w5V5a6^6e7R7e7h7s7y8j8q8{9[9bo:X&S&]/k3[6d:[:]:c:d:h:q:r:v:w:{$]#{h#`#d$P$Q$V$s%^&S&W&X&]'q'r's't'u'v'w'x'y'z'{'|(O(U([(`*b*c,r,w,y-n/k0z1i1l1}3P3[4w5V5a6^6d6e7R7e7h7s7y8j8q8{9[9b:[:]:c:d:h:i:j:k:l:m:n:o:p:q:r:v:w:{${jOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f$v!aOfgilmp!O!P!T!Y!Z!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ&Y![Q&Z!]R:e9{#rpOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hQ&[!^!W9x!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fR:f:zR$moR-f(rR$wqT(}$v-oQ/f*fS3d/d/gR6c3fQ3m/mQ3p/nQ6i3nR6l3qQ$zwQ)V${Q*q&fQ+f&qQ+i&sQ-w)YW.Z)b+j+k+lS/X*]+gW2b.W.[.].^U3W/Y/]0yU5o2c2d2eS6W3X3ZS7w5p5qS8Q6V6XQ8y7xS8}8R8SR9c9O^|O!O!P!T%_%b)iX)R$y)S)U-tQ&r!nQ*^&PQ*|&jQ+P&kQ+T&lQ+W&mQ+]&nQ+l&sQ-})[Q.Q)]Q.T)^Q.V)_Q.Y)aQ.^)bQ2S-uQ2e.WR4U0VU+a&o*u4TR4o0sQ+Y&mQ+k&sS.])b+l^0v+_+`/q/r4m4n7OS2d.W.^S4Q0R0SR5q2eS0R*x4RQ0a+UR7X4_U+d&o*u4TR4p0sQ*z&jQ+O&kQ+S&lQ+g&qQ+j&sS-{)[*|S.P)]+PS.S)^+TU.[)b+k+lQ/Y*]Q0X*{Q0q+[Q2X-|Q2Y-}Q2].QQ2_.TU2c.W.].^Q2g.XS3Z/]0yS5c2R4lQ5j2ZS5p2d2eQ6X3XS7q5e5rQ7x5qQ8R6VQ8v7pQ9O8SR9`8wQ0T*xR6|4RQ*y&jQ*}&kU-z)[*z*|U.O)]+O+PS2W-{-}S2[.P.QQ4X0ZQ5i2YQ5k2]R7T4YQ/w*vQ3t/tQ6r3wR8d6qQ*{&jS-|)[*|Q2Z-}Q4X0ZR7T4YQ+R&lU.R)^+S+TS2^.S.TR5l2_Q0]+QQ4V0YQ7V4ZR8l7UQ+[&nS.X)a+]S2R-u.YR5e2SQ0i+ZQ4f0gQ7`4hR8m7^Q.m)sQ0i+ZQ2p.jQ4f0gQ5|2sQ7`4hQ7}5yR8m7^Q0i+ZR4f0gX'O!q%X&|1PX&{!q%X&|1PW'O!q%X&|1PS+u&z'PR1U+z_|O!O!P!T%_%b)iQ%a!PS)h%_%bR.d)i$^%u!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ*U%yR*X%{$c%n!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gW)t%m%x*T*WQ.e)jR2{.vR.m)sR5|2sQ'W!sR,O'WQ!TOQ$TlQ$WmQ%b!P[%|!T$T$W%b)U/gQ)U$yR/g*f$b%i!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g[)n%i)p.i:`:t:xQ)p%jQ.i)qQ:`%nQ:t:aR:x:uQ!vUR'Y!vS!OO!TU%]!O%_)iQ%_!PR)i%b#rYOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i+n,s,z-m.}0}1h1|3_3a3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9hh!yY!|#U$`'a'n(d,q-R9s9|:gQ!|[b#Ub#Q$y'l(b)S)U*Z-t!h$`o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ'a!}Q'n#ZQ(d$aQ,q'oQ-R(e!W9s!Y!_!`*i*l/^3h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ9|9tR:g9}Q-U(gR1p-UQ1t-[R5Z1tQ,c'bQ,f'cQ,h'dW1`,c,f,h5UR5U1_Q/d*fS3c/d3fR3f/gfbO!O!P!T$y%_%b)S)U)i-tp#Wb'}(y.j/b/t/{0Y0g1h5y6a6q6v7U7^Q'}#zS(y$v-oQ.j)sW/b*f/d/g3fQ/t*vQ/{*wQ0Y+QQ0g+ZQ1h,sQ5y2sQ6q3wQ6v3|Q7U4ZR7^4hQ,t(OQ1g,rT1j,t1gS(X$Q([Q(^$VU,x(X(^,}R,}(`Q(s$mR-h(sQ-p)OR2P-pQ3n/mQ3q/nT6j3n3qQ)S$yS-r)S-tR-t)UQ4`0aR7Y4``0t+^+_+`+a+d/q/r7OR4q0tQ8i6zR9Z8iQ4S0TR6}4SQ3x/wQ6n3tT6s3x6nQ3}/|Q6t3zU6y3}6t8eR8e6uQ4[0]Q7Q4VT7W4[7QhzOb!O!P!T$y%_%b)S)U)i-tQ$|xW%Zz$|%f)v$b%f!Q!n$O$u%o%p%q%y%{&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR)v%nS4i0i0nS7]4f4gT7b4i7]W&z!q%X&|1PS+r&z+zR+z'PQ1Q+wR4z1QU1[,S,T,UR5R1[S3S/Q7OR6U3SQ2t.mQ5x2pT5}2t5xQ.z)zR3O.z^_O!O!P!T%_%b)iY#Xb$y)S)U-t$l#_fgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!h$io!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'j#Q'lQ-P(bR/V*Z&v!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'l'}(W(Y(b(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,s,z-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!{Y[#U#Z9s9tW&{!q%X&|1P['`!|!}'n'o9|9}S(c$`$aS+t&z'PU,X'a,q:gS-Q(d(eQ1T+zR1n-RS%t!Q&oQ&q!nQ(V$OQ(w$uS)w%o.pQ)z%pQ)}%qS*]&P&rQ+e&pQ,S']Q-d(qQ.l)sU.w)x)y2vS/O*O*PQ/P*RQ/T*VQ/W*[Q/]*^Q/`*eQ/l*nQ/|*wS0S*x4RQ0a+UQ0c+VQ0y+hQ0{+oQ1X+}Q1{-iQ2T-vQ2`.UQ2i.`Q2z.tQ2|.xQ2}.yQ3X/ZQ3Y/[S3z/{/}Q4^0`Q4l0rQ4s0wQ4x1OQ4}1YQ5O1ZQ5_1yQ5n2aQ5r2hQ5u2jQ5w2mQ5{2sQ6V3VQ6o3uQ6u3{Q6w3|Q7P4UQ7X4_Q7[4eQ7d4tQ7n5`Q7p5dQ7|5vQ8P6RQ8S6YQ8c6pS8f6v6xQ8o7cQ8w7rR9X8g$^%m!Q!n$O$u%o%p%q&P&o&p&r'](q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gQ)j%nQ*T%yR*W%{$y%h!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x'pWOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$x%g!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](q)p)q)s)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.i.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8g:`:a:t:u:x_&y!q%X&z&|'P+z1PR,V']$zrOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!j$]o!c!p$e$g$h$q$r&U&b&u(b(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mQ,T']R5P1Z_}O!O!P!T%_%b)i^|O!O!P!T%_%b)iQ#YbX)R$y)S)U-tbhO!O!T3_6]8W8X9U9hS#`f9uQ#dgQ$PiQ$QlQ$VmQ$spW%^!P%_%b)iU&S!Y!`*iQ&W!ZQ&X![Q&]!_Q'q#eQ'r#oS's#p:QQ't#qQ'u#rQ'v#sQ'w#tQ'x#uQ'y#vQ'z#wQ'{#xQ'|#yQ(O#zQ(U#}Q([$TQ(`$WQ*b&YQ*c&[Q,r'}Q,w(WQ,y(YQ-n(|Q/k*lQ0z+nQ1i,sQ1l,zQ1}-mQ3P.}Q3[/^Q4w0}Q5V1hQ5a1|Q6^3aQ6d3hQ6e3kQ7R4WQ7e4vQ7h4|Q7s5gQ7y5tQ8j7SQ8q7gQ8{7{Q9[8kQ9b8|Q:[9wQ:]9xQ:c9zQ:d9{Q:h:OQ:i:PQ:j:RQ:k:SQ:l:TQ:m:UQ:n:VQ:o:WQ:p:XQ:q:YQ:r:ZQ:v:eQ:w:fR:{9v^tO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6[3_Q8V6]Q9R8WQ9T8XQ9g9UR9m9hQ&V!YQ&^!`R/h*iQ$joQ&a!cQ&t!pU(g$e$g(jS(n$h0eQ(u$qQ(v$rQ*`&UQ*m&bQ+p&uQ-S(fS-b(o4cQ-c(pQ-e(rW/a*f/d/g3fQ/j*kW0f+Z0g4h7^Q1o-TQ1z-gQ3b/bQ4k0mQ5X1rQ7l5[Q8Z6aR8t7m!h$_o!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mR-P(b'qXOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'l'n'o'}(W(Y(b(d(e(f(j(o(p(r(|)S)U)i*Z*f*i*k*l+Z+n,q,s,z-R-T-g-m-t.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9s9t9u9v9w9x9z9{9|9}:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f:g$zqOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$fo!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7m&d^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'}(W(Y(f(j(o(p(r(|)i*f*i*k*l+Z+n,s,z-T-g-m.}/^/b/d/g0e0g0m0}1h1r1|3_3a3f3h3k4W4c4h4v4|5[5g5t6]6a7S7^7g7m7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f[!zY[$`$a9s9t['_!|!}(d(e9|9}W)o%i%j:`:aU,W'a-R:gW.h)p)q:t:uT2o.i:xQ(i$eQ(m$gR-W(jV(h$e$g(jR-^(kR-](k$znOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['}(W(Y(|)i*i*l+n,s,z-m.}/^0}1h1|3_3a3h3k4W4v4|5g5t6]7S7g7{8W8X8k8|9U9h9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:f!i$ko!c!p$e$g$h$q$r&U&b&u(f(j(o(p(r*f*k+Z-T-g/b/d/g0e0g0m1r3f4c4h5[6a7^7mS'g#O'pj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ,m'jQ.u)uR8_6f`,b'b'c'd,c,f,h1_5UQ1e,lX3l/m/n3n3qj,a'b'c'd,c,f,h,l/m/n1_3n3q5UQ7j5TR8s7k^uO!O!P!T%_%b)i$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['}(W(Y(|*i*l+n,s,z-m.}/^0}1h1|3a3h3k4W4v4|5g5t7S7g7{8k8|9u9v9w9x9z9{:O:P:Q:R:S:T:U:V:W:X:Y:Z:e:fQ6Z3_Q8U6]Q9Q8WQ9S8XQ9f9UR9l9hR(Q#zR(P#zQ$SlR(]$TR$ooR$noR)Q$vR)P$vQ)O$vR2O-ohwOb!O!P!T$y%_%b)S)U)i-t$l!lz!Q!n$O$u$|%f%n%o%p%q%y%{&P&o&p&r'](q)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR${xR0b+UR0W*xR0U*xR6{4PR/y*vR/x*vR0P*wR0O*wR0_+QR0^+Q%XyObxz!O!P!Q!T!n$O$u$y$|%_%b%f%n%o%p%q%y%{&P&o&p&r'](q)S)U)i)s)v)x)y*O*P*R*V*[*^*e*n*w*x+U+V+h+o+}-i-t-v.U.`.p.t.x.y/Z/[/{/}0`0r0w1O1Y1Z1y2a2h2j2m2s2v3V3u3{3|4R4U4_4e4t5`5d5v6R6Y6p6v6x7c7r8gR0k+ZR0j+ZQ'R!qQ)c%XQ+w&|R4y1PX'Q!q%X&|1PR+y&|R+x&|T/S*S4TT/R*S4TR.o)sR.n)sR){%p",
  nodeNames: "âš  | < > RawString Float LineComment BlockComment SourceFile ] InnerAttribute ! [ MetaItem self Metavariable super crate Identifier ScopedIdentifier :: QualifiedScope AbstractType impl SelfType MetaType TypeIdentifier ScopedTypeIdentifier ScopeIdentifier TypeArgList TypeBinding = Lifetime String Escape Char Boolean Integer } { Block ; ConstItem Vis pub ( in ) const BoundIdentifier : UnsafeBlock unsafe AsyncBlock async move IfExpression if LetDeclaration let LiteralPattern ArithOp MetaPattern SelfPattern ScopedIdentifier TuplePattern ScopedTypeIdentifier , StructPattern FieldPatternList FieldPattern ref mut FieldIdentifier .. RefPattern SlicePattern CapturedPattern ReferencePattern & MutPattern RangePattern ... OrPattern MacroPattern ParenthesizedTokens TokenBinding Identifier TokenRepetition ArithOp BitOp LogicOp UpdateOp CompareOp -> => ArithOp BracketedTokens BracedTokens _ else MatchExpression match MatchBlock MatchArm Attribute Guard UnaryExpression ArithOp DerefOp LogicOp ReferenceExpression TryExpression BinaryExpression ArithOp ArithOp BitOp BitOp BitOp BitOp LogicOp LogicOp AssignmentExpression TypeCastExpression as ReturnExpression return RangeExpression CallExpression ArgList AwaitExpression await FieldExpression GenericFunction BreakExpression break LoopLabel ContinueExpression continue IndexExpression ArrayExpression TupleExpression MacroInvocation UnitExpression ClosureExpression ParamList Parameter Parameter ParenthesizedExpression StructExpression FieldInitializerList ShorthandFieldInitializer FieldInitializer BaseFieldInitializer MatchArm WhileExpression while LoopExpression loop ForExpression for MacroInvocation MacroDefinition macro_rules MacroRule EmptyStatement ModItem mod DeclarationList AttributeItem ForeignModItem extern StructItem struct TypeParamList ConstrainedTypeParameter TraitBounds HigherRankedTraitBound RemovedTraitBound OptionalTypeParameter ConstParameter WhereClause where LifetimeClause TypeBoundClause FieldDeclarationList FieldDeclaration OrderedFieldDeclarationList UnionItem union EnumItem enum EnumVariantList EnumVariant TypeItem type FunctionItem default fn ParamList Parameter SelfParameter VariadicParameter VariadicParameter ImplItem TraitItem trait AssociatedType LetDeclaration UseDeclaration use ScopedIdentifier UseAsClause ScopedIdentifier UseList ScopedUseList UseWildcard ExternCrateDeclaration StaticItem static ExpressionStatement ExpressionStatement GenericType FunctionType ForLifetimes ParamList VariadicParameter Parameter VariadicParameter Parameter ReferenceType PointerType TupleType UnitType ArrayType MacroInvocation EmptyType DynamicType dyn BoundedType",
  maxTerm: 359,
  nodeProps: [
    ["isolate", -4, 4, 6, 7, 33, ""],
    ["group", -42, 4, 5, 14, 15, 16, 17, 18, 19, 33, 35, 36, 37, 40, 51, 53, 56, 101, 107, 111, 112, 113, 122, 123, 125, 127, 128, 130, 132, 133, 134, 137, 139, 140, 141, 142, 143, 144, 148, 149, 155, 157, 159, "Expression", -16, 22, 24, 25, 26, 27, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 239, "Type", -20, 42, 161, 162, 165, 166, 169, 170, 172, 188, 190, 194, 196, 204, 205, 207, 208, 209, 217, 218, 220, "Statement", -17, 49, 60, 62, 63, 64, 65, 68, 74, 75, 76, 77, 78, 80, 81, 83, 84, 99, "Pattern"],
    ["openedBy", 9, "[", 38, "{", 47, "("],
    ["closedBy", 12, "]", 39, "}", 45, ")"]
  ],
  propSources: [nR],
  skippedNodes: [0, 6, 7, 240],
  repeatNodeCount: 32,
  tokenData: "$%h_R!XOX$nXY5gYZ6iZ]$n]^5g^p$npq5gqr7Xrs9cst:Rtu;Tuv>vvwAQwxCbxy!+Tyz!,Vz{!-X{|!/_|}!0g}!O!1i!O!P!3v!P!Q!8[!Q!R!Bw!R![!Dr![!]#+q!]!^#-{!^!_#.}!_!`#1b!`!a#3o!a!b#6S!b!c#7U!c!}#8W!}#O#:T#O#P#;V#P#Q#Cb#Q#R#Dd#R#S#8W#S#T$n#T#U#8W#U#V#El#V#f#8W#f#g#Ic#g#o#8W#o#p$ S#p#q$!U#q#r$$f#r${$n${$|#8W$|4w$n4w5b#8W5b5i$n5i6S#8W6S;'S$n;'S;=`4s<%lO$nU$u]'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$nU%uV'_Q'OSOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[S&aV'OSOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[S&yVOz'`z{&v{!P'`!P!Q*y!Q;'S'`;'S;=`*m<%lO'`S'cVOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[S'{UOz'`{!P'`!P!Q(_!Q;'S'`;'S;=`*m<%lO'`S(bUOz(t{!P(t!P!Q(_!Q;'S(t;'S;=`*a<%lO(tS(wVOz)^z{)z{!P)^!P!Q(_!Q;'S)^;'S;=`*g<%lO)^S)eV'PS'OSOz)^z{)z{!P)^!P!Q(_!Q;'S)^;'S;=`*g<%lO)^S)}UOz(tz{)z{!P(t!Q;'S(t;'S;=`*a<%lO(tS*dP;=`<%l(tS*jP;=`<%l)^S*pP;=`<%l'`S*vP;=`<%l&[S+OO'PSU+T]'_QOY+|YZ-xZr+|rs'`sz+|z{+O{!P+|!P!Q4y!Q#O+|#O#P'`#P;'S+|;'S;=`4m<%lO+|U,R]'_QOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$nU-P]'_QOY+|YZ-xZr+|rs'`sz+|z{.d{!P+|!P!Q/Z!Q#O+|#O#P'`#P;'S+|;'S;=`4m<%lO+|U-}V'_QOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[Q.iV'_QOY.dYZ/OZr.ds#O.d#P;'S.d;'S;=`/T<%lO.dQ/TO'_QQ/WP;=`<%l.dU/`]'_QOY0XYZ3uZr0Xrs(tsz0Xz{.d{!P0X!P!Q/Z!Q#O0X#O#P(t#P;'S0X;'S;=`4a<%lO0XU0^]'_QOY1VYZ2XZr1Vrs)^sz1Vz{2w{!P1V!P!Q/Z!Q#O1V#O#P)^#P;'S1V;'S;=`4g<%lO1VU1`]'_Q'PS'OSOY1VYZ2XZr1Vrs)^sz1Vz{2w{!P1V!P!Q/Z!Q#O1V#O#P)^#P;'S1V;'S;=`4g<%lO1VU2bV'_Q'PS'OSOz)^z{)z{!P)^!P!Q(_!Q;'S)^;'S;=`*g<%lO)^U2|]'_QOY0XYZ3uZr0Xrs(tsz0Xz{2w{!P0X!P!Q.d!Q#O0X#O#P(t#P;'S0X;'S;=`4a<%lO0XU3zV'_QOz)^z{)z{!P)^!P!Q(_!Q;'S)^;'S;=`*g<%lO)^U4dP;=`<%l0XU4jP;=`<%l1VU4pP;=`<%l+|U4vP;=`<%l$nU5QV'_Q'PSOY.dYZ/OZr.ds#O.d#P;'S.d;'S;=`/T<%lO.d_5p]'_Q&|X'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_6rV'_Q&|X'OSOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[_7b_ZX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`8a!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_8j]#PX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_9lV']Q'OS'^XOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[_:[]'QX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_;^i'_Q'vW'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!c$n!c!}<{!}#O$n#O#P&[#P#R$n#R#S<{#S#T$n#T#o<{#o${$n${$|<{$|4w$n4w5b<{5b5i$n5i6S<{6S;'S$n;'S;=`4s<%lO$n_=Uj'_Q_X'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![<{![!c$n!c!}<{!}#O$n#O#P&[#P#R$n#R#S<{#S#T$n#T#o<{#o${$n${$|<{$|4w$n4w5b<{5b5i$n5i6S<{6S;'S$n;'S;=`4s<%lO$n_?P_(TP'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_@X]#OX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_AZa!qX'_Q'OSOY$nYZ%nZr$nrs&[sv$nvwB`wz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_Bi]'}X'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_Cik'_Q'OSOYE^YZGfZrE^rsHvswE^wxFdxzE^z{Ih{!PE^!P!QKl!Q!cE^!c!}Lp!}#OE^#O#P!!l#P#RE^#R#SLp#S#TE^#T#oLp#o${E^${$|Lp$|4wE^4w5bLp5b5iE^5i6SLp6S;'SE^;'S;=`!*}<%lOE^_Ee_'_Q'OSOY$nYZ%nZr$nrs&[sw$nwxFdxz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_Fm]'_Q'OSsXOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_GmX'_Q'OSOw&[wxHYxz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[]HaV'OSsXOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[]H{X'OSOw&[wxHYxz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[_Im_'_QOY+|YZ-xZr+|rs'`sw+|wxJlxz+|z{+O{!P+|!P!Q4y!Q#O+|#O#P'`#P;'S+|;'S;=`4m<%lO+|_Js]'_QsXOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_Kq_'_QOY+|YZ-xZr+|rs'`sw+|wxJlxz+|z{.d{!P+|!P!Q/Z!Q#O+|#O#P'`#P;'S+|;'S;=`4m<%lO+|_Lyl'_Q'OS'ZXOY$nYZ%nZr$nrs&[sw$nwxFdxz$nz{+O{!P$n!P!Q,z!Q![Nq![!c$n!c!}Nq!}#O$n#O#P&[#P#R$n#R#SNq#S#T$n#T#oNq#o${$n${$|Nq$|4w$n4w5bNq5b5i$n5i6SNq6S;'S$n;'S;=`4s<%lO$n_Nzj'_Q'OS'ZXOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![Nq![!c$n!c!}Nq!}#O$n#O#P&[#P#R$n#R#SNq#S#T$n#T#oNq#o${$n${$|Nq$|4w$n4w5bNq5b5i$n5i6SNq6S;'S$n;'S;=`4s<%lO$n]!!qZ'OSOzHvz{!#d{!PHv!P!Q!$n!Q#iHv#i#j!%Z#j#lHv#l#m!'V#m;'SHv;'S;=`!*w<%lOHv]!#gXOw'`wx!$Sxz'`z{&v{!P'`!P!Q*y!Q;'S'`;'S;=`*m<%lO'`]!$XVsXOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[]!$qWOw'`wx!$Sxz'`{!P'`!P!Q(_!Q;'S'`;'S;=`*m<%lO'`]!%`^'OSOz&[z{&v{!P&[!P!Q'x!Q![!&[![!c&[!c!i!&[!i#T&[#T#Z!&[#Z#o&[#o#p!({#p;'S&[;'S;=`*s<%lO&[]!&a['OSOz&[z{&v{!P&[!P!Q'x!Q![!'V![!c&[!c!i!'V!i#T&[#T#Z!'V#Z;'S&[;'S;=`*s<%lO&[]!'[['OSOz&[z{&v{!P&[!P!Q'x!Q![!(Q![!c&[!c!i!(Q!i#T&[#T#Z!(Q#Z;'S&[;'S;=`*s<%lO&[]!(V['OSOz&[z{&v{!P&[!P!Q'x!Q![Hv![!c&[!c!iHv!i#T&[#T#ZHv#Z;'S&[;'S;=`*s<%lO&[]!)Q['OSOz&[z{&v{!P&[!P!Q'x!Q![!)v![!c&[!c!i!)v!i#T&[#T#Z!)v#Z;'S&[;'S;=`*s<%lO&[]!){^'OSOz&[z{&v{!P&[!P!Q'x!Q![!)v![!c&[!c!i!)v!i#T&[#T#Z!)v#Z#q&[#q#rHv#r;'S&[;'S;=`*s<%lO&[]!*zP;=`<%lHv_!+QP;=`<%lE^_!+^]}X'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!,`]!PX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!-`_(QX'_QOY+|YZ-xZr+|rs'`sz+|z{+O{!P+|!P!Q4y!Q!_+|!_!`!._!`#O+|#O#P'`#P;'S+|;'S;=`4m<%lO+|_!.f]#OX'_QOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!/h_(PX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!0p]!eX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!1r`'gX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`!a!2t!a#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!2}]#QX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!4P^(OX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!O$n!O!P!4{!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!5U`!lX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!O$n!O!P!6W!P!Q,z!Q!_$n!_!`!7Y!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!6a]!tX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$nV!7c]'qP'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!8c_'_Q'xXOY+|YZ-xZr+|rs'`sz+|z{!9b{!P+|!P!Q!:O!Q!_+|!_!`!._!`#O+|#O#P'`#P;'S+|;'S;=`4m<%lO+|_!9iV&}]'_QOY.dYZ/OZr.ds#O.d#P;'S.d;'S;=`/T<%lO.d_!:V]'_QUXOY!;OYZ3uZr!;Ors!>jsz!;Oz{!Aq{!P!;O!P!Q!:O!Q#O!;O#O#P!>j#P;'S!;O;'S;=`!Bk<%lO!;O_!;V]'_QUXOY!<OYZ2XZr!<Ors!=Ssz!<Oz{!@q{!P!<O!P!Q!:O!Q#O!<O#O#P!=S#P;'S!<O;'S;=`!Bq<%lO!<O_!<Z]'_QUX'PS'OSOY!<OYZ2XZr!<Ors!=Ssz!<Oz{!@q{!P!<O!P!Q!:O!Q#O!<O#O#P!=S#P;'S!<O;'S;=`!Bq<%lO!<O]!=]XUX'PS'OSOY!=SYZ)^Zz!=Sz{!=x{!P!=S!P!Q!?[!Q;'S!=S;'S;=`!@k<%lO!=S]!=}XUXOY!>jYZ(tZz!>jz{!=x{!P!>j!P!Q!?|!Q;'S!>j;'S;=`!@e<%lO!>j]!>oXUXOY!=SYZ)^Zz!=Sz{!=x{!P!=S!P!Q!?[!Q;'S!=S;'S;=`!@k<%lO!=S]!?aXUXOY!>jYZ(tZz!>jz{!?|{!P!>j!P!Q!?[!Q;'S!>j;'S;=`!@e<%lO!>jX!@RSUXOY!?|Z;'S!?|;'S;=`!@_<%lO!?|X!@bP;=`<%l!?|]!@hP;=`<%l!>j]!@nP;=`<%l!=S_!@x]'_QUXOY!;OYZ3uZr!;Ors!>jsz!;Oz{!@q{!P!;O!P!Q!Aq!Q#O!;O#O#P!>j#P;'S!;O;'S;=`!Bk<%lO!;OZ!AxX'_QUXOY!AqYZ/OZr!Aqrs!?|s#O!Aq#O#P!?|#P;'S!Aq;'S;=`!Be<%lO!AqZ!BhP;=`<%l!Aq_!BnP;=`<%l!;O_!BtP;=`<%l!<O_!CQjuX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![!Dr![#O$n#O#P&[#P#R$n#R#S!Dr#S#U$n#U#V#!}#V#]$n#]#^!FZ#^#c$n#c#d#%u#d#i$n#i#j!FZ#j#l$n#l#m#(g#m;'S$n;'S;=`4s<%lO$n_!D{duX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![!Dr![#O$n#O#P&[#P#R$n#R#S!Dr#S#]$n#]#^!FZ#^#i$n#i#j!FZ#j;'S$n;'S;=`4s<%lO$n_!Fbg'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!R$n!R!S!Gy!S!T$n!T!U!K_!U!W$n!W!X!Le!X!Y$n!Y!Z!J]!Z#O$n#O#P&[#P#g$n#g#h!Mk#h;'S$n;'S;=`4s<%lO$n_!HQa'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!S$n!S!T!IV!T!W$n!W!X!J]!X#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!I^_'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!Y$n!Y!Z!J]!Z#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!Jf]uX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!Kf_'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!S$n!S!T!J]!T#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!Ll_'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!U$n!U!V!J]!V#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_!Mr_'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P#]$n#]#^!Nq#^;'S$n;'S;=`4s<%lO$n_!Nx_'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P#n$n#n#o# w#o;'S$n;'S;=`4s<%lO$n_#!O_'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P#X$n#X#Y!J]#Y;'S$n;'S;=`4s<%lO$n_##Ua'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!R#$Z!R!S#$Z!S#O$n#O#P&[#P#R$n#R#S#$Z#S;'S$n;'S;=`4s<%lO$n_#$deuX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!R#$Z!R!S#$Z!S#O$n#O#P&[#P#R$n#R#S#$Z#S#]$n#]#^!FZ#^#i$n#i#j!FZ#j;'S$n;'S;=`4s<%lO$n_#%|`'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!Y#'O!Y#O$n#O#P&[#P#R$n#R#S#'O#S;'S$n;'S;=`4s<%lO$n_#'XduX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!Y#'O!Y#O$n#O#P&[#P#R$n#R#S#'O#S#]$n#]#^!FZ#^#i$n#i#j!FZ#j;'S$n;'S;=`4s<%lO$n_#(nd'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![#)|![!c$n!c!i#)|!i#O$n#O#P&[#P#R$n#R#S#)|#S#T$n#T#Z#)|#Z;'S$n;'S;=`4s<%lO$n_#*VhuX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![#)|![!c$n!c!i#)|!i#O$n#O#P&[#P#R$n#R#S#)|#S#T$n#T#Z#)|#Z#]$n#]#^!FZ#^#i$n#i#j!FZ#j;'S$n;'S;=`4s<%lO$n_#+z_!SX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![$n![!]#,y!]#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#-S]dX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#.U]yX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#/W`#PX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!^$n!^!_#0Y!_!`8a!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#0c_'yX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#1k`oX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`8a!`!a#2m!a#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#2v]#RX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#3x`#PX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`8a!`!a#4z!a#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#5T_'zX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#6]](RX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$nV#7_]'pP'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#8cj'_Q'OS!yW'TPOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![#8W![!c$n!c!}#8W!}#O$n#O#P&[#P#R$n#R#S#8W#S#T$n#T#o#8W#o${$n${$|#8W$|4w$n4w5b#8W5b5i$n5i6S#8W6S;'S$n;'S;=`4s<%lO$n_#:^][X'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$nU#;[Z'OSOz#;}z{#<k{!P#;}!P!Q#=V!Q#i#;}#i#j#=n#j#l#;}#l#m#?j#m;'S#;};'S;=`#C[<%lO#;}U#<UVrQ'OSOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[U#<pVrQOz'`z{&v{!P'`!P!Q*y!Q;'S'`;'S;=`*m<%lO'`U#=[UrQOz'`{!P'`!P!Q(_!Q;'S'`;'S;=`*m<%lO'`U#=s^'OSOz&[z{&v{!P&[!P!Q'x!Q![#>o![!c&[!c!i#>o!i#T&[#T#Z#>o#Z#o&[#o#p#A`#p;'S&[;'S;=`*s<%lO&[U#>t['OSOz&[z{&v{!P&[!P!Q'x!Q![#?j![!c&[!c!i#?j!i#T&[#T#Z#?j#Z;'S&[;'S;=`*s<%lO&[U#?o['OSOz&[z{&v{!P&[!P!Q'x!Q![#@e![!c&[!c!i#@e!i#T&[#T#Z#@e#Z;'S&[;'S;=`*s<%lO&[U#@j['OSOz&[z{&v{!P&[!P!Q'x!Q![#;}![!c&[!c!i#;}!i#T&[#T#Z#;}#Z;'S&[;'S;=`*s<%lO&[U#Ae['OSOz&[z{&v{!P&[!P!Q'x!Q![#BZ![!c&[!c!i#BZ!i#T&[#T#Z#BZ#Z;'S&[;'S;=`*s<%lO&[U#B`^'OSOz&[z{&v{!P&[!P!Q'x!Q![#BZ![!c&[!c!i#BZ!i#T&[#T#Z#BZ#Z#q&[#q#r#;}#r;'S&[;'S;=`*s<%lO&[U#C_P;=`<%l#;}_#Ck]XX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#Dm_'{X'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_#Ewl'_Q'OS!yW'TPOY$nYZ%nZr$nrs#Gosw$nwx#H]xz$nz{+O{!P$n!P!Q,z!Q![#8W![!c$n!c!}#8W!}#O$n#O#P&[#P#R$n#R#S#8W#S#T$n#T#o#8W#o${$n${$|#8W$|4w$n4w5b#8W5b5i$n5i6S#8W6S;'S$n;'S;=`4s<%lO$n]#GvV'OS'^XOz&[z{&v{!P&[!P!Q'x!Q;'S&[;'S;=`*s<%lO&[_#Hd_'_Q'OSOYE^YZGfZrE^rsHvswE^wxFdxzE^z{Ih{!PE^!P!QKl!Q#OE^#O#P!!l#P;'SE^;'S;=`!*}<%lOE^_#Ink'_Q'OS!yW'TPOY$nYZ%nZr$nrs&[st#Kctz$nz{+O{!P$n!P!Q,z!Q![#8W![!c$n!c!}#8W!}#O$n#O#P&[#P#R$n#R#S#8W#S#T$n#T#o#8W#o${$n${$|#8W$|4w$n4w5b#8W5b5i$n5i6S#8W6S;'S$n;'S;=`4s<%lO$nV#Kji'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!c$n!c!}#MX!}#O$n#O#P&[#P#R$n#R#S#MX#S#T$n#T#o#MX#o${$n${$|#MX$|4w$n4w5b#MX5b5i$n5i6S#MX6S;'S$n;'S;=`4s<%lO$nV#Mbj'_Q'OS'TPOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q![#MX![!c$n!c!}#MX!}#O$n#O#P&[#P#R$n#R#S#MX#S#T$n#T#o#MX#o${$n${$|#MX$|4w$n4w5b#MX5b5i$n5i6S#MX6S;'S$n;'S;=`4s<%lO$n_$ ]]wX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_$!_a'rX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q!_$n!_!`@O!`#O$n#O#P&[#P#p$n#p#q$#d#q;'S$n;'S;=`4s<%lO$n_$#m]'|X'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n_$$o]vX'_Q'OSOY$nYZ%nZr$nrs&[sz$nz{+O{!P$n!P!Q,z!Q#O$n#O#P&[#P;'S$n;'S;=`4s<%lO$n",
  tokenizers: [iR, rR, tR, 0, 1, 2, 3],
  topRules: { SourceFile: [0, 8] },
  specialized: [{ term: 281, get: (t) => sR[t] || -1 }],
  tokenPrec: 15596
}), oR = /* @__PURE__ */ re.define({
  name: "rust",
  parser: /* @__PURE__ */ aR.configure({
    props: [
      /* @__PURE__ */ me.add({
        IfExpression: /* @__PURE__ */ ae({ except: /^\s*({|else\b)/ }),
        "String BlockComment": () => null,
        AttributeItem: (t) => t.continue(),
        "Statement MatchArm": /* @__PURE__ */ ae()
      }),
      /* @__PURE__ */ fe.add((t) => {
        if (/(Block|edTokens|List)$/.test(t.name))
          return Ie;
        if (t.name == "BlockComment")
          return (e) => ({ from: e.from + 2, to: e.to - 2 });
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:\{|\})$/,
    closeBrackets: { stringPrefixes: ["b", "r", "br"] }
  }
});
function lR() {
  return new le(oR);
}
const sp = 154, Ja = 155, cR = 156, hR = 1, QR = 2, yQ = 3, fR = 157, $R = 158, bQ = 4, uR = 5, dR = 159, xQ = 160, TQ = 161, qs = 162, wQ = 6, kQ = 7, pR = 8, mR = 9, Nn = 0, TO = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], PR = 58, gR = 40, ol = 95, SR = 91, Si = 45, XR = 46, ll = 35, yR = 37, ap = 123, bR = 125, Xi = 47, Fr = 42, He = 10, WQ = 61, xR = 43, TR = 38;
function Bi(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function op(t) {
  return t >= 48 && t <= 57;
}
function cl(t) {
  let e;
  return t.next == Xi && ((e = t.peek(1)) == Xi || e == Fr);
}
const wR = new q((t, e) => {
  if (e.dialectEnabled(Nn)) {
    let O;
    if (t.next < 0 && e.canShift(TQ))
      t.acceptToken(TQ);
    else if (((O = t.peek(-1)) == He || O < 0) && e.canShift(xQ)) {
      let i = 0;
      for (; t.next != He && TO.includes(t.next); )
        t.advance(), i++;
      t.next == He || cl(t) ? t.acceptToken(xQ, -i) : i && t.acceptToken(qs);
    } else if (t.next == He)
      t.acceptToken(dR, 1);
    else if (TO.includes(t.next)) {
      for (t.advance(); t.next != He && TO.includes(t.next); ) t.advance();
      t.acceptToken(qs);
    }
  } else {
    let O = 0;
    for (; TO.includes(t.next); )
      t.advance(), O++;
    O && t.acceptToken(qs);
  }
}, { contextual: !0 }), kR = new q((t, e) => {
  if (cl(t)) {
    if (t.advance(), e.dialectEnabled(Nn)) {
      let O = -1;
      for (let i = 1; ; i++) {
        let r = t.peek(-i - 1);
        if (r == He || r < 0) {
          O = i + 1;
          break;
        } else if (!TO.includes(r))
          break;
      }
      if (O > -1) {
        let i = t.next == Fr, r = 0;
        for (t.advance(); t.next >= 0; )
          if (t.next == He) {
            t.advance();
            let n = 0;
            for (; t.next != He && TO.includes(t.next); )
              n++, t.advance();
            if (n < O) {
              r = -n - 1;
              break;
            }
          } else if (i && t.next == Fr && t.peek(1) == Xi) {
            r = 2;
            break;
          } else
            t.advance();
        t.acceptToken(i ? kQ : wQ, r);
        return;
      }
    }
    if (t.next == Xi) {
      for (; t.next != He && t.next >= 0; ) t.advance();
      t.acceptToken(wQ);
    } else {
      for (t.advance(); t.next >= 0; ) {
        let { next: O } = t;
        if (t.advance(), O == Fr && t.next == Xi) {
          t.advance();
          break;
        }
      }
      t.acceptToken(kQ);
    }
  }
}), WR = new q((t, e) => {
  (t.next == xR || t.next == WQ) && e.dialectEnabled(Nn) && t.acceptToken(t.next == WQ ? pR : mR, 1);
}), RR = new q((t, e) => {
  if (!e.dialectEnabled(Nn)) return;
  let O = e.context.depth;
  if (t.next < 0 && O) {
    t.acceptToken(Ja);
    return;
  }
  if (t.peek(-1) == He) {
    let r = 0;
    for (; t.next != He && TO.includes(t.next); )
      t.advance(), r++;
    r != O && t.next != He && !cl(t) && (r < O ? t.acceptToken(Ja, -r) : t.acceptToken(sp));
  }
}), vR = new q((t, e) => {
  for (let O = !1, i = 0, r = 0; ; r++) {
    let { next: n } = t;
    if (Bi(n) || n == Si || n == ol || O && op(n))
      !O && (n != Si || r > 0) && (O = !0), i === r && n == Si && i++, t.advance();
    else if (n == ll && t.peek(1) == ap) {
      t.acceptToken(uR, 2);
      break;
    } else {
      O && t.acceptToken(n == gR ? fR : i == 2 && e.canShift(bQ) ? bQ : $R);
      break;
    }
  }
}), ZR = new q((t) => {
  if (t.next == bR) {
    for (t.advance(); Bi(t.next) || t.next == Si || t.next == ol || op(t.next); )
      t.advance();
    t.next == ll && t.peek(1) == ap ? t.acceptToken(QR, 2) : t.acceptToken(hR);
  }
}), YR = new q((t) => {
  if (TO.includes(t.peek(-1))) {
    let { next: e } = t;
    (Bi(e) || e == ol || e == ll || e == XR || e == SR || e == PR || e == Si || e == TR) && t.acceptToken(cR);
  }
}), zR = new q((t) => {
  if (!TO.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == yR && (t.advance(), t.acceptToken(yQ)), Bi(e)) {
      do
        t.advance();
      while (Bi(t.next));
      t.acceptToken(yQ);
    }
  }
});
function lp(t, e) {
  this.parent = t, this.depth = e, this.hash = (t ? t.hash + t.hash << 8 : 0) + e + (e << 4);
}
const qR = new lp(null, 0), UR = new Ft({
  start: qR,
  shift(t, e, O, i) {
    return e == sp ? new lp(t, O.pos - i.pos) : e == Ja ? t.parent : t;
  },
  hash(t) {
    return t.hash;
  }
}), VR = se({
  "AtKeyword import charset namespace keyframes media supports include mixin use forward extend at-root": l.definitionKeyword,
  "Keyword selector": l.keyword,
  ControlKeyword: l.controlKeyword,
  NamespaceName: l.namespace,
  KeyframeName: l.labelName,
  TagName: l.tagName,
  "ClassName Suffix": l.className,
  PseudoClassName: l.constant(l.className),
  IdName: l.labelName,
  "FeatureName PropertyName": l.propertyName,
  AttributeName: l.attributeName,
  NumberLiteral: l.number,
  KeywordQuery: l.keyword,
  UnaryQueryOp: l.operatorKeyword,
  "CallTag ValueName": l.atom,
  VariableName: l.variableName,
  SassVariableName: l.special(l.variableName),
  Callee: l.operatorKeyword,
  Unit: l.unit,
  "UniversalSelector NestingSelector IndentedMixin IndentedInclude": l.definitionOperator,
  MatchOp: l.compareOperator,
  "ChildOp SiblingOp, LogicOp": l.logicOperator,
  BinOp: l.arithmeticOperator,
  "Important Global Default": l.modifier,
  Comment: l.blockComment,
  LineComment: l.lineComment,
  ColorLiteral: l.color,
  "ParenthesizedContent StringLiteral": l.string,
  "InterpolationStart InterpolationContinue InterpolationEnd": l.meta,
  ': "..."': l.punctuation,
  "PseudoOp #": l.derefOperator,
  "; ,": l.separator,
  "( )": l.paren,
  "[ ]": l.squareBracket,
  "{ }": l.brace
}), _R = { __proto__: null, not: 62, only: 62, using: 179, as: 189, with: 193, without: 193, hide: 207, show: 207, from: 230, to: 232, if: 245, through: 251, in: 257 }, jR = { __proto__: null, url: 80, "url-prefix": 80, domain: 80, regexp: 80, lang: 94, "nth-child": 94, "nth-last-child": 94, "nth-of-type": 94, "nth-last-of-type": 94, dir: 94, "host-context": 94, selector: 172 }, GR = { __proto__: null, "@import": 156, "@include": 176, "@mixin": 182, "@function": 182, "@use": 186, "@extend": 196, "@at-root": 200, "@forward": 204, "@media": 210, "@charset": 214, "@namespace": 218, "@keyframes": 224, "@supports": 236, "@if": 240, "@else": 242, "@for": 248, "@each": 254, "@while": 260, "@debug": 264, "@warn": 264, "@error": 264, "@return": 264 }, CR = ne.deserialize({
  version: 14,
  states: "LvQ`Q+tOOO#fQ+tOOP#mOpOOOOQ#U'#Ch'#ChO#rQ(pO'#CjOOQ#U'#Ci'#CiO%_Q)QO'#FxO%rQ.jO'#CnO&jQ#dO'#DWO'aQ(pO'#CgO'hQ)OO'#DYO'sQ#dO'#DaO'xQ#dO'#DeO'}Q#dO'#DnOOQ#U'#Fx'#FxO(SQ(pO'#FxO(ZQ(nO'#DrO%rQ.jO'#DzO%rQ.jO'#EVO%rQ.jO'#EYO%rQ.jO'#E[O(`Q)OO'#EaO)QQ)OO'#EcO%rQ.jO'#EeO)_Q)OO'#EhO%rQ.jO'#EjO)yQ)OO'#ElO*UQ#dO'#EoO*ZQ)OO'#EuO*oQ)OO'#FVOOQ&Z'#Fw'#FwOOQ&Y'#FY'#FYO*yQ(nO'#FYQ`Q+tOOO%rQ.jO'#EwO+UQ(nO'#E{O+ZQ)OO'#FOO%rQ.jO'#FRO%rQ.jO'#FTOOQ&Z'#Fa'#FaO+cQ+uO'#GRO+pQ(oO'#GRQOQ#SOOP,UO#SO'#FvPOOO)CAk)CAkOOQ#U'#Cm'#CmOOQ#U,59W,59WOOQ#i'#Cp'#CpO%rQ.jO'#CsO,dQ.wO'#CuO/PQ.^O,59YO%rQ.jO'#CzOOQ#S'#DO'#DOO/bQ(nO'#DTOOQ#i'#Fz'#FzO/gQ(nO'#C}OOQ#U'#DX'#DXOOQ#U,59r,59rO&jQ#dO,59rO/lQ)OO,59tO'sQ#dO,59{O'xQ#dO,5:PO(`Q)OO,5:TO(`Q)OO,5:VO(`Q)OO,5:WO(`Q)OO'#F`O/wQ(nO,59RO0SQ+tO'#DpO0ZQ#TO'#DpOOQ&Z,59R,59ROOQ#U'#D['#D[OOQ#S'#D_'#D_OOQ#U,59t,59tO0`Q(nO,59tO0eQ(nO,59tOOQ#U'#Dc'#DcOOQ#U,59{,59{OOQ#S'#Dg'#DgO0jQ9`O,5:POOQ#U'#Do'#DoOOQ#U,5:Y,5:YO1jQ.jO,5:^O1tQ.jO,5:fO2mQ.jO,5:qO2zQ.YO,5:tO3]Q.jO,5:vOOQ#U'#Cj'#CjO4UQ(pO,5:{O4cQ(pO,5:}OOQ&Z,5:},5:}O4jQ)OO,5:}O4oQ.jO,5;POOQ#S'#D}'#D}O5_Q)OO'#ESO5fQ(nO'#GTO*ZQ)OO'#ERO5zQ(nO'#ETOOQ#S'#GU'#GUO/zQ(nO,5;SO3cQ.YO,5;UOOQ#d'#En'#EnO*yQ(nO,5;WO6PQ)OO,5;WOOQ#S'#Eq'#EqO6XQ(nO,5;ZO6^Q(nO,5;aO6iQ(nO,5;qOOQ&Z'#GS'#GSOOQ&Y,5;t,5;tOOQ&Y-E9W-E9WO2zQ.YO,5;cO6wQ)OO,5;gO6|Q)OO'#GWO7UQ)OO,5;jO2zQ.YO,5;mO3cQ.YO,5;oOOQ&Z-E9_-E9_O7ZQ(oO,5<mO7oQ+uO'#FdO7ZQ(oO,5<mPOO#S'#FX'#FXP8VO#SO,5<bPOOO,5<b,5<bO8eQ.YO,59_OOQ#i,59a,59aO%rQ.jO,59cO%rQ.jO,59hO%rQ.jO'#F]O8sQ#WO1G.tOOQ#k1G.t1G.tO8{Q.oO,59fO;eQ! lO,59oO<bQ.jO'#DPOOQ#i,59i,59iOOQ#U1G/^1G/^OOQ#U1G/`1G/`O0`Q(nO1G/`O0eQ(nO1G/`OOQ#U1G/g1G/gO<lQ9`O1G/kO=VQ(pO1G/oO=yQ(pO1G/qO>mQ(pO1G/rO?aQ(pO,5;zOOQ#S-E9^-E9^OOQ&Z1G.m1G.mO?nQ(nO,5:[O?sQ+uO,5:[O?zQ)OO'#D`O@RQ.jO'#D^OOQ#U1G/k1G/kO%rQ.jO1G/kO@}Q.jO'#DtOAXQ.kO1G/xOOQ#T1G/x1G/xO*yQ(nO1G0QOBUQ+uO'#GSOOQ&Z1G0]1G0]O/gQ(nO1G0]OOQ&Z1G0`1G0`OOQ&Z1G0b1G0bO/gQ(nO1G0bODqQ)OO1G0bOOQ&Z1G0g1G0gOOQ&Z1G0i1G0iODyQ)OO1G0iOEOQ(nO1G0iOETQ)OO1G0kOOQ&Z1G0k1G0kOEcQ.jO'#FfOEsQ#dO1G0kOExQ(nO'#D}OFTQ(nO,5:jOFYQ(nO,5:nO*ZQ)OO,5:lOFbQ)OO'#FeOFuQ(nO,5<oOGWQ(nO,5:mO(`Q)OO,5:oOOQ&Z1G0n1G0nOOQ&Z1G0p1G0pOOQ&Z1G0r1G0rO*yQ(nO1G0rOGoQ)OO'#ErOOQ&Z1G0u1G0uOOQ&Z1G0{1G0{OOQ&Z1G1]1G1]OG}Q+uO1G0}O%rQ.jO1G1ROJjQ)OO'#FjOJuQ)OO,5<rO%rQ.jO1G1UOOQ&Z1G1X1G1XOOQ&Z1G1Z1G1ZOJ}Q(oO1G2XOKcQ+uO,5<OOOQ#T,5<O,5<OOOQ#T-E9b-E9bPOO#S-E9V-E9VPOOO1G1|1G1|OOQ#i1G.y1G.yOKyQ.oO1G.}OOQ#i1G/S1G/SONcQ.^O,5;wOOQ#W-E9Z-E9ZOOQ#k7+$`7+$`ONtQ(nO1G/ZONyQ.jO'#FZO!!TQ.jO'#F}O!#lQ.jO'#FzO!#sQ(nO,59kOOQ#U7+$z7+$zOOQ#U7+%V7+%VO%rQ.jO7+%VOOQ&Z1G/v1G/vO!#xQ#TO1G/vO!#}Q(pO'#GPO!$XQ(nO,59zO!$^Q.jO'#GOO!$hQ(nO,59xO!$mQ.YO7+%VO!${Q.YO'#FzO!%^Q(nO,5:`OOQ#T,5:`,5:`O!%fQ.kO'#FcO%rQ.jO'#FcO!'VQ.kO7+%dOOQ#T7+%d7+%dOOQ&Z7+%l7+%lO6iQ(nO7+%wO*yQ(nO7+%|OOQ#d'#E_'#E_O!'yQ)OO7+%|O!(XQ(nO7+&TO*ZQ)OO7+&TOOQ#d-E9d-E9dOOQ&Z7+&V7+&VO!(^Q.jO'#GVOOQ#d,5<Q,5<QODtQ(nO7+&VO%rQ.jO1G0UOOQ#S1G0Y1G0YOOQ#S1G0W1G0WO!(xQ(nO,5<POOQ#S-E9c-E9cO!)^Q(pO1G0ZOOQ&Z7+&^7+&^O!)eQ(vO'#CuO/zQ(nO'#FhO!)pQ)OO,5;^OOQ&Z,5;^,5;^O!*OQ+uO7+&iO!,kQ)OO7+&iO!,vQ.jO7+&mOOQ#d,5<U,5<UOOQ#d-E9h-E9hO2zQ.YO7+&pOOQ#T1G1j1G1jOOQ#i7+$u7+$uOOQ#d-E9X-E9XO!-XQ.jO'#F[O!-fQ(nO,5<iO!-fQ(nO,5<iO%rQ.jO,5<iOOQ#i1G/V1G/VO!-nQ.YO<<HqOOQ&Z7+%b7+%bO!-|Q)OO'#F_O!.WQ(nO,5<kOOQ#U1G/f1G/fO!.`Q.jO'#F^O!.jQ(nO,5<jOOQ#U1G/d1G/dOOQ#U<<Hq<<HqO0rQ.jO,5;|O!.rQ(nO'#FbOOQ#S-E9`-E9`OOQ#T1G/z1G/zO!.wQ.kO,5;}OOQ#e-E9a-E9aOOQ#T<<IO<<IOOOQ&Z<<Ic<<IcOOQ&Z<<Ih<<IhO/gQ(nO<<IhO*ZQ)OO<<IoO!0hQ(nO<<IoO!0pQ.jO'#FgO!1TQ)OO,5<qOETQ)OO<<IqO!1fQ.jO7+%pOOQ#S7+%u7+%uOOQ#d,5<S,5<SOOQ#d-E9f-E9fOOQ&Z1G0x1G0xOOQ&Z-E9g-E9gO!,kQ)OO<<JTO%rQ.jO,5<TOOQ&Z<<JT<<JTO%rQ.jO<<JXOOQ&Z<<J[<<J[O!1mQ.jO,5;vO!1zQ.jO,5;vOOQ#S-E9Y-E9YO!2RQ(nO1G2TO!2ZQ.jO1G2TOOQ#UAN>]AN>]O!2eQ(pO,5;yOOQ#S-E9]-E9]O!2oQ.jO,5;xOOQ#S-E9[-E9[O!2yQ.YO1G1hO!3_Q(nO1G1hO*yQ(nOAN?SO!3jQ(nOAN?ZO/zQ(nOAN?ZO!3rQ.jO,5<ROOQ#d-E9e-E9eOETQ)OOAN?]OOQ&ZAN?]AN?]OOQ#S<<I[<<I[P!4^Q)OO'#FiOOQ&ZAN?oAN?oO2zQ.YO1G1oO2zQ.YOAN?sOOQ#S1G1b1G1bO%rQ.jO1G1bO!4cQ(nO7+'oOOQ#S7+'S7+'SOOQ&ZG24nG24nO/zQ(nOG24uOOQ&ZG24uG24uOOQ&ZG24wG24wOOQ&Z7+'Z7+'ZOOQ&ZG25_G25_O!4kQ.jO7+&|OOQ&ZLD*aLD*a",
  stateData: "!4{~O$hOSVOSUOS$fQQ~OS`OTVOWcOXbO_UOc`OtYO}YO!UZO!Y[O!omO!paO!zbO!}cO#PdO#UeO#WfO#YgO#]hO#_iO#ajO#dkO#jlO#lrO#psO#stO#vuO#xvO$dSO$mRO$pWO$t]O~O$_$uP~P`O$f{O~Ot^Xt!gXv^X}^X!U^X!Y^X!^^X!a^X!e^X$b^X$e^X$p^X~Ot$lXv$lX}$lX!U$lX!Y$lX!^$lX!a$lX!e$lX$b$lX$e$lX$p$lX~O$d}O!l$lX$g$lXf$lXe$lX~P$jOS!WOTVO_!WOc!WOf!QOh!WOj!WOo!TOx!VO$c!UO$d!PO$o!RO~O$d!YO~Ot!]O}!]O!U!^O!Y!_O!^!`O!a!bO!e!eO$b!aO$e!fO$p![O~Ov!cO~P&oO!P!lO$c!iO$d!hO~O$d!mO~O$d!oO~O$d!qO~Ot!sO~P$jOt!sO~OTVO_UOtYO}YO!UZO!Y[O$d!xO$mRO$pWO$t]O~Of!|O!e!eO$e!fO~P(`OTVOc#TOf#POo#RO!x#SO$d#OO!e$wP$e$wP~Oj#XOx!VO$d#WO~O$d#ZO~OTVOc#TOf#POo#RO!x#SO$d#OO~O!l$wP$g$wP~P)_O!l#_O$e#_O$g#_O~Oc#cO~Oc#dO#t$zP~O$_$uX!m$uX$a$uX~P`O!l#_O$e#_O$g#_O$_$uX!m$uX$a$uX~OU#lOV#lO$e#nO$h#lO~OR#pOPiXQiXliXmiX$piXTiXciXfiXoiX!liX!xiX$diX$eiX$giX!eiX!{iX#QiX#SiX#ZiXeiXSiX_iXhiXjiXviXxiX!iiX!jiX!kiX$ciX$oiX$_iXuiX!WiX#hiX#qiX!miX$aiX~OP#uOQ#sOl#qOm#qO$p#rO~Of#wO~Of#xO~O!P#}O$c!iO$d!hO~Ov!cO!e!eO$e!fO~O!m$uP~P`O$`$XO~Of$YO~Of$ZO~O!W$[O![$]O~OS!WOTVO_!WOc!WOf$^Oh!WOj!WOo!TOx!VO$c!UO$d!PO$o!RO~O!e!eO$e!fO~P0rOl#qOm#qO$p#rO!l$wP$e$wP$g$wP~P*ZOl#qOm#qO!l#_O$g#_O$p#rO~O!e!eO!{$dO$e$bO~P2[Ol#qOm#qO!e!eO$e!fO$p#rO~O#Q$hO#S$gO$e#_O~P2[Ot!]O}!]O!U!^O!Y!_O!^!`O!a!bO$b!aO$p![O~O!l#_O$e#_O$g#_O~P3jOf$kO~P&oO#S$lO~O#Q$pO#Z$oO$e#_O~P2[OTVOc#TOf#POo#RO!x#SO~O$d$qO~P4|Om$tOv$uO!e$wX$e$wX!l$wX$g$wX~Of$xO~Oj$|Ox!VO~O!e$}O~Om$tO!e!eO$e!fO~O!e!eO!l#_O$e$bO$g#_O~O#g%SO~Ov%TO#t$zX~O#t%VO~O!l#_O$e#_O$g#_O$_$ua!m$ua$a$ua~O!l$WX$_$WX$e$WX$g$WX!m$WX$a$WX~P`OU#lOV#lO$e%_O$h#lO~Oe%`Ol#qOm#qO$p#rO~OP%eOQ#sO~Ol#qOm#qO$p#rOPnaQnaTnacnafnaona!lna!xna$dna$ena$gna!ena!{na#Qna#Sna#ZnaenaSna_nahnajnavnaxna!ina!jna!kna$cna$ona$_nauna!Wna#hna#qna!mna$ana~Oj%fOy%fO~OS!WOTVO_!WOf!QOh!WOj!WOo!TOx!VO$c!UO$d!PO$o!RO~Oc%iOe$qP~P;mO!W%lO![%mO~Ot!]O}!]O!U!^O!Y!_O$p![O~Ov!]i!^!]i!a!]i!e!]i$b!]i$e!]i!l!]i$g!]if!]ie!]i~P<tOv!_i!^!_i!a!_i!e!_i$b!_i$e!_i!l!_i$g!_if!_ie!_i~P<tOv!`i!^!`i!a!`i!e!`i$b!`i$e!`i!l!`i$g!`if!`ie!`i~P<tOv$Sa!e$Sa$e$Sa~P3jO!m%nO~O$a$uP~P`Oe$sP~P(`Oe$rP~P%rOS!WOTVO_!WOc!WOf!QOh!WOo!TOx!VO$c!UO$d!PO$o!RO~Oe%wOj%uO~P@YOl#qOm#qOv%yO!i%{O!j%{O!k%{O$p#rO!l!fi$e!fi$g!fi$_!fi!m!fi$a!fi~P%rO$`$XOS$vXT$vXW$vXX$vX_$vXc$vXt$vX}$vX!U$vX!Y$vX!o$vX!p$vX!z$vX!}$vX#P$vX#U$vX#W$vX#Y$vX#]$vX#_$vX#a$vX#d$vX#j$vX#l$vX#p$vX#s$vX#v$vX#x$vX$_$vX$d$vX$m$vX$p$vX$t$vX!m$vX!l$vX$e$vX$g$vX$a$vX~O$d!PO$m&PO~O#S&RO~Ot&SO~O!l#_O#Z$oO$e#_O$g#_O~O!l$yP#Z$yP$e$yP$g$yP~P%rO$d!PO~Oe!qXm!qXt!sX~Ot&YO~Oe&ZOm$tO~Ov$XX!e$XX$e$XX!l$XX$g$XX~P*ZOv$uO!e$wa$e$wa!l$wa$g$wa~Om$tOv!ua!e!ua$e!ua!l!ua$g!uae!ua~O!m&dO#g&bO#h&bO$o&aO~O#m&fOS#kiT#kiW#kiX#ki_#kic#kit#ki}#ki!U#ki!Y#ki!o#ki!p#ki!z#ki!}#ki#P#ki#U#ki#W#ki#Y#ki#]#ki#_#ki#a#ki#d#ki#j#ki#l#ki#p#ki#s#ki#v#ki#x#ki$_#ki$d#ki$m#ki$p#ki$t#ki!m#ki!l#ki$e#ki$g#ki$a#ki~Oc&hOv$^X#t$^X~Ov%TO#t$za~O!l#_O$e#_O$g#_O$_$ui!m$ui$a$ui~O!l$Wa$_$Wa$e$Wa$g$Wa!m$Wa$a$Wa~P`O$p#rOPkiQkilkimkiTkickifkioki!lki!xki$dki$eki$gki!eki!{ki#Qki#Ski#ZkiekiSki_kihkijkivkixki!iki!jki!kki$cki$oki$_kiuki!Wki#hki#qki!mki$aki~Ol#qOm#qO$p#rOP$PaQ$Pa~Oe&lO~Ol#qOm#qO$p#rOS#}XT#}X_#}Xc#}Xe#}Xf#}Xh#}Xj#}Xo#}Xu#}Xv#}Xx#}X$c#}X$d#}X$o#}X~Ou&pOv&nOe$qX~P%rOS$nXT$nX_$nXc$nXe$nXf$nXh$nXj$nXl$nXm$nXo$nXu$nXv$nXx$nX$c$nX$d$nX$o$nX$p$nX~Ot&qO~P!!bOe&rO~O$a&tO~Ov&uOe$sX~P3jOe&wO~Ov&xOe$rX~P%rOe&zO~Ol#qOm#qO!W&{O$p#rO~Ot&|Oe$nXl$nXm$nX$p$nX~Oe'POj&}O~Ol#qOm#qO$p#rOS$VXT$VX_$VXc$VXf$VXh$VXj$VXo$VXv$VXx$VX!i$VX!j$VX!k$VX!l$VX$c$VX$d$VX$e$VX$g$VX$o$VX$_$VX!m$VX$a$VX~Ov%yO!i'SO!j'SO!k'SO!l!fq$e!fq$g!fq$_!fq!m!fq$a!fq~P%rO!l#_O#S'VO$e#_O$g#_O~Ot'WO~Ol#qOm#qOv'YO$p#rO!l$yX#Z$yX$e$yX$g$yX~Om$tOv$Xa!e$Xa$e$Xa!l$Xa$g$Xa~Oe'^O~P3jOR#pO!eiX$eiX~O!m'aO#g&bO#h&bO$o&aO~O#m'cOS#kqT#kqW#kqX#kq_#kqc#kqt#kq}#kq!U#kq!Y#kq!o#kq!p#kq!z#kq!}#kq#P#kq#U#kq#W#kq#Y#kq#]#kq#_#kq#a#kq#d#kq#j#kq#l#kq#p#kq#s#kq#v#kq#x#kq$_#kq$d#kq$m#kq$p#kq$t#kq!m#kq!l#kq$e#kq$g#kq$a#kq~O!e!eO#n'dO$e!fO~Ol#qOm#qO#h'fO#q'fO$p#rO~Oc'iOe$OXv$OX~P;mOv&nOe$qa~Ol#qOm#qO!W'mO$p#rO~Oe$RXv$RX~P(`Ov&uOe$sa~Oe$QXv$QX~P%rOv&xOe$ra~Ot&|O~Ol#qOm#qO$p#rOS$VaT$Va_$Vac$Vaf$Vah$Vaj$Vao$Vav$Vax$Va!i$Va!j$Va!k$Va!l$Va$c$Va$d$Va$e$Va$g$Va$o$Va$_$Va!m$Va$a$Va~Oe'vOm$tO~Ov$ZX!l$ZX#Z$ZX$e$ZX$g$ZX~P%rOv'YO!l$ya#Z$ya$e$ya$g$ya~Oe'{O~P%rOu(QOe$Oav$Oa~P%rOt(RO~P!!bOv&nOe$qi~Ov&nOe$qi~P%rOe$Rav$Ra~P3jOe$Qav$Qa~P%rOl#qOm#qOv(TO$p#rOe$Uij$Ui~Ov(TOe$Uij$Ui~Oe(VOm$tO~Ol#qOm#qO$p#rOv$Za!l$Za#Z$Za$e$Za$g$Za~O#n'dO~Ov&nOe$qq~Oe$Oqv$Oq~P%rO$o$pl!al~",
  goto: "9z${PPPPPPPPPPP$|%W%W%kP%W&O&RP'sPP(xP)wP(xPP(xP(x(x*z+yPPP,VPP%W-[%WP-bP-h-n-t%WP-zP%WP.QP%WP%W%WP%W.W.ZP/l0O0YPPPPP$|PP'g'g0`'g'g'g'gP$|PP$|P$|PP0cP$|P$|P$|PP$|P$|P$|P0i$|P0l0oPP$|P$|PPP$|PP$|PP$|P$|P$|P0r0x1O1n1|2S2Y2`2f2r2x3O3Y3`3j3p3v3|PPPPPPPPPPP4S4V4cP5YPP7a7d7gP7j7s9P9Y9t9wanOPqx!e#j$X%Zs^OPefqx!`!a!b!c!e#j$X$Y$x%Z&usTOPefqx!`!a!b!c!e#j$X$Y$x%Z&uR!OUb^ef!`!a!b!c$Y$x&u`_OPqx!e#j$X%Z!x!WVabcdgiruv!Q!T!s#q#r#s#x$Z$]$^$_$o%S%V%h%m%r%y%z&Y&n&q&x&|'Y']'d'f'h'l'p(R([e#Thlm!t#P#R$t$u&S'W!x!WVabcdgiruv!Q!T!s#q#r#s#x$Z$]$^$_$o%S%V%h%m%r%y%z&Y&n&q&x&|'Y']'d'f'h'l'p(R([Q&Q$hR&X$p!y!WVabcdgiruv!Q!T!s#q#r#s#x$Z$]$^$_$o%S%V%h%m%r%y%z&Y&n&q&x&|'Y']'d'f'h'l'p(R([!x!WVabcdgiruv!Q!T!s#q#r#s#x$Z$]$^$_$o%S%V%h%m%r%y%z&Y&n&q&x&|'Y']'d'f'h'l'p(R([T&b$}&c!y!XVabcdgiruv!Q!T!s#q#r#s#x$Z$]$^$_$o%S%V%h%m%r%y%z&Y&n&q&x&|'Y']'d'f'h'l'p(R([Q#y!XQ%}$dQ&O$gR't'V!x!WVabcdgiruv!Q!T!s#q#r#s#x$Z$]$^$_$o%S%V%h%m%r%y%z&Y&n&q&x&|'Y']'d'f'h'l'p(R([Q#XjR$|#YQ!ZWR#z![Q!jYR#{!]Q#{!lR%k#}Q!kYR#|!]Q#{!kR%k#|Q!nZR$O!^Q!p[R$P!_R!r]Q!gXQ!{fQ$V!dQ$`!sQ$c!uQ$e!vQ$j!zQ$y#UQ%P#]Q%Q#^Q%R#bQ%W#fQ'T%}Q'_&bQ'e&fQ'g&jQ'}'cQ(W'vQ(Y(OQ(Z(PR(](VSpOqUyP!e$XQ#ixQ%[#jR&k%Za`OPqx!e#j$X%ZQ$`!sR's&|R$r#PQ&Q$hR'[&XR#YjR#[kR%O#[Q#m{R%^#mQqOR#aqQ%h#xQ%r$Z^&m%h%r']'h'l'p([Q']&YQ'h&nQ'l&qQ'p&xR([(RQ&o%hU'j&o'k(SQ'k&pR(S'lQ#t!SR%d#tQ&y%rR'q&yQ&v%pR'o&vQ!dXR$U!dUxP!e$XS#hx%ZR%Z#jQ%v$^R'O%vQ%z$_R'R%zQ#kyQ%Y#iT%]#k%YQ$v#QR&^$vQ$m!}S&T$m'yR'y'[Q'Z&VR'x'ZQ&c$}R'`&cQ&e%RR'b&eQ%U#dR&i%UR|QSoOq]wPx!e#j$X%Z`XOPqx!e#j$X%ZQ!yeQ!zfQ$Q!`Q$R!aQ$S!bQ$T!cQ%p$YQ&_$xR'n&uQ!SVQ!taQ!ubQ!vcQ!wdQ!}gQ#ViQ#brQ#fuQ#gvS#o!Q$^Q#v!TQ$_!sQ%a#qQ%b#rQ%c#sl%g#x$Z%h%r&Y&n&q&x']'h'l'p(R([Q%t$]S%x$_%zQ&V$oQ&g%SQ&j%VQ&s%mQ'Q%yQ'r&|Q'w'YQ(O'dR(P'fR%j#xR%s$ZR%q$YQzPQ$W!eR%o$XQ#`pW#jy#i#k%YQ$c!uQ$f!wQ$i!yQ$n!}Q$z#VQ${#XQ%Q#^Q%X#gQ%|$aQ&U$mQ&`$|Q'T%}S'U&O&QQ'z'[Q(U'tR(X'yQ#UhQ#^mR$a!tU#Qhm!tQ#]lQ$s#PQ$w#RQ&[$tQ&]$uQ'X&SR'u'WR&W$oR#et",
  nodeNames: "âš  InterpolationEnd InterpolationContinue Unit VariableName InterpolationStart LineComment Comment IndentedMixin IndentedInclude StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector SuffixedSelector Suffix Interpolation SassVariableName ValueName ) ( ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp LogicOp UnaryExpression LogicOp NamespacedValue CallExpression Callee ArgList : ... , CallLiteral CallTag ParenthesizedContent ClassSelector ClassName PseudoClassSelector :: PseudoClassName PseudoClassName ArgList PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp PlaceholderSelector ClassName Block { Declaration PropertyName Map Important Global Default ; } ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery UnaryQuery ParenthesizedQuery SelectorQuery selector IncludeStatement include Keyword MixinStatement mixin UseStatement use Keyword Star Keyword ExtendStatement extend RootStatement at-root ForwardStatement forward Keyword MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList Keyword Keyword SupportsStatement supports IfStatement ControlKeyword ControlKeyword Keyword ForStatement ControlKeyword Keyword EachStatement ControlKeyword Keyword WhileStatement ControlKeyword OutputStatement ControlKeyword AtRule Styles",
  maxTerm: 180,
  context: UR,
  nodeProps: [
    ["openedBy", 1, "InterpolationStart", 5, "InterpolationEnd", 21, "(", 75, "{"],
    ["isolate", -3, 6, 7, 26, ""],
    ["closedBy", 22, ")", 67, "}"]
  ],
  propSources: [VR],
  skippedNodes: [0, 6, 7, 135],
  repeatNodeCount: 18,
  tokenData: "!!p~RyOq#rqr$jrs0jst2^tu8{uv;hvw;{wx<^xy={yz>^z{>c{|>||}Co}!ODQ!O!PDo!P!QFY!Q![Fk![!]Gf!]!^Hb!^!_Hs!_!`I[!`!aIs!a!b#r!b!cJt!c!}#r!}#OL^#O#P#r#P#QLo#Q#RMQ#R#T#r#T#UMg#U#c#r#c#dNx#d#o#r#o#p! _#p#qMQ#q#r! p#r#s!!R#s;'S#r;'S;=`!!j<%lO#rW#uSOy$Rz;'S$R;'S;=`$d<%lO$RW$WSyWOy$Rz;'S$R;'S;=`$d<%lO$RW$gP;=`<%l$RY$m[Oy$Rz!_$R!_!`%c!`#W$R#W#X%v#X#Z$R#Z#[)Z#[#]$R#]#^,V#^;'S$R;'S;=`$d<%lO$RY%jSyWlQOy$Rz;'S$R;'S;=`$d<%lO$RY%{UyWOy$Rz#X$R#X#Y&_#Y;'S$R;'S;=`$d<%lO$RY&dUyWOy$Rz#Y$R#Y#Z&v#Z;'S$R;'S;=`$d<%lO$RY&{UyWOy$Rz#T$R#T#U'_#U;'S$R;'S;=`$d<%lO$RY'dUyWOy$Rz#i$R#i#j'v#j;'S$R;'S;=`$d<%lO$RY'{UyWOy$Rz#`$R#`#a(_#a;'S$R;'S;=`$d<%lO$RY(dUyWOy$Rz#h$R#h#i(v#i;'S$R;'S;=`$d<%lO$RY(}S!kQyWOy$Rz;'S$R;'S;=`$d<%lO$RY)`UyWOy$Rz#`$R#`#a)r#a;'S$R;'S;=`$d<%lO$RY)wUyWOy$Rz#c$R#c#d*Z#d;'S$R;'S;=`$d<%lO$RY*`UyWOy$Rz#U$R#U#V*r#V;'S$R;'S;=`$d<%lO$RY*wUyWOy$Rz#T$R#T#U+Z#U;'S$R;'S;=`$d<%lO$RY+`UyWOy$Rz#`$R#`#a+r#a;'S$R;'S;=`$d<%lO$RY+yS!jQyWOy$Rz;'S$R;'S;=`$d<%lO$RY,[UyWOy$Rz#a$R#a#b,n#b;'S$R;'S;=`$d<%lO$RY,sUyWOy$Rz#d$R#d#e-V#e;'S$R;'S;=`$d<%lO$RY-[UyWOy$Rz#c$R#c#d-n#d;'S$R;'S;=`$d<%lO$RY-sUyWOy$Rz#f$R#f#g.V#g;'S$R;'S;=`$d<%lO$RY.[UyWOy$Rz#h$R#h#i.n#i;'S$R;'S;=`$d<%lO$RY.sUyWOy$Rz#T$R#T#U/V#U;'S$R;'S;=`$d<%lO$RY/[UyWOy$Rz#b$R#b#c/n#c;'S$R;'S;=`$d<%lO$RY/sUyWOy$Rz#h$R#h#i0V#i;'S$R;'S;=`$d<%lO$RY0^S!iQyWOy$Rz;'S$R;'S;=`$d<%lO$R~0mWOY0jZr0jrs1Vs#O0j#O#P1[#P;'S0j;'S;=`2W<%lO0j~1[Oj~~1_RO;'S0j;'S;=`1h;=`O0j~1kXOY0jZr0jrs1Vs#O0j#O#P1[#P;'S0j;'S;=`2W;=`<%l0j<%lO0j~2ZP;=`<%l0jZ2cY!UPOy$Rz!Q$R!Q![3R![!c$R!c!i3R!i#T$R#T#Z3R#Z;'S$R;'S;=`$d<%lO$RY3WYyWOy$Rz!Q$R!Q![3v![!c$R!c!i3v!i#T$R#T#Z3v#Z;'S$R;'S;=`$d<%lO$RY3{YyWOy$Rz!Q$R!Q![4k![!c$R!c!i4k!i#T$R#T#Z4k#Z;'S$R;'S;=`$d<%lO$RY4rYhQyWOy$Rz!Q$R!Q![5b![!c$R!c!i5b!i#T$R#T#Z5b#Z;'S$R;'S;=`$d<%lO$RY5iYhQyWOy$Rz!Q$R!Q![6X![!c$R!c!i6X!i#T$R#T#Z6X#Z;'S$R;'S;=`$d<%lO$RY6^YyWOy$Rz!Q$R!Q![6|![!c$R!c!i6|!i#T$R#T#Z6|#Z;'S$R;'S;=`$d<%lO$RY7TYhQyWOy$Rz!Q$R!Q![7s![!c$R!c!i7s!i#T$R#T#Z7s#Z;'S$R;'S;=`$d<%lO$RY7xYyWOy$Rz!Q$R!Q![8h![!c$R!c!i8h!i#T$R#T#Z8h#Z;'S$R;'S;=`$d<%lO$RY8oShQyWOy$Rz;'S$R;'S;=`$d<%lO$R_9O`Oy$Rz}$R}!O:Q!O!Q$R!Q![:Q![!_$R!_!`;T!`!c$R!c!}:Q!}#R$R#R#S:Q#S#T$R#T#o:Q#o;'S$R;'S;=`$d<%lO$RZ:X^yWcROy$Rz}$R}!O:Q!O!Q$R!Q![:Q![!c$R!c!}:Q!}#R$R#R#S:Q#S#T$R#T#o:Q#o;'S$R;'S;=`$d<%lO$R[;[S![SyWOy$Rz;'S$R;'S;=`$d<%lO$RZ;oS$tPlQOy$Rz;'S$R;'S;=`$d<%lO$RZ<QS_ROy$Rz;'S$R;'S;=`$d<%lO$R~<aWOY<^Zw<^wx1Vx#O<^#O#P<y#P;'S<^;'S;=`=u<%lO<^~<|RO;'S<^;'S;=`=V;=`O<^~=YXOY<^Zw<^wx1Vx#O<^#O#P<y#P;'S<^;'S;=`=u;=`<%l<^<%lO<^~=xP;=`<%l<^Z>QSfROy$Rz;'S$R;'S;=`$d<%lO$R~>cOe~_>jU$mPlQOy$Rz!_$R!_!`;T!`;'S$R;'S;=`$d<%lO$RZ?TWlQ!aPOy$Rz!O$R!O!P?m!P!Q$R!Q![Br![;'S$R;'S;=`$d<%lO$RZ?rUyWOy$Rz!Q$R!Q![@U![;'S$R;'S;=`$d<%lO$RZ@]YyW$oROy$Rz!Q$R!Q![@U![!g$R!g!h@{!h#X$R#X#Y@{#Y;'S$R;'S;=`$d<%lO$RZAQYyWOy$Rz{$R{|Ap|}$R}!OAp!O!Q$R!Q![BX![;'S$R;'S;=`$d<%lO$RZAuUyWOy$Rz!Q$R!Q![BX![;'S$R;'S;=`$d<%lO$RZB`UyW$oROy$Rz!Q$R!Q![BX![;'S$R;'S;=`$d<%lO$RZBy[yW$oROy$Rz!O$R!O!P@U!P!Q$R!Q![Br![!g$R!g!h@{!h#X$R#X#Y@{#Y;'S$R;'S;=`$d<%lO$RZCtSvROy$Rz;'S$R;'S;=`$d<%lO$RZDVWlQOy$Rz!O$R!O!P?m!P!Q$R!Q![Br![;'S$R;'S;=`$d<%lO$RZDtW$pROy$Rz!O$R!O!PE^!P!Q$R!Q![@U![;'S$R;'S;=`$d<%lO$RYEcUyWOy$Rz!O$R!O!PEu!P;'S$R;'S;=`$d<%lO$RYE|SuQyWOy$Rz;'S$R;'S;=`$d<%lO$RYF_SlQOy$Rz;'S$R;'S;=`$d<%lO$RZFp[$oROy$Rz!O$R!O!P@U!P!Q$R!Q![Br![!g$R!g!h@{!h#X$R#X#Y@{#Y;'S$R;'S;=`$d<%lO$RZGkUtROy$Rz![$R![!]G}!];'S$R;'S;=`$d<%lO$RXHUS}PyWOy$Rz;'S$R;'S;=`$d<%lO$RZHgS!lROy$Rz;'S$R;'S;=`$d<%lO$RYHxUlQOy$Rz!_$R!_!`%c!`;'S$R;'S;=`$d<%lO$R^IaU![SOy$Rz!_$R!_!`%c!`;'S$R;'S;=`$d<%lO$RZIzV!^PlQOy$Rz!_$R!_!`%c!`!aJa!a;'S$R;'S;=`$d<%lO$RXJhS!^PyWOy$Rz;'S$R;'S;=`$d<%lO$RXJwWOy$Rz!c$R!c!}Ka!}#T$R#T#oKa#o;'S$R;'S;=`$d<%lO$RXKh[!oPyWOy$Rz}$R}!OKa!O!Q$R!Q![Ka![!c$R!c!}Ka!}#T$R#T#oKa#o;'S$R;'S;=`$d<%lO$RXLcS!YPOy$Rz;'S$R;'S;=`$d<%lO$R^LtS!WUOy$Rz;'S$R;'S;=`$d<%lO$R[MTUOy$Rz!_$R!_!`;T!`;'S$R;'S;=`$d<%lO$RZMjUOy$Rz#b$R#b#cM|#c;'S$R;'S;=`$d<%lO$RZNRUyWOy$Rz#W$R#W#XNe#X;'S$R;'S;=`$d<%lO$RZNlSmRyWOy$Rz;'S$R;'S;=`$d<%lO$RZN{UOy$Rz#f$R#f#gNe#g;'S$R;'S;=`$d<%lO$RZ! dS!eROy$Rz;'S$R;'S;=`$d<%lO$RZ! uS!mROy$Rz;'S$R;'S;=`$d<%lO$R]!!WU!aPOy$Rz!_$R!_!`;T!`;'S$R;'S;=`$d<%lO$RW!!mP;=`<%l#r",
  tokenizers: [RR, YR, ZR, zR, vR, wR, kR, WR, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 10], Styles: [1, 134] },
  dialects: { indented: 0 },
  specialized: [{ term: 158, get: (t) => _R[t] || -1 }, { term: 157, get: (t) => jR[t] || -1 }, { term: 77, get: (t) => GR[t] || -1 }],
  tokenPrec: 3027
}), RQ = /* @__PURE__ */ re.define({
  name: "sass",
  parser: /* @__PURE__ */ CR.configure({
    props: [
      /* @__PURE__ */ fe.add({
        Block: Ie,
        Comment(t, e) {
          return { from: t.from + 2, to: e.sliceDoc(t.to - 2, t.to) == "*/" ? t.to - 2 : t.to };
        }
      }),
      /* @__PURE__ */ me.add({
        Declaration: /* @__PURE__ */ ae()
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" }, line: "//" },
    indentOnInput: /^\s*\}$/,
    wordChars: "$-"
  }
}), ER = /* @__PURE__ */ Ko((t) => t.name == "VariableName" || t.name == "SassVariableName");
function AR(t) {
  return new le(RQ, RQ.data.of({ autocomplete: ER }));
}
const DR = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "%pOVOWOOObQPOOOpOSO'#C_OOOO'#Cp'#CpQVOWOOQxQPOOO!TQQOOQ!YQPOOOOOO,58y,58yO!_OSO,58yOOOO-E6n-E6nO!dQQO'#CqQ{QPOOO!iQPOOQ{QPOOO!qQPOOOOOO1G.e1G.eOOQO,59],59]OOQO-E6o-E6oO!yOpO'#CiO#RO`O'#CiQOQPOOO#ZO#tO'#CmO#fO!bO'#CmOOQO,59T,59TO#qOpO,59TO#vO`O,59TOOOO'#Cr'#CrO#{O#tO,59XOOQO,59X,59XOOOO'#Cs'#CsO$WO!bO,59XOOQO1G.o1G.oOOOO-E6p-E6pOOQO1G.s1G.sOOOO-E6q-E6q",
  stateData: "$g~OjOS~OQROUROkQO~OWTOXUOZUO`VO~OSXOTWO~OXUO[]OlZO~OY^O~O[_O~OT`O~OYaO~OmcOodO~OmfOogO~O^iOnhO~O_jOphO~ObkOqkOrmO~OcnOsnOtmO~OnpO~OppO~ObkOqkOrrO~OcnOsnOtrO~OWX`~",
  goto: "!^hPPPiPPPPPPPPPmPPPpPPsy!Q!WTROSRe]Re_QSORYSS[T^Rb[QlfRqlQogRso",
  nodeNames: "âš  Content Text Interpolation InterpolationContent }} Entity Attribute VueAttributeName : Identifier @ Is ScriptAttributeValue AttributeScript AttributeScript AttributeName AttributeValue Entity Entity",
  maxTerm: 36,
  nodeProps: [
    ["isolate", -3, 3, 13, 17, ""]
  ],
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "'y~RdXY!aYZ!a]^!apq!ars!rwx!w}!O!|!O!P#t!Q![#y![!]$s!_!`%g!b!c%l!c!}#y#R#S#y#T#j#y#j#k%q#k#o#y%W;'S#y;'S;:j$m<%lO#y~!fSj~XY!aYZ!a]^!apq!a~!wOm~~!|Oo~!b#RX`!b}!O!|!Q![!|![!]!|!c!}!|#R#S!|#T#o!|%W;'S!|;'S;:j#n<%lO!|!b#qP;=`<%l!|~#yOl~%W$QXY#t`!b}!O!|!Q![#y![!]!|!c!}#y#R#S#y#T#o#y%W;'S#y;'S;:j$m<%lO#y%W$pP;=`<%l#y~$zXX~`!b}!O!|!Q![!|![!]!|!c!}!|#R#S!|#T#o!|%W;'S!|;'S;:j#n<%lO!|~%lO[~~%qOZ~%W%xXY#t`!b}!O&e!Q![#y![!]!|!c!}#y#R#S#y#T#o#y%W;'S#y;'S;:j$m<%lO#y!b&jX`!b}!O!|!Q![!|![!]!|!c!}'V#R#S!|#T#o'V%W;'S!|;'S;:j#n<%lO!|!b'^XW!b`!b}!O!|!Q![!|![!]!|!c!}'V#R#S!|#T#o'V%W;'S!|;'S;:j#n<%lO!|",
  tokenizers: [6, 7, /* @__PURE__ */ new nO("b~RP#q#rU~XP#q#r[~aOT~~", 17, 4), /* @__PURE__ */ new nO("!k~RQvwX#o#p!_~^TU~Opmq!]m!^;'Sm;'S;=`!X<%lOm~pUOpmq!]m!]!^!S!^;'Sm;'S;=`!X<%lOm~!XOU~~![P;=`<%lm~!bP#o#p!e~!jOk~~", 72, 2), /* @__PURE__ */ new nO("[~RPwxU~ZOp~~", 11, 15), /* @__PURE__ */ new nO("[~RPrsU~ZOn~~", 11, 14), /* @__PURE__ */ new nO("!e~RQvwXwx!_~^Tc~Opmq!]m!^;'Sm;'S;=`!X<%lOm~pUOpmq!]m!]!^!S!^;'Sm;'S;=`!X<%lOm~!XOc~~![P;=`<%lm~!dOt~~", 66, 35), /* @__PURE__ */ new nO("!e~RQrsXvw^~^Or~~cTb~Oprq!]r!^;'Sr;'S;=`!^<%lOr~uUOprq!]r!]!^!X!^;'Sr;'S;=`!^<%lOr~!^Ob~~!aP;=`<%lr~", 66, 33)],
  topRules: { Content: [0, 1], Attribute: [1, 7] },
  tokenPrec: 157
}), NR = /* @__PURE__ */ Ne.parser.configure({
  top: "SingleExpression"
}), cp = /* @__PURE__ */ DR.configure({
  props: [
    /* @__PURE__ */ se({
      Text: l.content,
      Is: l.definitionOperator,
      AttributeName: l.attributeName,
      VueAttributeName: l.keyword,
      Identifier: l.variableName,
      "AttributeValue ScriptAttributeValue": l.attributeValue,
      Entity: l.character,
      "{{ }}": l.brace,
      "@ :": l.punctuation
    })
  ]
}), hp = { parser: NR }, IR = /* @__PURE__ */ cp.configure({
  wrap: /* @__PURE__ */ SO((t, e) => t.name == "InterpolationContent" ? hp : null)
}), MR = /* @__PURE__ */ cp.configure({
  wrap: /* @__PURE__ */ SO((t, e) => t.name == "AttributeScript" ? hp : null),
  top: "Attribute"
}), LR = { parser: IR }, BR = { parser: MR }, eo = /* @__PURE__ */ Ht();
function Qp(t) {
  return t.configure({
    dialect: "selfClosing",
    wrap: SO(HR)
  }, "vue");
}
const FR = /* @__PURE__ */ Qp(eo.language);
function HR(t, e) {
  switch (t.name) {
    case "Attribute":
      return /^(@|:|v-)/.test(e.read(t.from, t.from + 2)) ? BR : null;
    case "Text":
      return LR;
  }
  return null;
}
function KR(t = {}) {
  let e = eo;
  if (t.base) {
    if (t.base.language.name != "html" || !(t.base.language instanceof re))
      throw new RangeError("The base option must be the result of calling html(...)");
    e = t.base;
  }
  return new le(e.language == eo.language ? FR : Qp(e.language), [
    e.support,
    e.language.data.of({ closeBrackets: { brackets: ["{", '"'] } })
  ]);
}
const JR = { __proto__: null, anyref: 34, dataref: 34, eqref: 34, externref: 34, i31ref: 34, funcref: 34, i8: 34, i16: 34, i32: 34, i64: 34, f32: 34, f64: 34 }, ev = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "!^Q]QPOOOqQPO'#CbOOQO'#Cd'#CdOOQO'#Cl'#ClOOQO'#Ch'#ChQ]QPOOOOQO,58|,58|OxQPO,58|OOQO-E6f-E6fOOQO1G.h1G.h",
  stateData: "!P~O_OSPOSQOS~OTPOVROXROYROZROaQO~OSUO~P]OSXO~P]O",
  goto: "xaPPPPPPbPbPPPhPPPrXROPTVQTOQVPTWTVXSOPTV",
  nodeNames: "âš  LineComment BlockComment Module ) ( App Identifier Type Keyword Number String",
  maxTerm: 17,
  nodeProps: [
    ["isolate", -3, 1, 2, 11, ""],
    ["openedBy", 4, "("],
    ["closedBy", 5, ")"],
    ["group", -6, 6, 7, 8, 9, 10, 11, "Expression"]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 1,
  tokenData: "0o~R^XY}YZ}]^}pq}rs!Stu#pxy'Uyz(e{|(j}!O(j!Q!R(s!R![*p!]!^.^#T#o.{~!SO_~~!VVOr!Srs!ls#O!S#O#P!q#P;'S!S;'S;=`#j<%lO!S~!qOZ~~!tRO;'S!S;'S;=`!};=`O!S~#QWOr!Srs!ls#O!S#O#P!q#P;'S!S;'S;=`#j;=`<%l!S<%lO!S~#mP;=`<%l!S~#siqr%bst%btu%buv%bvw%bwx%bz{%b{|%b}!O%b!O!P%b!P!Q%b!Q![%b![!]%b!^!_%b!_!`%b!`!a%b!a!b%b!b!c%b!c!}%b#Q#R%b#R#S%b#S#T%b#T#o%b#p#q%b#r#s%b~%giV~qr%bst%btu%buv%bvw%bwx%bz{%b{|%b}!O%b!O!P%b!P!Q%b!Q![%b![!]%b!^!_%b!_!`%b!`!a%b!a!b%b!b!c%b!c!}%b#Q#R%b#R#S%b#S#T%b#T#o%b#p#q%b#r#s%b~'ZPT~!]!^'^~'aTO!]'^!]!^'p!^;'S'^;'S;=`(_<%lO'^~'sVOy'^yz(Yz!]'^!]!^'p!^;'S'^;'S;=`(_<%lO'^~(_OQ~~(bP;=`<%l'^~(jOS~~(mQ!Q!R(s!R![*p~(xUY~!O!P)[!Q![*p!g!h){#R#S+U#X#Y){#l#m+[~)aRY~!Q![)j!g!h){#X#Y){~)oSY~!Q![)j!g!h){#R#S*j#X#Y){~*OR{|*X}!O*X!Q![*_~*[P!Q![*_~*dQY~!Q![*_#R#S*X~*mP!Q![)j~*uTY~!O!P)[!Q![*p!g!h){#R#S+U#X#Y){~+XP!Q![*p~+_R!Q![+h!c!i+h#T#Z+h~+mVY~!O!P,S!Q![+h!c!i+h!r!s-P#R#S+[#T#Z+h#d#e-P~,XTY~!Q![,h!c!i,h!r!s-P#T#Z,h#d#e-P~,mUY~!Q![,h!c!i,h!r!s-P#R#S.Q#T#Z,h#d#e-P~-ST{|-c}!O-c!Q![-o!c!i-o#T#Z-o~-fR!Q![-o!c!i-o#T#Z-o~-tSY~!Q![-o!c!i-o#R#S-c#T#Z-o~.TR!Q![,h!c!i,h#T#Z,h~.aP!]!^.d~.iSP~OY.dZ;'S.d;'S;=`.u<%lO.d~.xP;=`<%l.d~/QiX~qr.{st.{tu.{uv.{vw.{wx.{z{.{{|.{}!O.{!O!P.{!P!Q.{!Q![.{![!].{!^!_.{!_!`.{!`!a.{!a!b.{!b!c.{!c!}.{#Q#R.{#R#S.{#S#T.{#T#o.{#p#q.{#r#s.{",
  tokenizers: [0],
  topRules: { Module: [0, 3] },
  specialized: [{ term: 9, get: (t) => JR[t] || -1 }],
  tokenPrec: 0
}), Ov = /* @__PURE__ */ re.define({
  name: "wast",
  parser: /* @__PURE__ */ ev.configure({
    props: [
      /* @__PURE__ */ me.add({
        App: /* @__PURE__ */ YO({ closing: ")", align: !1 })
      }),
      /* @__PURE__ */ fe.add({
        App: Ie,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      }),
      /* @__PURE__ */ se({
        Keyword: l.keyword,
        Type: l.typeName,
        Number: l.number,
        String: l.string,
        Identifier: l.variableName,
        LineComment: l.lineComment,
        BlockComment: l.blockComment,
        "( )": l.paren
      })
    ]
  }),
  languageData: {
    commentTokens: { line: ";;", block: { open: "(;", close: ";)" } },
    closeBrackets: { brackets: ["(", '"'] }
  }
});
function tv() {
  return new le(Ov);
}
const Oo = 1, iv = 2, rv = 3, nv = 4, sv = 5, av = 35, ov = 36, lv = 37, cv = 11, hv = 13;
function Qv(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function fv(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let vQ = null, ZQ = null, YQ = 0;
function to(t, e) {
  let O = t.pos + e;
  if (ZQ == t && YQ == O) return vQ;
  for (; fv(t.peek(e)); ) e++;
  let i = "";
  for (; ; ) {
    let r = t.peek(e);
    if (!Qv(r)) break;
    i += String.fromCharCode(r), e++;
  }
  return ZQ = t, YQ = O, vQ = i || null;
}
function zQ(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let O = 0; O < t.length; O++) this.hash += (this.hash << 4) + t.charCodeAt(O) + (t.charCodeAt(O) << 8);
}
const $v = new Ft({
  start: null,
  shift(t, e, O, i) {
    return e == Oo ? new zQ(to(i, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == cv && t ? t.parent : t;
  },
  reuse(t, e, O, i) {
    let r = e.type.id;
    return r == Oo || r == hv ? new zQ(to(i, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: !1
}), uv = new q((t, e) => {
  if (t.next == 60) {
    if (t.advance(), t.next == 47) {
      t.advance();
      let O = to(t, 0);
      if (!O) return t.acceptToken(sv);
      if (e.context && O == e.context.name) return t.acceptToken(iv);
      for (let i = e.context; i; i = i.parent) if (i.name == O) return t.acceptToken(rv, -2);
      t.acceptToken(nv);
    } else if (t.next != 33 && t.next != 63)
      return t.acceptToken(Oo);
  }
}, { contextual: !0 });
function hl(t, e) {
  return new q((O) => {
    let i = 0, r = e.charCodeAt(0);
    e: for (; !(O.next < 0); O.advance(), i++)
      if (O.next == r) {
        for (let n = 1; n < e.length; n++)
          if (O.peek(n) != e.charCodeAt(n)) continue e;
        break;
      }
    i && O.acceptToken(t);
  });
}
const dv = hl(av, "-->"), pv = hl(ov, "?>"), mv = hl(lv, "]]>"), Pv = se({
  Text: l.content,
  "StartTag StartCloseTag EndTag SelfCloseEndTag": l.angleBracket,
  TagName: l.tagName,
  "MismatchedCloseTag/TagName": [l.tagName, l.invalid],
  AttributeName: l.attributeName,
  AttributeValue: l.attributeValue,
  Is: l.definitionOperator,
  "EntityReference CharacterReference": l.character,
  Comment: l.blockComment,
  ProcessingInst: l.processingInstruction,
  DoctypeDecl: l.documentMeta,
  Cdata: l.special(l.string)
}), gv = ne.deserialize({
  version: 14,
  states: ",SOQOaOOOrOxO'#CfOzOpO'#CiO!tOaO'#CgOOOP'#Cg'#CgO!{OrO'#CrO#TOtO'#CsO#]OpO'#CtOOOP'#DS'#DSOOOP'#Cv'#CvQQOaOOOOOW'#Cw'#CwO#eOxO,59QOOOP,59Q,59QOOOO'#Cx'#CxO#mOpO,59TO#uO!bO,59TOOOP'#C{'#C{O$TOaO,59RO$[OpO'#CoOOOP,59R,59ROOOQ'#C|'#C|O$dOrO,59^OOOP,59^,59^OOOS'#C}'#C}O$lOtO,59_OOOP,59_,59_O$tOpO,59`O$|OpO,59`OOOP-E6t-E6tOOOW-E6u-E6uOOOP1G.l1G.lOOOO-E6v-E6vO%UO!bO1G.oO%UO!bO1G.oO%dOpO'#CkO%lO!bO'#CyO%zO!bO1G.oOOOP1G.o1G.oOOOP1G.w1G.wOOOP-E6y-E6yOOOP1G.m1G.mO&VOpO,59ZO&_OpO,59ZOOOQ-E6z-E6zOOOP1G.x1G.xOOOS-E6{-E6{OOOP1G.y1G.yO&gOpO1G.zO&gOpO1G.zOOOP1G.z1G.zO&oO!bO7+$ZO&}O!bO7+$ZOOOP7+$Z7+$ZOOOP7+$c7+$cO'YOpO,59VO'bOpO,59VO'jO!bO,59eOOOO-E6w-E6wO'xOpO1G.uO'xOpO1G.uOOOP1G.u1G.uO(QOpO7+$fOOOP7+$f7+$fO(YO!bO<<GuOOOP<<Gu<<GuOOOP<<G}<<G}O'bOpO1G.qO'bOpO1G.qO(eO#tO'#CnOOOO1G.q1G.qO(sOpO7+$aOOOP7+$a7+$aOOOP<<HQ<<HQOOOPAN=aAN=aOOOPAN=iAN=iO'bOpO7+$]OOOO7+$]7+$]OOOO'#Cz'#CzO({O#tO,59YOOOO,59Y,59YOOOP<<G{<<G{OOOO<<Gw<<GwOOOO-E6x-E6xOOOO1G.t1G.t",
  stateData: ")Z~OPQOSVOTWOVWOWWOXWOiXOxPO}TO!PUO~OuZOw]O~O^`Oy^O~OPQOQcOSVOTWOVWOWWOXWOxPO}TO!PUO~ORdO~P!SOseO|gO~OthO!OjO~O^lOy^O~OuZOwoO~O^qOy^O~O[vO`sOdwOy^O~ORyO~P!SO^{Oy^O~OseO|}O~OthO!O!PO~O^!QOy^O~O[!SOy^O~O[!VO`sOd!WOy^O~Oa!YOy^O~Oy^O[mX`mXdmX~O[!VO`sOd!WO~O^!]Oy^O~O[!_Oy^O~O[!aOy^O~O[!cO`sOd!dOy^O~O[!cO`sOd!dO~Oa!eOy^O~Oy^Oz!gO~Oy^O[ma`madma~O[!jOy^O~O[!kOy^O~O[!lO`sOd!mO~OW!pOX!pOz!rO{!pO~O[!sOy^O~OW!pOX!pOz!vO{!pO~O",
  goto: "%[wPPPPPPPPPPxxP!OP!UPP!_!iP!oxxxP!u!{#R$Z$j$p$v$|PPPP%SXWORYbXRORYb_t`qru!T!U!bQ!h!YS!o!e!fR!t!nQdRRybXSORYbQYORmYQ[PRn[Q_QQkVjp_krz!R!T!X!Z!^!`!f!i!nQr`QzcQ!RlQ!TqQ!XsQ!ZtQ!^{Q!`!QQ!f!YQ!i!]R!n!eQu`S!UqrU![u!U!bR!b!TQ!q!gR!u!qQbRRxbQfTR|fQiUR!OiSXOYTaRb",
  nodeNames: "âš  StartTag StartCloseTag MissingCloseTag StartCloseTag StartCloseTag Document Text EntityReference CharacterReference Cdata Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue CloseTag SelfCloseEndTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag DoctypeDecl",
  maxTerm: 47,
  context: $v,
  nodeProps: [
    ["closedBy", 1, "SelfCloseEndTag EndTag", 13, "CloseTag MissingCloseTag"],
    ["openedBy", 12, "StartTag StartCloseTag", 19, "OpenTag", 20, "StartTag"],
    ["isolate", -6, 13, 18, 19, 21, 22, 24, ""]
  ],
  propSources: [Pv],
  skippedNodes: [0],
  repeatNodeCount: 8,
  tokenData: "Jy~R!XOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs'ssv$nvw(Zw}$n}!O,^!O!P$n!P!Q.m!Q![$n![!]0V!]!^$n!^!_3h!_!`El!`!aF_!a!bGQ!b!c$n!c!}0V!}#P$n#P#QHj#Q#R$n#R#S0V#S#T$n#T#o0V#o%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U$n4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$nX$uWVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nP%dTVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_P%vP;=`<%l%_W&OT{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yW&bP;=`<%l%yX&hP;=`<%l$n_&t_VP{WyUOX$nXY&kYZ&kZ]$n]^&k^p$npq&kqr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ'zTzYVPOv%_w!^%_!_;'S%_;'S;=`%s<%lO%_~(^ast)c![!]*g!c!}*g#R#S*g#T#o*g%W%o*g%p&a*g&b1p*g4U4d*g4e$IS*g$I`$Ib*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~)fQ!Q![)l#l#m)z~)oQ!Q![)l!]!^)u~)zOX~~)}R!Q![*W!c!i*W#T#Z*W~*ZS!Q![*W!]!^)u!c!i*W#T#Z*W~*jg}!O*g!O!P*g!Q![*g![!]*g!]!^,R!c!}*g#R#S*g#T#o*g$}%O*g%W%o*g%p&a*g&b1p*g1p4U*g4U4d*g4e$IS*g$I`$Ib*g$Je$Jg*g$Kh%#t*g&/x&Et*g&FV;'S*g;'S;:j,W?&r?Ah*g?BY?Mn*g~,WOW~~,ZP;=`<%l*gZ,eYVP{WOr$nrs%_sv$nw}$n}!O-T!O!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZ-[YVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a-z!a;'S$n;'S;=`&e<%lO$nZ.TW|QVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n].tYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!a/d!a;'S$n;'S;=`&e<%lO$n]/mWdSVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_0b!O`S^QVP{WOr$nrs%_sv$nw}$n}!O0V!O!P0V!P!Q$n!Q![0V![!]0V!]!^$n!^!_%y!_!c$n!c!}0V!}#R$n#R#S0V#S#T$n#T#o0V#o$}$n$}%O0V%O%W$n%W%o0V%o%p$n%p&a0V&a&b$n&b1p0V1p4U0V4U4d0V4d4e$n4e$IS0V$IS$I`$n$I`$Ib0V$Ib$Je$n$Je$Jg0V$Jg$Kh$n$Kh%#t0V%#t&/x$n&/x&Et0V&Et&FV$n&FV;'S0V;'S;:j3b;:j;=`&e<%l?&r$n?&r?Ah0V?Ah?BY$n?BY?Mn0V?MnO$n_3eP;=`<%l0VX3mW{WOq%yqr4Vsv%yw!a%y!a!bEU!b;'S%y;'S;=`&_<%lO%yX4[]{WOr%ysv%yw}%y}!O5T!O!f%y!f!g6V!g!}%y!}#O;f#O#W%y#W#XAr#X;'S%y;'S;=`&_<%lO%yX5YV{WOr%ysv%yw}%y}!O5o!O;'S%y;'S;=`&_<%lO%yX5vT}P{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX6[V{WOr%ysv%yw!q%y!q!r6q!r;'S%y;'S;=`&_<%lO%yX6vV{WOr%ysv%yw!e%y!e!f7]!f;'S%y;'S;=`&_<%lO%yX7bV{WOr%ysv%yw!v%y!v!w7w!w;'S%y;'S;=`&_<%lO%yX7|V{WOr%ysv%yw!{%y!{!|8c!|;'S%y;'S;=`&_<%lO%yX8hV{WOr%ysv%yw!r%y!r!s8}!s;'S%y;'S;=`&_<%lO%yX9SV{WOr%ysv%yw!g%y!g!h9i!h;'S%y;'S;=`&_<%lO%yX9nX{WOr9irs:Zsv9ivw:Zw!`9i!`!a:x!a;'S9i;'S;=`;`<%lO9iP:^TO!`:Z!`!a:m!a;'S:Z;'S;=`:r<%lO:ZP:rOiPP:uP;=`<%l:ZX;PTiP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yX;cP;=`<%l9iX;kX{WOr%ysv%yw!e%y!e!f<W!f#V%y#V#W?f#W;'S%y;'S;=`&_<%lO%yX<]V{WOr%ysv%yw!f%y!f!g<r!g;'S%y;'S;=`&_<%lO%yX<wV{WOr%ysv%yw!c%y!c!d=^!d;'S%y;'S;=`&_<%lO%yX=cV{WOr%ysv%yw!v%y!v!w=x!w;'S%y;'S;=`&_<%lO%yX=}V{WOr%ysv%yw!c%y!c!d>d!d;'S%y;'S;=`&_<%lO%yX>iV{WOr%ysv%yw!}%y!}#O?O#O;'S%y;'S;=`&_<%lO%yX?VT{WxPOr%ysv%yw;'S%y;'S;=`&_<%lO%yX?kV{WOr%ysv%yw#W%y#W#X@Q#X;'S%y;'S;=`&_<%lO%yX@VV{WOr%ysv%yw#T%y#T#U@l#U;'S%y;'S;=`&_<%lO%yX@qV{WOr%ysv%yw#h%y#h#iAW#i;'S%y;'S;=`&_<%lO%yXA]V{WOr%ysv%yw#T%y#T#U>d#U;'S%y;'S;=`&_<%lO%yXAwV{WOr%ysv%yw#c%y#c#dB^#d;'S%y;'S;=`&_<%lO%yXBcV{WOr%ysv%yw#V%y#V#WBx#W;'S%y;'S;=`&_<%lO%yXB}V{WOr%ysv%yw#h%y#h#iCd#i;'S%y;'S;=`&_<%lO%yXCiV{WOr%ysv%yw#m%y#m#nDO#n;'S%y;'S;=`&_<%lO%yXDTV{WOr%ysv%yw#d%y#d#eDj#e;'S%y;'S;=`&_<%lO%yXDoV{WOr%ysv%yw#X%y#X#Y9i#Y;'S%y;'S;=`&_<%lO%yXE]T!PP{WOr%ysv%yw;'S%y;'S;=`&_<%lO%yZEuWaQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n_FhW[UVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZGXYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aGw!a;'S$n;'S;=`&e<%lO$nZHQW!OQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$nZHqYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_#P$n#P#QIa#Q;'S$n;'S;=`&e<%lO$nZIhYVP{WOr$nrs%_sv$nw!^$n!^!_%y!_!`$n!`!aJW!a;'S$n;'S;=`&e<%lO$nZJaWwQVP{WOr$nrs%_sv$nw!^$n!^!_%y!_;'S$n;'S;=`&e<%lO$n",
  tokenizers: [uv, dv, pv, mv, 0, 1, 2, 3],
  topRules: { Document: [0, 6] },
  tokenPrec: 0
});
function Hr(t, e) {
  let O = e && e.getChild("TagName");
  return O ? t.sliceString(O.from, O.to) : "";
}
function Us(t, e) {
  let O = e && e.firstChild;
  return !O || O.name != "OpenTag" ? "" : Hr(t, O);
}
function Sv(t, e, O) {
  let i = e && e.getChildren("Attribute").find((n) => n.from <= O && n.to >= O), r = i && i.getChild("AttributeName");
  return r ? t.sliceString(r.from, r.to) : "";
}
function Vs(t) {
  for (let e = t && t.parent; e; e = e.parent)
    if (e.name == "Element")
      return e;
  return null;
}
function Xv(t, e) {
  var O;
  let i = I(t).resolveInner(e, -1), r = null;
  for (let n = i; !r && n.parent; n = n.parent)
    (n.name == "OpenTag" || n.name == "CloseTag" || n.name == "SelfClosingTag" || n.name == "MismatchedCloseTag") && (r = n);
  if (r && (r.to > e || r.lastChild.type.isError)) {
    let n = r.parent;
    if (i.name == "TagName")
      return r.name == "CloseTag" || r.name == "MismatchedCloseTag" ? { type: "closeTag", from: i.from, context: n } : { type: "openTag", from: i.from, context: Vs(n) };
    if (i.name == "AttributeName")
      return { type: "attrName", from: i.from, context: r };
    if (i.name == "AttributeValue")
      return { type: "attrValue", from: i.from, context: r };
    let s = i == r || i.name == "Attribute" ? i.childBefore(e) : i;
    return (s == null ? void 0 : s.name) == "StartTag" ? { type: "openTag", from: e, context: Vs(n) } : (s == null ? void 0 : s.name) == "StartCloseTag" && s.to <= e ? { type: "closeTag", from: e, context: n } : (s == null ? void 0 : s.name) == "Is" ? { type: "attrValue", from: e, context: r } : s ? { type: "attrName", from: e, context: r } : null;
  } else if (i.name == "StartCloseTag")
    return { type: "closeTag", from: e, context: i.parent };
  for (; i.parent && i.to == e && !(!((O = i.lastChild) === null || O === void 0) && O.type.isError); )
    i = i.parent;
  return i.name == "Element" || i.name == "Text" || i.name == "Document" ? { type: "tag", from: e, context: i.name == "Element" ? i : Vs(i) } : null;
}
class yv {
  constructor(e, O, i) {
    this.attrs = O, this.attrValues = i, this.children = [], this.name = e.name, this.completion = Object.assign(Object.assign({ type: "type" }, e.completion || {}), { label: this.name }), this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: "<" + this.name }), this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: "</" + this.name + ">", boost: 2 }), this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + ">" }), this.text = e.textContent ? e.textContent.map((r) => ({ label: r, type: "text" })) : [];
  }
}
const _s = /^[:\-\.\w\u00b7-\uffff]*$/;
function qQ(t) {
  return Object.assign(Object.assign({ type: "property" }, t.completion || {}), { label: t.name });
}
function UQ(t) {
  return typeof t == "string" ? { label: `"${t}"`, type: "constant" } : /^"/.test(t.label) ? t : Object.assign(Object.assign({}, t), { label: `"${t.label}"` });
}
function bv(t, e) {
  let O = [], i = [], r = /* @__PURE__ */ Object.create(null);
  for (let o of e) {
    let c = qQ(o);
    O.push(c), o.global && i.push(c), o.values && (r[o.name] = o.values.map(UQ));
  }
  let n = [], s = [], a = /* @__PURE__ */ Object.create(null);
  for (let o of t) {
    let c = i, h = r;
    o.attributes && (c = c.concat(o.attributes.map((f) => typeof f == "string" ? O.find(($) => $.label == f) || { label: f, type: "property" } : (f.values && (h == r && (h = Object.create(h)), h[f.name] = f.values.map(UQ)), qQ(f)))));
    let Q = new yv(o, c, h);
    a[Q.name] = Q, n.push(Q), o.top && s.push(Q);
  }
  s.length || (s = n);
  for (let o = 0; o < n.length; o++) {
    let c = t[o], h = n[o];
    if (c.children)
      for (let Q of c.children)
        a[Q] && h.children.push(a[Q]);
    else
      h.children = n;
  }
  return (o) => {
    var c;
    let { doc: h } = o.state, Q = Xv(o.state, o.pos);
    if (!Q || Q.type == "tag" && !o.explicit)
      return null;
    let { type: f, from: $, context: u } = Q;
    if (f == "openTag") {
      let d = s, p = Us(h, u);
      if (p) {
        let m = a[p];
        d = (m == null ? void 0 : m.children) || n;
      }
      return {
        from: $,
        options: d.map((m) => m.completion),
        validFor: _s
      };
    } else if (f == "closeTag") {
      let d = Us(h, u);
      return d ? {
        from: $,
        to: o.pos + (h.sliceString(o.pos, o.pos + 1) == ">" ? 1 : 0),
        options: [((c = a[d]) === null || c === void 0 ? void 0 : c.closeNameCompletion) || { label: d + ">", type: "type" }],
        validFor: _s
      } : null;
    } else if (f == "attrName") {
      let d = a[Hr(h, u)];
      return {
        from: $,
        options: (d == null ? void 0 : d.attrs) || i,
        validFor: _s
      };
    } else if (f == "attrValue") {
      let d = Sv(h, u, $);
      if (!d)
        return null;
      let p = a[Hr(h, u)], m = ((p == null ? void 0 : p.attrValues) || r)[d];
      return !m || !m.length ? null : {
        from: $,
        to: o.pos + (h.sliceString(o.pos, o.pos + 1) == '"' ? 1 : 0),
        options: m,
        validFor: /^"[^"]*"?$/
      };
    } else if (f == "tag") {
      let d = Us(h, u), p = a[d], m = [], P = u && u.lastChild;
      d && (!P || P.name != "CloseTag" || Hr(h, P) != d) && m.push(p ? p.closeCompletion : { label: "</" + d + ">", type: "type", boost: 2 });
      let X = m.concat(((p == null ? void 0 : p.children) || (u ? n : s)).map((y) => y.openCompletion));
      if (u && (p != null && p.text.length)) {
        let y = u.firstChild;
        y.to > o.pos - 20 && !/\S/.test(o.state.sliceDoc(y.to, o.pos)) && (X = X.concat(p.text));
      }
      return {
        from: $,
        options: X,
        validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/
      };
    } else
      return null;
  };
}
const io = /* @__PURE__ */ re.define({
  name: "xml",
  parser: /* @__PURE__ */ gv.configure({
    props: [
      /* @__PURE__ */ me.add({
        Element(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ fe.add({
        Element(t) {
          let e = t.firstChild, O = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: O.name == "CloseTag" ? O.from : t.to };
        }
      }),
      /* @__PURE__ */ Yo.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/$/
  }
});
function xv(t = {}) {
  let e = [io.data.of({
    autocomplete: bv(t.elements || [], t.attributes || [])
  })];
  return t.autoCloseTags !== !1 && e.push(Tv), new le(io, e);
}
function VQ(t, e, O = t.length) {
  if (!e)
    return "";
  let i = e.firstChild, r = i && i.getChild("TagName");
  return r ? t.sliceString(r.from, Math.min(r.to, O)) : "";
}
const Tv = /* @__PURE__ */ k.inputHandler.of((t, e, O, i, r) => {
  if (t.composing || t.state.readOnly || e != O || i != ">" && i != "/" || !io.isActiveAt(t.state, e, -1))
    return !1;
  let n = r(), { state: s } = n, a = s.changeByRange((o) => {
    var c, h, Q;
    let { head: f } = o, $ = s.doc.sliceString(f - 1, f) == i, u = I(s).resolveInner(f, -1), d;
    if ($ && i == ">" && u.name == "EndTag") {
      let p = u.parent;
      if (((h = (c = p.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (d = VQ(s.doc, p.parent, f))) {
        let m = f + (s.doc.sliceString(f, f + 1) === ">" ? 1 : 0), P = `</${d}>`;
        return { range: o, changes: { from: f, to: m, insert: P } };
      }
    } else if ($ && i == "/" && u.name == "StartCloseTag") {
      let p = u.parent;
      if (u.from == f - 2 && ((Q = p.lastChild) === null || Q === void 0 ? void 0 : Q.name) != "CloseTag" && (d = VQ(s.doc, p, f))) {
        let m = f + (s.doc.sliceString(f, f + 1) === ">" ? 1 : 0), P = `${d}>`;
        return {
          range: g.cursor(f + P.length, -1),
          changes: { from: f, to: m, insert: P }
        };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    n,
    s.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), xt = 63, _Q = 64, wv = 1, kv = 2, fp = 3, Wv = 4, $p = 5, Rv = 6, vv = 7, up = 65, Zv = 66, Yv = 8, zv = 9, qv = 10, Uv = 11, Vv = 12, dp = 13, _v = 19, jv = 20, Gv = 29, Cv = 33, Ev = 34, Av = 47, Dv = 0, Ql = 1, ro = 2, Fi = 3, no = 4;
class at {
  constructor(e, O, i) {
    this.parent = e, this.depth = O, this.type = i, this.hash = (e ? e.hash + e.hash << 8 : 0) + O + (O << 4) + i;
  }
}
at.top = new at(null, -1, Dv);
function yi(t, e) {
  for (let O = 0, i = e - t.pos - 1; ; i--, O++) {
    let r = t.peek(i);
    if (zO(r) || r == -1) return O;
  }
}
function so(t) {
  return t == 32 || t == 9;
}
function zO(t) {
  return t == 10 || t == 13;
}
function pp(t) {
  return so(t) || zO(t);
}
function ht(t) {
  return t < 0 || pp(t);
}
const Nv = new Ft({
  start: at.top,
  reduce(t, e) {
    return t.type == Fi && (e == jv || e == Ev) ? t.parent : t;
  },
  shift(t, e, O, i) {
    if (e == fp)
      return new at(t, yi(i, i.pos), Ql);
    if (e == up || e == $p)
      return new at(t, yi(i, i.pos), ro);
    if (e == xt)
      return t.parent;
    if (e == _v || e == Cv)
      return new at(t, 0, Fi);
    if (e == dp && t.type == no)
      return t.parent;
    if (e == Av) {
      let r = /[1-9]/.exec(i.read(i.pos, O.pos));
      if (r) return new at(t, t.depth + +r[0], no);
    }
    return t;
  },
  hash(t) {
    return t.hash;
  }
});
function It(t, e, O = 0) {
  return t.peek(O) == e && t.peek(O + 1) == e && t.peek(O + 2) == e && ht(t.peek(O + 3));
}
const Iv = new q((t, e) => {
  if (t.next == -1 && e.canShift(_Q))
    return t.acceptToken(_Q);
  let O = t.peek(-1);
  if ((zO(O) || O < 0) && e.context.type != Fi) {
    if (It(
      t,
      45
      /* '-' */
    ))
      if (e.canShift(xt)) t.acceptToken(xt);
      else return t.acceptToken(wv, 3);
    if (It(
      t,
      46
      /* '.' */
    ))
      if (e.canShift(xt)) t.acceptToken(xt);
      else return t.acceptToken(kv, 3);
    let i = 0;
    for (; t.next == 32; )
      i++, t.advance();
    (i < e.context.depth || i == e.context.depth && e.context.type == Ql && (t.next != 45 || !ht(t.peek(1)))) && // Not blank
    t.next != -1 && !zO(t.next) && t.next != 35 && t.acceptToken(xt, -i);
  }
}, { contextual: !0 }), Mv = new q((t, e) => {
  if (e.context.type == Fi) {
    t.next == 63 && (t.advance(), ht(t.next) && t.acceptToken(vv));
    return;
  }
  if (t.next == 45)
    t.advance(), ht(t.next) && t.acceptToken(e.context.type == Ql && e.context.depth == yi(t, t.pos - 1) ? Wv : fp);
  else if (t.next == 63)
    t.advance(), ht(t.next) && t.acceptToken(e.context.type == ro && e.context.depth == yi(t, t.pos - 1) ? Rv : $p);
  else {
    let O = t.pos;
    for (; ; )
      if (so(t.next)) {
        if (t.pos == O) return;
        t.advance();
      } else if (t.next == 33)
        mp(t);
      else if (t.next == 38)
        ao(t);
      else if (t.next == 42) {
        ao(t);
        break;
      } else if (t.next == 39 || t.next == 34) {
        if (fl(t, !0)) break;
        return;
      } else if (t.next == 91 || t.next == 123) {
        if (!Bv(t)) return;
        break;
      } else {
        Pp(t, !0, !1, 0);
        break;
      }
    for (; so(t.next); ) t.advance();
    if (t.next == 58) {
      if (t.pos == O && e.canShift(Gv)) return;
      let i = t.peek(1);
      ht(i) && t.acceptTokenTo(e.context.type == ro && e.context.depth == yi(t, O) ? Zv : up, O);
    }
  }
}, { contextual: !0 });
function Lv(t) {
  return t > 32 && t < 127 && t != 34 && t != 37 && t != 44 && t != 60 && t != 62 && t != 92 && t != 94 && t != 96 && t != 123 && t != 124 && t != 125;
}
function jQ(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function GQ(t, e) {
  return t.next == 37 ? (t.advance(), jQ(t.next) && t.advance(), jQ(t.next) && t.advance(), !0) : Lv(t.next) || e && t.next == 44 ? (t.advance(), !0) : !1;
}
function mp(t) {
  if (t.advance(), t.next == 60) {
    for (t.advance(); ; )
      if (!GQ(t, !0)) {
        t.next == 62 && t.advance();
        break;
      }
  } else
    for (; GQ(t, !1); )
      ;
}
function ao(t) {
  for (t.advance(); !ht(t.next) && vn(t.tag) != "f"; ) t.advance();
}
function fl(t, e) {
  let O = t.next, i = !1, r = t.pos;
  for (t.advance(); ; ) {
    let n = t.next;
    if (n < 0) break;
    if (t.advance(), n == O)
      if (n == 39)
        if (t.next == 39) t.advance();
        else break;
      else
        break;
    else if (n == 92 && O == 34)
      t.next >= 0 && t.advance();
    else if (zO(n)) {
      if (e) return !1;
      i = !0;
    } else if (e && t.pos >= r + 1024)
      return !1;
  }
  return !i;
}
function Bv(t) {
  for (let e = [], O = t.pos + 1024; ; )
    if (t.next == 91 || t.next == 123)
      e.push(t.next), t.advance();
    else if (t.next == 39 || t.next == 34) {
      if (!fl(t, !0)) return !1;
    } else if (t.next == 93 || t.next == 125) {
      if (e[e.length - 1] != t.next - 2) return !1;
      if (e.pop(), t.advance(), !e.length) return !0;
    } else {
      if (t.next < 0 || t.pos > O || zO(t.next))
        return !1;
      t.advance();
    }
}
const Fv = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function vn(t) {
  return t < 33 ? "u" : t > 125 ? "s" : Fv[t - 33];
}
function js(t, e) {
  let O = vn(t);
  return O != "u" && !(e && O == "f");
}
function Pp(t, e, O, i) {
  if (vn(t.next) == "s" || (t.next == 63 || t.next == 58 || t.next == 45) && js(t.peek(1), O))
    t.advance();
  else
    return !1;
  let r = t.pos;
  for (; ; ) {
    let n = t.next, s = 0, a = i + 1;
    for (; pp(n); ) {
      if (zO(n)) {
        if (e) return !1;
        a = 0;
      } else
        a++;
      n = t.peek(++s);
    }
    if (!(n >= 0 && (n == 58 ? js(t.peek(s + 1), O) : n == 35 ? t.peek(s - 1) != 32 : js(n, O))) || !O && a <= i || a == 0 && !O && (It(t, 45, s) || It(t, 46, s)))
      break;
    if (e && vn(n) == "f") return !1;
    for (let c = s; c >= 0; c--) t.advance();
    if (e && t.pos > r + 1024) return !1;
  }
  return !0;
}
const Hv = new q((t, e) => {
  if (t.next == 33)
    mp(t), t.acceptToken(Vv);
  else if (t.next == 38 || t.next == 42) {
    let O = t.next == 38 ? qv : Uv;
    ao(t), t.acceptToken(O);
  } else t.next == 39 || t.next == 34 ? (fl(t, !1), t.acceptToken(zv)) : Pp(t, !1, e.context.type == Fi, e.context.depth) && t.acceptToken(Yv);
}), Kv = new q((t, e) => {
  let O = e.context.type == no ? e.context.depth : -1, i = t.pos;
  e: for (; ; ) {
    let r = 0, n = t.next;
    for (; n == 32; ) n = t.peek(++r);
    if (!r && (It(t, 45, r) || It(t, 46, r)) || !zO(n) && (O < 0 && (O = Math.max(e.context.depth + 1, r)), r < O))
      break;
    for (; ; ) {
      if (t.next < 0) break e;
      let s = zO(t.next);
      if (t.advance(), s) continue e;
      i = t.pos;
    }
  }
  t.acceptTokenTo(dp, i);
}), Jv = se({
  DirectiveName: l.keyword,
  DirectiveContent: l.attributeValue,
  "DirectiveEnd DocEnd": l.meta,
  QuotedLiteral: l.string,
  BlockLiteralHeader: l.special(l.string),
  BlockLiteralContent: l.content,
  Literal: l.content,
  "Key/Literal Key/QuotedLiteral": l.definition(l.propertyName),
  "Anchor Alias": l.labelName,
  Tag: l.typeName,
  Comment: l.lineComment,
  ": , -": l.separator,
  "?": l.punctuation,
  "[ ]": l.squareBracket,
  "{ }": l.brace
}), eZ = ne.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: "âš  DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: Nv,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [Jv],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [Iv, Mv, Hv, Kv, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), OZ = /* @__PURE__ */ ne.deserialize({
  version: 14,
  states: "!vOQOPOOO]OPO'#C_OhOPO'#C^OOOO'#Cc'#CcOpOPO'#CaQOOOOOO{OPOOOOOO'#Cb'#CbO!WOPO'#C`O!`OPO,58xOOOO-E6a-E6aOOOO-E6`-E6`OOOO'#C_'#C_OOOO1G.d1G.d",
  stateData: "!h~OXPOYROWTP~OWVXXRXYRX~OYVOXSP~OXROYROWTX~OXROYROWTP~OYVOXSX~OX[O~OXY~",
  goto: "vWPPX[beioRUOQQOR]XRXQTTOUQWQRZWSSOURYS",
  nodeNames: "âš  Document Frontmatter DashLine FrontmatterContent Body",
  maxTerm: 10,
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "$z~RXOYnYZ!^Z]n]^!^^}n}!O!i!O;'Sn;'S;=`!c<%lOn~qXOYnYZ!^Z]n]^!^^;'Sn;'S;=`!c<%l~n~On~~!^~!cOY~~!fP;=`<%ln~!lZOYnYZ!^Z]n]^!^^}n}!O#_!O;'Sn;'S;=`!c<%l~n~On~~!^~#bZOYnYZ!^Z]n]^!^^}n}!O$T!O;'Sn;'S;=`!c<%l~n~On~~!^~$WXOYnYZ$sZ]n]^$s^;'Sn;'S;=`!c<%l~n~On~~$s~$zOX~Y~",
  tokenizers: [0],
  topRules: { Document: [0, 1] },
  tokenPrec: 67
}), tZ = /* @__PURE__ */ re.define({
  name: "yaml",
  parser: /* @__PURE__ */ eZ.configure({
    props: [
      /* @__PURE__ */ me.add({
        Stream: (t) => {
          for (let e = t.node.resolve(t.pos, -1); e && e.to >= t.pos; e = e.parent) {
            if (e.name == "BlockLiteralContent" && e.from < e.to)
              return t.baseIndentFor(e);
            if (e.name == "BlockLiteral")
              return t.baseIndentFor(e) + t.unit;
            if (e.name == "BlockSequence" || e.name == "BlockMapping")
              return t.column(e.from, 1);
            if (e.name == "QuotedLiteral")
              return null;
            if (e.name == "Literal") {
              let O = t.column(e.from, 1);
              if (O == t.lineIndent(e.from, 1))
                return O;
              if (e.to > t.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ YO({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ YO({ closing: "]" })
      }),
      /* @__PURE__ */ fe.add({
        "FlowMapping FlowSequence": Ie,
        "BlockSequence Pair BlockLiteral": (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function iZ() {
  return new le(tZ);
}
l.meta;
const gp = new Ki();
function rZ(t) {
  const e = t.lastIndexOf(".");
  if (e >= 0)
    switch (t.substring(e + 1).toLowerCase()) {
      case "component.html":
        return tw();
      case "json":
        return Zh();
      case "md":
        return tT();
      case "html":
        return Ht();
      case "js":
      case "jsonc":
      case "json5":
      case "mjs":
      case "cjs":
        return kt();
      case "jsx":
        return kt({ jsx: !0 });
      case "ts":
      case "mts":
        return kt({ typescript: !0 });
      case "tsx":
        return kt({ typescript: !0, jsx: !0 });
      case "sql":
        return d0();
      case "css":
        return Ju();
      case "go":
        return UT();
      case "cpp":
        return xw();
      case "java":
        return Rw();
      case "less":
        return Ew();
      case "lezer":
        return Lw();
      case "liquid":
        return mk();
      case "php":
        return EW();
      case "rs":
        return lR();
      case "sass":
        return AR();
      case "vue":
        return KR();
      case "wast":
        return tv();
      case "xml":
        return xv();
      case "yml":
      case "yaml":
        return iZ();
    }
  return Zh();
}
const $l = document.getElementById("root"), nZ = k.theme({
  "&": {
    backgroundColor: faraday.theme.colors["panel.background"],
    color: faraday.theme.colors["panel.foreground"],
    width: "100%",
    height: "100%",
    overflow: "hidden"
  },
  "& .cm-activeLine": {
    backgroundColor: `color-mix(in srgb, transparent, ${faraday.theme.colors["panel.foreground"]} 5%)`
  },
  "& .cm-selectionLayer .cm-selectionBackground": {
    backgroundColor: `color-mix(in srgb, ${faraday.theme.colors["panel.background"]}, ${faraday.theme.colors["panel.foreground"]} 10%)`
  },
  "&.cm-focused .cm-selectionLayer .cm-selectionBackground": {
    backgroundColor: `color-mix(in srgb, ${faraday.theme.colors["panel.background"]}, ${faraday.theme.colors["panel.foreground"]} 10%)`
  },
  "& .cm-gutters": {
    backgroundColor: `color-mix(in srgb, ${faraday.theme.colors["panel.background"]}, ${faraday.theme.colors["panel.foreground"]} 5%)`,
    color: faraday.theme.colors["panel.foreground"]
  },
  "& .cm-gutters .cm-activeLineGutter": {
    backgroundColor: `color-mix(in srgb, ${faraday.theme.colors["panel.background"]}, ${faraday.theme.colors["panel.foreground"]} 10%)`
  },
  "& .cm-scroller": {
    height: "100% !important"
  }
}), Qt = new k({
  extensions: [m1, nZ, P1, gp.of(kt()), E.readOnly.of(!0)],
  parent: $l
}), oo = async (t) => {
  const e = rZ(t), O = Qt.state.facet(ZO), i = await SS(t), r = new TextDecoder().decode(i), n = Qt.state.update({
    changes: { from: 0, to: Qt.state.doc.length, insert: r },
    effects: e.language !== O ? gp.reconfigure(e) : void 0
  });
  Qt.dispatch(n), $l.style.visibility = "visible";
};
function $Z() {
  console.info("Activated"), faraday.events.on("activefilechange", oo), faraday.activefile && oo(faraday.activefile);
}
function uZ() {
  console.info("Deactivated"), $l.style.visibility = "hidden", faraday.events.off("activefilechange", oo), Qt.dispatch(Qt.state.update({ changes: { from: 0, to: Qt.state.doc.length, insert: "" } }));
}
export {
  $Z as activate,
  uZ as deactivate
};
